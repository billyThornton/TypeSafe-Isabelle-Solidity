theory TypeSafe_Expressions
  imports TypeSafe_Def

begin

context statement_with_gas 
begin



section \<open>The following demonstrate that the supported Solidity expressions of isabelle-solidity
        do not violate the Typesafety of a given environment.\<close>

subsection \<open>Creating Signed and Unsigned integers\<close>
lemma checkSIntCreate:      
  shows "checkSInt (b) (createSInt b v)" unfolding checkSInt_def using STR_is_int_ShowL Show_ReadL_id createSInt_def createSInt_greater createSInt_less by force

lemma checkUIntCreate:
  shows "checkUInt (b) (createUInt b v)" unfolding checkUInt_def Read_ShowL_id createUInt_def by (simp  )

subsection \<open>Olift and Plift\<close>
lemma oliftTypeInput:
  assumes "olift op t1 t2 v1 v2 = Some(v',t')"
  shows "(\<exists>b. t1 = (TSInt b) \<or> t1 = (TUInt b)) \<and> (\<exists>b2. t2 = (TSInt b2) \<or> t2 = (TUInt b2))"
proof
  show "\<exists>b. t1 = TSInt b \<or> t1 = TUInt b" using assms olift.simps by (cases t1; cases t2; simp split:if_split_asm)
next
  show "\<exists>b2. t2 = TSInt b2 \<or> t2 = TUInt b2" using assms olift.simps by (cases t1; cases t2; simp split:if_split_asm)
qed

lemma pliftTypeInput:
  assumes "plift op t1 t2 v1 v2 = Some(v',t')"
  shows "(\<exists>b. t1 = (TSInt b) \<or> t1 = (TUInt b)) \<and> (\<exists>b2. t2 = (TSInt b2) \<or> t2 = (TUInt b2))"
proof
  show "\<exists>b. t1 = TSInt b \<or> t1 = TUInt b" using assms plift.simps by (cases t1; cases t2; simp split:if_split_asm)
next
  show "\<exists>b2. t2 = TSInt b2 \<or> t2 = TUInt b2" using assms plift.simps by (cases t1; cases t2; simp split:if_split_asm)
qed

lemma vtandTypeOut:
  assumes "vtand t1 t2 v1 v2 = Some(v', t')"
  shows "(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool"
proof -
  have a10:"t1 = TBool \<and> t2 = TBool" using assms vtand.elims by blast
  have "vtand TBool TBool v1 v2 = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True, TBool) \<or> vtand TBool TBool v1 v2 = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False, TBool)" using vtand.simps assms by simp
  then show "(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool" using assms a10 by auto
qed

lemma vtorTypeOut:
  assumes "vtor t1 t2 v1 v2 = Some(v', t')"
  shows "(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool"
proof -
  have a10:"t1 = TBool \<and> t2 = TBool" using assms vtor.elims by blast
  have "vtor TBool TBool v1 v2 = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True, TBool) \<or> vtor TBool TBool v1 v2 = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False, TBool)" using vtor.simps assms by simp
  then show "(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool" using assms a10 by auto
qed

lemma vtandTypeCon:
  assumes "vtand t1 t2 v1 v2 = Some(v', t')"
    and "(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool"
  shows "typeCon t' v'" using checkBool_def createBool_def  ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def assms by (simp split:if_splits)

subsubsection \<open>Results of successful olift must be typecon\<close>
lemma oliftTypeCon:
  assumes "olift op t1 t2 v1 v2 = Some(v',t')"
    and "t1 = TSInt b1 \<or> t1 = TUInt b1"
    and "t2 = TSInt b2 \<or> t2 = TUInt b2"
  shows "typeCon t' v'"
proof -
  consider (s1) "t1 = TSInt b1" | (u1) "t1 = TUInt b1" using assms(2) by auto
  then show ?thesis
  proof(cases)
    case s1
    consider (s2) "t2 = TSInt b2" | (u2) "t2 = TUInt b2" using assms(3) by auto
    then show ?thesis 
    proof(cases)
      case s2
      then have a10:"v' = createSInt (max b1 b2) (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using s1 olift.simps(1) assms by simp
      then have a20:"t' =  TSInt (max b1 b2)" using s1 s2 olift.simps(1) assms by simp
      then have "checkSInt (max b1 b2) (createSInt (max b1 b2) (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" 
        using checkSIntCreate[of "(max b1 b2)" "(op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))"]  assms(3) by simp
      then show ?thesis using a10 a20 by simp
    next
      case u2
      then have a10:"v' = createSInt b1 (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using s1 olift.simps(3) assms by (simp split:if_split_asm)
      then have a20:"t' =  TSInt b1" using s1 u2 olift.simps(3) assms by (simp split:if_split_asm)
      then have "checkSInt b1 (createSInt b1 (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" 
        using checkSIntCreate[of "b1" "(op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))"] assms(3) by simp
      then show ?thesis using a10 a20 by simp
    qed
  next
    case u1
    consider (s2) "t2 = TSInt b2" | (u2) "t2 = TUInt b2" using assms(3) by auto
    then show ?thesis 
    proof(cases)
      case s2
      then have a10:"v' = createSInt b2 (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using u1 olift.simps(4) assms by (simp split:if_split_asm)
      then have a20:"t' =  TSInt b2" using u1 s2 olift.simps(4) assms by (simp split:if_split_asm)
      then have "checkSInt b2 (createSInt b2 (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" 
        using checkSIntCreate[of "b2" "(op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))"] assms(3) by simp
      then show ?thesis using a10 a20 by simp 
    next
      case u2
      then have a10:"v' = createUInt (max b1 b2) (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using u1 olift.simps(2) assms by simp
      then have a20:"t' =  TUInt (max b1 b2)" using u1 u2 olift.simps(2) assms by simp
      then have "checkUInt (max b1 b2) (createUInt (max b1 b2) (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" 
        using checkUIntCreate[of "(max b1 b2)" "(op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))"] assms(3) by simp
      then show ?thesis using a10 a20 by simp
    qed
  qed
qed

subsubsection \<open>Results of successful plift must be typecon\<close>
lemma pliftTypeCon:
  assumes "plift op t1 t2 v1 v2 = Some(v',t')"
    and "t1 = TSInt b1 \<or> t1 = TUInt b1"
    and "t2 = TSInt b2 \<or> t2 = TUInt b2"
  shows "typeCon t' v'"
proof -
  consider (s1) "t1 = TSInt b1" | (u1) "t1 = TUInt b1" using assms(2) by auto
  then show ?thesis
  proof(cases)
    case s1
    consider (s2) "t2 = TSInt b2" | (u2) "t2 = TUInt b2" using assms(3) by auto
    then show ?thesis 
    proof(cases)
      case s2
      then have a10:"v' = createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using s1 plift.simps(1) assms by simp
      then have a20:"t' =  TBool" using s1 s2 plift.simps(1) assms by simp
      then have "checkBool (createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" unfolding checkBool_def createBool_def using ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by simp
      then show ?thesis using a10 a20 by simp
    next
      case u2
      then have a10:"v' = createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using s1 plift.simps(3) assms by (simp split:if_split_asm)
      then have a20:"t' = TBool" using s1 u2 plift.simps(3) assms by (simp split:if_split_asm)
      then have "checkBool (createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))"  unfolding checkBool_def createBool_def using ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by simp
      then show ?thesis using a10 a20 by simp
    qed
  next
    case u1
    consider (s2) "t2 = TSInt b2" | (u2) "t2 = TUInt b2" using assms(3) by auto
    then show ?thesis 
    proof(cases)
      case s2
      then have a10:"v' = createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using u1 plift.simps(4) assms by (simp split:if_split_asm)
      then have a20:"t' = TBool" using u1 s2 plift.simps(4) assms by (simp split:if_split_asm)
      then have "checkBool (createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))"  unfolding checkBool_def createBool_def using ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by simp
      then show ?thesis using a10 a20 by simp
    next
      case u2
      then have a10:"v' = createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2))" using u1 plift.simps(2) assms by simp
      then have a20:"t' =  TBool" using u1 u2 plift.simps(2) assms by simp
      then have "checkBool (createBool (op (ReadL\<^sub>i\<^sub>n\<^sub>t v1) (ReadL\<^sub>i\<^sub>n\<^sub>t v2)))" unfolding checkBool_def createBool_def using ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by simp
      then show ?thesis using a10 a20 by simp
    qed
  qed
qed

subsubsection \<open>Lift Of an expression with olift must be typecon\<close>
lemma oliftSuccess:
  assumes "lift expr (olift op) e1 e2 ev cd st g = Normal ((KValue v, Value t), g')"
  shows "typeCon t v"
proof -
  obtain v1 t1 g'' where a10:"expr e1 ev cd st g = Normal((KValue v1, Value t1), g'')" using lift_def assms by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
  then obtain v2 t2 g''' where a20:"expr e2 ev cd st g'' = Normal((KValue v2, Value t2), g''')" using lift_def assms by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
  then have a30:"(olift op) t1 t2 v1 v2 = Some(v, t)" using a10 a20 assms lift_def by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm option.split_asm)
  then obtain b1 where a40:"t1 = TSInt b1 \<or> t1 = TUInt b1" using oliftTypeInput[of op t1 t2 v1 v2 v t] a10 by auto
  then obtain b2 where a50:"t2 = TSInt b2 \<or> t2 = TUInt b2" using oliftTypeInput[of op t1 t2 v1 v2 v t] a20 a30 by auto
  then show ?thesis using oliftTypeCon[of op t1 t2 v1 v2 v t b1 b2] a30 a40 a50 by simp
qed

subsubsection \<open>Lift Of an expression with plift must be typecon\<close>
lemma pliftSuccess:
  assumes "lift expr (plift op) e1 e2 ev cd st g = Normal ((KValue v, Value t), g')"
  shows "typeCon t v"
proof -
  obtain v1 t1 g'' where a10:"expr e1 ev cd st g = Normal((KValue v1, Value t1), g'')" using lift_def assms by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
  then obtain v2 t2 g''' where a20:"expr e2 ev cd st g'' = Normal((KValue v2, Value t2), g''')" using lift_def assms by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
  then have a30:"(plift op) t1 t2 v1 v2 = Some(v, t)" using a10 a20 assms lift_def by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm option.split_asm)
  then obtain b1 where a40:"t1 = TSInt b1 \<or> t1 = TUInt b1" using pliftTypeInput[of op t1 t2 v1 v2 v t] a10 by auto
  then obtain b2 where a50:"t2 = TSInt b2 \<or> t2 = TUInt b2" using pliftTypeInput[of op t1 t2 v1 v2 v t] a20 a30 by auto
  then show ?thesis using pliftTypeCon[of op t1 t2 v1 v2 v t b1 b2] a30 a40 a50 by simp
qed

subsection \<open>Compatible types will both satisfy the consistency of a value\<close>
text \<open>If types are compatible and the value is consistent with the first type it must be consistent with the second\<close>
lemma SameCompTypeCon:
  assumes "comp t t'"
    and "typeCon t v"
  shows "typeCon t' v"
proof (cases t)
  case (TSInt x1)
  then obtain x2 where  "t' = TSInt x2 \<and> (bits.to_nat x1 \<le> bits.to_nat x2)" using assms(1) by (cases t'; auto) 
  then show ?thesis using assms(2) typeCon.simps(1)[of x1 v ] typeCon.simps(1)[of x2 v ] TSInt checkSIntIncreaseB checkSInt_def by (cases t'; metis) 
next
  case (TUInt x2)
  then obtain x3 where  "(t' = TUInt x3 \<and> (bits.to_nat x2 \<le> bits.to_nat x3))
                          \<or> (t' = TSInt x3 \<and> (bits.to_nat x2 < bits.to_nat x3))" using assms(1) by (cases t'; auto) 
  then show ?thesis using assms(2) typeCon.simps(2) typeCon.simps(1)   TUInt checkUIntIncreaseB  checkUIntToSInt checkSInt_def checkUInt_def  by (cases t'; metis) 
next
  case TBool
  then have "t' = t" using comp.elims(2) assms(1) by auto
  then show ?thesis using assms by simp
next
  case TAddr
  then have "t' = t" using comp.elims(2) assms(1) by auto
  then show ?thesis using assms by simp
qed

subsection \<open>Initial values\<close>
text \<open>When a new location is created in memory, storage or calldata, or a new variable is created
      then a default i(nitial)value is used. These values must be typecon, which is what the following
      lemma demonstrates.\<close>
lemma ivalTypeCon:
  assumes "ival t' = v'"
  shows "typeCon t' v'"
proof (cases t')
  case (TSInt x1)
  have a1:"ShowL\<^sub>i\<^sub>n\<^sub>t 0 = STR ''0''" by Solidity_Symbex.solidity_symbex
  then have a10:"ReadL\<^sub>i\<^sub>n\<^sub>t (STR ''0'') = (0::int)" by Solidity_Symbex.solidity_symbex
  then show ?thesis using  checkSInt_def[of x1 "STR ''0''"] TSInt assms a1 by simp
next
  case (TUInt x2)
  have a1:"ShowL\<^sub>i\<^sub>n\<^sub>t 0 = STR ''0''"  by eval
  then have a10:"ReadL\<^sub>i\<^sub>n\<^sub>t (STR ''0'') = (0::int)" by eval
  then show ?thesis using  checkUInt_def[of x2 "STR ''0''"] TUInt assms a1 by simp
next
  case TBool
  have "ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False = STR ''False''" by eval
  then show ?thesis using TBool checkBool_def assms by auto
next
  case TAddr
  then have "v' = STR ''0x0000000000000000000000000000000000000000''" using ival.simps(4) assms by simp
  moreover have "(CHR ''.'' \<notin> set (literal.explode STR ''0x0000000000000000000000000000000000000000''))" by eval
  ultimately show ?thesis using typeCon.simps(4) TAddr checkAddress_def by auto
qed


subsection \<open>Convert is typesafe\<close>
text \<open>If converting form one type to another the result must inheriently be type consistent.
      If the string value was consistent with the initial type and a successful conversion
      is performed then the result must be consistent with the new type.\<close>
lemma typeSafeConvert:
  assumes "typeCon t2 v"
    and "convert t2 t' v = Some(v)"
  shows "typeCon t' v"
proof (cases "t2 = t'")
  case True
  then show ?thesis using assms by simp
next
  case False
  then show ?thesis
  proof(cases t2)
    case t2x1:(TSInt x1)
    then show ?thesis
    proof(cases t')
      case (TSInt x1a)
      then have "bits.to_nat(x1) \<le> bits.to_nat(x1a)" using assms(2) convert.simps(1)[of x1 x1a v] by (metis TSInt not_Some_eq t2x1)
      then show ?thesis using assms(1) typeCon.simps(1)[of x1 v] typeCon.simps(1)[of x1a v] checkSIntIncreaseB checkSInt_def 
        by (metis TSInt t2x1)
    next
      case (TUInt x2)
      then have "convert (TSInt x1) (TUInt x2) v = None" using convert.simps by simp
      then have False using assms t2x1 TUInt by simp
      then show ?thesis by simp
    next
      case TBool
      then have "convert (TSInt x1) TBool v = None" using convert.simps by simp
      then have False using assms t2x1 TBool by simp
      then show ?thesis by simp
    next
      case TAddr
      then have "convert (TSInt x1) TAddr v = None" using convert.simps by simp
      then have False using assms t2x1 TAddr by simp
      then show ?thesis by simp
    qed
  next
    case t2x2:(TUInt x2)
    then show ?thesis
    proof(cases t')
      case (TSInt x1a)
      then have "bits.to_nat(x2) < bits.to_nat(x1a)" using assms(2) convert.simps(1)[of x2 x1a v] by (metis convert.simps(3) option.distinct(1) t2x2)
      then show ?thesis using assms(1) typeCon.simps(2)[of x2 v] typeCon.simps(1)[of x1a v] checkUIntToSInt checkSInt_def checkUInt_def TSInt assms(2) convert.simps(3) t2x2 by force
    next
      case (TUInt x2a)
      then have "bits.to_nat(x2)\<le>bits.to_nat(x2a)" using assms(2) convert.simps(2)[of x2 x2a v] by (metis option.discI t2x2)
      then show ?thesis using checkUIntIncreaseB assms t2x2 TUInt typeCon.simps(2) convert.simps(2) checkUInt_def by auto
    next
      case TBool
      then have "convert (TUInt x2) TBool v = None" using convert.simps by simp
      then have False using assms t2x2 TBool by simp
      then show ?thesis by simp
    next
      case TAddr
      then have "convert (TUInt x2) TAddr v = None" using convert.simps by simp
      then have False using assms t2x2 TAddr by simp
      then show ?thesis by simp
    qed
  next
    case TBool
    then have "t' \<noteq> TBool" using False by simp
    then have "convert t2 t' v = None" using convert.simps by (metis TBool Types.exhaust)
    then have False using assms by simp
    then show ?thesis by simp
  next
    case TAddr
    then have "t' \<noteq> TAddr" using False by simp
    then have "convert t2 t' v = None" using convert.simps by (metis TAddr Types.exhaust)
    then have False using assms by simp
    then show ?thesis by simp
  qed
qed

subsection \<open>Initialising an enviroment results in a typesafe env\<close>
text \<open>In the call and ecall expressions all calculations are done in a clean environment.
      To do this ffoldinit is used to create the environment.
      The following lemmas demonstrate the initialisation process results in a typesafe environment\<close>

subsubsection \<open>Safety of empty environments\<close>
lemma emptyTopLocs:
  shows "lessThanTopLocs emptyStore" unfolding lessThanTopLocs_def emptyStore_def accessStore_def by simp


lemma emptyEnvSafe:
  assumes "ev = emptyEnv addr contrct sendr sval"
    and "safeContract stor"
    and "methodVarsNoPref"
    and "balanceTypes acc"
    and "svalueTypes (svalue ev)"
    and "lessThanTopLocs sck"
    and "lessThanTopLocs cd"
    and "lessThanTopLocs mem"
    and "addressFormat addr"
    and "addressFormat sendr"
    and "AddressTypes acc"
  shows "TypeSafe ev acc sck mem stor cd" unfolding TypeSafe_def (* using assms unique_locations_def compPointers_def svalueTypes_def safeContract_def emptyEnv_def[of addr contrct sendr sval] emptyStoreStackLocs emptyMemoryLocs unfolding TypeSafe_def by auto*)
proof intros
  have *:"denvalue (ev) = fmempty" using assms(1) unfolding emptyEnv_def by simp
  then show " unique_locations (denvalue ev)" unfolding unique_locations_def by simp
  show "AddressTypes acc" using assms by auto
  show " compPointers sck  (denvalue ev)" unfolding compPointers_def using * by (simp split:if_splits)
  show "compMemPtrs sck mem (denvalue ev)" unfolding compMemPtrs_def using * by (simp split:if_splits)
  show "methodVarsNoPref" using assms(3) by simp
  show "balanceTypes acc" using assms(4) by simp
  show "svalueTypes (svalue ev)" using assms(5) by simp
  show "lessThanTopLocs sck" using assms(6) by simp
  show " lessThanTopLocs cd" using assms(7) by simp
  show " lessThanTopLocs mem" using assms(8) by simp
  show "addressFormat (address ev)" using assms(9) assms(1) by simp
  show "addressFormat (sender ev)" using assms(10) assms(1) by simp
  show "safeContract stor" using assms by simp
  show " typeCompat (denvalue ev) sck mem (stor (address ev)) cd " using * unfolding typeCompat_def by simp
qed


subsubsection \<open>Initialising a variable into a denvalue preserves unique_locations\<close>
lemma envUpdateUnique2:
  assumes "e' = e \<lparr>denvalue := fmupd i ((Storage tp),(Storeloc i)) (denvalue e)\<rparr>"
  shows"(\<forall>x. x \<noteq> i \<longrightarrow> fmlookup (denvalue e') x = fmlookup (denvalue e) x)" 
proof(intros)
  fix x
  assume a1:"x \<noteq> i"
  show "denvalue e' $$ x = denvalue e $$ x" using assms a1 by simp
qed

text \<open>There is an assumption here that the variable being loaded does not already exist in the 
environment. This is gained from the context of ffold_init as we are either loading into an empty
environment or if the location already exists then an update function is called so the value is overwritten\<close>
lemma uniqueLocationsPreserved:
  assumes "unique_locations (denvalue e)"
  assumes "e' =  e \<lparr> denvalue := fmupd i ((Storage tp),(Storeloc i)) (denvalue e) \<rparr>"
    and "(\<forall>x y. denvalue e $$ x = Some y \<longrightarrow>  snd y \<noteq> Storeloc i)"
  shows "unique_locations (denvalue e')" unfolding unique_locations_def
proof(intros)
  fix x y
  assume a1:"x |\<in>| fmran (denvalue e') \<and> y |\<in>| fmran (denvalue e') \<and> snd x = snd y" 
  have a2:"fmlookup (denvalue e') i = Some ((Storage tp),(Storeloc i))" using assms(2) by simp
  show "x = y"
  proof(cases "denvalue e' $$ i = Some x")
    case xt:True
    then have a3: "x = ((Storage tp),(Storeloc i))" using a2 by simp
    then show ?thesis 
    proof(cases "denvalue e' $$ i = Some y")
      case True
      then show ?thesis using xt by simp
    next
      case False
      then obtain t where "Some y = denvalue e' $$ t " using assms a1 fmranE by metis
      then have "denvalue e $$ t = Some y" using assms a1 False by auto
      then have "snd y \<noteq> snd x" using assms a1 a3 by fastforce
      then show ?thesis using a1 assms by simp
    qed
  next
    case xf:False
    then show ?thesis 
    proof(cases "denvalue e' $$ i = Some y")
      case True
      then obtain t where "Some x = denvalue e' $$ t " using assms a1 fmranE by metis
      then have "denvalue e $$ t = Some x" using assms a1 xf by auto
      then have "snd y \<noteq> snd x" using assms True a1 a2 xf  by fastforce
      then show ?thesis using a1 by simp    
    next
      case False
      then show ?thesis using False a1 assms envUpdateUnique2 fmranE fmranI unique_locations_def xf by metis
    qed
  qed
qed


lemma compPointersPreserved:
  assumes "compPointers st (denvalue e)"
  assumes "e' = e \<lparr> denvalue := fmupd i ((Storage tp), (Storeloc i)) (denvalue e) \<rparr>"
    and "SCon tp i (stor (address e'))"
    and "TypeSafe e acc st mem stor cd"
    and "(\<forall>x y. denvalue e $$ x = Some y \<longrightarrow> snd y \<noteq> Storeloc i)"
    and "\<forall>x y. denvalue e $$ x = Some y \<longrightarrow> snd y = Storeloc x"
    and "\<forall> x y t1 t2. x \<noteq> y \<and> denvalue e $$ x = Some (Storage t1, Storeloc x) \<and> denvalue e $$ y = Some (Storage t2, Storeloc y) 
        \<longrightarrow> \<not>TypedStoSubpref x y t2 \<and> \<not>TypedStoSubpref y x t1"
    and "\<forall>x t1. x \<noteq> i \<and> denvalue e $$ x = Some (Storage t1, Storeloc x) \<longrightarrow> \<not>TypedStoSubpref x i tp \<and> \<not>TypedStoSubpref i x t1"
  shows "compPointers st  (denvalue e')"
  unfolding compPointers_def 
proof (intro allI impI)
  fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
  have a2:"fmlookup (denvalue e') i = Some ((Storage tp),(Storeloc i))" using assms(2) by simp
  have storSame:"stor (address e') = stor (address e)" using assms(2) by simp 
  assume *: "(Storage tp1, l1) |\<in>| fmran (denvalue e') \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e') \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' st = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' st = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
  show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2
        else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"

  proof(cases "TypedStoSubpref stl2 stl1 tp1")
    case **:True
    have "CompStoType tp1 tp2 stl1 stl2"
    proof(cases "denvalue e' $$ i = Some (Storage tp1, l1)")
      case t1:True    
      then have a3: "(Storage tp1, l1) = ((Storage tp),(Storeloc i))" using assms(2) by simp
      then show ?thesis 
      proof(cases "denvalue e' $$ i = Some (Storage tp2, l2)")
        case True
        then have a4:"(Storage tp1, l1) =  (Storage tp2, l2)" using assms(2) a3 by simp
        then have "tp1 = tp \<and> tp2 = tp" using a3 by simp
        moreover have "l1 = Storeloc i \<and> l2 = Storeloc i" using a3 a4 by simp
        ultimately show ?thesis using assms(3) * CompStoType.simps ** 
          by (metis Denvalue.distinct(1) Denvalue.inject(2) STypes.exhaust)
      next
        case False
        then have a5:"(Storage tp2, l2) |\<in>| fmran (denvalue e)" using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
        then have a10:"l2 \<noteq> Storeloc i" using * ** t1 assms(5) fmranE by auto
        then have a20:"l1 = Storeloc i" using a3 by simp
        then have a30:"tp = tp1" using a3 by simp
        then have a40:"stl1 = i" using * a20 by simp
        have "\<forall>c. l2 \<noteq> Stackloc c" using assms(6) a5 by fastforce
        then obtain i' where "l2 = Storeloc i' \<and> i' \<noteq> i \<and> stl2 = i'" using a10 * by auto
        show ?thesis using ** assms(7) assms(8) 
          by (metis Denvalue.inject(2) \<open>\<And>thesis. (\<And>i'. l2 = Storeloc i' \<and> i' \<noteq> i \<and> stl2 = i' \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> a30 a40 a5 assms(6) fmranE snd_conv)
      qed
    next
      case f2:False
      then have a5:"(Storage tp1, l1) |\<in>| fmran (denvalue e)" using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
      then show ?thesis 
      proof(cases "denvalue e' $$ i = Some (Storage tp2, l2)")
        case True
        then have a3: "(Storage tp2, l2) = ((Storage tp),(Storeloc i))" using assms(2) by simp
        then have a20:"l1 \<noteq> Storeloc i" using a3 a5 * ** assms(5) fmranE by auto
        then have a30:"tp = tp2" using a3 by simp
        then have a40:"stl2 = i" using * a20  using a3 by auto
        have "\<forall>c. l2 \<noteq> Stackloc c" using assms(6) a5 a3 by auto
        then obtain i' where a50:"l2 = Storeloc i' \<and> i' \<noteq> i \<and> stl2 = i'" using *
          by (metis "**" Denvalue.distinct(1) Denvalue.inject(2) a20 a5 assms(6) assms(8) fmranE sndI)
        show ?thesis using ** assms(7) assms(8) 
          using a50 a40 by fastforce
      next
        case False
        then have a6:"(Storage tp2, l2) |\<in>| fmran (denvalue e)" using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
        then obtain x where b10:"denvalue e $$ x = Some (Storage tp2, Storeloc x)" using fmranE assms(5) by (metis assms(6) snd_conv)
        then obtain y where b20:"denvalue e $$ y = Some (Storage tp1, Storeloc y)" using a5 fmranE assms(5) by (metis assms(6) snd_conv)
        then show ?thesis using ** assms(4) a6 a5 b10 b20 fmranE unfolding TypeSafe_def compPointers_def using "*" by force
      qed
    qed
    then show ?thesis by (simp add: "**")
  next
    case f2:False
    then show ?thesis
    proof(cases "TypedStoSubpref stl1 stl2 tp2")
      case **:True
      have "CompStoType tp2 tp1 stl2 stl1"
      proof(cases "denvalue e' $$ i = Some (Storage tp1, l1)")
        case t1:True    
        then have a3: "(Storage tp1, l1) = ((Storage tp),(Storeloc i))" using assms(2) by simp
        then show ?thesis 
        proof(cases "denvalue e' $$ i = Some (Storage tp2, l2)")
          case True
          then have a4:"(Storage tp1, l1) =  (Storage tp2, l2)" using assms(2) a3 by simp
          then have "tp1 = tp \<and> tp2 = tp" using a3 by simp
          moreover have "l1 = Storeloc i \<and> l2 = Storeloc i" using a3 a4 by simp
          ultimately show ?thesis using assms(3) *  
            using "**" f2 by auto
        next
          case False
          then have a5:"(Storage tp2, l2) |\<in>| fmran (denvalue e)" 
            using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
          then have a10:"l2 \<noteq> Storeloc i" using * ** t1 assms(5) fmranE by auto
          then have a20:"l1 = Storeloc i" using a3 by simp
          then have a30:"tp = tp1" using a3 by simp
          then have a40:"stl1 = i" using * a20 by simp
          have "\<forall>c. l2 \<noteq> Stackloc c" using assms(6) a5 by fastforce
          then obtain i' where "l2 = Storeloc i' \<and> i' \<noteq> i \<and> stl2 = i'" using a10 * by auto
          show ?thesis using ** assms(7) assms(8) 
            by (metis Denvalue.inject(2) \<open>\<And>thesis. (\<And>i'. l2 = Storeloc i' \<and> i' \<noteq> i \<and> stl2 = i' \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> a40 a5 assms(6) fmranE snd_conv)
        qed
      next
        case f3:False
        then have a5:"(Storage tp1, l1) |\<in>| fmran (denvalue e)" using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
        then show ?thesis 
        proof(cases "denvalue e' $$ i = Some (Storage tp2, l2)")
          case True
          then have a3: "(Storage tp2, l2) = ((Storage tp),(Storeloc i))" using assms(2) by simp
          then have a20:"l1 \<noteq> Storeloc i" using a3 a5 * ** assms(5) fmranE by auto
          then have a30:"tp = tp2" using a3 by simp
          then have a40:"stl2 = i" using * a20  using a3 by auto
          have "\<forall>c. l1 \<noteq> Stackloc c" using assms(6) a5  by fastforce
          then obtain i' where a50:"l1 = Storeloc i' \<and> i' \<noteq> i \<and> stl1= i'" using * a40 a20
            by simp
          show ?thesis using **  assms(7) assms(8) 
            using a50 a40 by (metis Denvalue.inject(2) a30 a5 assms(6) fmranE snd_conv)
        next
          case False
          then have a6:"(Storage tp2, l2) |\<in>| fmran (denvalue e)" using assms(1) unfolding compPointers_def using  * assms envUpdateUnique2 fmranE fmranI by metis
          then obtain x where b10:"denvalue e $$ x = Some (Storage tp2, Storeloc x)" using fmranE assms(5) by (metis assms(6) snd_conv)
          then obtain y where b20:"denvalue e $$ y = Some (Storage tp1, Storeloc y)" using a5 fmranE assms(5) by (metis assms(6) snd_conv)
          then show ?thesis using **  f2 f3 assms(4) a6 a5 b10 b20 fmranE unfolding TypeSafe_def compPointers_def using "*" by force
        qed
      qed
      then show ?thesis by (simp add: "**" f2 )
    next
      case False
      then show ?thesis using f2 by simp
    qed
  qed
qed

lemma compPointersNonStackUpd:
  assumes "compPointers sck' (denvalue ev')"
    and "denvalue e = denvalue (ev'\<lparr>denvalue := denvalue ev'(ip $$:= (t, (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))))\<rparr>)"
    and "\<forall>t'. t \<noteq> Storage t'"
    and "k' = push v sck'"
    and "lessThanTopLocs sck'"
    and "TypeSafe ev' (accounts st) sck' mem' (storage st) cd'"
    and "address ev' = address e"
  shows "compPointers k' (denvalue e)"  unfolding compPointers_def
proof intros
  fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
  assume *:" (Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
  have b5: "fmlookup (denvalue e) ip = Some  (t,(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" using assms by simp
  have b6:"\<forall>i''. i'' \<noteq> ip \<longrightarrow> fmlookup (denvalue e) i'' = fmlookup (denvalue ev') i''" using assms fmupd_def by fastforce
  have b7:"\<forall>loc''. loc'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<longrightarrow> accessStore loc'' k' = accessStore loc'' sck'" using assms unfolding push_def allocate_def accessStore_def updateStore_def by simp
  have b8:"\<forall>x y. denvalue ev' $$ x = Some y \<longrightarrow> snd y \<noteq> Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using stackLocs_imp_NotDen[of sck' ev' st mem'] assms by auto
  then have b15:"fmlookup (denvalue e) ip \<noteq> Some (Storage tp1, l1) \<and> fmlookup (denvalue e) ip \<noteq> Some (Storage tp2, l2)" using b5 assms by simp
  then have b20:"(Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and> (Storage tp2, l2) |\<in>| fmran (denvalue ev')" 
    using b6 * by (metis fmlookup_ran_iff)
  then have b25:"l1 \<noteq>(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<and> l2 \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))" 
    using b5 * b8 b20 by fastforce  
  then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
  proof(cases "stl1 = stl2")
    case True
    then show ?thesis 
    proof(cases "l1")
      case st1:(Stackloc x1)
      then have a1:"accessStore x1 sck'  = Some (KStoptr stl1)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
      then show ?thesis 
      proof(cases "l2")
        case (Stackloc x2)
        then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
        then show ?thesis using True assms(6) a1 st1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
      next
        case (Storeloc x2)
        then show ?thesis using True assms(6) a1 st1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
      qed
    next
      case str1:(Storeloc x2)
      then have a1:"stl1 = x2" using * by simp
      then show ?thesis
      proof(cases "l2")
        case (Stackloc x2)
        then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
        then show ?thesis using True assms(6) a1 str1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
      next
        case (Storeloc x2)
        then show ?thesis using True assms(6) a1 str1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
      qed
    qed
  next
    case f1:False
    then show ?thesis 
    proof(cases "TypedStoSubpref stl2 stl1 tp1")
      case t2:True
      then show ?thesis
      proof(cases "l1")
        case st1:(Stackloc x1)
        then have a1:"accessStore x1 sck'  = Some (KStoptr stl1)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
        then show ?thesis 
        proof(cases "l2")
          case (Stackloc x2)
          then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
          then show ?thesis using f1 t2 assms(6) a1 st1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
        next
          case (Storeloc x2)
          then show ?thesis using f1 t2 assms(6) a1 st1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
        qed
      next
        case str1:(Storeloc x2)
        then have a1:"stl1 = x2" using * by simp
        then show ?thesis
        proof(cases "l2")
          case (Stackloc x2)
          then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
          then show ?thesis using f1 t2 assms(6) a1 str1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
        next
          case (Storeloc x2)
          then show ?thesis using f1 t2 assms(6) a1 str1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
        qed
      qed
    next
      case f2:False
      then show ?thesis 
      proof(cases " TypedStoSubpref stl1 stl2 tp2 ")
        case t3:True
        then show ?thesis 
        proof(cases "l1")
          case st1:(Stackloc x1)
          then have a1:"accessStore x1 sck'  = Some (KStoptr stl1)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
          then show ?thesis 
          proof(cases "l2")
            case (Stackloc x2)
            then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
            then show ?thesis using f1 f2  assms(6) a1 st1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
          next
            case (Storeloc x2)
            then show ?thesis using f1 f2 assms(6) a1 st1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
          qed
        next
          case str1:(Storeloc x2)
          then have a1:"stl1 = x2" using * by simp
          then show ?thesis
          proof(cases "l2")
            case (Stackloc x2)
            then have "accessStore x2 sck'  = Some (KStoptr stl2)" using assms(6) unfolding TypeSafe_def compPointers_def using b20 "*" b25 b7 by auto
            then show ?thesis using assms(6) a1 str1 Stackloc unfolding TypeSafe_def compPointers_def using b20  by blast
          next
            case (Storeloc x2)
            then show ?thesis using assms(6) a1 str1 unfolding TypeSafe_def compPointers_def using b20 using "*" by blast
          qed
        qed
      next
        case t4:False
        then show ?thesis using f1 f2 by simp
      qed
    qed
  qed
qed


lemma ffoldInitAllLocsStorage:
  shows "\<forall>e' x y.  ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) xs = e' 
          \<longrightarrow> ( (denvalue e') $$ x  = Some y \<longrightarrow> (snd y) = Storeloc x )
              
              "
proof(induct xs)
  case empty
  then show ?case
  proof(intros)
    fix e' x y
    assume **:"ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) {||} = e'"
    then have ***:"e' = emptyEnv(address e2) (contract e) (sender e3) sval" using FSet.comp_fun_commute.ffold_empty[OF init_commte] by simp

    assume ****:"denvalue e' $$ x = Some y "
    have "denvalue e' = fmempty" using *** by simp
    then have a23:"(denvalue e') $$ x = None" by simp
    then show "snd y = Storeloc x" using ** ****  by simp
  qed 
next
  case (insert x xs)
  then have *: "ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) (finsert x xs) =
    init ct x (ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) xs)" using FSet.comp_fun_commute.ffold_finsert[OF init_commte] by simp
  show ?case
  proof (intros)
    fix e' xa y ya  assume **: "ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) (finsert x xs) = e'"
    obtain e'' where ***: "ffold (init ct) (emptyEnv (address e2) (contract e) (sender e3) sval) xs = e''" using * by simp
    then have a15: "(denvalue e'' $$ x = Some y \<longrightarrow> snd y = Storeloc x)" using insert * *** by blast
    then have a20:"init ct x e'' = e'" using * ** *** by simp
    then have a23:"contract e = contract (emptyEnv (address e) (contract e) (sender e) (svalue e))" using a20 by simp
    then have a25: "contract e = contract e''" using *** ffold_init_contract by auto 
    have "(case ct $$ x of None \<Rightarrow> e'' | Some (Var tp) \<Rightarrow> updateEnvDup x (Storage tp) (Storeloc x) e'' | Some _ \<Rightarrow> e'') = e'" 
      using init_def[of ct x e''] a20 by auto


    assume a40:"denvalue e' $$ xa = Some y"
    show "snd y = Storeloc xa" 
    proof (cases "denvalue e'' $$ xa = Some y")
      case True
      then show ?thesis using insert *** by blast
    next
      case False
      then have a50:"denvalue e' \<noteq> denvalue e''" using a40 by auto
      then obtain tp where a60:"fmlookup ct x = Some (Var tp)" using a50 a20 a40 init_def by (simp split:option.splits Member.splits )
      then have a70:"denvalue e' = denvalue(updateEnvDup x (Storage tp) (Storeloc x) e'')" using a50 a20 a40 by (simp split:option.splits Member.splits )
      then have a80:"denvalue e' = denvalue(e''\<lparr> denvalue := fmupd x ((Storage tp),(Storeloc x)) (denvalue e'')\<rparr>)" using updateEnvDup.simps updateEnv.simps by (metis a20 a50 a60 init_s12 init_s13)
      then have a90:"xa = x" using a70 a40 a20 a50 a60 init_def updateEnvDup_dup False by metis
      then have "denvalue e' $$ x = Some ((Storage tp),(Storeloc x))" using a80 by simp
      then have "y = ((Storage tp), (Storeloc x))" using a90 a40 by simp
      then show ?thesis using a90 by simp
    qed

  qed
qed

lemma denvalueChange:
  assumes "e' = e\<lparr>denvalue := denvalue e(i $$:= y)\<rparr>"
    and "z \<noteq> i"
  shows "denvalue e' $$ z = denvalue e $$ z" using assms fmranI fmranE by auto




subsubsection \<open>Initialising a single variable from a typesafe env returns a safe env.\<close>
lemma initEmptySafe:
  assumes "TypeSafe e acc st mem stor cd" 
  assumes "init ct i e = e'"
    and "ep $$ contract (e::Environment) = Some(ct, dud)" (*Ct is a string identifier to contract member mapping*)
    and "\<forall>x y. (denvalue e) $$ x  = Some y \<longrightarrow> (snd y) = Storeloc x" (*from the context of ffold*)
    and "\<forall>l y. \<exists>t1. (denvalue e) $$ l = Some y \<longrightarrow> ct $$ l = Some (Var t1) \<and> (fst y) = Storage t1"
  shows "TypeSafe e' acc st mem stor cd" 
proof (cases "fmlookup ct i")
  case None
  then have "init ct i e = e" using init_def by simp
  then show ?thesis using assms by simp
next
  case (Some a)
  then show ?thesis 
  proof(cases a)
    case (Method x1)
    then have "init ct i e = e" using init_def Some by simp
    then show ?thesis using assms  by simp
  next
    case (Function x2)
    then show ?thesis  using init_def Some assms by simp
  next
    case (Var tp) 
    then have a0:"ct $$ i = Some (Var tp)" using Some by auto
    have "methodVarsNoPref" using assms TypeSafe_def by simp
    then have a1:"\<forall>c adv ct dud i1 i2 t1 t2.
     i1 \<noteq> i2 \<and> ep $$ c = Some (ct, dud) \<and> ct $$ i1 = Some (Var t1) \<and> ct $$ i2 = Some (Var t2) \<longrightarrow>
     \<not> TypedStoSubpref i1 i2 t2 \<and> \<not> TypedStoSubpref i2 i1 t1" 
      unfolding methodVarsNoPref_def using emptyEnv_members assms(3) by metis
    have a5:"address e = address e'" using init_def Some assms(2) Var by (auto split:option.split)
    have a51:"contract e = contract e'"using init_def Some assms(2) Var by (auto split:option.split)
    then have "init ct i e =  updateEnvDup i (Storage tp) (Storeloc i) e" using Var init_def Some by simp
    then have e'Def:"e' = (case fmlookup (denvalue e) i of 
              Some _ \<Rightarrow> e
            | None \<Rightarrow> updateEnv i (Storage tp) (Storeloc i) e)" using updateEnvDup.simps assms(2) by simp
    then show ?thesis
    proof (cases "fmlookup (denvalue e) i")
      case None
      then have a6:"e' =  updateEnv i (Storage tp) (Storeloc i) e" using updateEnvDup.simps assms(2) Some Var by simp
      then have a10:"e' =  e \<lparr> denvalue := fmupd i ((Storage tp),(Storeloc i)) (denvalue e) \<rparr>" using updateEnv.simps by simp

      have a15:" (\<forall>e ct dud i tp.
      ep $$ contract e = Some (ct, dud) \<and> ct $$ i = Some (Var tp) \<longrightarrow>
      SCon tp i (stor (address (e::Environment))))" 
        using assms(1) unfolding TypeSafe_def safeContract_def by blast

      then have a20:"SCon tp i (stor (address e'))"  using a15  
        by (metis a0 a5 assms(3))

      show ?thesis  unfolding TypeSafe_def
      proof(intros)
        show "safeContract stor" using assms(1) TypeSafe_def by simp
        show "methodVarsNoPref" using assms TypeSafe_def by simp
        show "balanceTypes acc" using assms TypeSafe_def by simp

      next 
        have a30:"svalueTypes (svalue e)" using assms TypeSafe_def by simp
        then have "svalue e= svalue e'" using a10 by simp
        show "svalueTypes (svalue e')" using assms TypeSafe_def svalueTypes_def a30 a10 by simp
      next
        show "typeCompat (denvalue e') st mem (stor (address e')) cd" unfolding typeCompat_def
        proof intros
          fix t l 
          assume a40:"(t, l) |\<in>| fmran (denvalue e')"
          then obtain x where a50:"fmlookup (denvalue e') x = Some(t,l)" by auto
          show "case l of
             Stackloc loc \<Rightarrow>
               (case accessStore loc st of None \<Rightarrow> False 
               | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
               | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
               | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct mem stloc | _ \<Rightarrow> False)
               | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (stor (address e')) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (stor (address e')) | _ \<Rightarrow> False)"
          proof(cases "x = i")
            case True
            then have a60:"fmlookup (denvalue e') x = Some ((Storage tp),(Storeloc i))" using a10 a50 by simp
            moreover have "l = Storeloc i" using a50 a60 by simp
            moreover have "t = Storage tp" using a50 a60 by simp
            ultimately show ?thesis using a20 by simp
          next
            case False
            then have a60:"fmlookup (denvalue e) x = fmlookup (denvalue e') x" using envUpdateUnique2 a10 by simp
            then have a70:"(t, l) |\<in>| fmran (denvalue e)" using False a40 a50 by (simp add: fmranI)
            then show ?thesis  using assms(1) unfolding TypeSafe_def typeCompat_def using a70 a5 a60 by metis
          qed
        qed
      next
        have *:"unique_locations (denvalue e)" using assms TypeSafe_def by simp
        have **:"(\<forall>x y. denvalue e $$ x = Some y \<longrightarrow>  snd y \<noteq> Storeloc i)" using None assms by fastforce
        show "unique_locations (denvalue e')" using uniqueLocationsPreserved * ** a10 by blast 
      next
        have *:"compPointers st (denvalue e)" using assms TypeSafe_def by simp
        have **:"(\<forall>x y. denvalue e $$ x = Some y \<longrightarrow>  snd y \<noteq> Storeloc i)" using None assms by fastforce
        have a20:"SCon tp i (stor (address e'))" using assms(1) assms(3) Var Some unfolding TypeSafe_def safeContract_def a10
          using a10 a20 by fastforce
        have "init ct i e = e'" using assms by simp
        moreover have "\<forall>x y t1 t2.  x \<noteq> y \<and> denvalue e $$ x = Some (Storage t1, Storeloc x) 
              \<and> denvalue e $$ y = Some (Storage t2, Storeloc y) 
              \<longrightarrow> \<not> TypedStoSubpref x y t2 \<and> \<not> TypedStoSubpref y x t1" 
        proof intros
          fix x y t1 t2 
          assume b99:"x \<noteq> y \<and> denvalue e $$ x = Some (Storage t1, Storeloc x) \<and> denvalue e $$ y = Some (Storage t2, Storeloc y)"
          then have b98:"ct $$ x = Some (Var t1)" using assms(5) by auto
          moreover have b97:"ct $$ y = Some (Var t2)" using assms(5) b99 by auto
          ultimately show " \<not> TypedStoSubpref x y t2" using a1 assms(3) b99  by metis
          show "\<not> TypedStoSubpref y x t1" using a1 assms(3) b99 b98 b97 by metis
        qed

        moreover have "\<forall>x t1. x \<noteq> i \<and> denvalue e $$ x = Some (Storage t1, Storeloc x) \<longrightarrow> \<not> TypedStoSubpref x i tp \<and> \<not> TypedStoSubpref i x t1"  
          using assms(4) assms(5) assms(3) assms(1) a1 a0 unfolding TypeSafe_def methodVarsNoPref_def  
          by (metis Type.inject(4) fst_conv)
        ultimately show "compPointers st (denvalue e')" using  a6 a10 compPointersPreserved[of st  e e' i tp] assms(1) a20 * ** assms(4) by blast
      next
        have *:"compMemPtrs st mem (denvalue e)" using assms TypeSafe_def by simp
        have **:"(\<forall>x y. denvalue e $$ x = Some y \<longrightarrow>  snd y \<noteq> Storeloc i)" using None assms by fastforce
        have "(\<forall>x y i''. denvalue e $$ x = Some y \<longrightarrow>  snd y \<noteq> Stackloc i'')" using assms by auto
        then have "(\<forall>x y i''. denvalue e' $$ x = Some y \<longrightarrow>  snd y \<noteq> Stackloc i'')" using a10 by auto
        then have "\<forall>tp1 l1. \<not>((Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e'))" using fmranI by fastforce
        then show "compMemPtrs st mem (denvalue e')" unfolding compMemPtrs_def  using assms(4)  by blast
      next
        show "lessThanTopLocs st"  using assms TypeSafe_def by simp
      next
        show "lessThanTopLocs cd"  using assms TypeSafe_def by simp
      next
        show "lessThanTopLocs mem"  using assms TypeSafe_def by simp
      next 
        show "addressFormat (address e')" using assms unfolding TypeSafe_def by auto
      next 
        show "addressFormat (sender e')" using assms unfolding TypeSafe_def by auto
      next 
        show "AddressTypes acc" using assms unfolding TypeSafe_def by blast
     
      qed
    next
      case some2:(Some a)
      then have a6:"e' = e" using updateEnvDup.simps assms(2) Some Var by simp
      then show ?thesis using assms by simp
    qed
  qed
qed

subsubsection \<open>Now initialising multiple variables starting with an empty environment will always
              result in a typesafe environment\<close>
  (*Assume the i does not exist in e - Follows from the context of ffold_init, Case split on lookup in e return some then use lemma in chat*)
lemma ffoldInitTypeSafe:
  assumes " safeContract stor"
    and "methodVarsNoPref"
    and "balanceTypes acc"
    and "svalueTypes sval"
    and "lessThanTopLocs mem"
    and "ep $$ contract e = Some(ct, dud)" (*from the context of CALL*)
    and "addressFormat (e2)"
    and "addressFormat  (e3)"
    and "AddressTypes acc"
  shows "\<forall>e' x y.  ffold (init ct) (emptyEnv (e2) (contract e) (e3) sval) xs = e' 
          \<longrightarrow> TypeSafe e' acc emptyStore mem stor emptyStore 
              \<and>( (denvalue e') $$ x  = Some y \<longrightarrow> (snd y) = Storeloc x )
              \<and> ( denvalue e' $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))
              "
proof(induct xs)
  case empty
  then show ?case
  proof(intros)
    fix e' x y
    assume **:"ffold (init ct) (emptyEnv (e2) (contract e) ( e3) sval) {||} = e'"
    then have ***:"e' = emptyEnv(e2) (contract e) ( e3) sval" using FSet.comp_fun_commute.ffold_empty[OF init_commte] by simp
    then have "svalueTypes sval" unfolding emptyEnv_def using assms(4) svalueTypes_def by simp
    have " safeContract stor" using assms(1) *** 
      using safeContract_def by force
    then show "TypeSafe e' acc emptyStore mem stor emptyStore"
      using ** ***  assms emptyEnvSafe emptyTopLocs emptyEnv_svalue   
      by (metis)
    assume a22: "denvalue e' $$ x = Some y"
    have "denvalue e' = fmempty" using *** by simp
    then have a23:"(denvalue e') $$ x = None" by simp
    then show "snd y = Storeloc x" using a22 by simp
    then show " \<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1" using a22 a23 by auto
  qed 
next
  case (insert x xs)
  then have *: "ffold (init ct) (emptyEnv (e2) (contract e) ( e3) sval) (finsert x xs) =
    init ct x (ffold (init ct) (emptyEnv (e2) (contract e) ( e3) sval) xs)" using FSet.comp_fun_commute.ffold_finsert[OF init_commte] by simp
  show ?case
  proof (intros)
    fix e' xa y ya  assume **: "ffold (init ct) (emptyEnv ( e2) (contract e) ( e3) sval) (finsert x xs) = e'"
    obtain e'' where ***: "ffold (init ct) (emptyEnv ( e2) (contract e) ( e3) sval) xs = e''" using * by simp
    then have a10:"TypeSafe e'' acc emptyStore mem stor emptyStore"  using insert * by simp
    then have a15: "(denvalue e'' $$ x = Some y \<longrightarrow> snd y = Storeloc x)" using insert * *** by blast
    then have a16:" denvalue e'' $$ xa = Some ya \<longrightarrow>  (\<exists>t1. ct $$ xa = Some (Var t1) \<and> fst ya = Storage t1)"  using insert * *** a10 by blast
    then have a20:"init ct x e'' = e'" using * ** *** by simp
    then have a23:"contract e = contract (emptyEnv (address e) (contract e) (sender e) (svalue e))" using a20 by simp
    then have a25: "contract e = contract e''" using *** ffold_init_contract by auto 
    have "(case ct $$ x of None \<Rightarrow> e'' | Some (Var tp) \<Rightarrow> updateEnvDup x (Storage tp) (Storeloc x) e'' | Some _ \<Rightarrow> e'') = e'" 
      using init_def[of ct x e''] a20 by auto
    then show a30:"TypeSafe e' acc emptyStore mem stor emptyStore" 
      using initEmptySafe[of e'' acc emptyStore mem stor emptyStore ct x] assms(2) a10 a15 a20 a25 a16 insert ***  assms(6) by metis

    assume a40:"denvalue e' $$ xa = Some y"
    show "snd y = Storeloc xa" 
    proof (cases "denvalue e'' $$ xa = Some y")
      case True
      then show ?thesis using insert *** by blast
    next
      case False
      then have a50:"denvalue e' \<noteq> denvalue e''" using a40 by auto
      then obtain tp where a60:"fmlookup ct x = Some (Var tp)" using a50 a20 a40 init_def by (simp split:option.splits Member.splits )
      then have a70:"denvalue e' = denvalue(updateEnvDup x (Storage tp) (Storeloc x) e'')" using a50 a20 a40 by (simp split:option.splits Member.splits )
      then have a80:"denvalue e' = denvalue(e''\<lparr> denvalue := fmupd x ((Storage tp),(Storeloc x)) (denvalue e'')\<rparr>)" using updateEnvDup.simps updateEnv.simps by (metis a20 a50 a60 init_s12 init_s13)
      then have a90:"xa = x" using a70 a40 a20 a50 a60 init_def updateEnvDup_dup False by metis
      then have "denvalue e' $$ x = Some ((Storage tp),(Storeloc x))" using a80 by simp
      then have "y = ((Storage tp), (Storeloc x))" using a90 a40 by simp
      then show ?thesis using a90 by simp
    qed
    show "\<exists>t1. ct $$ xa = Some (Var t1) \<and> fst y = Storage t1"
    proof (cases "denvalue e'' $$ xa = Some y")
      case True
      then show ?thesis using insert *** by blast
    next
      case False
      then have a50:"denvalue e' \<noteq> denvalue e''" using a40 by auto
      then obtain tp where a60:"fmlookup ct x = Some (Var tp)" using a50 a20 a40 init_def by (simp split:option.splits Member.splits )
      then have a70:"denvalue e' = denvalue(updateEnvDup x (Storage tp) (Storeloc x) e'')" using a50 a20 a40 by (simp split:option.splits Member.splits )
      then have a80:"denvalue e' = denvalue(e''\<lparr> denvalue := fmupd x ((Storage tp),(Storeloc x)) (denvalue e'')\<rparr>)" using updateEnvDup.simps updateEnv.simps by (metis a20 a50 a60 init_s12 init_s13)
      then have a90:"xa = x" using a70 a40 a20 a50 a60 init_def updateEnvDup_dup False by metis
      then have "denvalue e' $$ x = Some ((Storage tp),(Storeloc x))" using a80 by simp
      then show ?thesis using a90 a60 a80 a60 a40 by auto
    qed
  qed
qed

lemma ffoldInit_var_storage_mapping:
  assumes "ffold (init ct) (emptyEnv adv c adde v') (fmdom ct) = loaded"
  shows "\<forall>id v. ct $$ id = Some (Var v) \<longrightarrow> (denvalue loaded $$ id = Some (Storage v, Storeloc id))" using assms
proof(induct "fmdom ct" rule: fset_induct)
  case empty
  show ?case
  proof(intros)
    fix id v
    assume "ct $$ id = Some (Var v)"
    then have "id |\<in>| fmdom ct" using fmdomI by metis 
    then have "id |\<in>| {||}" using empty by simp
    then show "denvalue loaded $$ id = Some (Storage v, Storeloc id)" by blast
  qed
next
  case (insert x xs)
  let ?e_start = "emptyEnv adv c (adde) v'"
  have loaded_def: "ffold (init ct) ?e_start (finsert x xs) = loaded" using insert assms by simp
  show "\<forall>id v. ct $$ id = Some (Var v) \<longrightarrow> denvalue loaded $$ id = Some (Storage v, Storeloc id)"
  proof intros
    fix id v 
    assume "ct $$ id = Some (Var v)"
    then show "denvalue loaded $$ id = Some (Storage v, Storeloc id)" using insert 
      using ffold_init_fmdom by force
  qed
qed

lemma ffoldInit_var_storage_mapping2:
  assumes "ffold (init ct) (emptyEnv adv c (adde) v') (fmdom ct) = loaded"
  shows "\<forall>id v. (denvalue loaded $$ id = Some (Storage v, Storeloc id)) \<longrightarrow> ct $$ id = Some (Var v)" using assms
proof(induct "fmdom ct" rule: fset_induct)
  case empty
  show ?case
  proof(intros)
    fix id v
    assume " denvalue loaded $$ id = Some (Storage v, Storeloc id)"
    then show " ct $$ id = Some (Var v)" 
      using assms ffold_init_emptyDen_ran by blast
  qed
next
  case (insert x xs)
  let ?e_start = "emptyEnv adv c (adde) v'"

  have loaded_def: "ffold (init ct) ?e_start (finsert x xs) = loaded" using insert assms by simp
  show "\<forall>id v. denvalue loaded $$ id = Some (Storage v, Storeloc id) \<longrightarrow> ct $$ id = Some (Var v)"
  proof intros
    fix id v 
    assume "denvalue loaded $$ id = Some (Storage v, Storeloc id)"
    then show "ct $$ id = Some (Var v)" using insert 
      using ffold_init_fmdom 
      by (meson ffold_init_emptyDen_ran)
  qed
qed

lemma ffoldInit_var_storage_mapping_eq:
  assumes "ffold (init ct) (emptyEnv adv c (adde) v') (fmdom ct) = loaded"
  shows "\<forall>id v. (denvalue loaded $$ id = Some (Storage v, Storeloc id)) \<longleftrightarrow> ct $$ id = Some (Var v)"
  using ffoldInit_var_storage_mapping2 ffoldInit_var_storage_mapping assms by blast

subsection \<open>Decl is typesafe\<close>
text \<open>Decl is used by load in order to declare the contract variabled into the newly created environement.
  For simple cases (stack values) decl will copy the value from the source location into the top of the stack.
  For more complex data types such as copying a memory structure the structure is copied recursively using 
  a support function (such as cpm2mrec)\<close>
subsubsection \<open>Typesafety of cpm2m\<close>
subsubsection \<open>Mutual recursion; Iter' and cpm2mrec\<close>
text \<open>Cpm2m works by iteration (with iter') over each index in the array and copying the value 
      and in the case of arrays its sub-indexs (which is done by calling iter' on all indexs)
      To aid in the induction the following:\<close>

lemma iter'_ind:              
  assumes "\<And>v'. iter' f v 0 = Some v' \<Longrightarrow> P 0 v'"
    "\<And>x v''. (\<exists>v'. iter' f v x = Some v' \<and> P x v' \<and> f x v' = Some v'') \<Longrightarrow> iter' f v (Suc x) = Some v'' \<Longrightarrow> P (Suc x) v''"
  shows "iter' f v x = Some v' \<Longrightarrow> P x v'"
  apply (induction x arbitrary: v') using assms apply blast
proof -
  fix x v'
  assume xx:"\<And>v'. iter' f v x = Some v' \<Longrightarrow> P x v'" and
    *: "iter' f v (Suc x) = Some v'"

  from * obtain v'' where "f (Suc x-1) v'' = Some v'" and "iter' f v x = Some v''" using iter'.simps[of f v "Suc x"] by (auto split: option.split_asm)
  then have yy:"f x v'' = Some v'" and "iter' f v x = Some v''" by simp+
  then show  "P (Suc x) v'" using assms(2)[OF _ *]  xx by simp
qed

lemma cpm2mRec_destRootSame:
  shows "(cpm2mrec (hash ls suffixa) (hash ld suffix') t ms m = Some v'')\<longrightarrow> accessStore ld v'' = accessStore ld m"
proof intros
  assume "cpm2mrec (hash ls suffixa) (hash ld suffix') t ms m = Some v''" 
  then have ***:"cpm2mrec (hash ls suffixa) (hash ld suffix') t ms m = Some v''" by simp+
  show " accessStore ld v'' = accessStore ld m " using ***
  proof (induction t arbitrary: m v'' suffixa suffix' ls)
    case (MTArray x1 t)
    then obtain l where  a40:"accessStore (hash ls suffixa) ms = Some (MPointer l)" using cpm2mrec.simps(1) by (auto split:if_splits option.splits Memoryvalue.splits) 
    have a60:"Some v'' =
            (let m = updateStore (hash ld suffix') (MPointer (hash ld suffix')) m
                 in iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m x1)" 
      using MTArray cpm2mrec.simps(1)[of "hash ls suffixa" "hash ld suffix'" x1 t ms m] a40 by (simp split:option.splits Memoryvalue.splits)
    then obtain m' where a50:" m'= updateStore ((hash ld suffix')) (MPointer (hash ld suffix')) m" by simp
    then have a55:"accessStore ld m = accessStore ld m'" unfolding accessStore_def updateStore_def using hash_inequality by simp
    then have a70:"Some v'' =iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x1" using a40 a60 a50 by metis
    show ?case
    proof(induction rule: iter'_ind[OF _ _ a70[symmetric]])
      case (1 v')
      then have "v' = m'" using iter'.simps by simp
      then show ?case using a55 by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffix')(ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x = Some v'"
          and a20:"accessStore ld v' = accessStore ld m"
          and a30:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
      have "cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (hash suffix' (ShowL\<^sub>n\<^sub>a\<^sub>t x))) t ms v' = Some v''" using hash_suffixes_associative a30  by simp
      then have " accessStore ld  v'' = accessStore  ld  v'" using MTArray(1)[of l "(ShowL\<^sub>n\<^sub>a\<^sub>t x)"] by simp 
      then show ?case using a20 by simp
    qed
  next
    case (MTValue x)
    then have a10:"Some v'' =  (case accessStore (hash ls suffixa) ms of None \<Rightarrow> None | Some (MValue v) \<Rightarrow> Some (updateStore (hash ld suffix') (MValue v) m) | Some (MPointer literal) \<Rightarrow> None)" 
      using cpm2mrec.simps(2)[of "hash ls suffixa" "hash ld suffix'" x ms m ] by simp
    then obtain v where  " accessStore (hash ls suffixa) ms = Some (MValue v)" by (simp split:option.splits Memoryvalue.splits)
    then have "Some v'' =  Some (updateStore (hash ld suffix') (MValue v) m)" using a10 by simp
    then show ?case using hash_inequality unfolding updateStore_def accessStore_def by auto
  qed
qed

lemma cps2mRec_destRootSame:
  shows "(cps2mrec (hash ls suffixa) (hash ld suffix') t ms m' = Some v'')\<longrightarrow> accessStore ld v'' = accessStore ld m'"
proof intros
  assume "cps2mrec (hash ls suffixa) (hash ld suffix') t ms m' = Some v''" 
  then have ***:"cps2mrec (hash ls suffixa) (hash ld suffix') t ms m' = Some v''" by simp+
  show " accessStore ld v'' = accessStore ld m' " using ***
  proof (induction t arbitrary: m' v'' suffixa suffix' ls)
    case (STArray x1 t)
    have a60:"Some v'' =  (let m = updateStore (hash ld suffix') (MPointer (hash ld suffix')) m' in iter' (\<lambda>i. cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) m x1)" 
      using STArray cps2mrec.simps(1)[of "hash ls suffixa" "hash ld suffix'" x1 t ms m'] by (simp split:option.splits Memoryvalue.splits)
    then obtain m where a50:"m = updateStore (hash ld suffix') (MPointer (hash ld suffix')) m'" by simp
    then have a55:"accessStore ld m = accessStore ld m'" unfolding accessStore_def updateStore_def using hash_inequality by simp
    then have a70:"Some v'' =iter' (\<lambda>i. cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) m x1" using a60 a50 by metis
    show ?case
    proof(induction rule: iter'_ind[OF _ _ a70[symmetric]])
      case (1 v')
      then have "v' = m" using iter'.simps by simp
      then show ?case using a55 by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) m x = Some v'"
          and a20:"accessStore ld v' = accessStore ld m'"
          and a30:"cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
      have "cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" using hash_suffixes_associative a30  by simp
      then have "accessStore ld  v'' = accessStore  ld  v'" using STArray(1) by (simp add: hash_suffixes_associative) 
      then show ?case using a20 by simp
    qed
  next
    case (STValue x)
    then have a10:"Some v'' = (let v = accessStorage x (hash ls suffixa) ms in Some (updateStore (hash ld suffix') (MValue v) m'))" 
      using cps2mrec.simps(2)[of "hash ls suffixa" "hash ld suffix'"  x ms m' ] by simp
    then obtain v where  "accessStorage x (hash ls suffixa) ms =  v" by (simp split:option.splits Memoryvalue.splits)
    then have "Some v'' =  Some (updateStore (hash ld suffix') (MValue v) m')" using a10 by simp
    then show ?case using hash_inequality unfolding updateStore_def accessStore_def by auto
  next 
    case (STMap k v)
    then show ?case using cps2mrec.simps(3) by auto 
  qed
qed

lemma cpm2sRec_destRootSame:
  shows "\<forall>t'. (cpm2srec (hash ls suffixa) (hash ld suffix') t ms m' = Some v'')\<longrightarrow> accessStorage t' ld v'' = accessStorage t' ld m'"
proof intros
  fix t'
  assume **:"cpm2srec (hash ls suffixa) (hash ld suffix') t ms m' = Some v''" 
  then show "accessStorage t' ld v'' = accessStorage t' ld m'" 
  proof (induction t arbitrary: m' v'' suffixa suffix' ls)
    case (MTArray x1 t)
    then obtain l where ldef:"accessStore (hash ls suffixa) ms = Some (MPointer l)" unfolding  cpm2srec.simps by (simp split:option.splits Memoryvalue.splits)
    then have a60:"Some v'' =  iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) m' x1" 
      using MTArray unfolding cpm2srec.simps(1) by (simp split:option.splits Memoryvalue.splits)
    show ?case
    proof(induction rule: iter'_ind[OF _ _ a60[symmetric]])
      case (1 v')
      then have "v' = m'" using iter'.simps by simp
      then show ?case  by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) m' x = Some v'"
          and a20:"accessStorage t' ld v' = accessStorage t' ld m'"
          and a30:"cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
      then show ?case  
        using MTArray.IH hash_suffixes_associative by auto
    qed
  next
    case (MTValue x)
    then have "hash ld suffix' \<noteq> ld" 
      by (simp add: hash_inequality)
    then show ?case using MTValue unfolding cpm2srec.simps accessStorage_def by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma copyRec_destRootSame:
  shows "\<forall>t'. (copyRec (hash ls suffixa) (hash ld suffix') t m' = Some v'')\<longrightarrow> accessStorage t' ld v'' = accessStorage t' ld m'"
proof intros
  fix t'
  assume **:"copyRec (hash ls suffixa) (hash ld suffix') t m' = Some v''" 
  then show "accessStorage t' ld v'' = accessStorage t' ld m'" 
  proof (induction t arbitrary: m' v'' suffixa suffix' ls)
    case (STArray x1 t)
    then have a60:"Some v'' = iter' (\<lambda>i. copyRec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m' x1" 
      unfolding copyRec.simps by simp
    show ?case 
    proof(induction rule: iter'_ind[OF _ _ a60[symmetric]])
      case (1 v')
      then have "v' = m'" using iter'.simps by simp
      then show ?case  by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. copyRec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m' x = Some v'"
          and a20:"accessStorage t' ld v' = accessStorage t' ld m' "
          and a30:"copyRec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffix') (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = Some v''" by blast
      then show ?case using STArray.IH hash_suffixes_associative by auto
    qed
  next
    case (STMap x1 t)
    then show ?case 
      using copyRec.simps(3) by auto
  next
    case (STValue x)
    then show ?case using accessStorage_def hash_suffixes_associative 
      using copyRec.simps(2) hash_inequality by force
  qed
qed


(*If cpm2mrec writes to an index n (Would be from the context if iter in cpm2m)
Then the only value to changed between the source memory a and the result v'' would be the location
n and any/all sub-prefixes.
Therefore it should be trivial to show that for indexes 
na < n then all the values in a must equal v''*)
lemma cpm2mrecSingleChange:
  assumes " Some v'' = cpm2mrec (hash ls suffixa) (hash ld suffixb) t ms a  "
  shows "((\<forall>x'. suffix' \<noteq> hash suffixb x')
          \<and> suffix' \<noteq> suffixb
          \<longrightarrow> accessStore (hash ld suffix') a = accessStore (hash ld suffix') v'')"
proof intros
  fix suffix'
  assume **:" (\<forall>x'. suffix' \<noteq> hash suffixb x') \<and> suffix' \<noteq> suffixb" 
  show "accessStore (hash ld suffix') a = accessStore (hash ld suffix') v''" using ** assms
  proof(induction t arbitrary:a v'' suffixb ls suffixa suffix')
    case (MTArray x1 t)
    then obtain l where  a40:"accessStore (hash ls suffixa) ms = Some (MPointer l)" using cpm2mrec.simps(1) by (auto split:if_splits option.splits Memoryvalue.splits) 
    have a60:"Some v'' =
            (let m = updateStore (hash ld suffixb) (MPointer (hash ld suffixb)) a
                 in iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m x1)" 
      using a40 MTArray cpm2mrec.simps(1)[of "hash ls suffixa" "hash ld suffixb" x1 t ms a] by (simp split:option.splits Memoryvalue.splits)
    then obtain m' where a50:" m'= updateStore ((hash ld suffixb)) (MPointer (hash ld suffixb)) a" by simp
    then have a55:"accessStore ld a = accessStore ld m'" unfolding accessStore_def updateStore_def using hash_inequality by simp
    then have a70:"Some v'' =iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x1" using a60 a50 by presburger
    show ?case
    proof(induction rule: iter'_ind[OF _ _ a70[symmetric]])
      case (1 v')      
      then have "v' = m'" using iter'.simps by simp
      then show ?case using hash_never_equal_sufix MTArray(2) a50  unfolding accessStore_def updateStore_def by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i'. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb)(ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x = Some v'"
          and a20:"accessStore (hash ld suffix') a = accessStore (hash ld suffix') v'"
          and a30:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
      have a40:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x))) t ms v' = Some v''" using hash_suffixes_associative a30  by simp
      have a50:"suffix' \<noteq> suffixb" using MTArray(2) by simp
      then have a60:" suffix' \<noteq> hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x)" by (simp add: MTArray.prems(1))
      then have a70:"(\<forall>xa. suffix' \<noteq> hash (hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x)) xa)" by (simp add: MTArray.prems(1) hash_suffixes_associative)
      then have "(\<forall>x. suffix' \<noteq> hash suffixb x)" using MTArray by simp
      then have "accessStore (hash ld suffix') v' = accessStore (hash ld suffix') v''" using MTArray(1)[of suffix' "hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x)" v'' l "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" v']
          hash_never_equal_prefix MTArray(2) a40 a50 by (simp add: hash_suffixes_associative) 
      then show ?case using a20 by simp
    qed
  next
    case (MTValue x)
    then have a10:"Some v'' =  (case accessStore (hash ls suffixa) ms of None \<Rightarrow> None | Some (MValue v) \<Rightarrow> Some (updateStore (hash ld suffixb) (MValue v) a) | Some (MPointer literal) \<Rightarrow> None)" 
      using cpm2mrec.simps(2)[of "hash ls suffixa" "hash ld suffixb" x ms a ] by simp
    then obtain v where  " accessStore (hash ls suffixa) ms = Some (MValue v)" by (simp split:option.splits Memoryvalue.splits)
    then have "Some v'' =  Some (updateStore (hash ld suffixb) (MValue v) a)" using a10 by simp
    then show ?case using hash_never_equal_sufix MTValue unfolding updateStore_def accessStore_def by auto
  qed 
qed

lemma iterIndexMinOne:
  assumes "iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md (Suc x) = Some v''"
  shows "\<exists>v'. iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
proof -
  have "Some v'' =(if Suc x \<le> 0 then Some md
     else case iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md (Suc x - 1) of None \<Rightarrow> None
          | Some xa \<Rightarrow> cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) t ms xa)" 
    using assms iter'.simps[of " (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms)" md "(Suc x)"] by simp
  then have **:"Some v'' = (case iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md (Suc x - 1) of None \<Rightarrow> None
          | Some xa \<Rightarrow> cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) t ms xa)" by simp
  then show ?thesis
  proof(cases "iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md (Suc x - 1)")
    case None
    then show ?thesis using ** by simp
  next
    case (Some a)
    then have "Some v'' = cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x - 1))) t ms a" using ** by simp
    then have "iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = 
               iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md (Suc x - 1)" by simp
    then show ?thesis using Some by simp
  qed
qed

lemma cps2mrecSingleChange:
  assumes " Some v'' = cps2mrec (hash ls suffixa) (hash ld suffixb) t ms a  "
  shows "
          ( (\<forall>x'. suffix' \<noteq> hash suffixb x')
          \<and> suffix' \<noteq> suffixb
          \<longrightarrow> accessStore (hash ld suffix') a = accessStore (hash ld suffix') v'')"
proof intros
  fix suffix'
  assume **:" (\<forall>x'. suffix' \<noteq> hash suffixb x') \<and> suffix' \<noteq> suffixb" 
  show "accessStore (hash ld suffix') a = accessStore (hash ld suffix') v''" using ** assms
  proof(induction t arbitrary:a v'' suffixb ls suffixa suffix')
    case (STArray x1 t)
    have a60:"Some v'' =
            (let m = updateStore (hash ld suffixb) (MPointer (hash ld suffixb)) a
                 in iter' (\<lambda>i'. cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m x1)" 
      using  STArray cps2mrec.simps(1)[of "(hash ls suffixa)"] by (simp split:option.splits Memoryvalue.splits)
    then obtain m' where a50:" m'= updateStore ((hash ld suffixb)) (MPointer (hash ld suffixb)) a" by simp
    then have a55:"accessStore ld a = accessStore ld m'" unfolding accessStore_def updateStore_def using hash_inequality by simp
    then have a70:"Some v'' =iter' (\<lambda>i'. cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x1" using a60 a50 by presburger
    show ?case
    proof(induction rule: iter'_ind[OF _ _ a70[symmetric]])
      case (1 v')      
      then have "v' = m'" using iter'.simps by simp
      then show ?case using hash_never_equal_sufix STArray(2) a50  unfolding accessStore_def updateStore_def by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i'. cps2mrec (hash (hash ls suffixa)  (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (hash (hash ld suffixb)(ShowL\<^sub>n\<^sub>a\<^sub>t i')) t ms) m' x = Some v'"
          and a20:"accessStore (hash ld suffix') a = accessStore (hash ld suffix') v'"
          and a30:"cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash (hash ld suffixb) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
      have a40:"cps2mrec (hash (hash ls suffixa) (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x))) t ms v' = Some v''" using hash_suffixes_associative a30  by simp
      have a50:"suffix' \<noteq> suffixb" using STArray(2) by simp
      then have a60:" suffix' \<noteq> hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x)" by (simp add: STArray.prems(1))
      then have a70:"(\<forall>xa. suffix' \<noteq> hash (hash suffixb (ShowL\<^sub>n\<^sub>a\<^sub>t x)) xa)" by (simp add: STArray.prems(1) hash_suffixes_associative)
      then have "(\<forall>x. suffix' \<noteq> hash suffixb x)" using STArray by simp
      then have "accessStore (hash ld suffix') v' = accessStore (hash ld suffix') v''" using STArray(1)[of _ _ v'' "(hash ls suffixa)" "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" ]
          hash_never_equal_prefix STArray(2) a40 a50 by (metis a70) 
      then show ?case using a20 by simp
    qed

  next
    case (STValue x)
    then have a10:"Some v'' = (let v = accessStorage x (hash ls suffixa) ms in Some (updateStore (hash ld suffixb) (MValue v) a))" 
      using cps2mrec.simps(2)[of "hash ls suffixa" "hash ld suffixb" x ms a ] by simp
    then obtain v where  "accessStorage x (hash ls suffixa) ms = v" by (simp split:option.splits Memoryvalue.splits)
    then have "Some v'' = Some (updateStore (hash ld suffixb) (MValue v) a)" using a10 by simp
    then show ?case using hash_never_equal_sufix STValue unfolding updateStore_def accessStore_def by auto
  next 
    case (STMap k v)
    then show ?case using cps2mrec.simps by simp
  qed 
qed

lemma accessPrePost1:
  shows " Some v'' = iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1
          \<and> (\<forall>suffix. hash destl suffix \<noteq> destl)  \<longrightarrow> accessStore destl m = accessStore destl v'' "
proof intros
  assume " Some v'' = iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1 \<and>   (\<forall>suffix. hash destl suffix \<noteq> destl)"
  then have *:"Some v'' = iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1"
    and **: "(\<forall>suffix. hash destl suffix \<noteq> destl)" by simp+
  then show "accessStore destl m = accessStore destl v''"
  proof(induction rule: iter'_ind[OF _ _ *[symmetric]])
    case (1 v')
    then show ?case by simp
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x = Some v'"
        and a20:"(Some v' = iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x \<and> (\<forall>suffix. hash destl suffix \<noteq> destl) \<longrightarrow> accessStore destl m = accessStore destl v')"
        and a30:"cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' srcMem v' = Some v''" by blast
    then show ?case using cpm2mRec_destRootSame[of srcl "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" destl "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" t' srcMem v' v''] 
      using "**" by auto
  qed
qed

lemma cps2mAccessPrePost:
  shows " Some v'' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1
          \<and> (\<forall>suffix. hash destl suffix \<noteq> destl)  \<longrightarrow> accessStore destl m = accessStore destl v'' "
proof intros
  assume " Some v'' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1 \<and>   (\<forall>suffix. hash destl suffix \<noteq> destl)"
  then have *:"Some v'' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x1"
    and **: "(\<forall>suffix. hash destl suffix \<noteq> destl)" by simp+
  then show "accessStore destl m = accessStore destl v''"
  proof(induction rule: iter'_ind[OF _ _ *[symmetric]])
    case (1 v')
    then show ?case by simp
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x = Some v'"
        and a20:"(Some v' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) m x \<and> (\<forall>suffix. hash destl suffix \<noteq> destl) \<longrightarrow> accessStore destl m = accessStore destl v')"
        and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' srcMem v' = Some v''" by blast
    then show ?case using cps2mRec_destRootSame 
      using "**" by simp
  qed
qed

lemma cpm2mrec_SubPrefixes:
  "cpm2mrec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl'. (\<not>LSubPrefL2 destl' destl) \<longrightarrow> accessStore destl' a = accessStore destl' v''')"
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (MTArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume " cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''"
    then have 
      **: "cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''" by auto+

    obtain l where ldef:"accessStore srcl srcMem = Some (MPointer l)" using **  cpm2mrec.simps(1)[of srcl destl x1 t srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using **  by (simp add: cpm2mrec.simps(1))
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto
    have a20:"\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' a = accessStore destl' m"
    proof -
      assume "\<not> LSubPrefL2 destl' destl"
      then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] by auto
      then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
      then show "accessStore destl' a = accessStore destl' m" using mdef unfolding accessStore_def updateStore_def by auto
    qed

    then have v''def:"Some v''' =  iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a5 ldef mdef by metis 
    show "\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' a = accessStore destl' v'''" using a20 ldef
    proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]]) 
      case (1 v')

      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:"(\<not> LSubPrefL2 destl' destl \<longrightarrow> accessStore destl' a = accessStore destl' m)  
                        \<longrightarrow> accessStore destl' a = accessStore destl' v'"
          and a30:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have b40:"accessStore destl' a = accessStore destl' v'" using 2 by simp
      then show ?case
      proof(cases t)
        case mtr:(MTArray x11 x12)
        then have b10:"Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
                     | Some (MPointer l) \<Rightarrow> let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)"
          using a30 cpm2mrec.simps(1)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v' ] by simp
        then obtain thing where tig:"accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MPointer thing)" 
          using mtr by (simp split:option.splits Memoryvalue.splits)

        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray mtr a30 tig by simp
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by simp
        then show ?thesis using b45 b40 by simp
      next
        case (MTValue x2)
        then have "Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None 
                                      | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') |
                                       Some (MPointer literal) \<Rightarrow> None)" 
          using cpm2mrec.simps(2)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] using a30 by simp
        then obtain thing where "accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MValue thing)" 
          using MTValue by (simp split:option.splits Memoryvalue.splits)
        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray MTValue a30 by simp
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by simp
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45 by simp
        then show ?thesis using b40  by simp
      qed
    qed
  qed
next
  case (MTValue x)
  show ?case
  proof intros
    fix destl'
    assume " cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''"

    then have **:" cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''" by simp+
    then have mdef:"Some v''' = (case accessStore srcl srcMem of None \<Rightarrow> None 
                    | Some (MValue v) \<Rightarrow> Some (updateStore destl (MValue v) a) 
                    | Some (MPointer literal) \<Rightarrow> None)" using cpm2mrec.simps(2)[of srcl destl x srcMem a] by simp
    assume ***:"\<not> LSubPrefL2 destl' destl"
    then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] by auto
    then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
    then show "accessStore destl' a = accessStore destl' v'''" using mdef unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma cps2mrec_SubPrefixes:
  "cps2mrec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl'. (\<not>LSubPrefL2 destl' destl) \<longrightarrow> accessStore destl' a = accessStore destl' v''')"
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (STArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume " cps2mrec srcl destl (STArray x1 t) srcMem a = Some v'''"
    then have 
      **: "cps2mrec srcl destl (STArray x1 t) srcMem a = Some v'''" by auto+

    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using ** cps2mrec.simps(1)[of srcl destl x1 t srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto
    have a20:"\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' a = accessStore destl' m"
    proof -
      assume "\<not> LSubPrefL2 destl' destl"
      then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] by auto
      then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
      then show "accessStore destl' a = accessStore destl' m" using mdef unfolding accessStore_def updateStore_def by auto
    qed

    then have v''def:"Some v''' =  iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a5 mdef by metis 
    show "\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' a = accessStore destl' v'''" using a20 
    proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]]) 
      case (1 v')

      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:"(\<not> LSubPrefL2 destl' destl \<longrightarrow> accessStore destl' a = accessStore destl' m)  
                        \<longrightarrow> accessStore destl' a = accessStore destl' v'"
          and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have b40:"accessStore destl' a = accessStore destl' v'" using 2 by simp
      then show ?case
      proof(cases t)
        case mtr:(STArray x11 x12)
        then have b10:"Some v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cps2mrec (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)"
          using a30 cps2mrec.simps(1)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v' ] by simp
        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using STArray mtr a30 by simp
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by simp
        then show ?thesis using b45 b40 by simp
      next
        case (STValue x2)
        then have "Some v'' =  (let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem 
                                    in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'))" 
          using cps2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] using a30 by simp

        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using STArray STValue a30 by simp
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by simp
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45 by simp
        then show ?thesis using b40  by simp
      next case (STMap x3 x4)
        then show ?thesis 
          using cps2mrec.simps(3) using a30 by simp
      qed
    qed
  qed
next
  case (STValue x)
  show ?case
  proof intros
    fix destl'
    assume " cps2mrec srcl destl (STValue x) srcMem a = Some v'''"

    then have **:" cps2mrec srcl destl (STValue x) srcMem a = Some v'''" by simp+
    then have mdef:"Some v''' = (let v = accessStorage x srcl srcMem 
                      in Some (updateStore destl (MValue v) a))" 
      using cps2mrec.simps(2)[of srcl destl x srcMem a] by simp
    assume ***:"\<not> LSubPrefL2 destl' destl"
    then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] by auto
    then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
    then show "accessStore destl' a = accessStore destl' v'''" using mdef unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits)
  qed
next 
  case (STMap x1 tp)
  then show ?case using cps2mrec.simps(3) by auto
qed

lemma cpm2srec_SubPrefixes:
  "cpm2srec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl' t. (\<not>LSubPrefL2 destl' destl) \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v''')" 
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (MTArray x1 tp)
  show ?case 
  proof intros
    fix destl' t
    assume "cpm2srec srcl destl (MTArray x1 tp) srcMem a = Some v'''"
    then have 
      **: "cpm2srec srcl destl (MTArray x1 tp) srcMem a = Some v'''" by auto+
    then obtain l where ldef:"accessStore srcl srcMem = Some (MPointer l)"
      using ** cpm2srec.simps(1)[of srcl destl x1 tp srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then have a5:"Some v''' =   iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) a x1" 
      using ** cpm2srec.simps(1)[of srcl destl x1 tp srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)

    show "\<not> LSubPrefL2 destl' destl \<Longrightarrow>  accessStorage t destl' a = accessStorage t destl' v'''" 
    proof(induction rule: iter'_ind[OF _ _ a5[symmetric]]) 
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) a x = Some v'"
          and a20:"(\<not> LSubPrefL2 destl' destl \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v')"
          and a30:"cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp srcMem v' = Some v''" by blast
      then show ?case
      proof(cases tp)
        case (MTArray x11 x12)
        then show ?thesis 
          using "2.prems" MTArray.IH a20 a30 Not_Sub_More_Specific by fastforce
      next
        case (MTValue x2)
        then have a50:"cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MTValue x2) srcMem v' = Some v''" using a30 by simp
        then obtain v where vdef: "accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem  = Some (MValue v)" 
          using a30 unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
        then have "Some v'' = Some (v'(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) $$:= v))" using a50 unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
        then show ?thesis by (metis "2.prems" MTArray a20 a30 Not_Sub_More_Specific)
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix destl' t 
    assume *:"cpm2srec srcl destl (MTValue x) srcMem a = Some v'''" 
      and **:" \<not> LSubPrefL2 destl' destl"
    then obtain v where vdef: "accessStore srcl srcMem  = Some (MValue v)" 
      unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
    then have "Some v''' = Some (a(destl $$:= v))" using * unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
    moreover have "destl' \<noteq> destl" using ** LSubPrefL2_def by simp
    ultimately show "accessStorage t destl' a = accessStorage t destl' v''' " using ** accessStorage_def by simp
  qed
qed

lemma copyrec_SubPrefixes:
  "copyRec srcl destl tp a = Some v''' \<longrightarrow>
  (\<forall>destl' t. (\<not>LSubPrefL2 destl' destl) \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v''')" 
proof(induction tp arbitrary:srcl destl a v''' )
  case (STArray x1 t)
  show ?case
  proof intros
    fix destl' ta
    assume **:" copyRec srcl destl (STArray x1 t) a = Some v'''"

    then have a5:"Some v''' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) a x1" 
      using ** copyRec.simps(1)[of srcl destl x1 t a ] by simp

    show "\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStorage ta destl' a = accessStorage ta destl' v'''" 
    proof(induction rule: iter'_ind[OF _ _ a5[symmetric]]) 
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) a x = Some v' "
          and a20:"(\<not> LSubPrefL2 destl' destl \<longrightarrow> accessStorage ta destl' a = accessStorage ta destl' v')"
          and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = Some v''" by blast

      then show ?case
      proof(cases t)
        case mtr:(STArray x11 x12)
        then show ?thesis  using accessStorage_def "2.IH" "2.prems" Not_Sub_More_Specific 
          using STArray by force
      next
        case (STValue x2)
        then have "copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (STValue x2) v' = Some v''" using a30 by simp
        then have "(let e = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v' in Some (v'(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) $$:= e))) = Some v''" 
          unfolding copyRec.simps by simp
        then show ?thesis using accessStorage_def 
          using "2.IH" "2.prems" STArray Not_Sub_More_Specific by fastforce
      next 
        case (STMap x3 x4)
        then show ?thesis using a30 by (simp add: copyRec.simps(3))
      qed
    qed
  qed
next
  case (STValue x)
  show ?case
  proof intros
    fix destl' t
    assume "copyRec srcl destl (STValue x) a = Some v'''" and "\<not> LSubPrefL2 destl' destl"
    then show "accessStorage t destl' a = accessStorage t destl' v'''" 
      using accessStorage_def LSubPrefL2_def copyRec.simps(2) by auto
  qed
next 
  case (STMap x1 tp)
  then show ?case using copyRec.simps(3) by auto
qed


lemma cpm2srec_SubPrefixes2:
  "cpm2srec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl' tp' t.  destl' \<noteq> destl \<and> cps2mTypeCompatible tp' tp \<and> \<not> TypedStoSubpref destl' destl tp' \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v''')"
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (MTArray x1 tp)
  show ?case 
  proof intros
    fix destl' tp' t 
    assume **:"cpm2srec srcl destl (MTArray x1 tp) srcMem a = Some v'''"
      and ***:"destl' \<noteq> destl \<and> cps2mTypeCompatible tp' (MTArray x1 tp) \<and> \<not> TypedStoSubpref destl' destl tp'"
    then obtain l where ldef:"accessStore srcl srcMem = Some (MPointer l)"
      using ** cpm2srec.simps(1)[of srcl destl x1 tp srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then have a5:"Some v''' =   iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) a x1" 
      using ** cpm2srec.simps(1)[of srcl destl x1 tp srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    obtain st where stDef:"tp' = STArray x1 st" using *** 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    then have comp:" cps2mTypeCompatible (STArray x1 st) (MTArray x1 tp)" 
      using "***" by auto
    then have sub:"\<not> TypedStoSubpref destl' destl (STArray x1 st)" using *** stDef by blast
    show "accessStorage t destl' a = accessStorage t destl' v'''" using comp sub
    proof(induction rule: iter'_ind[OF _ _ a5[symmetric]]) 
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) a x = Some v'"
          and a20:"(cps2mTypeCompatible (STArray x st) (MTArray x tp)  \<longrightarrow> \<not> TypedStoSubpref destl' destl (STArray x st) \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v')"
          and a30:"cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp srcMem v' = Some v''" by blast

      then show ?case
      proof(cases tp)
        case (MTArray x11 x12)
        then show ?thesis 
        proof(cases "x = 0")
          case True
          then have "a = v'" using a10 by simp
          then show ?thesis 
            by (metis "2.prems"(1,2) MTArray.IH True TypedStoSubpref_sameLoc a30 cps2mTypeCompatible.simps(2) TypedStoSubpref.simps(2))
        next
          case False
          then have "accessStorage t destl' a = accessStorage t destl' v'" using a20 2 by simp
          moreover have "accessStorage t destl' v' = accessStorage t destl' v''" 
            using MTArray.IH[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem v' v''] a30 
            by (metis "2.prems"(1,2) TypedStoSubpref_sameLoc cps2mTypeCompatible.simps(2) lessI TypedStoSubpref.simps(2))
          ultimately show ?thesis using MTArray.IH[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem v' v''] a30 by auto
        qed
      next
        case (MTValue x2)
        then have a50:"cpm2srec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MTValue x2) srcMem v' = Some v''" using a30 by simp
        then obtain v where vdef: "accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem  = Some (MValue v)" 
          using a30 unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
        then have a70:"Some v'' = Some (v'(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) $$:= v))" using a50 unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
        then show ?thesis 
        proof(cases "x = 0")
          case True
          then have "a = v'" using a10 by simp
          then show ?thesis 
            using "2.prems"(1,2) MTArray True a30 
            by (metis TypedStoSubpref_sameLoc cps2mTypeCompatible.simps(2) TypedStoSubpref.simps(2))
        next
          case False
          then have "x>0" by blast
          then have "cps2mTypeCompatible (STArray x st) (MTArray x tp)" 
            using "2.prems"(1) by auto
          have "accessStorage t destl' a = accessStorage t destl' v'" using a20 False 2 by simp
          moreover have "accessStorage t destl' v' = accessStorage t destl' v''" using a30 
            by (metis "2.prems"(2) MTArray TypedStoSubpref_sameLoc \<open>cps2mTypeCompatible (STArray x st) (MTArray x tp)\<close> cps2mTypeCompatible.simps(2) lessI
                TypedStoSubpref.simps(2))
          ultimately show ?thesis using a70 a50 a20 by auto
        qed
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix destl' tp' t 
    assume *:"cpm2srec srcl destl (MTValue x) srcMem a = Some v'''" 
      and **:"destl' \<noteq> destl \<and> cps2mTypeCompatible tp' (MTValue x) \<and> \<not> TypedStoSubpref destl' destl tp'"
    then obtain v where vdef: "accessStore srcl srcMem  = Some (MValue v)" 
      unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
    then have "Some v''' = Some (a(destl $$:= v))" using * unfolding cpm2srec.simps by (auto split:if_splits option.splits Memoryvalue.splits)
    moreover have "destl' \<noteq> destl" using ** LSubPrefL2_def by simp
    ultimately show "accessStorage t destl' a = accessStorage t destl' v''' " using ** accessStorage_def 
      by auto
  qed
qed

lemma copyrec_SubPrefixes2:
  "copyRec srcl destl tp a = Some v''' \<longrightarrow>
  (\<forall>destl' t.  \<not> TypedStoSubpref destl' destl tp \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v''')"
proof(induction tp arbitrary:srcl destl a v''' )
  case (STArray x1 tp)
  show ?case 
  proof intros
    fix destl' t
    assume **:"copyRec srcl destl (STArray x1 tp) a = Some v'''"
      and ***:"\<not> TypedStoSubpref destl' destl (STArray x1 tp)"
    have a5:"Some v''' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp) a x1" 
      using ** unfolding copyRec.simps by simp

    show "accessStorage t destl' a = accessStorage t destl' v'''" using *** 
    proof(induction rule: iter'_ind[OF _ _ a5[symmetric]]) 
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp) a x = Some v'"
          and a20:"(\<not> TypedStoSubpref destl' destl (STArray x tp) \<longrightarrow> accessStorage t destl' a = accessStorage t destl' v')"
          and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp v' = Some v''" by blast
      then show ?case 
      proof(cases tp)
        case (STArray x11 x12)
        then show ?thesis 
          using "2.prems" STArray.IH a20 a30 by force
      next
        case (STMap x21 x22)
        then show ?thesis 
          using a30 copyRec.simps(3) by auto
      next
        case (STValue x3)
        then show ?thesis 
          using "2.prems" STArray a20 a30 by auto
      qed
    qed
  qed
next
  case (STMap x1 tp)
  then show ?case 
    by (simp add: copyRec.simps(3))
next
  case (STValue x)
  show ?case 
  proof intros
    fix destl' t
    assume *:"copyRec srcl destl (STValue x) a = Some v'''"
      and **:"\<not> TypedStoSubpref destl' destl (STValue x)"
    then show " accessStorage t destl' a = accessStorage t destl' v'''" using accessStorage_def 
      using copyRec.simps(2) by auto
  qed
qed

lemma copyrec_SubPrefixes2_rev:
  "copyRec srcl destl tp a = Some v''' \<longrightarrow>
  (\<forall>destl' t.   accessStorage t destl' a \<noteq> accessStorage t destl' v''' \<longrightarrow> TypedStoSubpref destl' destl tp)"
proof(induction tp arbitrary:srcl destl a v''' )
  case (STArray x1 tp)
  show ?case 
  proof intros
    fix destl' t
    assume **:"copyRec srcl destl (STArray x1 tp) a = Some v'''"
      and ***:"accessStorage t destl' a \<noteq> accessStorage t destl' v''' "
    have a5:"Some v''' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp) a x1" 
      using ** unfolding copyRec.simps by simp

    show " TypedStoSubpref destl' destl (STArray x1 tp)" using *** 
    proof(induction rule: iter'_ind[OF _ _ a5[symmetric]]) 
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp) a x = Some v'"
          and a20:"(accessStorage t destl' a \<noteq> accessStorage t destl' v' \<longrightarrow> TypedStoSubpref destl' destl (STArray x tp))"
          and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp v' = Some v''" by blast
      then show ?case 
      proof(cases tp)
        case (STArray x11 x12)
        then show ?thesis 
          using "2.prems" STArray.IH a20 a30 
          by (metis less_Suc_eq TypedStoSubpref.simps(2))
      next
        case (STMap x21 x22)
        then show ?thesis 
          using a30 copyRec.simps(3) by auto
      next
        case (STValue x3)
        then show ?thesis 
          using "2.prems" STArray a20 a30 
          using less_Suc_eq by fastforce
      qed
    qed
  qed
next
  case (STMap x1 tp)
  then show ?case 
    by (simp add: copyRec.simps(3))
next
  case (STValue x)
  show ?case 
  proof intros
    fix destl' t
    assume *:"copyRec srcl destl (STValue x) a = Some v'''"
      and **:" accessStorage t destl' a \<noteq> accessStorage t destl' v''' "
    then show "TypedStoSubpref destl' destl (STValue x)" using accessStorage_def 
      using copyRec.simps(2) 
      using copyrec_SubPrefixes2 by blast
  qed
qed



lemma Cpm2mrec_val_types:
  assumes "iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTValue x2) srcMem) m x1 = Some v'"
  shows "\<forall>i<x1. (\<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val))"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v' 
    where a10: "iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTValue x2) srcMem) m x = Some v'"
      and a20: "(\<forall>i<x. \<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val))" 
      and a30:"cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MTValue x2) srcMem v' = Some v''" by blast
  obtain t where a40: "accessStore (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MValue t)" using a30 using cpm2mrec.simps(2) by (auto split:option.splits Memoryvalue.splits)
  show ?case 
  proof intros
    fix i assume *:"i<Suc x"
    show "\<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue val) "
    proof(cases "(i<x)")
      case True
      then have "\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"
        by (simp add: Read_Show_nat'_id hash_int_prefix hash_never_equal_sufix readLintNotEqual ShowLNatDot)
      then have "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cpm2mrec_SubPrefixes a30 a40 by force
      then show ?thesis using a20 True by metis
    next
      case False
      then have "i = x" using * by simp
      moreover have "Some v'' =  (case accessStore (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None 
                | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') 
                | Some (MPointer literal) \<Rightarrow> None)" 
        using cpm2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] a30 by simp
      ultimately show ?thesis by (simp add: a40)
    qed
  qed
qed

lemma Cps2mrec_val_types:
  assumes "iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (STValue x2) srcMem) m x1 = Some v'"
  shows "\<forall>i<x1. (\<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val))"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v' 
    where a10: "iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (STValue x2) srcMem) m x = Some v'"
      and a20: "(\<forall>i<x. \<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val))" 
      and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (STValue x2) srcMem v' = Some v''" by blast
  obtain t where a40: " accessStorage x2 srcl srcMem = t" using a30 using cps2mrec.simps(2) by (auto split:option.splits Memoryvalue.splits)
  show ?case 
  proof intros
    fix i assume *:"i<Suc x"
    show "\<exists>val. accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue val) "
    proof(cases "(i<x)")
      case True
      then have "\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"
        by (simp add: Read_Show_nat'_id hash_int_prefix hash_never_equal_sufix readLintNotEqual ShowLNatDot)
      then have "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cps2mrec_SubPrefixes a30 a40 by force
      then show ?thesis using a20 True by metis
    next
      case False
      then have "i = x" using * by simp
      moreover have "Some v'' =  (let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'))" 
        using cps2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] a30 by simp
      ultimately show ?thesis by (simp add: a40)
    qed
  qed
qed

subsubsection \<open>Typesafety of minit\<close>

  



lemma minitRec_induct [case_names MTValue MTArray]:
  assumes value_case: "\<And>t_val loc mem. P (MTValue t_val) loc mem"
  assumes array_case: "\<And>x t loc mem.
      (\<And>i m. i < x \<Longrightarrow> P t (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (iter (\<lambda>j m'. minitRec (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t j)) t m') (updateStore loc (MPointer loc) m) i)) \<Longrightarrow>
      P (MTArray x t) loc mem"
  shows "P t loc mem"
  by (induct t arbitrary: loc mem) (auto simp: minitRec.simps assms)




lemma cpm2mrecPtrsPointToSelf:
  shows "cpm2mrec srcl destl t srcMem destm = Some v'
          \<longrightarrow>  (\<forall>l l'. (TypedMemSubPref l destl t \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"
proof(induction t arbitrary: srcl destl  srcMem destm v')
  case (MTArray x1 t)
  show ?case
  proof intros
    fix l l'
    assume *:"cpm2mrec srcl destl (MTArray x1 t) srcMem destm = Some v' "
      and **:"(TypedMemSubPref l destl (MTArray x1 t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have a10:"Some v' = (case accessStore srcl srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
     | Some (MPointer l) \<Rightarrow>
         let m = updateStore destl (MPointer destl) destm
          in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl  (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)"
      using * cpm2mrec.simps(1)[of srcl destl x1 t srcMem destm] by simp
    then obtain l''' where a20:"accessStore srcl srcMem = Some (MPointer l''')" by (auto split:option.splits Memoryvalue.splits MTypes.splits)
    then have a30:"Some v' = (let m = updateStore destl (MPointer destl) destm
          in iter' (\<lambda>i. cpm2mrec (hash l''' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl  (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" using a10 by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    then have a50:"Some v' = iter' (\<lambda>i. cpm2mrec (hash l''' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl  (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a30 a40 by presburger
    show "l' = l" using a45 **
    proof(induction rule: iter'_ind[OF _ _ a50[symmetric]])
      case (1 v')
      then show ?case by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2mrec (hash l''' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:" (accessStore destl m = Some (MPointer destl) \<longrightarrow> (TypedMemSubPref l destl (MTArray x t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l) "
          and a30:"cpm2mrec (hash l''' (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have "accessStore destl m = Some (MPointer destl)" using 2 by auto
      then show ?case
      proof(cases "l = destl")
        case True
        then show ?thesis using 2(1,3,4) cpm2mRec_destRootSame by auto
      next
        case f1:False
        then show ?thesis 
        proof(cases "TypedMemSubPref l destl (MTArray x t)")
          case True
          then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
          then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
          then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
            by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
          have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
          then have b50:"accessStore l v' = accessStore l v''" 
            using * cpm2mrec_SubPrefixes a30 by simp
          then show ?thesis using a20 2 using True by auto
        next
          case False
          then have b5:"TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using 2(4) TypedMemSubPref.simps(2)[of l destl "(Suc x)" t] f1 
            using less_Suc_eq by auto
          have b10:"accessStore l v'' = Some (MPointer l')" using 2(4) by auto

          have "(\<forall>l l'. (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> accessStore l v'' = Some (MPointer l') \<longrightarrow> l' = l)" 
            using  MTArray[of "(hash l''' (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem v' v''] a30 by simp
          then show ?thesis using b5 b10 by blast
        qed
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix l l'
    assume *:"cpm2mrec srcl destl (MTValue x) srcMem destm = Some v'" 
      and **:"(TypedMemSubPref l destl (MTValue x) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have "Some v' = (case accessStore srcl srcMem of None \<Rightarrow> None 
                | Some (MValue v) \<Rightarrow> Some (updateStore destl (MValue v) destm) 
                | Some (MPointer literal) \<Rightarrow> None)" 
      using cpm2mrec.simps(2)[of srcl destl x srcMem destm] * by simp
    then obtain v where b10: "accessStore destl v' = Some (MValue v)" by (auto split:option.splits Memoryvalue.splits)
    show "l' = l" using b10 ** by auto
  qed
qed

lemma cps2mrecPtrsPointToSelf:
  shows "cps2mrec srcl destl t srcMem destm = Some v'
          \<longrightarrow>  (\<forall>l l'. (TypedStoSubPref l destl t \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" 
proof(induction t arbitrary: srcl destl  srcMem destm v')
  case (STArray x1 t)
  show ?case 
  proof intros
    fix l l'
    assume *:"cps2mrec srcl destl (STArray x1 t) srcMem destm = Some v' " 
      and **:"(TypedStoSubPref l destl (STArray x1 t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have a10:"Some v' =  (let m = updateStore destl (MPointer destl) destm 
                          in iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using * cps2mrec.simps(1)[of srcl destl x1 t srcMem destm] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    then have a50:"Some v' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl  (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a40 a10 by presburger
    show "l' = l" using a45 **
    proof(induction rule: iter'_ind[OF _ _ a50[symmetric]])
      case (1 v')
      then show ?case by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:" (accessStore destl m = Some (MPointer destl) \<longrightarrow> (TypedStoSubPref l destl (STArray x t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l) "
          and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have "accessStore destl m = Some (MPointer destl)" using 2 by auto
      then show ?case 
      proof(cases "l = destl")
        case True
        then show ?thesis using 2 cpm2mRec_destRootSame 
          by (metis (no_types, opaque_lifting) LSubPrefL2_def cps2mrec_SubPrefixes hash_inequality hash_suffixes_associative)
      next
        case f1:False
        then show ?thesis 
        proof(cases "TypedStoSubPref l destl (STArray x t)")
          case True
          then obtain i where  b10:"i<x \<and> (TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
          then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using stoTypedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
          then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
            by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
          have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
          then have b50:"accessStore l v' = accessStore l v''" 
            using * cps2mrec_SubPrefixes a30 by simp
          then show ?thesis using a20 2 using True by auto
        next
          case False
          then have b5:"TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using 2(4) TypedStoSubPref.simps(2)[of l destl "(Suc x)" t] f1 
            using less_Suc_eq by auto
          have b10:"accessStore l v'' = Some (MPointer l')" using 2(4) by auto

          have "(\<forall>l l'. (TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> accessStore l v'' = Some (MPointer l') \<longrightarrow> l' = l)" 
            using  STArray[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem v' v''] a30 by simp
          then show ?thesis using b5 b10 by blast
        qed
      qed
    qed
  qed
next
  case (STValue x)
  then show ?case 
  proof intros
    fix l l'
    assume *:"cps2mrec srcl destl (STValue x) srcMem destm = Some v'" 
      and **:"(TypedStoSubPref l destl (STValue x) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have "Some v' = (let v = accessStorage x srcl srcMem in Some (updateStore destl (MValue v) destm))" 
      using cps2mrec.simps(2)[of srcl destl x srcMem destm] * by simp
    then obtain v where b10: "accessStore destl v' = Some (MValue v)" by (auto split:option.splits Memoryvalue.splits)
    show "l' = l" using b10 ** by auto
  qed
next
  case (STMap k v)
  then show ?case using cps2mrec.simps(3) by force
qed

lemma cpm2mSelfPointers:
  assumes "iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1 = Some v'"
  shows "(\<forall>l l'. TypedMemSubPref l destl (MTArray x1 t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"  using assms(1)
proof(induction  rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10: "iter' (\<lambda>i. cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
      and a20: "(\<forall>l l'. TypedMemSubPref l destl (MTArray x t) \<and> accessStore l v' = Some (MPointer l') 
                  \<longrightarrow> l' = l)"
      and a30: "cpm2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
  show ?case 
  proof intros
    fix l l'
    assume *:"TypedMemSubPref l destl (MTArray (Suc x) t) \<and> accessStore l v'' = Some (MPointer l')"
    show "l' = l"
    proof(cases t)
      case (MTArray x11 x12)

      then show ?thesis 
      proof(cases "TypedMemSubPref l destl (MTArray x t)")
        case True
        then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
        then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
        then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
          by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
        have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
        then have b50:"accessStore l v' = accessStore l v''" 
          using * cpm2mrec_SubPrefixes a30 by simp
        then show ?thesis using a20 True *  b50 by metis
      next
        case False
        then have "TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using TypedMemSubPref.simps(2)[of l destl "(Suc x)" t] *
          using less_Suc_eq by auto
        then show ?thesis using a30 cpm2mrecPtrsPointToSelf[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t srcMem v' v''] * by blast
      qed
    next
      case (MTValue x2)
      then have "Some v'' = (case accessStore (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None 
                | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') 
                | Some (MPointer literal) \<Rightarrow> None)" 
        using a30 cpm2mrec.simps(2)[of  "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] by simp
      have "(\<exists>i<Suc x. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t  \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using TypedMemSubPref.simps(2)[of l destl "Suc x" t] * by auto
      then obtain i where b400:"i< Suc x \<and> TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTValue x2)" using MTValue by auto
      then have "l =  (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      then obtain val where "accessStore l v'' = Some (MValue val)" using Cpm2mrec_val_types[of srcl destl x2 srcMem m "Suc x" v''] 2(2) MTValue b400 by auto
      then show ?thesis using  * by simp 
    qed
  qed
qed

lemma cps2mSelfPointers:
  assumes "iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1 = Some v'"
  shows "(\<forall>l l'. TypedStoSubPref l destl (STArray x1 t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"  using assms(1)
proof(induction  rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10: "iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
      and a20: "(\<forall>l l'. TypedStoSubPref l destl (STArray x t) \<and> accessStore l v' = Some (MPointer l') 
                  \<longrightarrow> l' = l)"
      and a30: "cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
  show ?case 
  proof intros
    fix l l'
    assume *:"TypedStoSubPref l destl (STArray (Suc x) t) \<and> accessStore l v'' = Some (MPointer l')"
    show "l' = l"
    proof(cases t)
      case (STArray x11 x12)

      then show ?thesis 
      proof(cases "TypedStoSubPref l destl (STArray x t)")
        case True
        then obtain i where  b10:"i<x \<and> (TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
        then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using stoTypedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
        then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
          by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
        have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
        then have b50:"accessStore l v' = accessStore l v''" 
          using * cps2mrec_SubPrefixes a30 by simp
        then show ?thesis using a20 True *  b50 by metis
      next
        case False
        then have "TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using TypedStoSubPref.simps(2)[of l destl "(Suc x)" t] *
          using less_Suc_eq by auto
        then show ?thesis using a30 cps2mrecPtrsPointToSelf[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t srcMem v' v''] * by blast
      qed
    next
      case (STValue x2)
      then have "Some v'' = (let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'))" 
        using a30 cps2mrec.simps(2)[of  "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] by simp
      have "(\<exists>i<Suc x. TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t  \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using TypedStoSubPref.simps(2)[of l destl "Suc x" t] * by auto
      then obtain i where b400:"i< Suc x \<and> TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTValue x2)" using STValue by auto
      then have "l =  (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      then obtain val where "accessStore l v'' = Some (MValue val)" using Cps2mrec_val_types[of srcl destl x2 srcMem m "Suc x" v''] 2(2) STValue b400 by auto
      then show ?thesis using  * by simp 
    next 
      case (STMap k v)
      then show ?thesis 
        using a30 cps2mrec.simps(3) by auto
    qed
  qed
qed

lemma cpm2mrec_MCon :
  "(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon tp srcMem l) 
  \<and>(\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon tp srcMem srcl) \<and> 
   cpm2mrec srcl destl tp srcMem a = Some v'''                    
          \<longrightarrow> MCon tp v''' destl"
proof (induction tp arbitrary:srcl destl srcMem a v''')
  case (MTArray x1 t)
  show ?case
  proof intros
    assume "(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x1 t) srcMem l) 
        \<and> (\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTArray x1 t) srcMem srcl) 
        \<and> cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''"
    then have *:"(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x1 t) srcMem l)"
      and **:"cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''"
      and ***:"(\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTArray x1 t) srcMem srcl) "
      by auto+

(*Expand the cpm2mrec defintion*)
    obtain l where ldef:"accessStore srcl srcMem = Some (MPointer l)" using **  cpm2mrec.simps(1)[of srcl destl x1 t srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using **  by (simp add: cpm2mrec.simps(1))
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto

(*We know this specific subset of srcMem is Mcon*)
    then show " MCon (MTArray x1 t) v''' destl"
    proof(cases "x1>0")
      case True
      then have "MCon (MTArray x1 t) srcMem l" using ldef * by auto
      then have srcMcon:"\<forall>i<x1.
               case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case t of MTValue x \<Rightarrow> MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
               | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t srcMem loc2 | MTValue Types \<Rightarrow> False)" 
        using MCon.simps(2)[of x1 t srcMem l] by auto

(*Concludes with the following from **  *)
      have v''def:"Some v''' =  iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a5 ldef mdef by metis 

      have "\<forall>i<x1. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''' of None \<Rightarrow> False 
             | Some (MValue val) \<Rightarrow> (case t of MTValue typ \<Rightarrow> MCon t v''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v''' loc2 | MTValue Types \<Rightarrow> False)" using * ldef
      proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]])
        case (1 v')
        then show ?case by simp
      next
        case (2 x v'')
        then obtain v'
          where a10:"iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
            and a20:"(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x t) srcMem l) \<longrightarrow> 
                          (\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                            | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
                            | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False))"
            and a30:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
        then have a40:"(\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                            | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
                            | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False))" using 2 by fastforce
        have a50:"MCon (MTArray (Suc x) t) srcMem l" using 2 by auto
        have a55:"(\<exists>p. accessStore destl v' = Some (MPointer p)) \<or> accessStore destl v' = None" using 2 
        proof -
          have "\<And>s. Some v'' \<noteq> Some s \<or> accessStore destl s = accessStore destl v'"
            using a30 cpm2mRec_destRootSame by blast
          then show ?thesis
            by (metis (no_types) "2.hyps" accessPrePost1 accessStore_updateStore hash_inequality mdef)
        qed

        show ?case 
        proof intros
          fix i 
          assume iless:"i<Suc x"

          show "case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t of MTValue x \<Rightarrow> MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)" 
          proof(cases "i < x")
            case True

            then have MCondestl:"MCon (MTArray x t) v' destl" using a40 MCon.simps(2)[of x t v' destl] a55 by simp

            then show ?thesis
            proof(cases t)
              case mtr:(MTArray x11 x12)
              then have "Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
                         | Some (MPointer l) \<Rightarrow>
                             let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'
                             in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)" 
                using cpm2mrec.simps(1)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v'] a30 by auto
              then obtain thing where b10:"accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MPointer thing)"  by (simp split:option.splits Memoryvalue.splits)
              have "\<forall>i<Suc x.
             case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t srcMem loc2 | MTValue Types \<Rightarrow> False)" 
                using a50 MCon.simps(2)[of "Suc x" t srcMem l] mtr by simp
              then have b5:"MCon t srcMem thing" using a50 MCon.simps(2)[of "Suc x" t srcMem l] mtr b10 by fastforce
              then have b10:"MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> 
                          (\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using MTArray[of  "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) " v' v''] a30 b10 cpm2mrec_SubPrefixes by simp
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)
              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using ShowLNatDot hash_int_prefix b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b19:"\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v''" using b10 by auto
              have accessSt:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v'  = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v''" 
                by (simp add: b15 b16 b17)
              then obtain val where valdef:" accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MPointer val)" 
                using MConArrayPointers[of x x11 x12 v' destl i] a40 MCondestl True mtr by auto
              have "Suc x - 1 = x" by simp
              then have subPref:"TypedMemSubPref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) destl (MTArray x t)" 
                using a50 MConIndexMin1[of "Suc x" t srcMem l] 2(3) True by auto
              then have b30:"( \<forall>l l'. TypedMemSubPref l destl (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" 
                using cpm2mSelfPointers[of l destl t srcMem m x v'] a10 by blast
              then have valeq:"val = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True valdef subPref by simp
              then have b20:"MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))"  using a40  mtr True valdef by fastforce 
              then have " \<forall>l l'. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l" 
                using b30 moreSpecificTypedSubPref[of destl x t v' ] True by blast
              then have "MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  t v' v'' ] a10 b17 b18 b20 b19 by blast
              then show ?thesis using accessSt valdef mtr valeq by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
            next
              case (MTValue x2)
              then have "Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None 
                                      | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') |
                                       Some (MPointer literal) \<Rightarrow> None)" using cpm2mrec.simps(2)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] using a30 by simp
              then obtain thing where thingDef:"accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MValue thing)"  by (simp split:option.splits Memoryvalue.splits)
              then have "MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using a50 MCon.simps(2)[of "Suc x" t srcMem l] MTValue by auto
              then have b10:"MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and>
                          (\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using MTArray[of  "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) " v' v''] a30 cpm2mrec_SubPrefixes[of "hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)" "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" t srcMem v' v''] *** thingDef
                by simp
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)

              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using ShowLNatDot hash_int_prefix b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b20:"MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using a40  MTValue True by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              then have "MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)" "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" t v' v''] using MTValue b10 b17 b18 by simp
              moreover have "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" 
                by (simp add: b15 b16 b17)
              moreover obtain val where "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val)" 
                using a40 MTValue True b20 by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              ultimately show ?thesis 
                by (simp add: MTValue b15 b16 b17)
            qed


          next
            case False
            then have iIsx:"i = x" using iless by simp
            then show ?thesis 
            proof(cases t)
              case mtr:(MTArray x11 x12)
              then have b10:"Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
                     | Some (MPointer l) \<Rightarrow> let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)"
                using a30 cpm2mrec.simps(1)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v' ] by simp
              then obtain loc2 where b20:"Some (MPointer loc2) = accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem" by (simp split:option.splits Memoryvalue.splits)
              then have b25:"Some v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cpm2mrec (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)" 
                using b10 by (simp split:option.splits Memoryvalue.splits)
              then obtain m' where b30:"m' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by auto
              then have b40:"Some v'' = iter' (\<lambda>i. cpm2mrec (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m' x11" using b20 b25 by presburger
              then have b50:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)))" using b30 iIsx by simp
              have "\<forall>suffs. hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffs \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using hash_inequality by simp
              then have b60:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' " 
                using accessPrePost1[of v'' loc2  "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x12 srcMem m' x11] b40  iIsx by presburger
              have "\<forall>i<Suc x.
             case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False) 
                  | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t srcMem loc2 | MTValue Types \<Rightarrow> False)" using a50 MCon.simps(2)[of "Suc x" t srcMem l] iless by simp
              then have "MCon t srcMem loc2" using iIsx mtr b20 iless by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
              then have "MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using MTArray[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] a30 b20 by fastforce
              then show ?thesis using b50 b60 mtr by simp (*need to show that loc2 is hash destl x*)
            next
              case (MTValue x2)
              then have b10:"Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') | Some (MPointer literal) \<Rightarrow> None)"
                using a30 cpm2mrec.simps(2)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] by simp
              then obtain v where b20:"Some (MValue v) = accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem" by (simp split:option.splits Memoryvalue.splits)
              then have b30:"v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'" using b10 by (simp split:option.splits Memoryvalue.splits)
              then have b40:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" using iIsx unfolding accessStore_def updateStore_def by auto
              have "\<forall>i<Suc x.
             case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False) 
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t srcMem loc2 | MTValue Types \<Rightarrow> False)" using a50 MCon.simps(2)[of "Suc x" t srcMem l] iless by simp
              then have "MCon t srcMem (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using iIsx MTValue b20 iless by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5))
              then have "typeCon x2 v" using MCon.simps(1) MTValue b20 iIsx by (metis Memoryvalue.simps(5) Option.option.simps(5))
              then show ?thesis  using iIsx MTValue b20 iless MCon.simps(1) b40 by (metis (full_types, lifting) MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5))
            qed
          qed
        qed
      qed

      moreover have "(\<exists>p. accessStore destl v''' = Some (MPointer p)) \<or> accessStore destl v''' = None" 
        by (metis (no_types) accessPrePost1 accessStore_updateStore hash_inequality mdef v''def)
      ultimately show ?thesis using MCon.simps(2)[of x1 t v''' destl]  by (simp add: True)
    next
      case False
      then show ?thesis 
        using "*" ldef by auto
    qed


  qed
next
  case (MTValue x)
  then show ?case
  proof intros
    assume "(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTValue x) srcMem l) \<and> 
            (\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTValue x) srcMem srcl)
            \<and> cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''"
    then have *:"(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTValue x) srcMem l)"
      and **:"(\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTValue x) srcMem srcl)"
      and ***:"cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''" by simp+

    then have a10:"Some v''' =  (case accessStore srcl srcMem of None \<Rightarrow> None
              | Some (MValue v) \<Rightarrow> Some (updateStore destl (MValue v) a) 
              | Some (MPointer literal) \<Rightarrow> None)" 
      using cpm2mrec.simps(2)[of srcl destl x srcMem a ] by simp
    then obtain v where  vdef:"Some (MValue v) = accessStore srcl srcMem" by (simp split:option.splits Memoryvalue.splits)
    then have "accessStore destl v''' = accessStore srcl srcMem" using a10 unfolding updateStore_def accessStore_def by (auto split:option.splits Memoryvalue.splits)
    moreover have "typeCon x v" using vdef ** by simp
    ultimately show "MCon (MTValue x) v''' destl" using ** MCon.simps(1)[of x v''' destl] vdef a10 by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma cps2mrec_MCon :(*Remove type from Memsubpref*)
  "SCon tp srcl srcMem \<and> cps2mTypeCompatible (STArray l tp) (MTArray l t') \<and>
   cps2mrec srcl destl tp srcMem a = Some v'''                    
          \<longrightarrow> MCon t' v''' destl
"
  (*Can get the precondition of assms(1) using the conclusion of assms(1) and MCon.def*)
proof (induction tp arbitrary:srcl destl srcMem a v''' l t')
  case (STArray x1 tp)
  show ?case 
  proof intros
    assume " SCon (STArray x1 tp) srcl srcMem \<and> cps2mTypeCompatible (STArray l (STArray x1 tp)) (MTArray l t') \<and> cps2mrec srcl destl (STArray x1 tp) srcMem a = Some v'''"
    then have *:" SCon (STArray x1 tp) srcl srcMem"
      and **:"cps2mTypeCompatible (STArray l (STArray x1 tp)) (MTArray l t')"
      and ***:"cps2mrec srcl destl (STArray x1 tp) srcMem a = Some v''' "
      by auto+
    obtain t''' where t'''def:"t' = MTArray x1 t'''" using ** 
      by (metis MTypes.exhaust cps2mTypeCompatible.simps(2) cps2mTypeCompatible.simps(3))

    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1)" 
      using ***  cps2mrec.simps(1)[of srcl destl x1 tp srcMem a] by simp
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto
    then have "MCon (MTArray x1 t''') v''' destl"
    proof(cases "x1>0")
      case True
      then have srcMcon:"(\<forall>i\<in>{0..x1 - 1}. SCon tp (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem)" 
        using * SCon.simps(2)[of x1 tp srcl srcMem] by auto
      then have **:"cps2mTypeCompatible  (STArray x1 tp)  (MTArray x1 t''')" using ** t'''def by auto
      then have v''def:"Some v''' =  iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1" 
        using a5  mdef by metis 
      have "\<forall>i<x1. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''' of None \<Rightarrow> False 
             | Some (MValue val) \<Rightarrow> (case t''' of MTValue typ \<Rightarrow> MCon t''' v''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t''' of MTArray len' arr' \<Rightarrow> MCon t''' v''' loc2 | MTValue Types \<Rightarrow> False)" 
        using * **
      proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]])
        case (1 v')
        then show ?case by simp
      next
        case (2 x v'')
        then obtain v'
          where a10:"iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x = Some v'"
            and a20:"SCon (STArray x tp) srcl srcMem \<longrightarrow>   cps2mTypeCompatible (STArray x tp) (MTArray x t''') \<longrightarrow>
                          (\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                            | Some (MValue val) \<Rightarrow> (case t''' of  MTValue typ \<Rightarrow> MCon t''' v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
                            | Some (MPointer loc2) \<Rightarrow> (case t''' of MTArray len' arr' \<Rightarrow> MCon t''' v' loc2 | MTValue Types \<Rightarrow> False))"
            and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp srcMem v' = Some v''" by blast
        have "SCon (STArray x tp) srcl srcMem " using 2(3) using SCon.simps by auto
        then have a40:"(\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                            | Some (MValue val) \<Rightarrow> (case t''' of  MTValue typ \<Rightarrow> MCon t''' v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
                            | Some (MPointer loc2) \<Rightarrow> (case t''' of MTArray len' arr' \<Rightarrow> MCon t''' v' loc2 | MTValue Types \<Rightarrow> False))" 
          using a20 2 by auto
        have a50:"(\<exists>p. accessStore destl v' = Some (MPointer p)) \<or> accessStore destl v' = None" using 2 
        proof -
          have "\<And>s. Some v'' \<noteq> Some s \<or> accessStore destl s = accessStore destl v'"
            by (metis a30 cps2mRec_destRootSame)
          then show ?thesis
            by (metis (no_types) "2.hyps" accessStore_updateStore cps2mAccessPrePost hash_inequality mdef)
        qed
        show ?case 
        proof intros
          fix i 
          assume iless:"i<Suc x"
          show "case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t''' of MTValue x \<Rightarrow> MCon t''' v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t''' of MTArray x xa \<Rightarrow> MCon t''' v'' loc2 | MTValue Types \<Rightarrow> False)" 
          proof(cases "i < x")
            case True
            then have MCondestl:"MCon (MTArray x t''') v' destl" using a40 MCon.simps(2)[of x t''' v' destl] a50 by simp
            then show ?thesis
            proof(cases t''')
              case mtr:(MTArray x11 x12)
              then obtain stotp where stotp:"tp = STArray x11 stotp" using 2(4) iless True cps2mTypeCompatible.simps 
                by (metis STypes.exhaust)
              have tpt''comp:"cps2mTypeCompatible tp t'''" using 2(4)by simp

              have "Some v'' = 
                    (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cps2mrec (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stotp srcMem) m x11)"
                using cps2mrec.simps(1)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 stotp srcMem v' ] a30 stotp by auto
                  (*then have b5:"MCon t srcMem thing" using a50 MCon.simps(2)[of "Suc x" t srcMem l] mtr by auto*)
              then have b10:"  (\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using STArray(1)[of " (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem  ] a30 cps2mrec_SubPrefixes[of " (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" tp srcMem v' v''] by simp
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)
              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using hash_int_prefix ShowLNatDot b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b19:"\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v''" using b10 by auto
              have accessSt:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v'  = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v''" 
                by (simp add: b15 b16 b17)
              then obtain val where valdef:" accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MPointer val)" 
                using MConArrayPointers[of x x11 x12 v' destl i] a40 MCondestl True mtr by auto
              have "Suc x - 1 = x" by simp
              then have subPref:"TypedStoSubPref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) destl (STArray x tp)" 
                using 2(3) True by auto
              then have b30:"(\<forall>l l'. TypedStoSubPref l destl (STArray x tp) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" 
                using cps2mSelfPointers[of srcl destl tp srcMem m x v'] a10 by blast
              then have valeq:"val = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True valdef subPref by simp
              then have b20:"MCon t''' v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))"  using a40  mtr True valdef by fastforce 
              then have " \<forall>l l'. TypedStoSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l" 
                using b30 stoMoreSpecificTypedSubPref[of destl x tp v' ] True by blast
              then have "MCon t''' v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using frd[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" tp v' t''' v''] a10 b17 b18 b20 b19 tpt''comp by blast
              then show ?thesis using accessSt valdef mtr valeq by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
            next
              case (MTValue x2)
              then have stotp:"tp = (STValue x2)" using 2(4) iless True cps2mTypeCompatible.simps 
                by (metis STypes.exhaust)
              have tpt''comp:"cps2mTypeCompatible tp t'''" using 2(4) by simp
              then have "(let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v')) = Some v''" 
                using cps2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  x2 srcMem v'] a30 stotp by simp
              then have b10:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using STArray(1)[of " (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem ] a30 cps2mrec_SubPrefixes[of " (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" tp srcMem v' v''] by simp
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)

              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using ShowLNatDot hash_int_prefix b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b20:"MCon t''' v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using a40  MTValue True by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              then have "MCon t''' v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)" "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" ] using MTValue b10 b17 b18 by simp
              moreover have "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" 
                by (simp add: b15 b16 b17)
              moreover obtain val where "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val)" 
                using a40 MTValue True b20 by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              ultimately show ?thesis 
                by (simp add: MTValue b15 b16 b17)
            qed


          next
            case False
            then have iIsx:"i = x" using iless by simp
            then show ?thesis 
            proof(cases t''')
              case mtr:(MTArray x11 x12)
              then obtain stotp where stotp:"tp = STArray x11 stotp" using 2(4) iless True cps2mTypeCompatible.simps 
                by (metis STypes.exhaust)
              have tpt''comp:"cps2mTypeCompatible tp t'''" using 2(4) by simp

              have b20:"Some v'' = 
                    (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cps2mrec (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stotp srcMem) m x11)"
                using cps2mrec.simps(1)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 stotp srcMem v' ] a30 stotp by auto
              then obtain m where b30:"m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by auto
              then have b40:"Some v'' = iter' (\<lambda>i. cps2mrec (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stotp srcMem) m x11" using b20 b30 by metis
              then have b50:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m = Some (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)))" using b30 iIsx by simp
              have "\<forall>suffs. hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffs \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using hash_inequality by simp
              then have b60:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m " 
                using cps2mAccessPrePost[of v'' "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" stotp srcMem m x11] b40 iIsx by presburger
              have "MCon t''' v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using STArray[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem "(Suc x)" t''' " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] 2(4) a30 b20 t'''def 2 by simp
              then show ?thesis using b50 b60 mtr by simp (*need to show that loc2 is hash destl x*)
            next
              case (MTValue x2)
              then have stotp:"tp = (STValue x2)" using 2(4) iless True cps2mTypeCompatible.simps 
                by (metis STypes.exhaust)
              have tpt''comp:"cps2mTypeCompatible tp t'''" using 2(4) by simp
              then have b10:"(let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v')) = Some v''" 
                using cps2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  x2 srcMem v'] a30 stotp by simp
              then obtain v where b20:"v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem" by (simp split:option.splits Memoryvalue.splits)
              then have b30:"v'' = (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v')" using b10  by (simp split:option.splits Memoryvalue.splits)
              then have b40:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" using iIsx unfolding accessStore_def updateStore_def by auto
              have "(\<forall>i\<in>{0..Suc x - 1}. SCon tp (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem)" using 2(3) SCon.simps(2)[of "Suc x" tp srcl srcMem ] by auto
              then have b50:"typeCon x2 (accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) srcMem)" using SCon.simps(1)[of x2 "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" srcMem] stotp iIsx by simp
              have b60:"(case srcMem $$ hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x) of None \<Rightarrow> ival x2 | Some v \<Rightarrow> v) = v" using b20 unfolding accessStorage_def by blast
              then show ?thesis  using iIsx MTValue b20 iless MCon.simps(1) b40 b50 by (metis (full_types, lifting) MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5))
            qed
          qed
        qed
      qed
      moreover have "(\<exists>p. accessStore destl v''' = Some (MPointer p)) \<or> accessStore destl v''' = None" 
        by (metis (no_types, lifting) "***" accessStore_updateStore cps2mAccessPrePost cps2mrec.simps(1) hash_inequality)
      ultimately show ?thesis using MCon.simps(2)[of x1 t''' v''' destl]
        by (simp add: True)
    next
      case False
      then show ?thesis 
        using "**" t'''def by auto
    qed

    then show " MCon t' v''' destl" using t'''def by auto
  qed
next
  case (STMap x1 tp)
  then show ?case by simp
next
  case (STValue x)
  then show ?case
  proof intros
    assume a1:" SCon (STValue x) srcl srcMem \<and> cps2mTypeCompatible (STArray l (STValue x)) (MTArray l t') \<and> cps2mrec srcl destl (STValue x) srcMem a = Some v'''"
    then have *:"SCon (STValue x) srcl srcMem"
      and **:"cps2mTypeCompatible (STArray l (STValue x)) (MTArray l t')"
      and ***:"cps2mrec srcl destl (STValue x) srcMem a = Some v'''" by simp+

    then have a10:"Some v''' = (let v = accessStorage x srcl srcMem in Some (updateStore destl (MValue v) a))" 
      using cps2mrec.simps(2)[of srcl destl x srcMem a ] by simp

    then obtain v where b20:"v = accessStorage x srcl srcMem" by (simp split:option.splits Memoryvalue.splits)
    then have b30:"v''' = (updateStore destl (MValue v) a)" using a10 by (simp split:option.splits Memoryvalue.splits)
    then have b40:"accessStore destl v''' = Some (MValue v)"  unfolding accessStore_def updateStore_def by auto
    then have b50:"typeCon x (accessStorage x srcl srcMem)" using SCon.simps(1)[of x "srcl" srcMem] * by simp
    have b60:"(case srcMem $$ srcl of None \<Rightarrow> ival x | Some v \<Rightarrow> v) = v" using b20 unfolding accessStorage_def by blast
    then have "typeCon x v" using b50 b20 by simp
    then show "MCon t' v''' destl"  using  STValue b20  MCon.simps(1) b40 
      by (metis Memoryvalue.simps(5) Option.option.simps(5) a1 cps2mTypeCompatible.simps(1) cps2mTypeCompatible.simps(2) cps2mTypeCompatible.simps(6) extractType.cases)
  qed
qed


lemma cpm2srec_MCon :
  "(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon t' srcMem l) 
  \<and>(\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon t' srcMem srcl)
 \<and> cps2mTypeCompatible (STArray l tp) (MTArray l t') \<and>
   cpm2srec srcl destl t' srcMem a = Some v'''                    
          \<longrightarrow> SCon tp destl v'''"
proof (induction t' arbitrary:srcl destl srcMem a v''' l tp)
  case (MTArray x1 t')
  show ?case 
  proof intros
    assume "(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x1 t') srcMem l) \<and>
    (\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTArray x1 t') srcMem srcl) \<and> cps2mTypeCompatible (STArray l tp) (MTArray l (MTArray x1 t')) \<and> cpm2srec srcl destl (MTArray x1 t') srcMem a = Some v'''"
    then have *:"(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x1 t') srcMem l)"
      and ****:"(\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTArray x1 t') srcMem srcl)"
      and **:"cps2mTypeCompatible (STArray l tp) (MTArray l (MTArray x1 t'))"
      and ***:"cpm2srec srcl destl (MTArray x1 t') srcMem a = Some v'''"
      by blast+
    obtain t''' where t'''def:"tp = STArray x1 t'''" using ** 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    obtain ptr where ptrDef:"accessStore srcl srcMem = Some (MPointer ptr)"
      using ***  unfolding cpm2srec.simps by (auto split:option.splits Memoryvalue.splits)
    then have a5:"(iter' (\<lambda>i. cpm2srec (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) a x1) = Some v'''" 
      using ***  unfolding cpm2srec.simps by simp

    then have "SCon (STArray x1 t''') destl v'''" 
    proof -

      have **:"cps2mTypeCompatible  (STArray x1 t''')  (MTArray x1 t')" using ** t'''def by auto
      have "\<forall>i<x1. SCon t''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'''" using * ** ptrDef 
      proof(induction rule: iter'_ind[OF _ _ a5])
        case (1 v')
        then show ?case by simp
      next
        case (2 x v'')
        then obtain v'
          where a10:" iter' (\<lambda>i. cpm2srec (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' srcMem) a x = Some v'"
            and a20:"((\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTArray x t') srcMem l) \<longrightarrow>
          cps2mTypeCompatible (STArray x t''') (MTArray x t') \<longrightarrow> accessStore srcl srcMem = Some (MPointer ptr) 
          \<longrightarrow> (\<forall>i<x. SCon t''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'))"
            and a30:"cpm2srec (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' srcMem v' = Some v''" by blast
        show ?case 
        proof intros
          fix i 
          assume iless:"i<Suc x"
          show "SCon t''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" 
          proof(cases "i < x")
            case True
            then have scOA:"(\<forall>i<x. SCon t''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v')" using a20 True 2 by auto 
            then have scO:"SCon t''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" using True by simp
            have notSub1:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
              by (metis ShowLNatDot hash_int_prefix hashesIntSame nat_neq_iff)  
            then have notSub2:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True  scO scOA 
              by (metis (full_types) LSubPrefL2_def  hash_suffixes_associative hashesInts)
            then have b65:"\<forall>t. accessStorage t (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStorage t (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cpm2srec_SubPrefixes a30 
              using notSub1 by auto
            then have b70:"\<forall>i' t. accessStorage t (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) i') v' = accessStorage t (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) i') v'' " 
              using notSub1 notSub1 Mutual_NonSub_SpecificNonSub a30 cpm2srec_SubPrefixes notSub2 by blast
            have "cps2mTypeCompatible (STArray (x) t''') (MTArray (x) t')" using 2(4) 
              using True by auto
            then show ?thesis using scO b70 True b65
            proof(induction t''' arbitrary:x destl i t')
              case (STArray x11 x12)

              have "\<forall>ia<x11. SCon x12 (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" 
              proof intros
                fix ia 
                assume *:"ia < x11"
                then have "SCon x12 (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v'" using STArray by simp
                moreover have "\<forall>i' t. accessStorage t (hash (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) i') v' 
                              = accessStorage t (hash (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) i') v''" 
                  using STArray.prems(3) hash_suffixes_associative by auto
                moreover have " \<forall>t. accessStorage t (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v' 
                                = accessStorage t (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" using STArray by blast
                ultimately show "SCon x12 (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" 
                  using STArray.IH[of x11 _ "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" ia] * 
                  using MTypes.exhaust STArray.prems(1) cps2mTypeCompatible.simps(2,3) by metis
              qed
              then show ?case using SCon.simps(2)[of x11 x12 "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" v''] by simp
            next
              case (STMap x21 x22)
              show ?case using STMap(2) by simp
            next
              case (STValue x3)
              then have "typeCon x3 (accessStorage x3 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" 
                unfolding SCon.simps using a30 scO notSub2 notSub1
                by simp
              then show ?case using STValue by simp
            qed
          next 
            case False
            then have "i = x" using iless by auto
            moreover have "(\<forall>l. accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MPointer l) \<longrightarrow> MCon t' srcMem l)" 
              using "2.prems"(1) MCon_imps_sub_Mcon ptrDef by blast
            moreover have "(\<forall>val. accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MValue val) 
                            \<longrightarrow> MCon t' srcMem (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t x)))" 
              using "2.prems"(1) MCon_imps_sub_Mcon ptrDef by blast
            ultimately show ?thesis using a30 MTArray[of  "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t x))" srcMem _ t''' "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] 
              using "2.prems"(2) by blast
          qed
        qed
      qed
      then show "SCon (STArray x1 t''') destl v'''" using t'''def by auto
    qed
    then show "SCon tp destl v'''" 
      by (simp add: t'''def)
  qed

next
  case (MTValue x)
  show ?case 
  proof intros
    assume **:"(\<forall>l. accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> MCon (MTValue x) srcMem l) \<and>
      (\<forall>val. accessStore srcl srcMem = Some (MValue val) \<longrightarrow> MCon (MTValue x) srcMem srcl) \<and>
      cps2mTypeCompatible (STArray l tp) (MTArray l (MTValue x)) \<and> cpm2srec srcl destl (MTValue x) srcMem a = Some v'''"
    then have *:"cpm2srec srcl destl (MTValue x) srcMem a = Some v'''" by simp
    then obtain v where ptrDef:"accessStore srcl srcMem = Some (MValue v)"
      unfolding cpm2srec.simps by (auto split:option.splits Memoryvalue.splits)
    then have v'''Def:"(a(destl $$:= v)) =  v'''" using * unfolding cpm2srec.simps by (auto split:option.splits Memoryvalue.splits)
    have mcMem:"MCon (MTValue x) srcMem srcl" using ptrDef ** by blast
    have "cps2mTypeCompatible tp (MTValue x)" using ** unfolding cps2mTypeCompatible.simps by simp
    then have "STValue x = tp" using cps2mTypeCompatible.simps 
      using cps2mTypeCompatible.elims(2) by auto
    moreover have "SCon (STValue x) destl v'''" using v'''Def mcMem ptrDef accessStorage_def unfolding SCon.simps MCon.simps by auto
    ultimately show "SCon tp destl v'''" using ** by simp
  qed
qed





lemma cpm2mrecTopLocSame:
  shows " cpm2mrec srcl destl tp' srcMem a = Some v''' \<longrightarrow> toploc a = toploc v'''" 
proof( induction tp' arbitrary: srcl destl  a v''')
  case (MTArray x1 tp)
  show ?case  
  proof intros
    assume *:" cpm2mrec srcl destl (MTArray x1 tp) srcMem a = Some v'''"
    then have a10:"Some v''' = (case accessStore srcl srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
              | Some (MPointer l) \<Rightarrow> 
              let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1)" using cpm2mrec.simps(1)[of srcl destl x1 tp srcMem a] by simp
    then obtain p where a20:"Some (MPointer p) =  accessStore srcl srcMem" by (auto split:option.splits Memoryvalue.splits)
    then have a30:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cpm2mrec (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1)" 
      using a10 by (auto split:option.splits Memoryvalue.splits)
    then obtain m where a40:"m =  updateStore destl (MPointer destl) a" by auto
    then have a50:"toploc a = toploc m" unfolding updateStore_def by simp
    then have a60:"Some v''' =  iter' (\<lambda>i. cpm2mrec (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1" using a10 a20 a30 a40 by metis
    then show "toploc a =toploc v'''" using a50
    proof(induction rule: iter'_ind[OF _ _ a60[symmetric]])
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v' 
        where b10:" iter' (\<lambda>i. cpm2mrec (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x = Some v'"
          and b20:"(Some v' = iter' (\<lambda>i. cpm2mrec (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x \<longrightarrow> toploc a = toploc m \<longrightarrow> toploc a = toploc v')"
          and b30: "cpm2mrec (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp srcMem v' = Some v''" by blast
      then have "toploc a= toploc v'" using 2 by simp
      then show ?case using MTArray[of " (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  v' v''' ] b30  using MTArray by auto
    qed
  qed
next
  case (MTValue x)
  then show ?case using cpm2mrec.simps(2)[of srcl destl x srcMem a] unfolding updateStore_def by (auto split:option.splits Memoryvalue.splits)
qed

lemma cps2mrecTopLocSame:
  shows " cps2mrec srcl destl tp' srcMem a = Some v''' \<longrightarrow> toploc a = toploc v'''" 
proof( induction tp' arbitrary: srcl destl  a v''')
  case (STArray x1 tp)
  show ?case  
  proof intros
    assume *:" cps2mrec srcl destl (STArray x1 tp) srcMem a = Some v'''"
    then have a10:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1)" using cps2mrec.simps(1)[of srcl destl x1 tp srcMem a] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) a" by auto
    then have a50:"toploc a = toploc m" unfolding updateStore_def by simp
    then have a60:"Some v''' =  iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x1" using a10 a40 by metis
    then show "toploc a =toploc v'''" using a50
    proof(induction rule: iter'_ind[OF _ _ a60[symmetric]])
      case (1 v')
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v' 
        where b10:" iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x = Some v'"
          and b20:"(Some v' = iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) tp srcMem) m x \<longrightarrow> toploc a = toploc m \<longrightarrow> toploc a = toploc v')"
          and b30: "cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) tp srcMem v' = Some v''" by blast
      then have "toploc a= toploc v'" using 2 by simp
      then show ?case using STArray[of " (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  v' v''' ] b30  using STArray by auto
    qed
  qed
next
  case (STValue x)
  then show ?case using cps2mrec.simps(2)[of srcl destl x srcMem a] unfolding updateStore_def by (auto split:option.splits Memoryvalue.splits)
next 
  case (STMap k v)
  then show ?case using cps2mrec.simps(3) by simp
qed

lemma cpm2mTopLocSame:
  assumes "iter' (\<lambda>i m. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
    and "x>0"
  shows "toploc md = toploc updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"toploc md = toploc v'"
      and a30:"cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  then show ?case using cpm2mrecTopLocSame by auto
qed

lemma cps2mTopLocSame:
  assumes "iter' (\<lambda>i m. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "toploc md = toploc updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"toploc md = toploc v'"
      and a30:"cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  then show ?case using cps2mrecTopLocSame by auto
qed

lemma cpm2mSingleChange:
  assumes "iter' (\<lambda>i m. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>locs. \<not>LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStore locs md = accessStore locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>locs. \<not> LSubPrefL2 locs ld  \<or> locs = ld  \<longrightarrow> accessStore locs md = accessStore locs v')"
      and a30:"cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs 
    assume *:"\<not> LSubPrefL2 locs ld \<or> locs = ld"
    then have "accessStore locs md =  accessStore locs v'" using a20  by simp
    then show "accessStore locs md = accessStore locs v''" using cpm2mrec_SubPrefixes[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t ms v' v'']
      using a30 * using Not_Sub_More_Specific 
      by (metis cpm2mRec_destRootSame)
  qed
qed

lemma cpm2sSingleChange:
  assumes "iter' (\<lambda>i m. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>t' locs. \<not>LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStorage t' locs md = accessStorage t' locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>t' locs. \<not> LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStorage t' locs md = accessStorage t' locs v') "
      and a30:"cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs t'
    assume *:"\<not> LSubPrefL2 locs ld \<or> locs = ld"
    then have "accessStorage t' locs md =  accessStorage t' locs v'" using a20  by simp
    then show "accessStorage t' locs md = accessStorage t' locs v''" 
      using cpm2srec_SubPrefixes[of _ _  t ms v' v'']  a30 * Not_Sub_More_Specific 
      by (metis cpm2sRec_destRootSame)
  qed
qed

lemma copySingleChange:
  assumes "iter' (\<lambda>i m. copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m) md x = Some updM"
  shows "\<forall>t' locs. \<not>LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStorage t' locs md = accessStorage t' locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) md x = Some v'"
      and a20:"(\<forall>t' locs. \<not> LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStorage t' locs md = accessStorage t' locs v') "
      and a30:" copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs t'
    assume *:"\<not> LSubPrefL2 locs ld \<or> locs = ld"
    then have "accessStorage t' locs md =  accessStorage t' locs v'" using a20  by simp
    then show "accessStorage t' locs md = accessStorage t' locs v''" 
      using copyrec_SubPrefixes  a30 * Not_Sub_More_Specific 
      by (metis copyRec_destRootSame)
  qed
qed




lemma cpm2mrec_SubPrefixes2:
  "cpm2mrec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl'. destl' \<noteq> destl \<and> (\<not> TypedMemSubPref destl' destl tp) \<longrightarrow> accessStore destl' a = accessStore destl' v''')" 
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (MTArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume " cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''"
    then have 
      **: "cpm2mrec srcl destl (MTArray x1 t) srcMem a = Some v'''" by auto+

    obtain l where ldef:"accessStore srcl srcMem = Some (MPointer l)" 
      using **  cpm2mrec.simps(1)[of srcl destl x1 t srcMem a ] 
      by (auto split:if_splits option.splits Memoryvalue.splits)
    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using **  by (simp add: cpm2mrec.simps(1))
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto
    have a20:"destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' m"
    proof -
      assume asm:"destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t)"
      then have "\<not>(\<exists>i<x1. TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> destl' = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" 
        using TypedMemSubPref.simps(2)[of destl' destl x1 t] by auto
      then have "(\<forall>i<x1. \<not>TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<and> destl' \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      then show "accessStore destl' a = accessStore destl' m" using mdef asm unfolding accessStore_def updateStore_def by  auto
    qed

    then have v''def:"Some v''' =  iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a5 ldef mdef by metis 
    show "destl'  \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' v'''" using a20 ldef
    proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]]) 
      case (1 v')
      then show ?case using 1 by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:" (destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x t) \<longrightarrow>
          (destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x t) \<longrightarrow> accessStore destl' a = accessStore destl' m) \<longrightarrow>
          accessStore srcl srcMem = Some (MPointer l) \<longrightarrow> accessStore destl' a = accessStore destl' v')"
          and a30:"cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have b40:"accessStore destl' a = accessStore destl' v'" using 2 by simp
      then show ?case
      proof(cases t)
        case mtr:(MTArray x11 x12)
        then have b10:"Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None | Some (MValue literal) \<Rightarrow> None
                     | Some (MPointer l) \<Rightarrow> let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cpm2mrec (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)"
          using a30 cpm2mrec.simps(1)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v' ] by simp
        then obtain thing where tig:"accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MPointer thing)" 
          using mtr by (simp split:option.splits Memoryvalue.splits)

        then have b45:"(\<forall>destl'. destl' \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> \<not> TypedMemSubPref destl'(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray mtr a30 tig by simp
        have "\<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using Not_Sub_More_Specific 2 by simp
        then show ?thesis using b45 b40  
          using "2.prems"(1) by force
      next
        case (MTValue x2)
        then have "Some v'' = (case accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem of None \<Rightarrow> None 
                                      | Some (MValue v) \<Rightarrow> Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') |
                                       Some (MPointer literal) \<Rightarrow> None)" 
          using cpm2mrec.simps(2)[of "(hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] using a30 by simp
        then obtain thing where "accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem = Some (MValue thing)" 
          using MTValue by (simp split:option.splits Memoryvalue.splits)
        then have b45:"(\<forall>destl'. destl' \<noteq>  (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> \<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray MTValue a30 by simp
        have "\<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using Not_Sub_More_Specific 2 by simp
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45
          by (simp add: MTValue)
        then show ?thesis using b40  by simp
      qed
    qed
  qed
next
  case (MTValue x)
  show ?case
  proof intros
    fix destl'
    assume " cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''"

    then have **:" cpm2mrec srcl destl (MTValue x) srcMem a = Some v'''" by simp+
    then have mdef:"Some v''' = (case accessStore srcl srcMem of None \<Rightarrow> None 
                    | Some (MValue v) \<Rightarrow> Some (updateStore destl (MValue v) a) 
                    | Some (MPointer literal) \<Rightarrow> None)" using cpm2mrec.simps(2)[of srcl destl x srcMem a] by simp
    assume ***:" destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTValue x)"
    then show "accessStore destl' a = accessStore destl' v'''" using mdef unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma cps2mrec_SubPrefixes2:
  "
   cps2mrec srcl destl tp srcMem a = Some v''' \<longrightarrow>
  (\<forall>destl'.  destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl tp \<longrightarrow> accessStore destl' a = accessStore destl' v''')"
proof(induction tp arbitrary:srcl destl srcMem a v''' )
  case (STArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume " cps2mrec srcl destl (STArray x1 t) srcMem a = Some v'''"
    then have 
      **: "cps2mrec srcl destl (STArray x1 t) srcMem a = Some v'''" by auto+

    then have a5:"Some v''' = (let m = updateStore destl (MPointer destl) a in iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1)" 
      using ** cps2mrec.simps(1)[of srcl destl x1 t srcMem a ] by (auto split:if_splits option.splits Memoryvalue.splits)
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto

    have a20:"destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' m"
    proof -
      assume asm:"destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STArray x1 t)"
      then have "\<not>(\<exists>i<x1. TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t 
                    \<or> destl' = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" 
        using TypedStoSubPref.simps(2)[of destl' destl x1 t] by auto
      then have "(\<forall>i<x1. \<not>TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<and> destl' \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      then show "accessStore destl' a = accessStore destl' m" using mdef asm unfolding accessStore_def updateStore_def by  auto
    qed


    then have v''def:"Some v''' =  iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x1" using a5 mdef by metis 
    show " destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' v'''" using a20 
    proof(induction rule: iter'_ind[OF _ _ v''def[symmetric]]) 
      case (1 v')

      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter' (\<lambda>i. cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t srcMem) m x = Some v'"
          and a20:"(destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STArray x t) \<longrightarrow>
          (destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STArray x t) \<longrightarrow> accessStore destl' a = accessStore destl' m) \<longrightarrow> accessStore destl' a = accessStore destl' v')"
          and a30:"cps2mrec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t srcMem v' = Some v''" by blast
      then have b40:"accessStore destl' a = accessStore destl' v'" using 2 by simp
      then show ?case
      proof(cases t)
        case mtr:(STArray x11 x12)
        then have b10:"Some v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cps2mrec (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 srcMem) m x11)"
          using a30 cps2mrec.simps(1)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 srcMem v' ] by simp
        then have b45:"(\<forall>destl'. destl' \<noteq>(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> \<not> TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using STArray mtr a30 by simp
        have "\<not> TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using Not_Sub_More_Specific 2 by simp
        then show ?thesis using b45 b40 2 by simp
      next
        case (STValue x2)
        then have "Some v'' =  (let v = accessStorage x2 (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem 
                                    in Some (updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'))" 
          using cps2mrec.simps(2)[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 srcMem v'] using a30 by simp

        then have b45:"(\<forall>destl'. destl' \<noteq>(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> \<not> TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using STArray STValue a30 by simp
        have "\<not> TypedStoSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using Not_Sub_More_Specific 2 by simp
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45 2 by simp
        then show ?thesis using b40  by simp
      next case (STMap x3 x4)
        then show ?thesis 
          using cps2mrec.simps(3) using a30 by simp
      qed
    qed
  qed
next
  case (STValue x)
  show ?case
  proof intros
    fix destl'
    assume " cps2mrec srcl destl (STValue x) srcMem a = Some v'''"

    then have **:" cps2mrec srcl destl (STValue x) srcMem a = Some v'''" by simp+
    then have mdef:"Some v''' = (let v = accessStorage x srcl srcMem 
                      in Some (updateStore destl (MValue v) a))" 
      using cps2mrec.simps(2)[of srcl destl x srcMem a] by simp
    assume ***:" destl' \<noteq> destl \<and> \<not> TypedStoSubPref destl' destl (STValue x)"
    then show "accessStore destl' a = accessStore destl' v'''" using mdef unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits)
  qed
next 
  case (STMap x1 tp)
  then show ?case using cps2mrec.simps(3) by auto
qed

lemma cpm2mSingleChange2:
  assumes "iter' (\<lambda>i m. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>locs.  \<not>TypedMemSubPref locs ld (MTArray x t) \<longrightarrow> accessStore locs md = accessStore locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>locs. \<not> TypedMemSubPref locs ld (MTArray x t) \<longrightarrow> accessStore locs md = accessStore locs v')"
      and a30:"cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs 
    assume *:" \<not> TypedMemSubPref locs ld (MTArray (Suc x) t)"
    then have "accessStore locs md =  accessStore locs v'" using a20 by auto
    then show "accessStore locs md = accessStore locs v''" using cpm2mrec_SubPrefixes2 
      using "*" a30 by auto

  qed
qed



lemma cpm2sSingleChange2:
  assumes "iter' (\<lambda>i m. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>locs t' t''.  cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> ld 
        \<and> \<not>TypedStoSubpref locs ld (STArray x t') \<longrightarrow> accessStorage t'' locs md = accessStorage t'' locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>locs t' t''. cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> ld \<and> \<not> TypedStoSubpref locs ld (STArray x t') \<longrightarrow> accessStorage t'' locs md = accessStorage t'' locs v')"
      and a30:"cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs t' t''
    assume *:"cps2mTypeCompatible (STArray (Suc x) t') (MTArray (Suc x) t) \<and> locs \<noteq> ld \<and> \<not> TypedStoSubpref locs ld (STArray (Suc x) t')"
    then show "accessStorage t'' locs md = accessStorage t'' locs v''" 
    proof(cases "x = 0")
      case True
      then have "accessStorage t'' locs md = accessStorage t'' locs v'"  using a10 by simp
      then show ?thesis using cpm2srec_SubPrefixes2 a30 
        using "*" 
        by (metis True TypedStoSubpref_sameLoc cps2mTypeCompatible.simps(2) TypedStoSubpref.simps(2))
    next
      case False
      then have "cps2mTypeCompatible (STArray x t') (MTArray x t)"  
        by (meson "*" bot_nat_0.not_eq_extremum cps2mTypeCompatible.simps(2))
      have "\<not> TypedStoSubpref locs ld (STArray x t')" using False * by simp
      have "\<not> TypedStoSubpref locs ld (STArray x t') \<longrightarrow> accessStorage t'' locs md = accessStorage t'' locs v'" using a20 
        using "*" \<open>cps2mTypeCompatible (STArray x t') (MTArray x t)\<close> by blast
      then show ?thesis using a30 cpm2srec_SubPrefixes2 * 
        by (metis TypedStoSubpref_sameLoc \<open>\<not> TypedStoSubpref locs ld (STArray x t')\<close> cps2mTypeCompatible.simps(2) lessI TypedStoSubpref.simps(2))
    qed

  qed
qed

lemma copySingleChange2:
  assumes "iter' (\<lambda>i m. copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m) md x = Some updM"
  shows "\<forall>locs t''.  \<not>TypedStoSubpref locs ld (STArray x t) \<longrightarrow> accessStorage t'' locs md = accessStorage t'' locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) md x = Some v'"
      and a20:"(\<forall>locs t''. \<not> TypedStoSubpref locs ld (STArray x t) \<longrightarrow> accessStorage t'' locs md = accessStorage t'' locs v')"
      and a30:"copyRec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs t''
    assume *:"\<not> TypedStoSubpref locs ld (STArray (Suc x) t) "
    then show "accessStorage t'' locs md = accessStorage t'' locs v''" 
    proof(cases "x = 0")
      case True
      then have "accessStorage t'' locs md = accessStorage t'' locs v'"  using a10 by simp
      then show ?thesis using copyrec_SubPrefixes2 a30 
        using "*" by simp
    next
      case False
      then show ?thesis using a30 copyrec_SubPrefixes2 * 
        by (metis "2.hyps" copyRec.simps(1))
    qed
  qed
qed

lemma cps2mSingleChange:
  assumes "iter' (\<lambda>i m. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>locs. \<not>LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStore locs md = accessStore locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>locs. \<not> LSubPrefL2 locs ld \<longrightarrow> accessStore locs md = accessStore locs v')"
      and a30:"cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs 
    assume *:"\<not> LSubPrefL2 locs ld \<or> locs = ld"
    then have "accessStore locs md =  accessStore locs v'" using a20 
      using "2.IH" a10 by auto
    then show "accessStore locs md = accessStore locs v''" using cps2mrec_SubPrefixes
      using a30 * using Not_Sub_More_Specific  
      by (metis cps2mRec_destRootSame)
  qed
qed

lemma cps2mSingleChange2:
  assumes "iter' (\<lambda>i m. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
  shows "\<forall>locs. locs \<noteq> ld \<and> \<not>TypedStoSubPref locs ld (STArray x t) \<longrightarrow> accessStore locs md = accessStore locs updM"
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(\<forall>locs. locs \<noteq> ld \<and> \<not> TypedStoSubPref locs ld (STArray x t) \<longrightarrow> accessStore locs md = accessStore locs v')"
      and a30:"cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  show ?case 
  proof intros
    fix locs 
    assume *:"locs \<noteq> ld \<and> \<not> TypedStoSubPref locs ld (STArray (Suc x) t)"
    then have "accessStore locs md =  accessStore locs v'" using a20 by auto
    then show "accessStore locs md = accessStore locs v''" using cps2mrec_SubPrefixes2[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t ms v' v'']
      using a30 * using Not_Sub_More_Specific by simp
  qed
qed


lemma copyAccessPrePost:
  shows "\<forall>t''. Some v'' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') m x1
          \<and> (\<forall>suffix. hash destl suffix \<noteq> destl)  \<longrightarrow> accessStorage t''  destl m = accessStorage t'' destl v'' "
proof intros
  fix t''
  assume " Some v'' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') m x1 \<and>   (\<forall>suffix. hash destl suffix \<noteq> destl)"
  then have *:"Some v'' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') m x1"
    and **: "(\<forall>suffix. hash destl suffix \<noteq> destl)" by simp+
  then show " accessStorage t'' destl m = accessStorage t'' destl v''"
  proof(induction rule: iter'_ind[OF _ _ *[symmetric]])
    case (1 v')
    then show ?case by simp
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') m x = Some v'"
        and a20:" (Some v' = iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') m x \<longrightarrow>
          (\<forall>suffix. hash destl suffix \<noteq> destl) \<longrightarrow> accessStorage t'' destl m = accessStorage t'' destl v')"
        and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'  v' = Some v''" by blast
    then show ?case using copyRec_destRootSame 
      using "**" by simp
  qed
qed



(*
From context of iter' we know we have an MCon array a which has been partially initialised to a index len.
Due to how MCon is defined we can just say we have an MCon Array of length len.
We then assign using cpm2mrec to the next index of that array (which is len due to zero indexing)
Therefore we are required to show that the new array is Mcon up to this new index \<longrightarrow> len+1
we also know that the source memory is MCon for the full length
*)
lemma MCon_cpm2m: 
  assumes "iter' (\<lambda>i m. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
    and "MCon (MTArray x t) ms ls"
    and "(\<exists>p. accessStore (ld) md = Some (MPointer p)) \<or> accessStore (ld) md = None"
  shows " MCon (MTArray x t) updM ld" using assms(2) 
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case using MCon.simps by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(MCon (MTArray x t) ms ls \<and> 0 < x \<longrightarrow> MCon (MTArray x t) v' ld)"
      and a30:"cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  then have a40:"MCon (MTArray (Suc x) t) ms ls" using "2.prems" by auto


  have " (\<forall>destl'. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
    using cpm2mrec_SubPrefixes[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t ms v' v''] using a30 by simp
  then have "accessStore ld v' = accessStore ld v''" 
    using a30 cpm2mRec_destRootSame by auto


  then have ld:"(\<exists>p. accessStore (ld) v'' = Some (MPointer p)) \<or> accessStore (ld) v'' = None" 
  proof(cases "x =0")
    case True
    then have v'MD:"v' = md" using a10 by auto
    then have "cpm2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms md = Some v''" using a30 by blast
    then have "(\<forall>destl'. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' md = accessStore destl' v'')" 
      using cpm2mrec_SubPrefixes[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t ms md v''] by simp
    then have "accessStore ld md = accessStore ld v''" 
      using cpm2mRec_destRootSame v'MD using \<open>accessStore ld v' = accessStore ld v''\<close> by blast
    then show ?thesis using assms(3) by simp
  next
    case False
    then have "MCon (MTArray x t) ms ls" using a40 by auto
    then have "MCon (MTArray x t) v' ld" using a20 False by auto
    then show ?thesis 
      by (metis \<open>accessStore ld v' = accessStore ld v''\<close> MCon.simps(2))
  qed


  have "\<forall>i<Suc x.
             case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)" 
  proof intros
    fix i assume *:"i<Suc x"
    show "case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
           | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
           | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)"
    proof(cases t)
      case (MTArray x11 x12)
      then show ?thesis 
      proof(cases "i<x")
        case True
        have b10: "MCon (MTArray x t) v' ld" using a20 a40
          using True by fastforce
        then obtain loc2 where l2Def:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' =  Some (MPointer loc2)"
          using True MCon.simps(2) MTArray MConArrayPointers by blast
        have b50:"\<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
          by (metis Read_Show_nat'_id ShowLNatDot hash_int_prefix hash_never_equal_sufix nat_neq_iff)
        have b60:" \<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True 
          using b50 ShowLNatDot hash_int_prefix by force
        then have b65:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cpm2mrec_SubPrefixes[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t ms v' v''] a30 b50 by simp
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using l2Def by simp
        have b70:" (\<forall>l l'. TypedMemSubPref l ld  (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" using cpm2mSelfPointers[of ls ld t ms md x v'] a10 by auto
        have "\<forall>i<x. case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" 
          using b10 by auto
        then have b80:"MCon t v' loc2" using b10 MCon.simps(2)[of x t v' ld] True l2Def MTArray True 
          by fastforce
        have "TypedMemSubPref (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ld (MTArray x t)" 
          using True by auto
        then have loc2Same:"loc2 = (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using b70 l2Def by metis
        then have "MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "t" v' v''] b50 b60 b70 b80 b65
          using True a30 cpm2mrec_SubPrefixes TypedMemSubPref.simps(2) by blast
        moreover have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using b65 l2Def by auto
        ultimately show ?thesis using MTArray True loc2Same by (auto split:Memoryvalue.splits option.splits MTypes.splits)
      next
        case False
        then have iIsx:"i = x" using * by auto
        then have b10:"\<forall>i<Suc x.
             case accessStore (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ms of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t ms (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t ms loc2 | MTValue Types \<Rightarrow> False)" 
          using a40 using MCon.simps(2)[of "Suc x" t ms ls] by auto
        then obtain loc2 where locDef:"accessStore (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ms = Some (MPointer loc2)"   using iIsx b10 MTArray 
          using MConArrayPointers a40 by blast
        then have "MCon t ms loc2" using b10 MTArray iIsx by fastforce
        then have MCON:"MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" 
          using cpm2mrec_MCon[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" ms t "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] a30 locDef iIsx by simp
        have v''Def:"Some v'' = ( let m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' 
                in iter' (\<lambda>i. cpm2mrec (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 ms) m x11)" 
          using a30 cpm2mrec.simps(1)[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12 ms v'] locDef iIsx
          by (simp add: MTArray)
        then obtain m where mDef:"m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by simp
        then have v''Def:"Some v'' =  iter' (\<lambda>i. cpm2mrec (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12 ms) m x11" using v''Def by presburger
        have "(\<forall>suffix. hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffix \<noteq> hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using hash_inequality by simp
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) m = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v''" 
          using accessPrePost1[of v'' loc2 "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x12 ms m x11] v''Def by simp
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" 
          using iIsx mDef by simp
        then show ?thesis using MCON MTArray iIsx by (auto split:Memoryvalue.splits option.splits MTypes.splits)
      qed
    next
      case (MTValue x2)
      then show ?thesis 
      proof(cases "i<x")
        case True

        have "MCon (MTArray x t)  v' ld" using a20 2 
          using True by auto
        then have MCON:"case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" 
          using True MCon.simps(2)[of "x" t v' ld] 
          by simp
        then obtain v where vdef:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue v)" using True MTValue by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have tc:"typeCon x2 v" using  MCon.simps vdef True a40  MTValue MCON by auto
        have b10:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
          by (simp add: Read_Show_nat'_id readLintNotEqual)
        then have b20:"(\<forall>x'. (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash (ShowL\<^sub>n\<^sub>a\<^sub>t x) x')" using True 
          by (metis LSubPrefL2_def hash_inequality ShowLNatDot hash_int_prefix hash_suffixes_associative)
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using a30 cpm2mrecSingleChange[of v'' ls "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" ld "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" t ms v' "(ShowL\<^sub>n\<^sub>a\<^sub>t i)"] b10 by simp
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" 
          using vdef by simp
        then show ?thesis using  MCon.simps vdef True a40  MTValue v''Store tc by auto
      next
        case False

        then have iIsx: "i = x" using * by simp
        have sv'':"Some v'' =  (case accessStore (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) ms of None \<Rightarrow> None 
                | Some (MValue v) \<Rightarrow> Some (updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v') 
                | Some (MPointer literal) \<Rightarrow> None)" 
          using cpm2mrec.simps(2)[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 ms v'] a30 MTValue by simp
        then obtain v where vdef:"accessStore (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ms = Some (MValue v)" using iIsx by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" 
          using sv'' iIsx unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        have "typeCon x2 v" using  MCon.simps vdef iIsx a40  MTValue by auto
        then show ?thesis using  MCon.simps vdef iIsx a40  MTValue v''Store by auto
      qed
    qed
  qed
  then show ?case using cpm2mrec_MCon MCon.simps(2)[of "Suc x" t v'' "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))"] ld by simp
qed

lemma cps2m:
  assumes "iter' (\<lambda>i m. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' ms m) md x = Some updM"
    and "SCon (STArray x t') ls ms"
    and "cps2mTypeCompatible (STArray x t') (MTArray x t)"
    and "(\<exists>p. accessStore (ld) md = Some (MPointer p)) \<or> accessStore (ld) md = None"
  shows "MCon (MTArray x t) updM ld" using assms(2) assms(3) assms(4)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case  using MCon.simps by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t' ms) md x = Some v'"
      and a20:"(SCon (STArray x t') ls ms \<longrightarrow> 0 < x \<longrightarrow> cps2mTypeCompatible (STArray x t') (MTArray x t) \<longrightarrow> MCon (MTArray x t) v' ld)"
      and a30:"cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' ms v' = Some v''" by blast
  then have a40:"SCon (STArray (Suc x) t') ls ms" using "2.prems" by auto

  have " (\<forall>destl'. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
    using cps2mrec_SubPrefixes a30 by simp
  then have "accessStore ld v' = accessStore ld v''" 
    using a30 cps2mRec_destRootSame by auto
  then have ld:"(\<exists>p. accessStore (ld) v'' = Some (MPointer p)) \<or> accessStore (ld) v'' = None" 
  proof(cases "x =0")
    case True
    then have v'MD:"v' = md" using a10 by auto
    then have "cps2mrec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' ms md = Some v''" using a30 by blast
    then have "(\<forall>destl'. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' md = accessStore destl' v'')" 
      using cps2mrec_SubPrefixes[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' ms md v''] by simp
    then have "accessStore ld md = accessStore ld v''" 
      using cpm2mRec_destRootSame v'MD using \<open>accessStore ld v' = accessStore ld v''\<close> by blast
    then show ?thesis using assms(4) by simp
  next
    case False
    then have "SCon (STArray x t') ls ms" using a40 by auto
    then have "MCon (MTArray x t) v' ld" using a20 False 
      by (metis assms(3) cps2mTypeCompatible.simps(2) less_nat_zero_code linorder_neqE_nat)
    then show ?thesis 
      by (metis \<open>accessStore ld v' = accessStore ld v''\<close> MCon.simps(2))
  qed

  have "\<forall>i<Suc x.
             case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
             | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)" 
  proof intros
    fix i assume *:"i<Suc x"
    show "case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
           | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
           | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)"
    proof(cases t)
      case (MTArray x11 x12)
      then show ?thesis 
      proof(cases "i<x")
        case True
        have b10: "MCon (MTArray x t) v' ld" using a20 a40 2(4) 2(5) 
          using True by fastforce
        then obtain loc2 where l2Def:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' =  Some (MPointer loc2)"
          using True MCon.simps(2) MTArray MConArrayPointers by blast
        have b50:"\<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
          by (metis Read_Show_nat'_id ShowLNatDot hash_int_prefix hash_never_equal_sufix nat_neq_iff)
        have b60:" \<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True 
          using b50 ShowLNatDot hash_int_prefix by force
        then have b65:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cps2mrec_SubPrefixes a30 b50 by auto
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using l2Def by simp
        have b70:"( \<forall>l l'. TypedStoSubPref l ld (STArray x t') \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" using cps2mSelfPointers[of ls ld t' ms md x v' ] a10 by simp
        have " \<forall>i<x. case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" using b10 by simp
        then have b80:"MCon t v' loc2" using b10 MCon.simps(2)[of x t v' ld] True l2Def MTArray True by fastforce
        then have "TypedStoSubPref (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ld (STArray x t')" 
          using True by auto
        then have loc2Same:"loc2 = (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using b70 l2Def by auto 
        have "cps2mTypeCompatible t' t" using 2(4) cps2mTypeCompatible.simps True by simp
        then have "MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using frd[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' t v''] b50 b60 b70 b80 b65
            True a30 cps2mrec_SubPrefixes TypedStoSubPref.simps(2) 2(5) loc2Same by blast
        moreover have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using b65 l2Def by auto
        ultimately show ?thesis using MTArray True loc2Same by  simp
      next
        case False
        then have iIsx:"i = x" using * by auto
        then have b10:"(\<forall>i\<in>{0..Suc x - 1}. SCon t' (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ms)" 
          using a40 using SCon.simps(2)[of "Suc x" t' "ls" "ms"] by auto
        have b20:"cps2mTypeCompatible t' t" using 2(4) cps2mTypeCompatible.simps by simp
        then obtain x12' where x12':"t' = STArray x11 x12'" using MTArray using cps2mTypeCompatible.elims(2) by blast

        then have MCON:"MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" 
          using cps2mrec_MCon[of t' "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" ms  "Suc x" t "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] 2(4) a30  iIsx b10 by simp
        have v''Def:"Some v'' = (let m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter' (\<lambda>i. cps2mrec (hash (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12' ms) m x11)" 
          using a30 cps2mrec.simps(1)[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12' ms v']  iIsx x12'
          by (simp add: MTArray)
        then obtain m where mDef:"m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by simp
        then have v''Def:"Some v'' =  iter' (\<lambda>i. cps2mrec (hash (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12' ms) m x11" using v''Def by presburger
        have "(\<forall>suffix. hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffix \<noteq> hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using hash_inequality by simp
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) m = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v''" 
          using cps2mAccessPrePost[of] v''Def by blast
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" 
          using iIsx mDef by simp
        then show ?thesis using MCON MTArray iIsx by (auto split:Memoryvalue.splits option.splits MTypes.splits)
      qed
    next
      case (MTValue x2)
      then show ?thesis 
      proof(cases "i<x")
        case True
        have "MCon (MTArray x t)  v' ld" using a20 2 using True by auto
        then have MCON:"case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" using True MCon.simps(2)[of "x" t v' ld] 
          by simp
        then obtain v where vdef:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue v)" using True MTValue by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have tc:"typeCon x2 v" using  MCon.simps vdef True a40  MTValue MCON by auto
        have b10:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
          by (simp add: Read_Show_nat'_id readLintNotEqual)
        then have b20:"(\<forall>x'. (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash (ShowL\<^sub>n\<^sub>a\<^sub>t x) x')" using True 
          by (metis LSubPrefL2_def hash_inequality ShowLNatDot hash_int_prefix hash_suffixes_associative)
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using a30 cps2mrecSingleChange[of v'' ls "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" ld "(ShowL\<^sub>n\<^sub>a\<^sub>t x)" t' ms v'] b10 by simp
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" 
          using vdef by simp
        then show ?thesis using  MCon.simps vdef True a40  MTValue v''Store tc by auto
      next
        case False
        then have iIsx: "i = x" using * by simp
        then have b10:"(\<forall>i\<in>{0..Suc x - 1}. SCon t' (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ms)" 
          using a40 using SCon.simps(2)[of "Suc x" t' "ls" "ms"] by auto
        have b20:"cps2mTypeCompatible t' t" using 2(4) cps2mTypeCompatible.simps by simp
        then have x12':"t' = STValue x2" using MTValue using cps2mTypeCompatible.elims(2) by blast
        have sv'':"Some v'' =   (let v = accessStorage x2 (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) ms in Some (updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue v) v'))" 
          using cps2mrec.simps(2)[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 ms v'] a30 MTValue x12' by simp
        then obtain v where vdef:"accessStorage x2 (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) ms = v" using iIsx by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" 
          using sv'' iIsx unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have MCON:"MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" 
          using cps2mrec_MCon[of t' "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" ms  "Suc x" t "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] 2(4) a30  iIsx b10 by simp
        then have tc:"typeCon x2 v" using  MCon.simps vdef False a40  MTValue iIsx   v''Store by auto
        then show ?thesis using  MCon.simps vdef iIsx a40  MTValue v''Store by auto
      qed
    qed
  qed
  then show ?case using cpm2mrec_MCon MCon.simps(2)[of "Suc x" t v'' "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))"] ld by simp
qed


lemma MCon_cpm2s:
  assumes "iter' (\<lambda>i m. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms m) md x = Some updM"
    and "MCon (MTArray x t) ms ls"
    and "cps2mTypeCompatible (STArray x t') (MTArray x t)"
  shows "SCon (STArray x t') ld updM" using assms(2) assms(3)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case  using MCon.simps by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'"
      and a20:"(MCon (MTArray x t) ms ls \<longrightarrow> cps2mTypeCompatible (STArray x t') (MTArray x t) \<longrightarrow> SCon (STArray x t') ld v')"
      and a30:"cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v''" by blast
  then have a40:"MCon (MTArray (Suc x) t) ms ls" using "2.prems" by auto

  have " (\<forall>destl' t. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow>  accessStorage t destl' v' =  accessStorage t destl' v'')" 
    using cpm2srec_SubPrefixes a30 by simp
  then have "\<forall>t.  accessStorage t ld v' = accessStorage t ld v''"
    using a30 cpm2sRec_destRootSame by auto
  have "(\<forall>i<Suc x. SCon t' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" 
  proof intros
    fix i assume *:"i<Suc x"
    show "SCon t' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''"
    proof(cases t')
      case (STArray x11 x12)
      then show ?thesis 
      proof(cases "i<x")
        case True
        have b10: "SCon (STArray x t') ld v' " using a20 a40 2(4)  
          using True by fastforce

        have b50:"\<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
          by (metis Read_Show_nat'_id ShowLNatDot hash_int_prefix hash_never_equal_sufix nat_neq_iff)
        have b60:" \<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True 
          using b50 ShowLNatDot hash_int_prefix by force
        then have b65:"\<forall>t. accessStorage t (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStorage t (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cpm2srec_SubPrefixes a30 b50 by auto
        then have b70:"\<forall>i' t. accessStorage t (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) i') v' = accessStorage t (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) i') v'' " 
          using b50 b60 \<open>\<forall>destl' t. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStorage t destl' v' = accessStorage t destl' v''\<close> Mutual_NonSub_SpecificNonSub by auto
        have "cps2mTypeCompatible (STArray x t') (MTArray  x t)" using 2(4) 
          using True by auto
        then show ?thesis using b10 b70 True b65
        proof(induction t' arbitrary:x ld t i)
          case (STArray x1 t')
          have "(\<forall>i<x. SCon (STArray x1 t') (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v')" using STArray.prems(2) SCon.simps(2)[of x "STArray x1 t'" ld v'] by blast
          then have oSC:"SCon (STArray x1 t') (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" 
            by (simp add: STArray.prems)
          have "\<forall>ia<x1. SCon t' (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" 
          proof intros
            fix ia 
            assume *:"ia < x1"
            have "\<forall>i' t. accessStorage t (hash (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) i') v' 
                          = accessStorage t (hash (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) i') v''" 
              using STArray.prems(3) hash_suffixes_associative by auto
            moreover have "\<forall>t. accessStorage t (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v' 
                            = accessStorage t (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" using STArray by blast
            ultimately show "SCon t' (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ia)) v''" using STArray.IH[of x1 _ "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" ia] oSC * 
              by (metis MTypes.exhaust STArray.prems(1) cps2mTypeCompatible.simps(2,3))
          qed
          then show ?case unfolding SCon.simps by simp
        next
          case (STMap x1 t')
          then show ?case by simp
        next
          case (STValue x')
          then show ?case 
            by auto
        qed

      next
        case False
        then have iIsx:"i = x" using * by auto
        then have MCON:"SCon t' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v''" 
          using cpm2srec_MCon[of "(hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x))" ms t _ t' "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] 2(4) a30  iIsx 
          using MCon_imps_sub_Mcon a40 by blast
        then show ?thesis using MCON  iIsx by simp
      qed
    next
      case (STMap x21 x22)
      then show ?thesis using 2 by simp
    next
      case (STValue x3)
      then show ?thesis 
      proof(cases "i<x")
        case True
        then have "SCon (STArray x t') ld v'" using a20 a40 2(4) by auto
        have b50:"\<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
          by (metis Read_Show_nat'_id ShowLNatDot hash_int_prefix hash_never_equal_sufix nat_neq_iff)
        have b60:" \<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True 
          using b50 ShowLNatDot hash_int_prefix by force
        then have b65:"\<forall>t. accessStorage t (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStorage t (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using cpm2srec_SubPrefixes a30 b50 by auto
        then show ?thesis using STValue True \<open>SCon (STArray x t') ld v'\<close> by auto
      next
        case False
        then have "i = x" 
          using "*" by auto
        then show ?thesis 
          by (meson MCon_imps_sub_Mcon
              \<open>\<And>thesis. (\<And>v'. iter' (\<lambda>i. cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t ms) md x = Some v'
 \<Longrightarrow> MCon (MTArray x t) ms ls \<longrightarrow> cps2mTypeCompatible (STArray x t') (MTArray x t) 
\<longrightarrow> SCon (STArray x t') ld v' \<Longrightarrow> cpm2srec (hash ls (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t ms v' = Some v'' \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close>
              a40 assms(3) cpm2srec_MCon lessI)
      qed                          
    qed
  qed
  then show ?case using cpm2mrec_MCon SCon.simps(2)[of "Suc x" t' ld v''] by simp
qed

lemma copyRec_nonZero_Arrays:
  assumes "copyRec srcl destl t' srcMem = Some v'''"
    and  "subStoTp (STArray len t) t'"
    and "len = 0"
  shows "srcMem = v'''" using assms
proof(induction t' arbitrary:srcl destl srcMem v''' len t)
  case (STArray x1 t')
  have a5:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x1 = Some v'''" 
    using STArray.prems(1) unfolding copyRec.simps by simp
  show ?case using STArray.prems(2)
  proof(induction rule: iter'_ind[OF _ _ a5])
    case (1 v')
    then show ?case by auto
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
        and a20:"(subStoTp (STArray len t) (STArray x t') \<longrightarrow> srcMem = v')"
        and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
    then show ?case 
      using "2.prems" STArray.IH STArray.prems(3) by force
  qed
next
  case (STMap x1 t')
  then show ?case 
    by (simp add: copyRec.simps(3))
next
  case (STValue x)
  then show ?case by simp
qed

lemma iter'Copy_nonZero_Arrays:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and  "subStoTp (STArray len t) t'"
    and "len = 0"
  shows "srcMem = v'" using assms
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then show ?case 
    using copyRec_nonZero_Arrays by blast
qed


lemma copyRec_subT_mustNotBeArray:
  assumes "copyRec srcl destl t' srcMem = Some v'''"
    and "\<forall>len t. subStoTp (STArray len t) t' \<longrightarrow> len > 0"
  shows "\<forall>k v. \<not>subStoTp (STMap k v) t'" using assms
proof(induction t' arbitrary:srcl destl srcMem v''')
  case (STArray x1 t')
  have a5:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x1 = Some v'''" 
    using STArray.prems(1) unfolding copyRec.simps by simp
  show ?case using STArray.prems(2)
  proof(induction rule: iter'_ind[OF _ _ a5])
    case (1 v')
    then show ?case by auto
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
        and a20:"((\<forall>len t. subStoTp (STArray len t) (STArray x t') \<longrightarrow> 0 < len) \<longrightarrow> (\<forall>k v. \<not> subStoTp (STMap k v) (STArray x t'))) "
        and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl  (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
    then show ?case 
      by (metis STArray.IH STArray.prems(2) STypes.distinct(1) subStoTp.simps(2))
  qed
next
  case (STMap x1 t')
  then show ?case 
    by (simp add: copyRec.simps(3))
next
  case (STValue x)
  then show ?case by simp
qed

lemma copy_unchanged:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and "SCon (STArray x t') srcl srcMem" 
    and "SCon (STArray x t') destl srcMem"
  shows "\<forall>destl' t i' . i'\<ge>x \<and>  LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i')) \<longrightarrow> accessStorage t destl' srcMem = accessStorage t destl' v'" using assms(2,3)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:"(SCon (STArray x t') srcl srcMem \<longrightarrow>
          SCon (STArray x t') destl srcMem \<longrightarrow> (\<forall>destl' t i'. x \<le> i' \<and> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i')) 
          \<longrightarrow> accessStorage t destl' srcMem = accessStorage t destl' v'))"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl  (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

  show ?case 
  proof intros 
    fix destl' t i'
    assume as1:"Suc x \<le> i' \<and> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i'))"
    then have g1:"accessStorage t destl' srcMem = accessStorage t destl' v'" using a20 2 by (metis Suc_leD subSCon)
    have g5:"(\<forall>destl' t. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStorage t destl' v' = accessStorage t destl' v'')" 
      using a30 copyrec_SubPrefixes[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' v''] by simp
    have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using as1  
      by (smt (verit) LSubPrefL2_def Suc_le_eq hash_suffixes_associative hashesInts less_irrefl_nat)
    then have g10:" accessStorage t destl' v' = accessStorage t destl' v''" using g5 by simp
    then show "accessStorage t destl' srcMem = accessStorage t destl' v''" using g1 by simp
  qed
qed

lemma copy_unchanged_limit:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
  shows "\<forall>destl' . \<not>TypedStoSubpref destl' destl (STArray (Suc x) t') \<longrightarrow> 
                    (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:" (\<forall>destl'. \<not> TypedStoSubpref destl' destl (STArray (Suc x) t') \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v'))"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

  show ?case 
  proof intros 
    fix destl' t 
    assume as1:"\<not> TypedStoSubpref destl' destl (STArray (Suc (Suc x)) t')"
    then have g1:"accessStorage t destl' srcMem = accessStorage t destl' v'" using a20 2 by simp
    have "(\<forall>destl' t. \<not> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> accessStorage t destl' v' = accessStorage t destl' v'')"
      using a30 as1 copyrec_SubPrefixes2[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' v'']  by simp
    then have g10:" accessStorage t destl' v' = accessStorage t destl' v''" using as1 by simp
    then show "accessStorage t destl' srcMem = accessStorage t destl' v''" using g1 by simp
  qed
qed

lemma copy_unchanged_limit_2:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
  shows "\<forall>destl' . \<not>TypedStoSubpref destl' destl (STArray (x) t') \<longrightarrow> 
                    (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:" (\<forall>destl'. \<not> TypedStoSubpref destl' destl (STArray (x) t') \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v'))"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

  show ?case 
  proof intros 
    fix destl' t 
    assume as1:"\<not> TypedStoSubpref destl' destl (STArray (Suc ( x)) t')"
    then have g1:"accessStorage t destl' srcMem = accessStorage t destl' v'" using a20 2 by simp
    have "(\<forall>destl' t. \<not> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> accessStorage t destl' v' = accessStorage t destl' v'')"
      using a30 as1 copyrec_SubPrefixes2[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' v'']  by simp
    then have g10:" accessStorage t destl' v' = accessStorage t destl' v''" using as1 by simp
    then show "accessStorage t destl' srcMem = accessStorage t destl' v''" using g1 by simp
  qed
qed

lemma copyRec_unchanged_limit:
  assumes "copyRec srcl destl t' srcMem  = Some v'"
  shows "\<forall>destl'. \<not>TypedStoSubpref destl' destl t' \<longrightarrow> 
                    (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')"  using assms
proof(induction t' arbitrary:srcl destl srcMem v')
  case (STArray x1 t')
  have a5:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x1 = Some v'" 
    using STArray.prems(1) unfolding copyRec.simps by simp
  show ?case 
  proof(induction rule: iter'_ind[OF _ _ a5])
    case (1 v')
    then show ?case by auto
  next
    case (2 x v'')
    then obtain v'
      where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
        and a20:"(\<forall>destl'. \<not> TypedStoSubpref destl' destl (STArray x t') \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v'))"
        and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
    then show ?case 
      by (metis "2.hyps" copyRec.simps(1) copyrec_SubPrefixes2_rev)
  qed
next
  case (STMap x1 t')
  then show ?case 
    using copyrec_SubPrefixes2_rev by blast
next
  case (STValue x)
  then show ?case 
    by (simp add: copyrec_SubPrefixes2)
qed

lemma copy_unchanged_limit22:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
  shows "\<forall>destl' . TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> 
                    (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:"(\<forall>destl'. TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v'))"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

  show ?case 
  proof intros 
    fix destl' t 
    assume as1:"TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t (Suc x))) t'"
    then have g1:"accessStorage t destl' srcMem = accessStorage t destl' v'" using a20 2 
      by (meson NotRelatedPrnt_imps_notRelatedChild Sto_divergence_imps_notsubloc TypedStoSubpref_hashes a10 copy_unchanged_limit)
    have "(\<forall>destl' t. \<not> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> accessStorage t destl' v' = accessStorage t destl' v'')"
      using a30 as1 copyrec_SubPrefixes2[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' v'']  by simp
    then have "accessStorage t destl' v' = accessStorage t destl' v''" using as1 
      by (metis "2.hyps" NotRelatedPrnt_imps_notRelatedChild Sto_divergence_imps_notsubloc TypedStoSubpref_hashes copyRec.simps(1) copyrec_SubPrefixes2 g1)
    then show "accessStorage t destl' srcMem = accessStorage t destl' v''" using g1 by simp
  qed
qed

lemma single_STValue:
  assumes "SCon (STArray x t') srcl srcMem"
  shows "\<exists>!x'. subStoTp (STValue x') (STArray x t')" using assms
proof(induction t' arbitrary:x srcl)
  case (STArray x1 t')
  then show ?case by fastforce
next
  case (STMap x1 t')
  then show ?case by fastforce
next
  case (STValue x)
  then show ?case by simp
qed

lemma copy_unchanged_limit_rev:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and "SCon (STArray x t') srcl srcMem" 
    and "SCon (STArray x t') destl srcMem"
  shows "\<forall>destl' t. accessStorage t destl' srcMem \<noteq> accessStorage t destl' v'
                    \<longrightarrow> TypedStoSubpref destl' destl (STArray (Suc x) t')" using assms(2,3)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by auto
next
  case (2 x v'')
  then obtain v'
    where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:" (SCon (STArray x t') srcl srcMem \<longrightarrow>
          SCon (STArray x t') destl srcMem \<longrightarrow> 
          (\<forall>destl' t. accessStorage t destl' srcMem \<noteq> accessStorage t destl' v' \<longrightarrow> TypedStoSubpref destl' destl (STArray (Suc x) t')))"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
  show ?case 
  proof intros 
    fix destl' t 
    assume as1:" accessStorage t destl' srcMem \<noteq> accessStorage t destl' v'' "
    then have g1:"TypedStoSubpref destl' destl (STArray (Suc x) t')" using a20 2
      by (metis copyrec_SubPrefixes2 lessI TypedStoSubpref.simps(2) subSCon)
    have "(\<forall>destl' t. accessStorage t destl' v' \<noteq> accessStorage t destl' v'' \<longrightarrow> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t')"
      using a30 as1 copyrec_SubPrefixes2_rev[of "(hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t' v' v'']  by simp
    then show "TypedStoSubpref destl' destl (STArray (Suc (Suc x)) t')" using g1 by auto
  qed
qed

lemma copyRec_notSub_Scon:
  assumes "copyRec srcl  destl t' srcMem = Some v'"
    and "SCon t' srcl srcMem" 
    and "\<not>TypedStoSubpref destl srcl t'"
    and "\<not>TypedStoSubpref srcl destl t'"
    and "SCon t' destl srcMem" 
    and "\<forall>subL. TypedStoSubpref subL srcl t' \<longrightarrow> \<not> TypedStoSubpref subL destl t'"
    and "\<forall>subL. TypedStoSubpref subL destl t' \<longrightarrow> \<not> TypedStoSubpref subL srcl t'"
  shows "SCon t' destl v'" using assms
proof(induction t' arbitrary:srcl destl srcMem v')
  case (STArray x1 t')
  have a5:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x1 = Some v'" 
    using STArray.prems(1) unfolding copyRec.simps by simp
  show ?case using STArray.prems(2,3,4,5,6,7)
  proof(induction rule: iter'_ind[OF _ _ a5])
    case (1 v')
    then show ?case by simp
  next
    case (2 x v'')
    then obtain v' where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:" (SCon (STArray x t') srcl srcMem \<longrightarrow> \<not> TypedStoSubpref destl srcl (STArray x t') 
            \<longrightarrow> \<not> TypedStoSubpref srcl destl (STArray x t') \<longrightarrow> SCon (STArray x t') destl srcMem 
            \<longrightarrow> (\<forall>subL. TypedStoSubpref subL srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL destl (STArray x t')) \<longrightarrow>
              (\<forall>subL. TypedStoSubpref subL destl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL srcl (STArray x t')) 
              \<longrightarrow> SCon (STArray x t') destl v' )"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

    moreover have p1:"(\<forall>subL. TypedStoSubpref subL srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL destl (STArray x t'))" 
      using TypedStoSubpref_arr_longer 2(7) by blast
    moreover have "(\<forall>subL. TypedStoSubpref subL destl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL srcl (STArray x t'))"
      using TypedStoSubpref_arr_longer 2(8) by blast
    ultimately have a40:"SCon (STArray x t') destl v'" using 2  
      using TypedStoSubpref_sameLoc subSCon by presburger


    have g11:"\<forall>destl'. \<not> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' v' = accessStorage t destl' v'')"
      using copyRec_unchanged_limit[OF a30] by blast
    have g12:"\<forall>destl'. TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
      using copy_unchanged_limit22[OF a10] by simp
    have g13:"\<forall>destl'. \<not> TypedStoSubpref destl' destl (STArray x t') \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
      using copy_unchanged_limit_2[OF a10] by blast

    have scSrc:"SCon (STArray (Suc x) t') srcl v'" using g13  p1 "2.prems"(5) 2(3) dhsuhdua 
      by (meson NotRelatedPrnt_imps_notRelatedChild Scon_NoChange TypedStoSubpref_sameLoc)


    show ?case
    proof(cases "\<forall>len t. subStoTp (STArray len t) t' \<longrightarrow> 0 < len")
      case True
      have a45:"SCon (STArray x t') destl v''" unfolding SCon.simps
      proof intros
        fix i assume a1:"i<x"
        then have a41:"SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" using a40 by simp
        then have g10:" \<forall>k v. \<not> subStoTp (STMap k v) t'" 
          using copyRec_subT_mustNotBeArray a30 True by simp
        then have g12:"\<not> TypedStoSubpref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" using a1
          by (meson NotRelatedPrnt_imps_notRelatedChild Sto_divergence_imps_notsubloc TypedStoSubpref_hashes TypedStoSubpref.simps(2))
        then have "\<forall>l. \<not> TypedStoSubpref (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" 
          by (metis (full_types) TypedStoSubpref_b a1 hash_suffixes_associative hashesInts nat_neq_iff)
        then show "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using g11 a41 g10 g12
        proof(induction t' arbitrary:destl i)
          case (STArray x1 t')
          then show ?case 
            using NoSubChanged_Scon_Preserved by presburger
        next
          case (STMap x1 t')
          then show ?case by auto
        next
          case (STValue x')
          then show ?case by simp
        qed
      qed

      show ?thesis unfolding SCon.simps
      proof intros
        fix i 
        assume as1:"i<Suc x"
        show "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' " 
        proof(cases "i = x")
          case True
          have "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem" using 2(6) by simp
          then have cc1:"SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'" using g12 Scon_NoChange by simp        
          have cc2:"SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'"  using scSrc by simp
          have cc3:"\<not>TypedStoSubpref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))  t'" using 2 
            by (metis True TypedStoSubpref_specific_unreachanble_arry as1 TypedStoSubpref.simps(2))
          have cc4:"\<not>TypedStoSubpref (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))  t'" using 2 
            by (metis True TypedStoSubpref_specific_unreachanble_arry as1 TypedStoSubpref.simps(2))
          have cc5:"\<forall>subL. TypedStoSubpref subL (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> \<not> TypedStoSubpref subL (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'"
            using 2 NotRelatedPrnt_imps_notRelatedChild cc3 cc4 by blast
          have cc6:"\<forall>subL. TypedStoSubpref subL (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> \<not> TypedStoSubpref subL  (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'"
            using 2 NotRelatedPrnt_imps_notRelatedChild cc3 cc4 by blast
          then show ?thesis using STArray.IH[OF a30 cc2 cc3 cc4 cc1 cc5 cc6] True by blast
        next
          case False
          then have "i<x" using as1 by simp
          then show ?thesis using a45 by simp
        qed
      qed
    next
      case False
      then have a9:"\<exists>len t. subStoTp (STArray len t) t' \<and> 0 = len" by simp
      then have "v' = v''" using copyRec_nonZero_Arrays a30 by blast
      moreover have "srcMem = v'" using iter'Copy_nonZero_Arrays[OF a10] a9 by auto
      ultimately show ?thesis using a40 2(6) by simp
    qed
  qed
next
  case (STMap x1 t')
  then show ?case 
    by (metis copyRec.simps(3) option.distinct(1))
next
  case (STValue x)
  have "(let e = accessStorage x srcl srcMem in Some (srcMem(destl $$:= e))) = Some v'" using STValue(1) unfolding copyRec.simps by simp
  then have "(accessStorage x destl v') = (accessStorage x srcl srcMem)" unfolding accessStorage_def by auto
  moreover have "typeCon x (accessStorage x srcl srcMem)" using STValue(2) unfolding SCon.simps by simp
  ultimately show ?case unfolding SCon.simps by simp
qed


lemma copy_notSub_Scon:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and "SCon (STArray x t') srcl srcMem" 
    and "\<not>TypedStoSubpref destl srcl (STArray x t')"
    and "\<not>TypedStoSubpref srcl destl (STArray x t')"
    and "SCon (STArray x t') destl srcMem" 
    and "\<forall>subL. TypedStoSubpref subL srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL destl (STArray x t')"
    and "\<forall>subL. TypedStoSubpref subL destl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL srcl (STArray x t')"
  shows "SCon (STArray x t') destl v'" using assms(2,3,4,5,6,7)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v' where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and a20:" (SCon (STArray x t') srcl srcMem \<longrightarrow> \<not> TypedStoSubpref destl srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref srcl destl (STArray x t') \<longrightarrow> SCon (STArray x t') destl srcMem 
        \<longrightarrow> (\<forall>subL. TypedStoSubpref subL srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL destl (STArray x t')) \<longrightarrow>
          (\<forall>subL. TypedStoSubpref subL destl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL srcl (STArray x t')) 
          \<longrightarrow> SCon (STArray x t') destl v' )"
    and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast

  moreover have p1:"(\<forall>subL. TypedStoSubpref subL srcl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL destl (STArray x t'))" 
    using TypedStoSubpref_arr_longer 2(7) by blast
  moreover have "(\<forall>subL. TypedStoSubpref subL destl (STArray x t') \<longrightarrow> \<not> TypedStoSubpref subL srcl (STArray x t'))"
    using TypedStoSubpref_arr_longer 2(8) by blast
  ultimately have a40:"SCon (STArray x t') destl v'" using 2  
    using TypedStoSubpref_sameLoc subSCon by presburger


  have g11:"\<forall>destl'. \<not> TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' v' = accessStorage t destl' v'')"
    using copyRec_unchanged_limit[OF a30] by blast
  have g12:"\<forall>destl'. TypedStoSubpref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
    using copy_unchanged_limit22[OF a10] by simp
  have g13:"\<forall>destl'. \<not> TypedStoSubpref destl' destl (STArray x t') \<longrightarrow> (\<forall>t. accessStorage t destl' srcMem = accessStorage t destl' v')" 
    using copy_unchanged_limit_2[OF a10] by blast

  have scSrc:"SCon (STArray (Suc x) t') srcl v'" using g13  p1 "2.prems"(5) 2(3) dhsuhdua 
    by (meson NotRelatedPrnt_imps_notRelatedChild Scon_NoChange TypedStoSubpref_sameLoc)

  show ?case
  proof(cases "\<forall>len t. subStoTp (STArray len t) t' \<longrightarrow> 0 < len")
    case True
    have a45:"SCon (STArray x t') destl v''" unfolding SCon.simps
    proof intros
      fix i assume a1:"i<x"
      then have a41:"SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" using a40 by simp
      then have g10:" \<forall>k v. \<not> subStoTp (STMap k v) t'" 
        using copyRec_subT_mustNotBeArray a30 True by simp
      then have g12:"\<not> TypedStoSubpref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" using a1
        by (meson NotRelatedPrnt_imps_notRelatedChild Sto_divergence_imps_notsubloc TypedStoSubpref_hashes TypedStoSubpref.simps(2))
      then have "\<forall>l. \<not> TypedStoSubpref (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" 
        by (metis (full_types) TypedStoSubpref_b a1 hash_suffixes_associative hashesInts nat_neq_iff)
      then show "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using g11 a41 g10 g12
      proof(induction t' arbitrary:destl i)
        case (STArray x1 t')
        then show ?case 
          using NoSubChanged_Scon_Preserved by presburger
      next
        case (STMap x1 t')
        then show ?case by auto
      next
        case (STValue x')
        then show ?case by simp
      qed
    qed

    show ?thesis unfolding SCon.simps
    proof intros
      fix i 
      assume as1:"i<Suc x"
      show "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' " 
      proof(cases "i = x")
        case True
        have "SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) srcMem" using 2(6) by simp
        then have cc1:"SCon t' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'" using g12 Scon_NoChange by simp        
        have cc2:"SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'"  using scSrc by simp
        have cc3:"\<not>TypedStoSubpref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x))  t'" using 2 
          by (metis True TypedStoSubpref_specific_unreachanble_arry as1 TypedStoSubpref.simps(2))
        have cc4:"\<not>TypedStoSubpref (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))  t'" using 2 
          by (metis True TypedStoSubpref_specific_unreachanble_arry as1 TypedStoSubpref.simps(2))
        have cc5:"\<forall>subL. TypedStoSubpref subL (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> \<not> TypedStoSubpref subL (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'"
          using 2 NotRelatedPrnt_imps_notRelatedChild cc3 cc4 by blast
        have cc6:"\<forall>subL. TypedStoSubpref subL (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> \<not> TypedStoSubpref subL  (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'"
          using 2 NotRelatedPrnt_imps_notRelatedChild cc3 cc4 by blast
        then show ?thesis using copyRec_notSub_Scon[OF a30 cc2 cc3 cc4 cc1 cc5 cc6] True by blast
      next
        case False
        then have "i<x" using as1 by simp
        then show ?thesis using a45 by simp
      qed   
    qed
  next
    case False
    then have a9:"\<exists>len t. subStoTp (STArray len t) t' \<and> 0 = len" by simp
    then have "v' = v''" using copyRec_nonZero_Arrays a30 by blast
    moreover have "srcMem = v'" using iter'Copy_nonZero_Arrays[OF a10] a9 by auto
    ultimately show ?thesis using a40 2(6) by simp
  qed
qed

lemma copyrec_same_Scon:
  assumes "SCon t' srcl srcMem"
    and "copyRec srcl srcl t' srcMem = Some v'''"
  shows "SCon t' srcl v'''" using assms
proof (induction t' arbitrary:srcl srcMem v''' )
  case (STArray x1 t')
  have a5:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x1 = Some v'''" 
    using STArray.prems(2) unfolding copyRec.simps by simp
  show ?case using STArray.prems(1)
  proof(induction rule: iter'_ind[OF _ _ a5])
    case (1 v')
    then show ?case by simp
  next
    case (2 x v'')
    then obtain v' where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
      and a20:"(SCon (STArray x t') srcl srcMem  \<longrightarrow> SCon (STArray x t') srcl v')"
      and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
    then have a40:" SCon (STArray x t') srcl v'" using 2 by auto
    have a50:"\<forall>l t. LSubPrefL2 l (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStorage t l srcMem = accessStorage t l v'" using a10 
      using "2.prems" copy_unchanged subSCon by blast    
    then show ?case
    proof(cases "\<forall>len t. subStoTp (STArray len t) t' \<longrightarrow> 0 < len")
      case t2:True
      then have g10:" \<forall>k v. \<not> subStoTp (STMap k v) t'" 
        using copyRec_subT_mustNotBeArray a30 by blast
      then have "SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'" using 2(3) a50
      proof(induction t' arbitrary:srcl  x)
        case (STArray x1 t')
        have " \<forall>i<x1. SCon t' (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'"
        proof(intros)
          fix i 
          assume asi1:"i<x1"
          then show "SCon t' (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" using STArray.IH STArray.prems 
            by (meson LSubPrefL2_def NoSubChanged_Scon_Preserved lessI SCon.simps(2))
        qed
        then show ?case unfolding SCon.simps by blast
      next
        case (STMap x1 t')
        then show ?case by auto
      next
        case (STValue x')
        then show ?case
          by (metis LSubPrefL2_def lessI SCon.simps(1,2))
      qed
      have g11:"\<forall>destl'. \<not> TypedStoSubpref destl' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' \<longrightarrow> (\<forall>t. accessStorage t destl' v' = accessStorage t destl' v'')" 
        using copyRec_unchanged_limit[OF a30] by blast
      have a55:"SCon (STArray x t') srcl v''" unfolding SCon.simps
      proof intros
        fix i assume a1:"i<x"
        then have a41:"SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" using a40 by simp
        then have g12:"\<not> TypedStoSubpref (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" using a1
          by (meson NotRelatedPrnt_imps_notRelatedChild Sto_divergence_imps_notsubloc TypedStoSubpref_hashes TypedStoSubpref.simps(2))
        then have "\<forall>l. \<not> TypedStoSubpref (hash (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t'" 
          by (metis (full_types) TypedStoSubpref_b a1 hash_suffixes_associative hashesInts nat_neq_iff)
        then show "SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" using g11 a41 g10 g12
        proof(induction t' arbitrary:srcl i)
          case (STArray x1 t')
          then show ?case 
            using NoSubChanged_Scon_Preserved by presburger
        next
          case (STMap x1 t')
          then show ?case by auto
        next
          case (STValue x')
          then show ?case by simp
        qed
      qed

      then have a60:"SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v''" 
        using STArray.IH[OF _ a30] 
        by (simp add: \<open>SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v'\<close>)
      show ?thesis unfolding SCon.simps
      proof intros
        fix i assume as1:"i<Suc x"
        show "SCon t' (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''"
        proof(cases "i \<noteq> x")
          case True
          then show ?thesis using a55 as1 by auto
        next
          case False
          then show ?thesis using a60 by simp
        qed
      qed
    next
      case False
      then have a9:"\<exists>len t. subStoTp (STArray len t) t' \<and> 0 = len" by simp
      then have "v' = v''" using copyRec_nonZero_Arrays a30 by blast
      moreover have "srcMem = v'" using iter'Copy_nonZero_Arrays[OF a10] a9 by auto
      ultimately show ?thesis using a40 2(3) by blast
    qed          
  qed
next
  case (STMap x1 t')
  then show ?case 
    by (metis copyRec_nonZero_Arrays copyRec_subT_mustNotBeArray neq0_conv subStoTp.simps(3))
next
  case (STValue x)
  then have " (let e = accessStorage x srcl srcMem in Some (srcMem(srcl $$:= e))) = Some v'''" 
    unfolding copyRec.simps by blast
  then show ?case 
    using STValue(1) using accessStorage_def by fastforce
qed 


lemma copy_same_Scon:
  assumes "iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and "SCon (STArray x t') srcl srcMem" 
  shows "SCon (STArray x t') srcl v'" using assms(2)
proof(induction rule: iter'_ind[OF _ _ assms(1)])
  case (1 v')
  then show ?case by simp
next
  case (2 x v'')
  then obtain v' where a10:"iter' (\<lambda>i. copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t') srcMem x = Some v'"
    and a20:"(SCon (STArray x t') srcl srcMem  \<longrightarrow> SCon (STArray x t') srcl v')"
    and a30:"copyRec (hash srcl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash  srcl  (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t' v' = Some v''" by blast
  then show ?case using copyrec_same_Scon 
    using "2.hyps" "2.prems" copyRec.simps(1) by presburger
qed

lemma cdMemLocsToploc:
  assumes "lessThanTopLocs cd'"
    and "l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc cd'))"
    and "\<exists>dud. (dud, c') = allocate cd'"
    and "toploc c' = toploc c"
    and "\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs cd' = accessStore locs c"
  shows "lessThanTopLocs c" unfolding lessThanTopLocs_def
proof intros
  fix tloc loc
  assume b20:"toploc c \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
  then have "toploc c' \<le> tloc" using assms  by simp
  then have b30:"toploc cd' < tloc" using assms unfolding allocate_def by simp
  then have "ReadL\<^sub>n\<^sub>a\<^sub>t l < tloc" using assms 
    by (simp add: Read_Show_nat'_id)
  then have "l \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
    using Read_Show_nat'_id by auto
  then have "\<not> LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
    by (metis LSubPrefL2_def assms(2) hash_inequality ShowLNatDot hash_int_prefix hash_suffixes_associative)
  then have b40:"\<not> LSubPrefL2 loc l" using b20 assms(2) ShowLNatDot
    by (metis LSubPrefL2_def assms(2) hash_suffixes_associative hashesInts)
  then have "accessStore loc cd' = None" using assms b20 b30 unfolding lessThanTopLocs_def using nat_less_le by auto
  then show "accessStore loc c= None" using assms b40 by auto
next 
  fix loc y 
  assume b20:" accessStore loc c = Some y"
  then show "\<exists>tloc<toploc c. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
  proof(cases "LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc cd'))")
    case True
    have a10:"toploc cd' < toploc c'" using assms unfolding allocate_def updateStore_def by simp
    have "LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc cd'))" using True LSubPrefL2_def by simp
    have "\<forall>l. l\<noteq>(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc cd')) \<longrightarrow>  \<not>(LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc cd')) l)" using ShowLNatDot unfolding LSubPrefL2_def hash_def 
      using subPrefCannotBeInt by auto
    then show ?thesis using True a10 assms 
      using LSubPrefL2_def by auto
  next
    case False
    have a20:"((\<forall>tloc loc. toploc cd' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc cd' = None) 
          \<and> (\<forall>loc y. accessStore loc cd' = Some y \<longrightarrow> (\<exists>tloc<toploc cd'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      using assms lessThanTopLocs_def[of cd']  by blast
    then obtain tloc where  tlocdef:"tloc < toploc cd' \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
      by (metis False assms(2) assms(5) b20)
    moreover have "toploc cd' < toploc c'" using assms unfolding allocate_def updateStore_def by simp
    ultimately show ?thesis using assms lessThanTopLocs_def[of cd'] b20 tlocdef 
      using order.strict_trans by metis
  qed
qed

lemma cpm2mNotSubPrefsOfOriginal:
  assumes "MCon (MTArray x11 x12) m' stl2"
    and "\<forall>l'. l' \<noteq> stl1 \<longrightarrow> \<not> LSubPrefL2 stl1 l'"
    and "\<forall>loc. LSubPrefL2 loc stl1 \<longrightarrow> accessStore loc mem' = None"
    and "\<not> LSubPrefL2 stl2 stl1"
    and "MCon (MTArray x11 x12) mem' stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs stl1 \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<forall>l' \<noteq> stl1. \<not>(LSubPrefL2 stl1 l')"
  shows "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using assms
proof(induction x12 arbitrary:stl2 x11)
  case (MTArray x1 x12)
  have "(\<forall>i<x11. \<exists>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l \<noteq> stl1 \<and> \<not>TypedMemSubPrefPtrs m' x1 x12 l stl1))" 
  proof intros
    fix i 
    assume idef':"i<x11" 
    have d5:"\<forall>i<x11. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' =  accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem'" using MTArray.prems LSubPrefL2_def 
      by (metis Mutual_NonSub_SpecificNonSub)
    then have d10:"\<forall>i<x11. \<exists>l'. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m'  = Some (MPointer l')"  using MTArray.prems
      by (metis MConArrayPointers less_nat_zero_code neq0_conv)

    then obtain l' where idef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m'  = Some (MPointer l')"  using MTArray.prems(1) idef' by fastforce
    then have idef2:" accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l')" using d5 idef' by auto

    have "(case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' of None \<Rightarrow> False 
          | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) m' (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
          | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) m' loc2 | MTValue Types \<Rightarrow> False))" 
      using MCon.simps(2)[of x11 "MTArray x1 x12" m' stl2] MTArray idef idef' by metis
    then have mdcond:"MCon (MTArray x1 x12) m' l'" using idef by simp
    then have "\<forall>i<x1. \<exists>x. accessStore (hash l' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some x" 
      by (metis bot_nat_0.not_eq_extremum less_nat_zero_code mcon_accessStore)
    have "(case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' of None \<Rightarrow> False 
          | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) mem' (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
          | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) mem' loc2 | MTValue Types \<Rightarrow> False))" 
      using MTArray.prems(5) MCon.simps(2)[of x11 "MTArray x1 x12" mem' stl2] idef idef2 idef' by metis
    then have memCond:"MCon (MTArray x1 x12) mem' l'" using idef idef2 by simp
    then have d40:"\<forall>i<x1. \<exists>x. accessStore (hash l' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some x" using idef2 idef 
      by (metis bot_nat_0.not_eq_extremum less_nat_zero_code mcon_accessStore)
    have d90:"hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> stl1" using MTArray.prems using LSubPrefL2_def by auto
    have "l' \<noteq> stl1" 
    proof
      assume e1:"l' = stl1"
      then have "LSubPrefL2 l' stl1" using LSubPrefL2_def by auto
      then have "\<forall>i. LSubPrefL2 (hash l' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stl1" using e1 LSubPrefL2_def by auto
      then have "\<forall>i. accessStore (hash l' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = None" using MTArray.prems(3) by auto
      then show False using d40 
        using \<open>MCon (MTArray x1 x12) mem' l'\<close> by fastforce
    qed
    moreover have "\<not>TypedMemSubPrefPtrs m' x1 x12 l' stl1" using MTArray.IH[of x1 l'] using mdcond MTArray.prems(2,3,6) memCond idef idef2 
      by (metis MCon_imps_Some MTArray.IH LSubPrefL2_def hash_suffixes_associative option.discI)
    ultimately show "\<exists>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> l \<noteq> stl1 \<and> \<not> TypedMemSubPrefPtrs m' x1 x12 l stl1 " 
      by (simp add: idef)
  qed

  then show ?case using TypedMemSubPrefPtrs.simps(2)[of m' x11 x1 x12 stl2 stl1]   
    by (metis Memoryvalue.inject(2)  option.inject)
next
  case (MTValue x)
  then show ?case 
    by (metis LSubPrefL2_def TypedMemSubPrefPtrs.simps(1) hash_inequality)
qed

lemma cpm2mLocationRelatedToTopNotInOrig:
  assumes  " LSubPrefL2 intimLoc l"
    and "\<not> LSubPrefL2 stl2 l"
    and "MCon (MTArray x11 x12) m' stl2"
    and "\<forall>loc. LSubPrefL2 loc stl1 \<longrightarrow> accessStore loc mem' = None"
    and "MCon (MTArray x11 x12) mem' stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs stl1 \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"
    and "stl1 = l"
  shows "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 intimLoc" using assms
proof(induction x12 arbitrary:x11 stl2)
  case (MTArray x1 x12)
  have "(\<forall>i<x11. \<exists>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l \<noteq> intimLoc \<and> \<not>TypedMemSubPrefPtrs m' x1 x12 l intimLoc))" 
  proof intros
    fix i assume d10:"i<x11"
    then obtain l' where idef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l')" using MTArray.prems
      by (metis MConArrayPointers MCon.simps(2))
    then have "l \<noteq> l'" using idef MTArray LSubPrefL2_def  d10
      by (smt (verit, best)  cpm2mNotSubPrefsOfOriginal TypedMemSubPrefPtrs.simps(2))
    moreover have "MCon (MTArray x1 x12) mem' l'" using MTArray.prems idef d10
      by (metis CompTypeRemainsMCon   Mutual_NonSub_SpecificNonSub CompMemType.simps(2))
    moreover have " MCon (MTArray x1 x12) m' l'" using MTArray.prems idef d10
      by (metis CompTypeRemainsMCon CompMemType.simps(2))
    moreover have "\<not> LSubPrefL2 l' l" using calculation MTArray.prems idef LSubPrefL2_def 
      by (metis MCon_imps_Some  hash_suffixes_associative option.distinct(1))
    ultimately have "\<not>TypedMemSubPrefPtrs m' x1 x12 l' intimLoc" using MTArray.IH[of l' x1] MTArray.prems idef by blast
    then show "\<exists>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> l \<noteq> intimLoc \<and> \<not> TypedMemSubPrefPtrs m' x1 x12 l intimLoc" using d10 idef 
      using MTArray.prems(1) \<open>\<not> LSubPrefL2 l' l\<close> by auto
  qed
  then show ?case using TypedMemSubPrefPtrs.simps(2)[of m' x11 x1 x12 stl2 intimLoc] by auto

next
  case (MTValue x)
  then have "(\<forall>i<x11. hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> intimLoc)" using LSubPrefL2_def  
    using Mutual_NonSub_SpecificNonSub by blast
  then show ?case using TypedMemSubPrefPtrs.simps(1)[of m' x11 x stl2 intimLoc] by blast
qed



lemma cpm2mNotSubPrefsOfChanged:
  assumes "MCon (MTArray x t) m' stl1"
    and "\<not> LSubPrefL2 stl2 stl1"
    and "\<forall>la l'. TypedMemSubPref la stl1 (MTArray x t) \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la"
    and "0 < x"
  shows "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using assms
proof(induction t arbitrary:stl1 x)
  case (MTArray x1 t)
  then have d10:"\<forall>i<x. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" using TypedMemSubPref.simps(2) 
    by (metis MConArrayPointers)

  have "(\<forall>i<x. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> \<not>(l = stl2 \<or> hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = stl2 \<or> TypedMemSubPrefPtrs m' x1 t l stl2))" 
  proof intros
    fix i
    assume idef:"i<x"
    then have ac:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" using d10 by simp
    have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> stl2" using MTArray LSubPrefL2_def by blast
    have mcond:"(case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) m' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) m' loc2 | MTValue Types \<Rightarrow> False)) \<and>
                ((\<exists>p. accessStore stl1 m' = Some (MPointer p)) \<or> accessStore stl1 m' = None)" 
      using MCon.simps(2)[of x "(MTArray x1 t)" m' stl1] MTArray.prems(1) idef by simp
    have " \<forall>la l'. TypedMemSubPref la (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTArray x1 t) \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" 
      using MTArray.prems(3) idef moreSpecificTypedSubPref by blast
    moreover have "MCon (MTArray x1 t) m' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTArray.prems(1) ac mcond by force
    moreover have "\<not> LSubPrefL2 stl2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTArray.prems(2) LSubPrefL2_def Not_Sub_More_Specific by auto
    ultimately have "\<not>TypedMemSubPrefPtrs m' x1 t (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stl2" using MTArray.IH[of x1 "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))"] idef ac by fastforce
    then show "\<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> \<not> (l = stl2 \<or> hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = stl2 \<or> TypedMemSubPrefPtrs m' x1 t l stl2) " using ac  
      using \<open>hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> stl2\<close> by auto
  qed
  then show ?case using TypedMemSubPrefPtrs.simps(2)[of m' x x1 t stl1 stl2] by auto
next
  case (MTValue x')
  then show ?case 
    using LSubPrefL2_def by (metis TypedMemSubPrefPtrs.simps(1))
qed

lemma cps2mNotSubPrefsOfChanged:
  assumes "MCon (MTArray x t) m' stl1"
    and "\<not> LSubPrefL2 stl2 stl1"
    and "\<forall>la l'. TypedStoSubPref la stl1 (STArray x' t') \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la"
    and "0 < x"
    and "cps2mTypeCompatible (STArray x' t') (MTArray x t)"
  shows "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using assms
proof(induction t' arbitrary:stl1 x x' t)
  case (STArray x1 t')
  then have a1:"(0 < x \<and> x' = x \<and> cps2mTypeCompatible (STArray x1 t') t)" 
    using cps2mTypeCompatible.simps(2)[of x' "STArray x1 t'" x t] by blast
  then obtain t'' where tdef:"t = MTArray x1 t''" using cps2mTypeCompatible.simps by (cases t; auto)
  then have d10:"\<forall>i<x. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" 
    using STArray(4) TypedStoSubPref.simps(2)[of _ stl1 x' "STArray x1 t'" ] STArray(2) MConArrayPointers[of x x1 t''] a1 by metis

  have "(\<forall>i<x. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> \<not>(l = stl2 \<or> hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = stl2 \<or> TypedMemSubPrefPtrs m' x1 t'' l stl2))" 
  proof intros
    fix i
    assume idef:"i<x"
    then have ac:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" using d10 by simp
    have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> stl2" using STArray LSubPrefL2_def by blast
    have mcond:"\<forall>i<x. (case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' of None \<Rightarrow> False
                 | Some (MValue val) \<Rightarrow> (case MTArray x1 t'' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t'') m' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t'' of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t'') m' loc2 | MTValue Types \<Rightarrow> False)) \<and>
                ((\<exists>p. accessStore stl1 m' = Some (MPointer p)) \<or> accessStore stl1 m' = None)" 
      using MCon.simps(2)[of x "(MTArray x1 t'')" m' stl1] STArray.prems(1) idef tdef a1 by auto
    have " \<forall>la l'. TypedStoSubPref la (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (STArray x1 t') \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" 
      using STArray.prems(3) idef stoMoreSpecificTypedSubPref a1 by blast
    moreover have "MCon (MTArray x1 t'') m' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using STArray.prems(1) ac mcond a1 tdef  
      using CompTypeRemainsMCon idef CompMemType.simps(2) by blast
    moreover have "\<not> LSubPrefL2 stl2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using STArray.prems(2) LSubPrefL2_def Not_Sub_More_Specific by auto
    ultimately have "\<not>TypedMemSubPrefPtrs m' x1 t'' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) stl2" using STArray.IH[of x1 t'' "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i))"x1] idef ac a1 tdef by fastforce
    then show "\<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) 
              \<and> \<not> (l = stl2 \<or> hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = stl2 \<or> TypedMemSubPrefPtrs m' x1 t'' l stl2) " 
      using ac \<open>hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> stl2\<close> tdef by simp
  qed
  then show ?case using TypedMemSubPrefPtrs.simps(2)[of m' x x1 t'' stl1 stl2] using tdef by auto
next
  case (STMap x1 t')
  then show ?case by simp
next
  case (STValue x)
  then show ?case
    using LSubPrefL2_def TypedMemSubPrefPtrs.simps(1) 
    by (metis cps2mTypeCompatible.simps(2) cps2mTypeCompatible.simps(6) mcon_accessStore)
qed


lemma TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2:
  assumes "MCon (MTArray x t) m' stl1"
    and "\<forall>la l'. TypedMemSubPref la stl1 (MTArray x t) \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la"
    and "0 < x"
  shows "\<forall>locs. TypedMemSubPrefPtrs m' x t stl1 locs \<longrightarrow> LSubPrefL2 locs stl1"
  using assms
proof(induction t arbitrary:stl1 x)
  case (MTArray x1 t)
  then show ?case 
    by (meson cpm2mNotSubPrefsOfChanged)
next
  case (MTValue x')
  then show ?case 
    using cpm2mNotSubPrefsOfChanged by blast
qed

lemma cpm2mTPrefOld_imps_TPref:
  assumes "TypedMemSubPrefPtrs mem' len x stl1 stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<not> LSubPrefL2 stl1 l"
    and "\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None"
    and "MCon (MTArray len x) mem' stl1"
  shows "TypedMemSubPrefPtrs m' len x stl1 stl2" using assms 
proof(induction x arbitrary:stl1 len)
  case (MTArray x1 tp1)

  have c10:"(\<exists>i<len. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l) \<and> (l = stl2  \<or> TypedMemSubPrefPtrs mem' x1 tp1 l stl2))" 
    using MTArray(2) TypedMemSubPrefPtrs.simps(2)[of mem' len x1 tp1 stl1 stl2]  by auto
  then obtain i l' where idef:"i<len \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l') \<and> (l' = stl2  \<or> TypedMemSubPrefPtrs mem' x1 tp1 l' stl2)" by auto
  then obtain l''  where l''def:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l'')" using  MTArray(2,6) c10 MConArrayPointers by blast
  then have c20:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l'')" using MTArray(3, 4) LSubPrefL2_def c10 
    by (metis MTArray(5) not_None_eq)
  have "\<forall>i<len.
             (case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTArray x1 tp1 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 tp1) mem' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 tp1 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 tp1) mem' loc2 | MTValue Types \<Rightarrow> False))" 
    using MTArray(6) MCon.simps(2)[of len "(MTArray x1 tp1)" mem' stl1] by auto
  then have mcond:"MCon (MTArray x1 tp1) mem' l'" using idef by fastforce

  have "\<not> LSubPrefL2 l' l" 
    by (metis MCon_imps_Some LSubPrefL2_def assms(4) hash_suffixes_associative mcond option.distinct(1))
  then have imps:"TypedMemSubPrefPtrs mem' x1 tp1 l' stl2 \<longrightarrow> TypedMemSubPrefPtrs m' x1 tp1 l' stl2" 
    using MTArray(1)[of x1 l'] MTArray(3,5) mcond by auto

  have "(l' = stl2 \<or> TypedMemSubPrefPtrs mem' x1 tp1 l' stl2)" using c10 idef l''def mcond by auto
  then show ?case using imps 
    using c20 idef l''def 
    using MTArray.prems(1) by auto
next
  case (MTValue x)
  then show ?case using TypedMemSubPrefPtrs.simps(1) by auto
qed


lemma cpm2mCompMemTypeOld_imps_CompMemType:
  assumes " CompMemType mem' len x tp2 stl1 stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<not> LSubPrefL2 stl1 l"
    and "\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None"
    and "MCon (MTArray len x) mem' stl1"
  shows " CompMemType m' len x tp2 stl1 stl2" using assms 
proof(induction x arbitrary:stl1 len)
  case (MTArray x1 tp1)
  have c10:"(\<exists>i<len. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l) 
            \<and> ((l = stl2) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType mem' x1 tp1 tp2 l stl2))" 
    using MTArray(2) CompMemType.simps(2)[of mem' len x1 tp1 tp2 stl1 stl2] using hash_inequality by auto
  then obtain i l' where idef:"i<len \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l') \<and> ((l' = stl2 ) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType mem' x1 tp1 tp2 l' stl2)" 
    using c10 by auto
  then have c20:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l')" using MTArray(3, 4) LSubPrefL2_def  
    by (metis MTArray(3,5) not_None_eq)
  have "\<forall>i<len.
           (case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' of None \<Rightarrow> False 
            | Some (MValue val) \<Rightarrow> (case MTArray x1 tp1 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 tp1) mem' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
            | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 tp1 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 tp1) mem' loc2 | MTValue Types \<Rightarrow> False)) \<and>
           ((\<exists>p. accessStore stl1 mem' = Some (MPointer p)) \<or> accessStore stl1 mem' = None)" 
    using MTArray(6) MCon.simps(2)[of len  "(MTArray x1 tp1)" mem' stl1] by auto
  then have mcond:"MCon (MTArray x1 tp1) mem' l'" using MTArray(6) using idef c10
    by (metis (no_types, lifting) MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
  have "\<not> LSubPrefL2 l' l" 
    by (metis MCon_imps_Some LSubPrefL2_def assms(4) Not_Sub_More_Specific mcond not_None_eq)
  then have "CompMemType mem' x1 tp1 tp2 l' stl2 \<longrightarrow> CompMemType m' x1 tp1 tp2 l' stl2" 
    using MTArray(1)[of x1 l'] MTArray(3,5) mcond  by auto

  moreover have "((l' = stl2) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType mem' x1 tp1 tp2 l' stl2)" using c10 idef  by simp
  ultimately have "(l' = stl2) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType m' x1 tp1 tp2 l' stl2" using MTArray(1) MTArray(3,5) mcond by auto

  then show ?case using idef c10 c20 
    using MTArray.prems(1) by auto
next
  case (MTValue x)
  then show ?case using TypedMemSubPrefPtrs.simps(1) by auto
qed

lemma inv_cpm2mCompMemTypeOld_imps_CompMemType:
  assumes "\<not>CompMemType mem' len x tp2 stl1 stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<not> LSubPrefL2 stl1 l"
    and "\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None"
    and "MCon (MTArray len x) mem' stl1"
  shows "\<not>CompMemType m' len x tp2 stl1 stl2" using assms 
proof(induction x arbitrary:stl1 len)
  case (MTArray x1 tp1)
  show ?case
  proof
    assume *:"CompMemType m' len (MTArray x1 tp1) tp2 stl1 stl2"
    then have c10:"(\<exists>i<len. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> ((l = stl2) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType m' x1 tp1 tp2 l stl2))" 
      using MTArray(2) CompMemType.simps(2)[of mem' len x1 tp1 tp2 stl1 stl2] using hash_inequality by auto
    then obtain i l' where idef:"i<len \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l') \<and> ((l' = stl2 ) \<and> MTArray x1 tp1 = tp2 \<or> CompMemType m' x1 tp1 tp2 l' stl2)" 
      using c10 by auto
    then have c20:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l')" 
      using MTArray(3, 4) LSubPrefL2_def by (metis)
    have a20:"(\<forall>i<len. \<not>(\<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l) \<and> (l = stl2 \<and> MTArray x1 tp1 = tp2 \<or> CompMemType mem' x1 tp1 tp2 l stl2)))" 
      using MTArray(2) * CompMemType.simps(2)[of mem' len x1 tp1 tp2 stl1 stl2] by auto
    have c25:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l')" using MTArray LSubPrefL2_def idef 
      by (metis MConArrayPointers dual_order.strict_trans neq0_conv option.discI)
    have "\<forall>i<len.
           (case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' of None \<Rightarrow> False 
            | Some (MValue val) \<Rightarrow> (case MTArray x1 tp1 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 tp1) mem' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
            | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 tp1 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 tp1) mem' loc2 | MTValue Types \<Rightarrow> False)) \<and>
           ((\<exists>p. accessStore stl1 mem' = Some (MPointer p)) \<or> accessStore stl1 mem' = None)" using  MTArray(6) MCon.simps(2)[of len  "(MTArray x1 tp1)" mem' stl1] by auto
    then have mcond:"MCon (MTArray x1 tp1) mem' l'" using MTArray(6) using idef c10 
      by (metis CompTypeRemainsMCon c25 CompMemType.simps(2))
    moreover have "\<not> LSubPrefL2 l' l" 
      by (metis MCon_imps_Some LSubPrefL2_def assms(4) Not_Sub_More_Specific mcond not_None_eq)
    ultimately show False using MTArray 
      using a20 c25 idef by presburger
  qed
next
  case (MTValue x)
  then show ?case by auto
qed


lemma inv_cpm2mTPrefOld_imps_TPref:
  assumes "\<not>TypedMemSubPrefPtrs mem' len x stl1 stl2"
    and "\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'"
    and "\<not> LSubPrefL2 stl1 l"
    and "\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None"
    and "MCon (MTArray len x) mem' stl1"
  shows "\<not>TypedMemSubPrefPtrs m' len x stl1 stl2" using assms 
proof(induction x arbitrary:stl1 len)
  case (MTArray x1 tp1)
  show ?case 
  proof
    assume *:"TypedMemSubPrefPtrs m' len (MTArray x1 tp1) stl1 stl2"
    then have a10:"(\<exists>i<len. \<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l = stl2  \<or> TypedMemSubPrefPtrs m' x1 tp1 l stl2))" 
      using TypedMemSubPrefPtrs.simps(2)[of m' len  x1 tp1 stl1 stl2] by blast
    have a20:"(\<forall>i<len. \<not>(\<exists>l. accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l) \<and> (l = stl2 \<or> TypedMemSubPrefPtrs mem' x1 tp1 l stl2)))" using MTArray(2) * by auto

    then obtain i l' where idef:"i<len \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l') \<and> (l' = stl2  \<or> TypedMemSubPrefPtrs m' x1 tp1 l' stl2)" using a10 by auto
    then have c20:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer l')" using MTArray(3, 4) LSubPrefL2_def    
      by (metis MConArrayPointers MTArray.prems(5) a10 assms(4) gr_zeroI less_nat_zero_code option.discI)

    have "\<forall>i<len.
             (case accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTArray x1 tp1 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 tp1) mem' (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 tp1 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 tp1) mem' loc2 | MTValue Types \<Rightarrow> False))"
      using  MTArray(6) MCon.simps(2)[of len  "MTArray x1 tp1" mem' stl1] by auto
    then have c30:"MCon (MTArray x1 tp1) mem' l'" using MTArray(6) using idef  c20    
      by (metis (no_types, lifting) MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
    moreover have "\<not> LSubPrefL2 l' l" using MTArray(4,5) c20 idef  c30 
      by (metis MCon_imps_Some LSubPrefL2_def Not_Sub_More_Specific not_None_eq)
    ultimately show False using MTArray 
      using a20 c20 idef by auto
  qed
next
  case (MTValue x)
  then show ?case by simp
qed


lemma SameLocsSameTypescpm2m:
  assumes "tp2 = (MTArray x t)"
    and "
                     (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl1 \<and> tp'' = tp1 \<or>
                     (\<exists>len arr. p' \<noteq> stl1 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp1 p' stl1))"
    and "(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                            \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                             (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))"
    and "(if p' = p'' then tp'' = tp'''
                     else (case tp'' of
                        MTArray len arr \<Rightarrow>
                          (case tp''' of
                          MTArray len2 arr2 \<Rightarrow>
                            (if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                            else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                            else if TypedMemSubPrefPtrs (memory st) len arr p' stl1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' stl1
                                then \<exists>dt.
                                        CompMemType (memory st) len2 arr2 dt p'' stl1 \<and>
                                        CompMemType (memory st) len arr dt  p' stl1 
                            else True)
                          | MTValue val2 \<Rightarrow> (if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True))
                        | MTValue val \<Rightarrow>
                            (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                           | MTValue val2 \<Rightarrow> True)))"
    and "MCon tp''' (memory st) p''"
    and "MCon tp'' (memory st) p'"
  shows "tp1 = (MTArray x t)" 
proof(cases "p' = p''")
  case t4:True
  then have d10: "tp'' = tp'''" using assms by simp
  then show ?thesis 
  proof(cases "p' = stl1")
    case True
    then have "tp'' = tp1" using assms by auto
    moreover have "tp''' = MTArray x t" using assms t4 True by auto
    ultimately show ?thesis using d10 assms by auto
  next
    case False
    then have "\<exists>len arr. tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp1 p' stl1" using assms by simp
    then obtain len arr where p''def:" tp'' = MTArray len arr" by blast
    have d20:"CompMemType (memory st) len arr tp1 p' stl1" using p''def assms False by auto
    have d30:"CompMemType (memory st) len arr (MTArray x t) p' stl1" using p''def assms False d10 t4 by auto
    then show ?thesis using d20 CompMemTypeSameLocsSameType d30 assms 
      using p''def assms by blast
  qed
next
  case False
  then show ?thesis 
  proof(cases "tp''")
    case (MTArray x11 x12)
    then show ?thesis 
    proof(cases tp''')
      case mta:(MTArray x11' x12')
      then have d20:" if TypedMemSubPrefPtrs (memory st) x11' x12' p'' p' then CompMemType (memory st) x11' x12' (MTArray x11 x12) p'' p'
                  else if TypedMemSubPrefPtrs (memory st) x11 x12 p' p'' then CompMemType (memory st) x11 x12 (MTArray x11' x12') p' p'' 
                  else True" using assms   MTArray False by simp
      then show ?thesis 
      proof(cases "TypedMemSubPrefPtrs (memory st) x11' x12' p'' p'")
        case t6:True
        then have d30:"CompMemType (memory st) x11' x12' (MTArray x11 x12) p'' p'" using d20 by simp
        then show ?thesis
        proof(cases "stl1 = p'")
          case True
          then have "tp'' = tp1" using assms by simp
          then show ?thesis using assms  d30 
            by (metis CompMemTypeSameLocsSameType False MTArray MTypes.inject(1) True mta )
        next
          case f7:False
          then show ?thesis 
          proof(cases "stl1 = p''")
            case True
            then have "tp''' =  MTArray x t" using assms by simp
            then show ?thesis using assms  d30 True mta   
              by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc CompTypeRemainsMCon MConSubTypes MTArray CompMemJustType.simps(2))
          next
            case False
            then have "CompMemType (memory st) x11 x12 tp1 p' stl1" using assms  using f7 MTArray by simp
            then have "CompMemType (memory st) x11' x12' tp1 p'' stl1" using compMemTypes_trns[of "memory st" x11 x12 tp1 p' stl1 x11' x12' p''] d30 by auto
            moreover have "CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1" using False mta assms by simp
            ultimately show ?thesis using CompMemTypeSameLocsSameType  
              using mta assms  by blast
          qed
        qed
      next
        case f6:False
        then show ?thesis 
        proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 p' p''")
          case t7:True
          then have d30:"CompMemType (memory st) x11 x12 (MTArray x11' x12') p' p''" using d20 f6 by simp
          then show ?thesis
          proof(cases "stl1 = p'")
            case True
            then have "tp'' = tp1" using assms  by simp
            then show ?thesis using assms   t7 f6 
              using CompMemType_imps_TypedMemSubPrefPtrs False True mta by force 
          next
            case f7:False
            then show ?thesis 
            proof(cases "stl1 = p''")
              case True
              then have "tp''' =  MTArray x t" using assms by simp
              then show ?thesis using assms  d30 True mta    
                using CompMemTypeSameLocsSameType MTArray f7  by blast
            next
              case False
              then have "CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1" 
                using assms  f7 MTArray mta by auto
              then have "CompMemType (memory st) x11 x12 (MTArray x t) p' stl1" 
                using compMemTypes_trns[of "memory st" x11' x12' "(MTArray x t)" p'' stl1 x11 x12 p'] d30 by simp
              then show ?thesis using CompMemTypeSameLocsSameType  
                using mta assms  
                using MTArray f7   by blast
            qed
          qed
        next
          case f8:False
          then show ?thesis
          proof(cases "stl1 = p''")
            case True
            then have "tp''' =  MTArray x t" using assms by simp
            then show ?thesis using assms  True mta   
              using CompMemTypeSameLocsSameType MTArray f8  
              by (metis CompMemType_imps_TypedMemSubPrefPtrs False MTypes.inject(1))
          next
            case f9:False
            then show ?thesis 
            proof(cases "stl1 = p'")
              case True
              then show ?thesis using assms  True mta   
                using CompMemTypeSameLocsSameType MTArray f8   f9 
                by (metis CompMemType_imps_TypedMemSubPrefPtrs MTypes.inject(1) f6)
            next
              case f10:False
              then have e10:"\<exists>dt.
                        CompMemType (memory st) x11' x12' dt p'' stl1 \<and>
                        CompMemType (memory st) x11 x12 dt p' stl1 
                       
                        " 
                using     CompMemType_imps_TypedMemSubPrefPtrs False MTArray f6 mta f8  assms by fastforce

              then show ?thesis  using CompMemTypeSameLocsSameType CompTypeRemainsMCon mta assms 
                by (metis MTArray MTypes.inject(1) f10 f9)

            qed
          qed
        qed
      qed
    next
      case (MTValue x2)
      then have "if TypedMemSubPrefPtrs (memory st) x11 x12 p' p'' then CompMemType (memory st) x11 x12 (MTValue x2) p' p'' else True" using assms MTArray MTValue False by simp
      then show ?thesis using assms  MTValue False by simp
    qed
  next
    case (MTValue x2)
    then show ?thesis 
    proof(cases tp''')
      case (MTArray x11 x12)
      then have "if TypedMemSubPrefPtrs (memory st) x11 x12 p'' p' then CompMemType (memory st) x11 x12 (MTValue x2) p'' p' else True" using assms MTValue False by auto
      then show ?thesis using assms  MTValue False 
        by (metis CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs MTArray MTypes.distinct(1) MTypes.inject(1) )
    next
      case mtv:(MTValue x2')
      then show ?thesis using assms  MTValue False by blast
    qed
  qed
qed

lemma cpm2mCompMemType:
  assumes "    CompMemType v' x11 x12 (MTValue x2) ll x3"
    and "\<forall>pos. \<not> LSubPrefL2 (hash ll pos) destl"
    and "\<forall>l l'. TypedMemSubPref l ll (MTArray x11 x12) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l"
    and "(\<forall>destl'. \<not> LSubPrefL2 destl' destl \<longrightarrow> accessStore destl' v' = accessStore destl' v'')"
  shows "(CompMemType v'' x11 x12 (MTValue x2) ll x3)" using assms(1,2,3)
proof(induction x12 arbitrary:ll x11)
  case (MTArray x1 x12)
  obtain iii lll where d10:"iii<x11 \<and> accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iii)) v' = Some (MPointer lll) \<and>  CompMemType v' x1 x12 (MTValue x2) lll x3" 
    using CompMemType.simps(2)[of v' x11 x1 x12 "MTValue x2" ll x3] MTArray(2) by blast
  then have d20:"accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iii)) v' = accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iii)) v''" using MTArray.prems assms(4) by blast
  have d30:"(hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iii)) = lll" using d10 MTArray.prems(3) 
    using TypedMemSubPref.simps(2) by blast
  then have d40:"\<forall>pos. \<not> LSubPrefL2 (hash lll pos) destl" 
    using MTArray.prems(2) hash_suffixes_associative by auto
  have d50:"\<forall>l l'. TypedMemSubPref l lll (MTArray x1 x12) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l" using d30 MTArray.prems 
    using d10 moreSpecificTypedSubPref by blast
  then have "(CompMemType v'' x1 x12 (MTValue x2) lll x3)" using MTArray.IH[of x1 lll] d10 d40 by blast
  then show ?case using CompMemType.simps(2)[of v'' x11 x1 x12 "MTValue x2" ll x3] d10 d20 by auto
next
  case (MTValue x')
  then show ?case  
    by (metis CompMemType.simps(1))
qed

lemma selfPoint_imps_TypedMemSubPref:
  assumes "\<forall>l l'. TypedMemSubPref l ld (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l"
    and "TypedMemSubPrefPtrs v' x t ld x3"
  shows "TypedMemSubPref x3 ld (MTArray x t)" using assms(1,2)
proof(induction t arbitrary:ld x)
  case (MTArray x1 t)
  then have "\<exists>i<x. \<exists>l. accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MPointer l) \<and> (l = x3 \<or> TypedMemSubPrefPtrs v' x1 t l x3)" 
    using TypedMemSubPrefPtrs.simps(2)[of v' x x1 t ld x3] by blast
  then obtain i l where idef:"i<x \<and> accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MPointer l) \<and> (l = x3 \<or> TypedMemSubPrefPtrs v' x1 t l x3)" by blast
  then have ldef:"l =  (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTArray(2) 
    by (metis TypedMemSubPref.simps(2))
  then show ?case
  proof(cases "x3 = l")
    case True
    then show ?thesis using ldef idef by auto
  next
    case False
    have "\<forall>la l'. TypedMemSubPref la l (MTArray x1 t) \<and> accessStore la v' = Some (MPointer l') \<longrightarrow> l' = la" using ldef idef MTArray.prems(1) 
      using moreSpecificTypedSubPref by blast
    then have "(TypedMemSubPref x3 l (MTArray x1 t))" using MTArray.IH[of l x1] idef False by blast
    then show ?thesis  using TypedMemSubPref.simps(2)[of x3 ld x "MTArray x1 t"] using ldef idef by blast
  qed
next
  case (MTValue x)
  then show ?case by auto
qed

definition ncpElementsNoSubPref::"MemoryT \<Rightarrow> MemoryT \<Rightarrow> bool"
  where "ncpElementsNoSubPref lmO lmD = (\<forall>i l1 t1 l2 t2 loc i2 loc2. toploc lmO > i 
                                              \<and> toploc lmO \<le> i2   
                                              \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) 
                                              \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)
                                              \<and> MCon (MTArray l1 t1) lmO loc \<longrightarrow>
                                      \<not>TypedMemSubPrefPtrs lmD l2 t2 loc2 loc 
                                              \<and> \<not>TypedMemSubPrefPtrs lmD l1 t1 loc loc2)"

definition ncpOMemInDMem::"MemoryT \<Rightarrow> MemoryT \<Rightarrow> bool"
  where "ncpOMemInDMem lmO lmD = (\<forall>i loc. i < toploc lmO \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc lmO = accessStore loc lmD)"

(*
  Every item that exists in lev0 [The env added to] which is less than the top location of the 
  original memory [mem] must have existed in the original environment [lev] and stack [lk] 
*)
definition ncpDenvalueLimit::"Environment \<Rightarrow> Environment \<Rightarrow> Stack \<Rightarrow> Stack \<Rightarrow> MemoryT \<Rightarrow> bool "
  where "ncpDenvalueLimit lev0 lev lk lst mem = (\<forall>tp' locs p i. (Memory tp', Stackloc locs) |\<in>| fmran (denvalue lev0)   
                                            \<and> accessStore locs lk = Some (KMemptr p) \<and> i < toploc mem \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i)\<longrightarrow>
                                              (\<exists>tp'' loc2 p'.( (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue lev) 
                                                                  \<and> accessStore loc2 lst = Some (KMemptr p') \<and>
                                                     ((p' = p \<and> tp'' = tp' ) \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len  arr \<and> CompMemType mem len arr tp' p' p))))

                     )"

definition ncpNewSelfPoint::"MemoryT \<Rightarrow> MemoryT \<Rightarrow> bool"
  where "ncpNewSelfPoint lmO lmD = (\<forall>i loc loc2. toploc lmD > i 
                                              \<and> toploc lmO \<le> i  
                                              \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) 
                                              \<and> accessStore loc lmD = Some (MPointer loc2)
                                             \<longrightarrow> loc = loc2
                                      )"

lemma ncpElementsNoSubPref_sameMem:
  assumes "TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd"
  shows "ncpElementsNoSubPref (memory st) (memory st)" unfolding ncpElementsNoSubPref_def
proof intros
  fix i l1 t1 l2 t2 loc i2 loc2
  assume f1:" i < toploc (memory st) \<and> toploc (memory st) \<le> i2 
             \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc"
  then have stringdif:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t i2)" 
    by (metis Read_Show_nat'_id linorder_not_less)
  then have notHash1:"\<forall>lll. hash loc lll \<noteq> loc2" using f1 
    by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative)
  have notHash2:"\<forall>lll. hash loc2 lll \<noteq> loc" using f1 stringdif         
    by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative)

  have "\<not> TypedMemSubPrefPtrs (memory st) l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs (memory st) l1 t1 loc loc2" 
  proof -
    have " TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd" using assms by simp
    then have limits:"((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
               (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      unfolding TypeSafe_def  lessThanTopLocs_def by blast
    show "\<not> TypedMemSubPrefPtrs (memory st) l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs (memory st) l1 t1 loc loc2"
    proof 
      show "\<not> TypedMemSubPrefPtrs (memory st) l2 t2 loc2 loc"
      proof
        assume f2:"TypedMemSubPrefPtrs (memory st) l2 t2 loc2 loc"
        then show False 
        proof(cases t2)
          case (MTArray x11 x12)
          then obtain i' l where "(i'<l2 \<and>  accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some (MPointer l) 
                                \<and> (l = loc \<or> TypedMemSubPrefPtrs (memory st) x11 x12 l loc))" 
            using TypedMemSubPrefPtrs.simps(2)[of "memory st" l2 x11 x12 loc2 loc] f2 by blast
          then show ?thesis using f1  limits 
            by (metis LSubPrefL2_def hash_suffixes_associative not_Some_eq)
        next
          case (MTValue x2)
          then have "(\<exists>i<l2. hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc)" using TypedMemSubPrefPtrs.simps(1)[of "memory st" l2 x2 loc2 loc] f2 by auto
          then show ?thesis using notHash2 by simp
        qed

      qed
    next 
      show "\<not> TypedMemSubPrefPtrs (memory st) l1 t1 loc loc2 "
      proof
        assume f2:"TypedMemSubPrefPtrs (memory st) l1 t1 loc loc2"
        then show False using f1 notHash1 
        proof(induction t1 arbitrary:loc l1 i)
          case (MTArray x11 x12)
          then obtain i' l where  i'def:"(i'<l1 \<and> accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some (MPointer l) 
                                      \<and> (l = loc2 \<or> TypedMemSubPrefPtrs (memory st) x11 x12 l loc2))" 
            using TypedMemSubPrefPtrs.simps(2)[of "memory st" l1 x11 x12 loc loc2] f2 by blast
          then show ?thesis
          proof(cases "l = loc2")
            case True
            then have "MCon (MTArray l1  (MTArray x11 x12)) (memory st) loc" using MTArray by blast
            then have " MCon  (MTArray x11 x12) (memory st) loc2 " using MCon.simps(2)[of l1 t1 "memory st" loc] i'def MTArray 
              using CompTypeRemainsMCon True CompMemType.simps(2) by blast
            then have "\<exists>x i. accessStore l (memory st) = Some x \<or> accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" 
              using i'def MCon_imps_Some[of " (MTArray x11 x12)" "memory st" loc2] True by simp
            then show ?thesis using limits True f1 
              by (metis LSubPrefL2_def Not_Sub_More_Specific not_Some_eq)
          next
            case False
            then have "MCon (MTArray l1  (MTArray x11 x12)) (memory st) loc" using MTArray by blast
            then have " MCon  (MTArray x11 x12) (memory st) l " using MCon.simps(2)[of l1 t1 "memory st" l] i'def MTArray 
              using CompTypeRemainsMCon False CompMemType.simps(2) by blast
            then obtain i'' where i''def: "\<exists>x. accessStore l (memory st) = Some x \<or> accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some x" 
              using i'def MCon_imps_Some[of " (MTArray x11 x12)" "memory st" l] False by blast
            then obtain newLoc where nlocdef:"newLoc < toploc (memory st) \<and> LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t newLoc) 
                                              \<or> LSubPrefL2 (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t newLoc)" 
              using limits by blast
            then have "TypedMemSubPrefPtrs (memory st) x11 x12 l loc2" using i'def False by simp
            then show ?thesis using MTArray.IH[of x11 l newLoc] MTArray i'def nlocdef 
              by (metis MemLSubPrefL2_specific_imps_general \<open>MCon (MTArray x11 x12) (memory st) l\<close> i''def 
                  lessThanSome_imps_Locs2 lessThanTopLocs_def limits linorder_not_less option.discI)
          qed
        next
          case (MTValue x2)
          then have "(\<exists>i<l1. hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc2)" using TypedMemSubPrefPtrs.simps(1)[of "memory st" l2 x2 loc loc2] f2 by auto
          then show ?thesis using MTValue by simp
        qed
      qed
    qed
  qed
  moreover show "\<not> TypedMemSubPrefPtrs (memory st) l2 t2 loc2 loc" using calculation by blast
  ultimately show "\<not> TypedMemSubPrefPtrs (memory st) l1 t1 loc loc2" by blast
qed


lemma oneValueoneArray:
  assumes "(k',e) =  astack ip (Memory (MTArray x t)) (KMemptr p) (sck', ev')"

and "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
         accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
and "(denvalue e) $$ ip = Some  ((Memory (MTArray x t)),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))"
and "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev')"
and "accessStore l1 sck' = accessStore l1 k'"
and "(\<forall>tp' locs p i.
        (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev') \<and> accessStore locs sck' = Some (KMemptr p) \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
        (\<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))))"
and "(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  (MTArray x t) \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x t) p' p)))"
and "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
and "tp1 = MTValue x''"
and "MTArray x11' x12' = tp2"
and "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip"
and "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1"
and "stl1 \<noteq> stl2"
and "TypeSafe ev' (accounts st) sck' m' (storage st) cd'"
and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m'  \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m'"
and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
and "\<exists>tloc<toploc (memory st). LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
and "\<exists> tloc. tloc <toploc m' \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
and "MCon (MTArray x t) (memory st) p"
shows "CompMemType m' x11' x12' tp1 stl2 stl1"  (*NEED TO UPDATE TO REFLECT THE CHANGE TO THE FIRST ASSUMPTION*)
proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
  case t2:True
  have a1:"k' = push (KMemptr p) sck'" using assms(1) unfolding astack.simps by simp 
  then have b40:"stl2 = p" using t2 assms(2) unfolding push_def accessStore_def updateStore_def allocate_def by simp
  then have b45:"tp2 = (MTArray x t)"  using assms(11,1) t2  
    by (metis Type.inject(3) assms(2) assms(3) fmranE option.inject prod.inject)
  then have b50:"MCon (MTArray x11' x12') (memory st) stl2" using b40 assms by blast
  obtain tloc1 where tloc2def:" tloc1 <toploc m' \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" using assms by blast
  obtain tloc2 where tloc1def:"tloc2 <toploc (memory st) \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2)" using assms b40 by blast
  show ?thesis 
  proof(cases "tloc1< toploc(memory st)")
    case False
    then have "(\<forall>i l1 t1 l2 t2 loc i2 loc2. i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and>  MCon (MTArray l1 t1) (memory st) loc
                \<longrightarrow>  \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2)
        " using assms unfolding ncpElementsNoSubPref_def by blast
    then have "tloc2 < toploc (memory st) \<and> toploc (memory st) \<le> tloc1 \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1) 
                \<and> MCon (MTArray x11' x12') (memory st) stl2
                \<longrightarrow> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" by blast
    then have "\<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using False assms tloc2def tloc1def b50 
      by linarith
    then show ?thesis using assms LSubPrefL2_def by blast
  next
    case True
    then obtain tp'' loc2 p' where  c10:"
                       (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl1 \<and> tp'' = tp1 \<or>
                       (\<exists>len arr. p' \<noteq> stl1 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp1 p' stl1))" 
      using  assms(6,4,2,5) tloc2def by metis
    obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                  \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                   (tp''' = MTArray x t \<and> stl2 = p'' \<or> (\<exists>len arr. stl2 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl2))" 
      using  extractValueType.simps(3) b45 b40 assms by blast
    have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by simp
    then  have c30:"(if p' = p'' then tp'' = tp'''
           else case tp'' of
              MTArray len arr \<Rightarrow>
                (case tp''' of
                MTArray len2 arr2 \<Rightarrow>
                  (if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                  else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                  else if TypedMemSubPrefPtrs (memory st) len arr p' stl1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' stl1
                      then \<exists>dt.
                              CompMemType (memory st) len2 arr2 dt p'' stl1 \<and>
                              CompMemType (memory st) len arr dt p' stl1 
                  else True)
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
              | MTValue val \<Rightarrow>
                  (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                 | MTValue val2 \<Rightarrow> True))" using assms(1,2,3,4,5,6,7,8,9) unfolding TypeSafe_def compMemPtrs_def by blast
    have tp'''Mcon:"MCon tp''' (memory st) p''" using assms  c20 unfolding TypeSafe_def 
      by (metis assms(8) sameMemTSafe)
    have tp''Mcon:"MCon tp'' (memory st) p'" using assms c10 unfolding TypeSafe_def 
      by (metis assms(8) sameMemTSafe)

    have tp'''Mcon:"MCon tp''' m' p''" using assms  c20 unfolding TypeSafe_def 
      by (metis assms(8) sameMemTSafe)
    have tp''Mcon:"MCon tp'' m' p'" using assms c10 unfolding TypeSafe_def 
      by (metis assms(8) sameMemTSafe)

    then show ?thesis
    proof(cases "p' = p''")
      case True
      then have sameParentType:"tp'' = tp'''" using c30 by simp
      have pNotStl1:"p'\<noteq>stl1" using c10 c20 sameParentType assms(1,2,3,4,5,6,7,8,9,10) by auto
      then obtain len arr where tp''def: " p' \<noteq> stl1 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp1 p' stl1" using c10 by blast
      then show ?thesis
      proof(cases "p'' = stl2")
        case t2:True
        then have "tp'' = MTArray x t" using sameParentType c20 by auto
        then have "CompMemType (memory st) x t tp1 p' stl1" using tp''def by simp
        then have "CompMemType (memory st) x t tp1 stl2 stl1" using assms(1,2,3,4,5,6,7,8,9) b45 t2 True by auto
        then show ?thesis using c20 b45 assms(8,10) assms(16,15) ncpOMemInDMem_def  
          by (smt (verit, ccfv_SIG) MTypes.inject(1) cpm2mLessThanTopMemSame)
      next
        case False
        then have tp'''def: "tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl2" using c20 b45 sameParentType tp''def by blast
        then have  "tp''' = MTArray len arr \<and> CompMemType m' len arr (MTArray x t) p'' stl2" using c20 b45 sameParentType tp''def  assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
        moreover have "CompMemType m' len arr tp1 p'' stl1"using tp''def True 
          using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
        moreover have "TypedMemSubPrefPtrs m' x t stl2 stl1" using  b45  assms(1,2,3,4,5,6,7,8,9,11,10,12,13,14) not_Some_eq by blast
        moreover have "MCon (MTArray len arr) m' p''" using tp'''Mcon tp'''def  
          using assms(15) by blast
        ultimately have " CompMemType m' x t tp1  stl2 stl1" using CompMemType_asc_withSharedTarget  tp'''Mcon tp'''def 
          using CompTypeRemainsMCon by blast
        then show ?thesis using c20 True b45 assms not_Some_eq assms(15,16) ncpOMemInDMem_def by blast
      qed
    next
      case f2:False
      then show ?thesis
      proof(cases tp'')
        case mtatp'':(MTArray x11'' x12'')
        have e1:"p' \<noteq> stl1" using c10 assms mtatp'' by blast
        then have e2:"CompMemType (memory st) x11'' x12'' tp1 p' stl1" using c10 mtatp'' by simp
        then have e3:"CompMemType m' x11'' x12'' tp1 p' stl1" using c10 mtatp'' 
          using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
        then show ?thesis 
        proof(cases "tp'''")
          case mtatp''':(MTArray x11''' x12''')
          then have c30:" if TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' p' then CompMemType (memory st) x11''' x12''' (MTArray x11'' x12'') p'' p'
                        else if TypedMemSubPrefPtrs (memory st) x11'' x12'' p' p'' then CompMemType (memory st) x11'' x12'' (MTArray x11''' x12''') p' p''
                        else if TypedMemSubPrefPtrs (memory st) x11'' x12'' p' stl1 \<and> TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' stl1
                        then \<exists>dt.
                                CompMemType (memory st) x11''' x12''' dt p'' stl1 \<and>
                                CompMemType (memory st) x11'' x12'' dt p' stl1 
                                
            else True" using c30  mtatp'' f2  by simp
          then show ?thesis 
          proof(cases "TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' p'")
            case True
            then have h1:"CompMemType (memory st) x11''' x12''' (MTArray x11'' x12'') p'' p'" using c30 by simp
            then have h11:"CompMemType m' x11''' x12''' (MTArray x11'' x12'') p'' p'" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
            then show ?thesis
            proof(cases "p'' = stl2")
              case True
              then have "MTArray x11' x12'  = MTArray x11''' x12'''" using c20 mtatp''' b45 assms(10) by auto
              then show ?thesis using h11 e3
                  MTypes.inject(1) True compMemTypes_trns assms ncpOMemInDMem_def  by metis
            next
              case False
              then have e10:"stl2 \<noteq> p'' \<and> CompMemType (memory st) x11''' x12''' (MTArray x11' x12') p'' stl2" using c20 mtatp''' b45 
                using assms(10) by blast
              then have "stl2 \<noteq> p'' \<and> CompMemType m' x11''' x12''' (MTArray x11' x12') p'' stl2" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
              then have "CompMemType m' x11' x12' tp1 stl2 stl1"
                using h11  e3 CompMemType_asc_withSharedTarget2 e10  assms CompTypeRemainsMCon mtatp''' tp'''Mcon by metis

              then show ?thesis 
                by (simp add:  assms)
            qed

          next
            case f3:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x11'' x12'' p' p''")
              case True
              then have h1:"CompMemType (memory st) x11'' x12'' (MTArray x11''' x12''') p' p''" using c30 f3 by simp
              then have h11:"CompMemType m' x11'' x12'' (MTArray x11''' x12''') p' p''" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
              then show ?thesis 
              proof(cases "p'' = stl2")
                case True
                then have "MTArray x11' x12'  = MTArray x11''' x12'''" using c20 mtatp'''  b45  
                  by (simp add: assms(10))
                then show ?thesis using h11 e3 f3 compMemTypes_trns True assms CompMemType_asc_withSharedTarget CompTypeRemainsMCon mtatp''  tp''Mcon
                  by (smt (verit, ccfv_threshold))
              next
                case False
                then have e10:"stl2 \<noteq> p'' \<and> CompMemType (memory st) x11''' x12''' (MTArray x11' x12') p'' stl2" using c20 mtatp''' assms(10) b45 by simp    
                then have e11:"stl2 \<noteq> p'' \<and> CompMemType m' x11''' x12''' (MTArray x11' x12') p'' stl2" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
                then have "CompMemType m' x11' x12' tp1 stl2 stl1"
                  using h11 assms e3 CompMemType_asc_withSharedTarget2   

                  by (smt (verit, ccfv_threshold) CompMemType_asc_withSharedTarget CompTypeRemainsMCon compMemTypes_trns mtatp'' tp''Mcon)
                then show ?thesis 
                  by (simp add: assms)
              qed
            next
              case f4:False
              then have h1:"CompMemType (memory st) x11'' x12'' (MTValue x'') p' stl1 " using c10 e2 b45 assms by blast
              then have h11:"CompMemType m' x11'' x12'' (MTValue x'') p' stl1 " using assms(15)  cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
              then show ?thesis 
              proof(cases "p'' = stl2")
                case True
                then have k0:"MTArray x11' x12'  = MTArray x11''' x12'''" using c20 mtatp''' assms(10) b45 by simp

                have k1:"\<exists>dpt2.  CompMemType m' x11' x12' dpt2 p'' stl1" using assms(12) True
                proof(induction  x12' arbitrary:x11' p'' stl2)
                  case (MTArray l a)
                  then show ?case using True by fastforce
                next
                  case (MTValue x2)
                  then show ?case using TypedMemSubPrefPtrs.simps(1)[of "(memory st)" x11' x2 stl2 stl1 ] by auto
                qed
                have "MCon (MTArray x11''' x12''') (memory st) p''" using True k0 
                  using assms(8) c20 mtatp''' sameMemTSafe by blast
                then have " TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' stl1" using cpm2mLessThanTopTypedMem[of x11''' x12''' "memory st" p'' m' stl1] k0
                    assms(16,15,12,13) True unfolding ncpOMemInDMem_def by blast
                then have " \<exists>dt.
                         CompMemType (memory st)  x11' x12' dt p'' stl1 \<and>
                         CompMemType (memory st) x11'' x12'' dt p' stl1
                         " using c30 k0 True h1
                  using e2 f3 f4 k1 
                  using CompMemType_imps_TypedMemSubPrefPtrs   by simp 
                then have " \<exists>dt.
                         CompMemType m'  x11' x12' dt p'' stl1 \<and>
                         CompMemType m' x11'' x12'' dt p' stl1" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
                then show ?thesis 
                  using CompMemTypeSameLocsSameType CompTypeRemainsMCon True  mtatp'' tp''Mcon assms e2 
                  using e3 by blast

              next
                case False
                then have k4:"CompMemType (memory st) x11''' x12''' (MTArray x t) p'' stl2" using c20 mtatp''' by simp   
                have "MCon (MTArray x11''' x12''') (memory st) p''"  
                  using assms(8) c20 mtatp''' sameMemTSafe by blast
                then have k5:" TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' stl1" using cpm2mLessThanTopTypedMem[of x11''' x12''' "memory st" p'' m' stl1] 
                    assms(16,15,12,13)  unfolding ncpOMemInDMem_def using CompTypeRemainsMCon TypedMemSubPrefPtrs_trns b45  mtatp''' tp'''Mcon k4 False 
                  by (smt (verit, best) assms(10) cpm2mLessThanTopTypedMem)

                then have "TypedMemSubPrefPtrs (memory st) x11'' x12'' p' stl1 \<and> TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' stl1"  using e2 f3 f4  compMemTypes_trns  
                  using CompMemType_imps_TypedMemSubPrefPtrs by blast
                then have "\<exists>dt.
                      CompMemType (memory st) x11''' x12''' dt p'' stl1 \<and>
                      CompMemType (memory st) x11'' x12'' dt p' stl1" using c30 h1 
                  using e2 f3 f4  compMemTypes_trns  by metis


                then have k7:"\<exists>dt. CompMemType m' x11''' x12''' dt p'' stl1 \<and>
                      CompMemType m' x11'' x12'' dt p' stl1"  using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
                moreover have "CompMemType m' x11''' x12''' (MTArray x t) p'' stl2" using k4  using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
                moreover have "TypedMemSubPrefPtrs m' x11''' x12''' p'' stl1" using assms False 
                  by (metis CompMemType_imps_TypedMemSubPrefPtrs k7)
                ultimately show ?thesis 
                  using h1 e2 f3 f4 k5 b45 using  CompMemType_imps_TypedMemSubPrefPtrs 
                    CompMemTypeSameLocsSameType mtatp'' tp''Mcon CompMemType_asc_withSharedTarget CompTypeRemainsMCon assms mtatp''' tp'''Mcon 
                  by (metis e3)


              qed

            qed
          qed
        next
          case (MTValue x2)
          then show ?thesis using c20 by simp
        qed
      next
        case mtv'':(MTValue x2'')
        then have e1:"x'' = x2''" using assms c10 by blast
        then have e2:"p' = stl1" using c10  mtv'' by simp
        have e98:"MCon (MTArray x11' x12') (memory st) stl2" 
          using CompTypeRemainsMCon assms(10) assms(8) b45 c20 sameMemTSafe by blast
        then have e99:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using cpm2mLessThanTopTypedMem[of x11' x12' "memory st" stl2 m' stl1] using assms(16,15,12,13)  unfolding ncpOMemInDMem_def by auto
        then show ?thesis 
        proof(cases tp''')
          case (MTArray x11''' x12''')
          then have e3:"if TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' p' then CompMemType (memory st) x11''' x12''' (MTValue x2'') p'' p' else True" 
            using c30 f2 mtv'' by simp
          then show ?thesis using c10 c20 assms  MTArray 
          proof(cases "p'' = stl2")
            case True
            then have e100:"MTArray x11''' x12''' = MTArray x11' x12'" using c20 MTArray  assms(10) b45 by auto
            then have " CompMemType (memory st) x11''' x12''' (MTValue x2'') p'' p'" using e3 e99 True e2 by simp
            then have " CompMemType m' x11''' x12''' (MTValue x2'') p'' p'" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
            then show ?thesis using e100  
              using True assms(9) e1 e2 by auto
          next
            case False
            then have e10:"stl2 \<noteq> p'' \<and> CompMemType (memory st) x11''' x12''' (MTArray x t) p'' stl2" using c20 MTArray by simp
            moreover have "TypedMemSubPrefPtrs (memory st) x t stl2 p'" using e2   b45 c10   
              using assms(10) assms(13) assms(8) e99 by simp
            moreover have "TypedMemSubPrefPtrs (memory st) x11''' x12''' p'' p'" 
              using TypedMemSubPrefPtrs_trns e10 CompTypeRemainsMCon MTArray tp'''Mcon CompMemType_imps_TypedMemSubPrefPtrs  calculation e99

              by (metis assms(8) c20 sameMemTSafe)
            ultimately have "CompMemType (memory st) x t (MTValue x'') stl2 stl1" using c10 c20 MTArray e1 e2 e3 tp'''Mcon CompMemType_asc_withSharedTarget

              by (metis assms(10) assms(8) b45 e98 mtv'' sameMemTSafe)
            then have "CompMemType m' x t (MTValue x'') stl2 stl1" using assms(15) assms(16) cpm2mLessThanTopMemSame ncpOMemInDMem_def assms   by blast
            then show ?thesis using e1 e2  e3 MTArray b45 
              using assms(10) assms(11) assms(9) assms(8) by  blast
          qed
        next
          case (MTValue x2)
          then show ?thesis using c10 c20 assms by blast
        qed
      qed
    qed
  qed
next
  case False

  have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                      \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using fmranI lessThanTopLocs_def 
    using assms(3) by force
  have a30:"e = (updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev')" using assms(1) by simp

  then have a40:
    "denvalue e = denvalue(ev' \<lparr> denvalue := fmupd ip ((Memory (MTArray x t)),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev') \<rparr>)" by simp
  then have l2InOld:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev') " using  fmranI assms(1,2) False astack.simps  a160 by fastforce
  have l2SckK:"accessStore l2 sck' = accessStore l2 k'" using l2InOld assms(1,2,3,4,5,6,7,8) False astack.simps unfolding push_def accessStore_def updateStore_def allocate_def by simp  
  then have e98:"MCon (MTArray x11' x12') m' stl2"
    using assms(10,2) assms(14)   sameMemTSafe[of ev' "accounts st" sck' m' "storage st" cd' ] l2InOld by auto

  then have e99:"TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" 
    using cpm2mLessThanTopTypedMem[of x11' x12' "m'" stl2 m' stl1] using assms(16,15,12,13)  unfolding ncpOMemInDMem_def by auto

  have e1:"  compMemPtrs sck' m' (denvalue ev')"  using  assms(14) unfolding TypeSafe_def by simp
  have "if TypedMemSubPrefPtrs m' x11' x12' stl2 stl1 then CompMemType m' x11' x12' (MTValue x'') stl2 stl1 else True"
    using e1 unfolding compMemPtrs_def  using l2InOld l2SckK assms(2,3,4,5,6,7,8,9,10,11,12,13,14) apply (auto split:if_splits MTypes.splits) apply blast by blast
  then have " CompMemType m' x11' x12' (MTValue x'') stl2 stl1" using e99 
    by (simp add: assms(12))
  then show ?thesis using assms(16,10,13) 
    by (simp add: assms(9))
qed


lemma cpm2mTwoArraysSubLocs:
  assumes "(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
           (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))"
    and "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl2 \<and> tp'' = tp2 \<or>
     (\<exists>len arr. p' \<noteq> stl2 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl2))"
    and "p' \<noteq> p''"
    and "tp'' = (MTArray tp''L tp''T)"
    and "tp''' = MTArray tp'''L tp'''T"
    and "CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'"
    and "TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p'"
    and "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"

and "MTArray x11' x12' =tp2"
and "MTArray x11 x12 = tp1"
and "MCon tp'' (memory st) p'"
and "MCon tp''' (memory st) p''"
and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m' \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m'"
and "\<exists>y tloc. tloc <toploc (memory st) \<and> LSubPrefL2 (hash stl1 y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
shows "CompMemType m' x11' x12' (MTArray x t) stl2 stl1"
proof(cases "p'' = stl1")
  case t6:True
  then have h2:"(MTArray tp'''L tp'''T) = MTArray x t" using assms by simp
  then show ?thesis 
  proof(cases "p' = stl2")
    case True
    then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using assms by blast
    have "TypedMemSubPrefPtrs (memory st)  x t stl1 stl2" using  h2 True t6 assms by simp
    then show ?thesis using   h2 h3 True t6 
      using CompMemType_imps_CompMemJustType TypedMemSubPrefOneWay    assms 
      by (smt (verit, best) cpm2mLessThanTopTypedMem ncpOMemInDMem_def)
  next
    case False
    then have h3:"p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st)tp''L tp''T tp2 p' stl2" using  assms by simp
    then have h4:"TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl2" using CompMemType_imps_TypedMemSubPrefPtrs by auto

    then have h5:"TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl1" using TypedMemSubPrefPtrs_trns assms 
      by (metis CompTypeRemainsMCon h3) 
    then show ?thesis  using   TypedMemSubPrefOneWay[of "memory st" x11' x12' stl2 stl1 x t]  h2 t6  assms CompMemType_imps_CompMemJustType CompTypeRemainsMCon TypedMemSubPrefOneWay TypedMemSubPrefPtrs_trns
      by metis
  qed
next
  case p''NotStl1:False
  then have h2:"(stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1)" using  assms by simp
  then show ?thesis 
  proof(cases "p' = stl2")
    case True
    then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using   assms by blast
    have "TypedMemSubPrefPtrs (memory st)  tp'''L tp'''T p'' stl2" using  h2 True assms by simp
    then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1" using  h2 h3 True p''NotStl1 
      using CompMemType_asc_withSharedTarget CompTypeRemainsMCon   assms by metis
    then show ?thesis using assms 
      using cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
  next
    case False
    then have h3:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using  assms by auto
    then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1"  
      using CompMemType_asc_withSharedTarget    h2 h3  p''NotStl1 assms
      by (metis CompTypeRemainsMCon compMemTypes_trns  )
    then show ?thesis using assms
      using cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
  qed
qed

lemma cpm2mTwoArraysSubLocs2:
  assumes "(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
           (tp''' = MTArray x11' x12'\<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray  x11' x12') p'' stl1))"
    and "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl2 \<and> tp'' = tp2 \<or>
     (\<exists>len arr. p' \<noteq> stl2 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl2))"
    and "p' \<noteq> p''"
    and "tp'' = (MTArray tp''L tp''T)"
    and "tp''' = MTArray tp'''L tp'''T"
    and "CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'"
    and "TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p'"
    and "TypedMemSubPrefPtrs (memory st) x11' x12' stl1 stl2"
    and "MTArray x11' x12' =tp1"
    and "MTArray x11 x12 = tp2"
    and "MCon tp'' (memory st) p'"
    and "MCon tp''' (memory st) p''"
    and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
        toploc (memory st) \<le> toploc m' \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m'"
    and "\<exists>tloc. tloc <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
    and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
  shows "CompMemType m' x11' x12' (MTArray x11 x12) stl1 stl2" 
proof(cases "p'' = stl1")
  case t6:True
  then have h2:"(MTArray tp'''L tp'''T) = MTArray  x11' x12'" using assms by simp
  then show ?thesis 
  proof(cases "p' = stl2")
    case True
    then have h3:"MTArray tp''L tp''T =  MTArray x11 x12" using assms by blast
    have "TypedMemSubPrefPtrs (memory st) x11' x12' stl1 stl2" using  h2 True t6 assms by simp
    then show ?thesis using   h2 h3 True t6  assms cpm2mLessThanTopMemSame ncpOMemInDMem_def  by blast
  next
    case False
    then have h3:"p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st)tp''L tp''T tp2 p' stl2" using  assms by simp
    then have h4:"TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl2" using CompMemType_imps_TypedMemSubPrefPtrs by auto

    have "TypedMemSubPrefPtrs (memory st)  x11' x12' stl1 stl2" using  h2  assms by blast
    then have "CompMemType (memory st)  x11' x12' (MTArray x11 x12) stl1 stl2" using  h2 h3   
      using CompMemType_asc_withSharedTarget CompTypeRemainsMCon assms
      by (smt (verit, best) MTypes.inject(1) compMemTypes_trns)
    then show ?thesis using assms 
      using cpm2mLessThanTopMemSame ncpOMemInDMem_def by  blast


  qed
next
  case p''NotStl1:False
  then have h2:"(stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11' x12') p'' stl1)" using  assms by simp
  then show ?thesis 
  proof(cases "p' = stl2")
    case True
    then have h3:"MTArray tp''L tp''T =  MTArray x11 x12" using   assms by blast
    have "TypedMemSubPrefPtrs (memory st)  tp'''L tp'''T p'' stl2" using  h2 True assms by simp
    then have "CompMemType (memory st)  x11' x12' (MTArray x11 x12) stl1 stl2" using  h2 h3 True p''NotStl1 
      using CompMemType_asc_withSharedTarget  assms 
      using CompTypeRemainsMCon by metis
    then show ?thesis using assms
      using cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
  next
    case False
    then have h3:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using  assms by auto
    then have "CompMemType (memory st)  x11' x12' (MTArray x11 x12) stl1 stl2"  
      using CompMemType_asc_withSharedTarget2 h2 h3  p''NotStl1 assms CompTypeRemainsMCon

      by meson
    then show ?thesis using assms cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
  qed
qed

lemma cpm2mSublocationDoubleArray:
  assumes "(\<forall>tp' locs p i.
        (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev') \<and> accessStore locs sck' = Some (KMemptr p) \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
        (\<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))))"
    and "(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  (MTArray x t) \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x t) p' p)))"
    and "stl1 = p"
    and "accessStore l2 sck' = accessStore l2 k'"
    and "(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')"
    and "MTArray x11 x12 = tp1"
    and "MTArray x11 x12 = MTArray x t"
    and "MTArray x11' x12' = tp2"
    and "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
    and "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
    and "stl1 \<noteq> stl2"

and "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1"
and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m' \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m'"
and "\<exists>y tloc. tloc <toploc (memory st) \<and> LSubPrefL2 (hash stl1 y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
and "\<exists> tloc. tloc <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
and "\<exists> tloc1. tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)"
and " MCon (MTArray x11 x12) (memory st) stl1"
shows "CompMemType m' x11' x12' (MTArray x11 x12) stl2 stl1"
proof -


  obtain tloc2 where tloc2def:" tloc2 <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2)" using assms(16) by blast
  obtain tloc1 where tloc1def:"tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" using assms(17) by blast
  show ?thesis 
  proof(cases "tloc2< toploc(memory st)")
    case False
    then have "(\<forall>i l1 t1 l2 t2 loc i2 loc2. i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and>  MCon (MTArray l1 t1) (memory st) loc
                \<longrightarrow>  \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2)
        " using assms(13) unfolding ncpElementsNoSubPref_def by blast
    then have "tloc1 < toploc (memory st) \<and> toploc (memory st) \<le> tloc2 \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1) \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2) 
                \<and> MCon (MTArray x11 x12) (memory st) stl1
                \<longrightarrow> \<not> TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" by auto
    then have "\<not> TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using False assms(17,18) tloc2def tloc1def by simp
    then show ?thesis using assms(12) LSubPrefL2_def by simp
  next
    case True
    then obtain tp'' loc2 p' where  c10:"
       (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl2 \<and> tp'' = tp2 \<or>
       (\<exists>len arr. p' \<noteq> stl2 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl2))" 
      using  assms(1,4,5)  assms(9) tloc2def by metis


    obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                  \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                   (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))" 
      using  extractValueType.simps(3) assms    by blast
    have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by simp
    then  have c30:"(if p' = p'' then tp'' = tp'''
           else case tp'' of
              MTArray len arr \<Rightarrow>
                (case tp''' of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                  else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                  else if TypedMemSubPrefPtrs (memory st) len arr p' stl1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' stl1
                      then \<exists>dt.
                              CompMemType (memory st) len2 arr2 dt p'' stl1 \<and>
                              CompMemType (memory st) len arr dt p' stl1 
                  else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
              | MTValue val \<Rightarrow>
                  (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                 | MTValue val2 \<Rightarrow> True))" using assms unfolding TypeSafe_def compMemPtrs_def by simp
    have ppp:"(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m' \<and>
    (\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc m') \<and>
    (\<forall>i l1 t1 l2 t2 loc i2 loc2.
      i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)  \<and> MCon (MTArray l1 t1) (memory st) loc \<longrightarrow>
      \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2)" using assms(13) unfolding ncpDenvalueLimit_def ncpOMemInDMem_def ncpElementsNoSubPref_def by blast

    have tp'''Mcon:"MCon tp''' (memory st) p''" using c20 unfolding TypeSafe_def 
      by (metis assms(10) sameMemTSafe)
    have tp''Mcon:"MCon tp'' (memory st) p'" using c10 unfolding TypeSafe_def 
      by (metis assms(10) sameMemTSafe)
    have stl2MCon:"MCon (MTArray x11' x12') (memory st) stl2" using  c10  assms  CompTypeRemainsMCon  
      by (metis tp''Mcon)
    then have stl21MemSt:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using stl2MCon assms(11,12) cpm2mLessThanTopTypedMem ppp assms(14,15) by blast

    then show ?thesis
    proof(cases "p' = p''")
      case parentSame:True
      then have sameParentType:"tp''=tp'''" using c30 by simp
      then show ?thesis
      proof(cases "p' = stl2")
        case True
        then have j1:"tp'' = (MTArray x11' x12')" using assms c10 by simp
        then have j2:"tp''' = (MTArray x11' x12')" using sameParentType by simp

        then show ?thesis 
        proof(cases "p'' =stl1")
          case t2:True
          then show ?thesis using parentSame assms(11) True by simp
        next
          case False
          then have "stl1 \<noteq> p'' \<and> tp''' = MTArray x11' x12' \<and> CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1" using c20 j2 by auto
          have " CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
            using True \<open>stl1 \<noteq> p'' \<and> tp''' = MTArray x11' x12' \<and> CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1\<close> assms parentSame by auto
          then show ?thesis using ppp assms(14,15) cpm2mLessThanTopMemSame by meson
        qed
      next
        case f4:False
        then show ?thesis 
        proof(cases "p'' = stl1")
          case t2:True
          then have j4:"p' = stl1" using parentSame by simp
          then have j3:"tp''' = MTArray x t" using c20 t2 by simp
          then have j5:"(p' \<noteq> stl2 \<and> tp'' = MTArray x t \<and> CompMemType (memory st) x t (MTArray x11' x12') stl1 stl2)" using sameParentType c10 f4 assms j4 by simp
          then have j7:"CompMemType (memory st) x t (MTArray x11' x12') stl1 stl2" by simp
          then have j12:"CompMemJustType (MTArray x t) (MTArray x11' x12')"  
            using CompMemType_imps_CompMemJustType by blast
          have j8:"MCon (MTArray x t) (memory st) stl1" using tp'''Mcon j3 t2 by blast
          have j10:"MCon (MTArray x11' x12') (memory st) stl2" 
            using CompTypeRemainsMCon j5 j8 by blast
          then have j6:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using  assms(11,12) cpm2mLessThanTopTypedMem ppp assms(14,15) by blast


          have "TypedMemSubPrefPtrs (memory st) x t stl1 stl2" using j5 
            using CompMemType_imps_TypedMemSubPrefPtrs by auto
          then show ?thesis using j6 TypedMemSubPrefOneWay j7 j8 j10 j12 by simp
        next
          case f5:False
          then obtain x'' t'' where x''def:"(p' \<noteq> stl2 \<and> tp'' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x11' x12') p' stl2)" using sameParentType c10 f4 assms by blast
          then have  k1:"stl1 \<noteq> p' \<and> tp''' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x t) p' stl1" using c20 sameParentType parentSame f5 by simp
          have"MCon (MTArray x11' x12') (memory st) stl2" using sameParentType c10 f4 assms  CompTypeRemainsMCon parentSame 
            by (metis tp''Mcon)
          moreover have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using assms(11,12) cpm2mLessThanTopTypedMem ppp assms(14,15) calculation by blast
          then have " CompMemType (memory st) x11' x12' (MTArray x t) stl2 stl1"
            using x''def   CompMemType_asc_withSharedTarget[of "memory st" x'' t'' x11' x12' p' stl2 "MTArray x t" stl1]  
            using CompTypeRemainsMCon tp''Mcon assms(12) k1  by blast
          then show ?thesis using assms ppp  cpm2mLessThanTopMemSame  
            by (metis (no_types, lifting))
        qed
      qed
    next
      case parentNotSame:False
      then show ?thesis
      proof(cases tp'')
        case tp''MTA:(MTArray tp''L tp''T)
        then show ?thesis 
        proof(cases tp''')
          case tp'''MTA:(MTArray tp'''L tp'''T)
          then have c30:"if TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p' then CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'
                    else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p'' then CompMemType (memory st) tp''L tp''T (MTArray  tp'''L tp'''T) p' p''
                     else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' stl1 \<and> TypedMemSubPrefPtrs (memory st)  tp'''L tp'''T p'' stl1
                          then \<exists>dt.
                              CompMemType (memory st) tp'''L tp'''T dt p'' stl1 \<and>
                              CompMemType (memory st) tp''L tp''T dt p' stl1 
                          else True" 
            using c30 parentNotSame tp''MTA  by auto
          then show ?thesis 
          proof(cases "TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p'")
            case t5:True
            then have h1:"CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'" using c30 by simp

            then have "CompMemType m'  x11' x12' (MTArray x t) stl2 stl1"  using cpm2mTwoArraysSubLocs[of tp''' stloc ev st p'' x t stl1 tp'' loc2 p' stl2 tp2 tp''L tp''T tp'''L tp'''T  x11' x12' x11 x12 tp1] 
                c10 c20 tp'''MTA tp''MTA    t5  parentNotSame h1 tp'''Mcon tp''Mcon assms stl21MemSt
              by blast
            then show ?thesis using parentNotSame  assms by simp

          next
            case f2:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p''")
              case t5:True
              then have h1:"CompMemType (memory st) tp''L tp''T (MTArray tp'''L tp'''T) p' p''" using c30 f2 parentNotSame by simp

              then show ?thesis 
              proof(cases "p'' = stl1")
                case t6:True
                then have h2:"(MTArray tp'''L tp'''T) = MTArray x t" using c20 tp'''MTA by simp
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1" using t6 True h3 h2 h1 by blast
                  then show ?thesis using     assms ppp cpm2mLessThanTopMemSame
                    by (metis (no_types, lifting))
                next
                  case False
                  then have "p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st)tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                  then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1" using h1 h2  False 
                    using CompMemType_asc_withSharedTarget CompTypeRemainsMCon   tp'''Mcon assms ppp t6 tp''Mcon
                    by (metis stl21MemSt)
                  then show ?thesis using assms ppp cpm2mLessThanTopMemSame
                    by (metis (no_types, lifting))
                qed
              next
                case p''NotStl1:False
                then have h2:"(stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1)" using c20 tp'''MTA by simp
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  have "TypedMemSubPrefPtrs (memory st)  tp''L tp''T stl2 p''" using t5 h2 True by simp
                  then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1" using h1 h2 h3 True p''NotStl1 
                    using CompMemType_asc_withSharedTarget CompTypeRemainsMCon  tp'''Mcon 
                    by (metis MTypes.inject(1) compMemTypes_trns)
                  then show ?thesis using parentNotSame assms ppp cpm2mLessThanTopMemSame
                    by (metis (no_types, lifting))
                next
                  case False
                  then have h3:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by auto
                  then have "CompMemType (memory st)  x11' x12' (MTArray x t) stl2 stl1"  
                    using CompMemType_asc_withSharedTarget  tp'''Mcon h1 h2 h3  p''NotStl1  CompTypeRemainsMCon compMemTypes_trns   tp''Mcon assms(12) assms(13) assms(8) stl21MemSt
                    by metis
                  then show ?thesis using    parentNotSame    assms ppp cpm2mLessThanTopMemSame
                    by (metis (no_types, lifting))
                qed
              qed
            next
              case f3:False
              then show ?thesis 
              proof(cases "p' = stl2")
                case t3:True
                then have h2:"tp'' = tp2" using c10 by simp
                then show ?thesis
                proof(cases "p''=stl1")
                  case t4:True
                  then have h3:"tp''' = MTArray x t" using c20 by simp
                  show ?thesis using h3 h2 t3 t4 f3 f2 tp''MTA stl21MemSt
                    using assms(12) assms(13) assms(8) by auto
                next
                  case f4:False
                  then have "stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1" using c20  tp'''MTA by simp
                  then show ?thesis 

                    by (metis (no_types, lifting) CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs MTypes.inject(1) assms(15) assms(7) assms(8) c30 cpm2mLessThanTopMemSame f2 f3 h2 ppp stl21MemSt t3 tp'''Mcon tp''MTA)
                qed
              next
                case f4:False
                then have h2:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                then show ?thesis 
                proof(cases "p'' = stl1")
                  case True
                  then have h3:"tp''' = MTArray x t" using c20 by simp
                  then show ?thesis using h3 h2 f3 f2 tp''MTA    assms  CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon True TypedMemSubPrefPtrs_trns tp''Mcon ppp stl2MCon 
                    by (metis stl21MemSt)
                next
                  case False
                  then have h3:"stl1 \<noteq> p'' \<and> tp''' = MTArray  tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1" using c20 tp'''MTA by simp
                  have "TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl2" using h2 CompMemType_imps_TypedMemSubPrefPtrs by blast
                  then have "TypedMemSubPrefPtrs (memory st) tp''L tp''T p' stl1"   
                    using CompTypeRemainsMCon TypedMemSubPrefPtrs_trns h2  assms tp''Mcon stl21MemSt ppp by metis
                  then have "\<exists>dt.
                              CompMemType (memory st) tp'''L tp'''T dt p'' stl1 \<and>
                              CompMemType (memory st) tp''L tp''T dt p' stl1 " 
                    using c30 h3 CompMemType_imps_TypedMemSubPrefPtrs f3 f2 by auto
                  then obtain dt where h4:"
                              CompMemType (memory st) tp'''L tp'''T dt p'' stl1 \<and>
                              CompMemType (memory st) tp''L tp''T dt p' stl1 " by blast
                  then show ?thesis 
                    using h3 h2 f3 f2 tp''MTA CompMemType_imps_TypedMemSubPrefPtrs h4  stl21MemSt 
                      CompMemTypeSameLocsSameType CompMemType_asc_withSharedTarget CompTypeRemainsMCon assms(12) assms(13) assms(7) assms(8) tp'''Mcon tp''Mcon ppp 
                    by (smt (verit, best) assms(15) cpm2mLessThanTopMemSame)

                qed
              qed

            qed
          qed
        next
          case (MTValue x2)
          then show ?thesis using c10 c20 by simp
        qed
      next
        case mtvin:(MTValue tp''Val)
        then have e3:"p' \<noteq> stl2" using c10 assms(8) by blast
        then show ?thesis using c10 mtvin by simp
      qed
    qed 
  qed
qed

lemma cpm2mSublocationDoubleArray2:
  assumes "(\<forall>tp' locs p i.
        (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
        (\<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))))"
    and "(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  (MTArray x t) \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x t) p' p)))"
    and "stl1 = p"
    and "accessStore l2 sck' = accessStore l2 k'"
    and "(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')"
    and "MTArray x11 x12 = tp1"
    and "MTArray x11 x12 = MTArray x t"
    and "MTArray x11' x12' = tp2"
    and "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
    and "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
    and "stl1 \<noteq> stl2"
    and "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2"
    and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m'  \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m'"
    and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
    and "\<exists> tloc. tloc <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
    and "\<exists> tloc1. tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)"
    and " MCon (MTArray x11 x12) (memory st) stl1"
  shows "CompMemType m' x11 x12 (MTArray x11' x12') stl1 stl2"
proof -
  obtain tloc2 where tloc2def:" tloc2 <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2)" using assms(15) by blast
  obtain tloc1 where tloc1def:"tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" using assms(16) by blast
  show ?thesis 
  proof(cases "tloc2< toploc(memory st)")
    case False
    then have "(\<forall>i l1 t1 l2 t2 loc i2 loc2. i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and>  MCon (MTArray l1 t1) (memory st) loc
                \<longrightarrow>  \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2)
        " using assms(13) unfolding ncpElementsNoSubPref_def by blast
    then have "tloc1 < toploc (memory st) \<and> toploc (memory st) \<le> tloc2 \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1) \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2) 
                \<and> MCon (MTArray x11 x12) (memory st) stl1
                \<longrightarrow> \<not> TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" by auto
    then have "\<not> TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using False assms(16,17) tloc2def tloc1def by simp
    then show ?thesis using assms(12) LSubPrefL2_def by simp
  next
    case True
    obtain tp'' loc2 p' where  c10:"
       (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl2 \<and> tp'' = tp2 \<or>
       (\<exists>len arr. p' \<noteq> stl2 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl2))" 
      using  assms(1,4,5)  assms(9) tloc2def True  by metis
    obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                  \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                   (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))" 
      using  extractValueType.simps(3) assms    by blast
    have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by simp
    then  have c30:"\<forall>dtp1. (if p' = p'' then tp'' = tp'''
           else case tp'' of
              MTArray len arr \<Rightarrow>
                (case tp''' of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                  else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                  else if TypedMemSubPrefPtrs (memory st) len arr p' stl2 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' stl2
                      then \<exists>dt.
                              CompMemType (memory st) len2 arr2 dt p'' stl2 \<and>
                              CompMemType (memory st) len arr dt p' stl2 
                  else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
              | MTValue val \<Rightarrow>
                  (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                 | MTValue val2 \<Rightarrow> True))" using assms unfolding TypeSafe_def compMemPtrs_def by simp

    have ppp:"(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
  toploc (memory st) \<le> toploc m' \<and>
  (\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc m') \<and>
  (\<forall>i l1 t1 l2 t2 loc i2 loc2.
      i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc \<longrightarrow>
      \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2)" using assms(13) unfolding  ncpOMemInDMem_def ncpElementsNoSubPref_def by blast


    have tp'''Mcon:"MCon tp''' (memory st) p''" using c20 unfolding TypeSafe_def 
      by (metis assms(10) sameMemTSafe)
    have tp''Mcon:"MCon tp'' (memory st) p'" using c10 unfolding TypeSafe_def 
      by (metis assms(10) sameMemTSafe)

    have stl2MCon:"MCon (MTArray x11 x12) (memory st) stl1" using  c20  assms  CompTypeRemainsMCon  
      by (metis)
    then have stl21MemSt:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using stl2MCon assms(11,12) cpm2mLessThanTopTypedMem ppp assms(14,15)
      by (smt (verit, ccfv_SIG))

    then show ?thesis
    proof(cases "p' = p''")
      case parentSame:True
      then have sameParentType:"tp''=tp'''" using c30 by simp
      then show ?thesis
      proof(cases "p' = stl2")
        case True
        then have j1:"tp'' = (MTArray x11' x12')" using assms c10 by simp
        then have j2:"tp''' = (MTArray x11' x12')" using sameParentType by simp

        then show ?thesis 
        proof(cases "p'' =stl1")
          case t2:True
          then show ?thesis using parentSame assms(11) True by simp
        next
          case False
          then have "stl1 \<noteq> p'' \<and> tp''' = MTArray x11' x12' \<and> CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1" using c20 j2 by auto
          have " CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
            using True \<open>stl1 \<noteq> p'' \<and> tp''' = MTArray x11' x12' \<and> CompMemType (memory st) x11' x12' (MTArray x t) p'' stl1\<close> assms parentSame by auto

          then show ?thesis 
            using CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon 
              True TypedMemSubPrefOneWay assms(12) assms(13) j2 parentSame tp'''Mcon ppp stl21MemSt stl2MCon 
            by (metis )
        qed
      next
        case f4:False
        then show ?thesis 
        proof(cases "p'' = stl1")
          case t2:True
          then have j4:"p' = stl1" using parentSame by simp
          then have j3:"tp''' = MTArray x t" using c20 t2 by simp
          then have j5:"(p' \<noteq> stl2 \<and> tp'' = MTArray x t \<and> CompMemType (memory st) x t (MTArray x11' x12') stl1 stl2)" using sameParentType c10 f4 assms j4 by simp
          then have j7:"CompMemType (memory st) x t (MTArray x11' x12') stl1 stl2" by simp
          then have j12:"CompMemJustType (MTArray x t) (MTArray x11' x12')"  
            using CompMemType_imps_CompMemJustType by blast
          then have j6:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using  assms(12,13) stl21MemSt by auto
          have j8:"MCon (MTArray x t) (memory st) stl1" using tp'''Mcon j3 t2 by blast
          have j10:"MCon (MTArray x11' x12') (memory st) stl2" 
            using CompTypeRemainsMCon j5 j8 by blast
          have "TypedMemSubPrefPtrs (memory st) x t stl1 stl2" using j5 
            using CompMemType_imps_TypedMemSubPrefPtrs by auto
          then show ?thesis using j6 j7 j8 j10 j12  ppp stl21MemSt stl2MCon
            using assms(12) assms(7) 
            by (metis MTypes.inject(1) assms(14) cpm2mLessThanTopMemSame)
        next
          case f5:False
          then obtain x'' t'' where x''def:"(p' \<noteq> stl2 \<and> tp'' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x11' x12') p' stl2)" using sameParentType c10 f4 assms by blast
          then have  k1:"stl1 \<noteq> p' \<and> tp''' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x t) p' stl1" using c20 sameParentType parentSame f5 by simp
          then have " CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" 
            using x''def   CompMemType_asc_withSharedTarget assms 
            using CompTypeRemainsMCon tp''Mcon  ppp stl21MemSt stl2MCon by metis
          then show ?thesis using assms  ppp stl21MemSt stl2MCon 
            by (metis (no_types, lifting) cpm2mLessThanTopMemSame)
        qed
      qed
    next
      case parentNotSame:False
      then show ?thesis
      proof(cases tp'')
        case tp''MTA:(MTArray tp''L tp''T)
        then show ?thesis 
        proof(cases tp''')
          case tp'''MTA:(MTArray tp'''L tp'''T)
          then have c30:"if TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p' then CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'
                    else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p'' then CompMemType (memory st) tp''L tp''T (MTArray  tp'''L tp'''T) p' p''
                     else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' stl2 \<and> TypedMemSubPrefPtrs (memory st)  tp'''L tp'''T p'' stl2
                          then \<exists>dt.
                              CompMemType (memory st) tp'''L tp'''T dt p'' stl2 \<and>
                              CompMemType (memory st) tp''L tp''T dt p' stl2
                          else True" 
            using c30 parentNotSame tp''MTA  by auto
          then show ?thesis 
          proof(cases "TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p'")
            case t5:True
            then have h1:"CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'" using c30 by simp
            have "CompMemType m'  x t (MTArray x11' x12') stl1 stl2"  using cpm2mTwoArraysSubLocs2[of tp''' stloc ev st p'' x11 x12 stl1 tp'' loc2 p' stl2 tp2 tp''L tp''T tp'''L tp'''T  tp1 x11' x12']
                c10 c20 tp'''MTA tp''MTA    t5  parentNotSame h1 tp'''Mcon tp''Mcon assms  ppp stl21MemSt stl2MCon
              by blast
            then show ?thesis using parentNotSame  assms by auto

          next
            case f2:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p''")
              case t5:True
              then have h1:"CompMemType (memory st) tp''L tp''T (MTArray tp'''L tp'''T) p' p''" using c30 f2 parentNotSame by simp

              then show ?thesis 
              proof(cases "p'' = stl1")
                case t6:True
                then have h2:"(MTArray tp'''L tp'''T) = MTArray x t" using c20 tp'''MTA by simp
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  then have "CompMemType (memory st)  x11 x12 (MTArray x11' x12') stl1 stl2" using t6 True h3 h2 h1 
                    using assms(12) assms(13) assms(7) f2  ppp stl21MemSt stl2MCon by blast
                  then show ?thesis using     assms  ppp stl21MemSt stl2MCon 
                    using True f2 h2 t6 by fastforce
                next
                  case False
                  then have "p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st)tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                  then have "CompMemType (memory st)  x11 x12 (MTArray x11' x12') stl1 stl2" using h1 h2  False 
                    using CompMemType_asc_withSharedTarget CompTypeRemainsMCon   tp'''Mcon assms  ppp stl21MemSt stl2MCon
                    by (metis  t6 tp''Mcon)
                  then show ?thesis using assms  ppp stl21MemSt stl2MCon 
                    by (meson cpm2mLessThanTopMemSame)
                qed
              next
                case p''NotStl1:False
                then have h2:"(stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1)" using c20 tp'''MTA by simp
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  have "TypedMemSubPrefPtrs (memory st)  tp''L tp''T stl2 p''" using t5 h2 True by simp
                  then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using h1 h2 h3 True p''NotStl1 
                    using  CompTypeRemainsMCon  tp'''Mcon  ppp stl21MemSt stl2MCon
                    by (metis TypedMemSubPrefPtrs_trns assms(7) f2)
                  then show ?thesis using parentNotSame assms  ppp stl21MemSt stl2MCon 
                    by (metis True TypedMemSubPrefPtrs_trns f2 h2 tp'''Mcon)
                next
                  case False
                  then have h3:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by auto
                  then have "CompMemType (memory st)  x11 x12 (MTArray x11' x12') stl1 stl2"  
                    using CompMemType_asc_withSharedTarget  tp'''Mcon h1 h2 h3  p''NotStl1  CompTypeRemainsMCon compMemTypes_trns   tp''Mcon
                      assms(12) assms(13) assms(8)  ppp stl21MemSt stl2MCon
                    by (smt (verit, ccfv_threshold) assms(7))

                  then show ?thesis using    parentNotSame    assms  ppp stl21MemSt stl2MCon 
                    by (meson cpm2mLessThanTopMemSame)
                qed
              qed
            next
              case f3:False
              then show ?thesis 
              proof(cases "p' = stl2")
                case t3:True
                then have h2:"tp'' = tp2" using c10 by simp
                then show ?thesis
                proof(cases "p''=stl1")
                  case t4:True
                  then have h3:"tp''' = MTArray x t" using c20 by simp
                  show ?thesis using h3 h2 t3 t4 f3 f2 tp''MTA 
                    using assms(12) assms(13) assms(8)  ppp stl21MemSt stl2MCon
                    using assms(7) tp'''MTA by blast
                next
                  case f4:False
                  then have "stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1" using c20  tp'''MTA by simp
                  then show ?thesis using h2 t3 f3 f2 tp''MTA    assms c30 
                    using CompMemType_imps_TypedMemSubPrefPtrs   ppp stl21MemSt stl2MCon
                    by (metis TypedMemSubPrefPtrs_trns tp'''Mcon)
                qed
              next
                case f4:False
                then have h2:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                then show ?thesis 
                proof(cases "p'' = stl1")
                  case True
                  then have h3:"tp''' = MTArray x t" using c20 by simp
                  have "\<exists>dt.
                              CompMemType (memory st) tp'''L tp'''T dt p'' stl2 \<and>
                              CompMemType (memory st) tp''L tp''T dt p' stl2" 
                    using c30 h3 h2 f3 f2 tp''MTA 
                    using CompMemType_imps_TypedMemSubPrefPtrs True assms(12) assms(13) assms(7) tp'''MTA  ppp stl21MemSt stl2MCon
                    by (metis MTypes.inject(1))

                  then show ?thesis 
                    using h3 h2 f3 f2 tp''MTA True   ppp stl21MemSt stl2MCon  CompMemTypeSameLocsSameType
                      MTypes.inject(1) assms(12) assms(7) assms(8) compMemTypes_trns tp'''MTA tp''Mcon

                    by (smt (verit, ccfv_SIG) assms(14) cpm2mLessThanTopMemSame)
                next
                  case False
                  then have h3:"stl1 \<noteq> p'' \<and> tp''' = MTArray  tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x t) p'' stl1" using c20 tp'''MTA by simp
                  have "TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl2" using h2 CompMemType_imps_TypedMemSubPrefPtrs by blast

                  then have "
                              CompMemType (memory st) tp'''L tp'''T tp2 p'' stl2 \<and>
                              CompMemType (memory st) tp''L tp''T tp2 p' stl2" 
                    using c30 h3 CompMemType_imps_TypedMemSubPrefPtrs f3 f2  CompTypeRemainsMCon TypedMemSubPrefPtrs_trns assms(12) assms(13) assms(7) tp'''Mcon  ppp stl21MemSt stl2MCon
                    by (metis CompMemTypeSameLocsSameType h2 tp''Mcon)
                  then show ?thesis 
                    using  h2 f3 f2 tp''MTA  assms(12) assms(7) assms(8) tp'''MTA tp''Mcon ppp stl21MemSt stl2MCon CompMemType_asc_withSharedTarget CompTypeRemainsMCon assms(13) h3 tp'''Mcon

                    by (smt (verit, ccfv_SIG) assms(14) cpm2mLessThanTopMemSame)
                qed
              qed

            qed
          qed
        next
          case (MTValue x2)
          then show ?thesis using c10 c20 by simp
        qed
      next
        case mtvin:(MTValue tp''Val)
        then have e3:"p' \<noteq> stl2" using c10 assms(8) by blast
        then show ?thesis using c10 mtvin by simp
      qed
    qed 
  qed
qed

lemma cpm2mSublocationDoubleArray3:
  assumes "(\<forall>tp' locs p i.
        (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
        (\<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))))"
    and "(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  MTArray x11 x12 \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x11 x12) p' p)))"
    and "stl1 = p"
    and "accessStore l2 sck' = accessStore l2 k'"
    and "(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')"
    and "MTArray x11 x12 = tp1"
    and "MTArray x11' x12' = tp2"
    and "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
    and "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
    and "stl1 \<noteq> stl2"
    and "TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1"
    and "TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1"
    and "\<not>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1"
    and "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2"
    and "(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
    toploc (memory st) \<le> toploc m' \<and> ncpOMemInDMem (memory st) m' \<and> ncpDenvalueLimit ev' ev sck' (stack st) (memory st)  \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m'"
    and "\<exists>y tloc. tloc <toploc (memory st) \<and> LSubPrefL2 (hash stl1 y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
    and "(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"
    and "\<exists> tloc. tloc <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
    and "\<exists> tloc1. tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)"
    and " MCon (MTArray x11 x12) (memory st) stl1"
    and "((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
   (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))"
    and " MCon (MTArray x11' x12') (m') stl2"
  shows "\<exists>dt. CompMemType m' x11' x12' dt stl2 dloc1 \<and> CompMemType m' x11 x12 dt stl1 dloc1"
proof -
  obtain tloc2 where tloc2def:" tloc2 <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2)" using assms(18) by blast
  obtain tloc1 where tloc1def:"tloc1 <toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" using assms(19) by blast
  show ?thesis 
  proof(cases "tloc2< toploc(memory st)")
    case False
    then have "\<not> TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using assms by simp
    have g1:" (\<forall>i loc loc2. i < toploc m' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc m' = Some (MPointer loc2) \<longrightarrow> loc = loc2)" 
      using assms(15) unfolding ncpNewSelfPoint_def by blast
    then have "\<forall>loc2. accessStore stl2 m' = Some (MPointer loc2) \<longrightarrow> stl2 = loc2" using False tloc2def by fastforce
    have g2:"LSubPrefL2 dloc1 stl2 \<and> (\<exists>x. accessStore dloc1 m' = Some x)" using assms(12)   tloc2def   assms(22)
    proof(induction x12' arbitrary:stl2 x11')
      case (MTArray x1 x12)
      then obtain i'' l'' where idef:" (i''<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m' = Some (MPointer l'') 
                \<and> (l'' = dloc1 \<or> TypedMemSubPrefPtrs m' x1 x12 l'' dloc1))" 
        using TypedMemSubPrefPtrs.simps(2)[of m' x11' x1 x12 stl2 dloc1] by blast
      then have g3:"LSubPrefL2 (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc2)" using MTArray LSubPrefL2_def 
        by (metis hash_suffixes_associative)
      then have g2:"l'' = (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using MTArray idef False g1 by fastforce
      then show ?case 
      proof(cases "l'' = dloc1")
        case True
        then show ?thesis using g2 
          using LSubPrefL2_def 
          using idef by blast
      next
        case False
        then have "TypedMemSubPrefPtrs m' x1 x12 l'' dloc1" using idef by simp
        moreover have "MCon (MTArray x1 x12) m' l''" using MTArray idef 
          using CompTypeRemainsMCon CompMemType.simps(2) by blast
        ultimately show ?thesis using MTArray(1)[of x1 l''] g2 idef g3 LSubPrefL2_def 
          using MTArray.prems(2) Not_Sub_More_Specific by blast
      qed
    next
      case (MTValue x)
      then have "(\<exists>i<x11'. hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = dloc1)" 
        using TypedMemSubPrefPtrs.simps(1)[of m' x11' x stl2 dloc1] by simp
      then show ?case using LSubPrefL2_def 
        using MCon_sub_MTVal_imps_val MTValue.prems(3) by blast
    qed
    have g4:"(\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc m')" 
      using assms(15) unfolding ncpOMemInDMem_def by blast
    have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1" 
    proof
      assume asm:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1"
      then show False using tloc1def assms(20)
      proof(induction x12 arbitrary:x11 stl1)
        case (MTArray x1 x12)
        then obtain i l where idef:"(i<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l = dloc1 \<or> TypedMemSubPrefPtrs m' x1 x12 l dloc1))" 
          using TypedMemSubPrefPtrs.simps(2)[of m' x11 x1 x12 stl1 dloc1] by blast 
        then have h1:"LSubPrefL2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" 
          using LSubPrefL2_def MTArray by (metis Not_Sub_More_Specific)
        then have h2:" accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l)" using g4 MTArray idef by auto
        then have h3:"MCon (MTArray x1 x12) (memory st) l" using MTArray(4) idef 
          using CompTypeRemainsMCon CompMemType.simps(2) by blast
        then have h4:"\<exists>x i. accessStore (hash l (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" using MTArray(4) idef MCon_imps_Some h2 
          by (metis mcon_accessStore MCon.simps(2))
        then have h5:"LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" 
          by (smt (verit) False MTArray.prems(1) MTArray.prems(2) MTArray.prems(3) LSubPrefL2_def assms(15) Not_Sub_More_Specific g2 le_neq_implies_less nat_le_linear ncpElementsNoSubPref_def tloc2def)
        then show ?case 
        proof(cases "l = dloc1")
          case True
          then show ?thesis 
            by (smt (verit, del_insts) False LSubPrefL2_def asm assms(15) assms(19) assms(20) Not_Sub_More_Specific g2 linorder_le_less_linear ncpElementsNoSubPref_def tloc2def)
        next
          case False
          then have "TypedMemSubPrefPtrs m' x1 x12 l dloc1" using idef by simp
          then show ?thesis using MTArray(1)[of x1 l] idef h1 h2 h3 h4 h5 
            using tloc1def by blast
        qed
      next
        case (MTValue x)
        then have "(\<exists>i<x11. hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = dloc1)" 
          using TypedMemSubPrefPtrs.simps(1)[of m' x11 x stl1 dloc1] by blast
        then have "LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)" 
          using LSubPrefL2_def MTValue by (metis Not_Sub_More_Specific)
        then have "accessStore dloc1 (memory st) = None" using MTValue g4 g2 False LSubPrefL2_def Not_Sub_More_Specific g2 linorder_le_less_linear tloc2def

          by (metis assms(21))
        then show ?case using MTValue g4 
          using MTValue.prems(2) \<open>LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc1)\<close> by fastforce
      qed
    qed

    then show ?thesis using assms LSubPrefL2_def g2 tloc1def by blast
  next
    case True

    then obtain tp'' loc2 p' where  c10:"
       (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl2 \<and> tp'' = tp2 \<or>
       (\<exists>len arr. p' \<noteq> stl2 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl2))" 
      using  assms(1,4,5)  assms tloc2def  by metis
    obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                  \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                   (tp''' = MTArray x11 x12 \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x11 x12) p'' stl1))" 
      using  extractValueType.simps(3) assms    by blast
    have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by simp
    then  have c30:"(if p' = p'' then tp'' = tp'''
           else case tp'' of
              MTArray len arr \<Rightarrow>
                (case tp''' of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                  else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                  else if TypedMemSubPrefPtrs (memory st) len arr p' dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' dloc1
                      then \<exists>dt.
                              CompMemType (memory st) len2 arr2 dt p'' dloc1 \<and>
                              CompMemType (memory st) len arr dt p' dloc1 
                  else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
              | MTValue val \<Rightarrow>
                  (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                 | MTValue val2 \<Rightarrow> True))" using assms unfolding TypeSafe_def compMemPtrs_def by simp
    have ppp:" (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
  toploc (memory st) \<le> toploc m' \<and>
  (\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc m') \<and>
  (\<forall>tp' locs p i.
      (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev') \<and> accessStore locs sck' = Some (KMemptr p) \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
      (\<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p)))) \<and>
  (\<forall>i l1 t1 l2 t2 loc i2 loc2.
      i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc \<longrightarrow>
      \<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2) \<and>
  ncpNewSelfPoint (memory st) m'" using assms(15) unfolding ncpDenvalueLimit_def ncpOMemInDMem_def ncpElementsNoSubPref_def by blast


    have tp'''Mcon:"MCon tp''' (memory st) p''" using c20 unfolding TypeSafe_def
      by (metis assms(9) sameMemTSafe)
    have tp''Mcon:"MCon tp'' (memory st) p'" using c10 unfolding TypeSafe_def 
      by (metis assms(9) sameMemTSafe)

    have stl2MCon:"MCon (MTArray x11 x12) (memory st) stl1" using  c20  assms  CompTypeRemainsMCon  
      by (metis)

    have k2:"MCon (MTArray x11' x12') (memory st) stl2" using tp''Mcon c10
      using CompTypeRemainsMCon assms(7)  by blast
    then have k21:"MCon (MTArray x11' x12') m' stl2" using ppp by blast
    have k3:"MCon (MTArray x11 x12) (memory st) stl1" using tp'''Mcon  
      using CompTypeRemainsMCon assms  c20 by blast
    then have k31:"MCon (MTArray x11 x12) m' stl1" using ppp by blast
    then have k4:"\<nexists>a1 a2. x12 = MTValue a1 \<or> x12' = MTValue a2" using sharedLocationsParentsMustBeArray assms(14,13,15,10,12,11,9) k2 k3 by blast

    have k5: "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1" using assms(11) 
      by (smt (verit, ccfv_SIG) assms(12) assms(13) assms(17) cpm2mLessThanTopTypedMem ppp stl2MCon)
    have k6:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1"  
      using assms(12)  assms(12) assms(13) assms(17) cpm2mLessThanTopTypedMem ppp 
      by (smt (verit, ccfv_threshold) assms(11) assms(14) k2)


    then show ?thesis
    proof(cases "p' = p''")
      case parentSame:True
      then have sameParentType:"tp''=tp'''" using c30 by simp
      then show ?thesis
      proof(cases "p' = stl2")
        case True
        then have j1:"tp'' = (MTArray x11' x12')" using assms c10 by simp
        then have j2:"tp''' = (MTArray x11' x12')" using sameParentType by simp

        then show ?thesis 
        proof(cases "p'' =stl1")
          case t2:True
          then show ?thesis using parentSame assms(10) True by simp
        next
          case False
          then have "stl1 \<noteq> p'' \<and> tp''' = MTArray x11' x12' \<and> CompMemType (memory st) x11' x12' (MTArray x11 x12) p'' stl1" using c20 j2 by auto
          then have " CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
            using True  assms parentSame by auto
          then have "CompMemType (m') x11' x12' (MTArray x11 x12) stl2 stl1" using assms ppp 
            by (metis (no_types, lifting) cpm2mLessThanTopMemSame)
          then show ?thesis using assms 
            using CompMemType_imps_TypedMemSubPrefPtrs by simp 
        qed
      next
        case f4:False
        then show ?thesis 
        proof(cases "p'' = stl1")
          case t2:True
          then have j4:"p' = stl1" using parentSame by simp
          then have j3:"tp''' = MTArray x11 x12" using c20 t2 by simp
          then have j5:"(p' \<noteq> stl2 \<and> tp'' = MTArray x11 x12 \<and> CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2)" using sameParentType c10 f4 assms j4 sameParentType by blast
          then have j7:"CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" by simp
          then have j12:"CompMemJustType (MTArray x11 x12) (MTArray x11' x12')"  
            using CompMemType_imps_CompMemJustType by blast
          have j8:"MCon (MTArray x11 x12) (memory st) stl1" using tp'''Mcon j3 t2 by blast
          have j10:"MCon (MTArray x11' x12') (memory st) stl2" 
            using CompTypeRemainsMCon j5 j8 by blast
          have " CompMemType m' x11 x12 (MTArray x11' x12') stl1 stl2" using j5 ppp assms cpm2mLessThanTopMemSame 
            by (metis (no_types, lifting))
          then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using j5 
            using CompMemType_imps_TypedMemSubPrefPtrs by auto
          then show ?thesis using  j7 j8 j10 j12 
            using assms by blast
        next
          case f5:False
          then obtain x'' t'' where x''def:"(p' \<noteq> stl2 \<and> tp'' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x11' x12') p' stl2)" using sameParentType c10 f4 assms by blast
          then have k01:"CompMemType m' x'' t'' (MTArray x11' x12') p' stl2"using ppp stl2MCon 
            using assms(17) cpm2mLessThanTopMemSame 
            by meson
          then have  k0:"stl1 \<noteq> p' \<and> tp''' = MTArray x'' t'' \<and> CompMemType (memory st) x'' t'' (MTArray x11 x12) p' stl1" using c20 x''def sameParentType parentSame f5 assms by simp
          then have k1:" CompMemType m' x'' t'' (MTArray x11 x12) p' stl1" using ppp stl2MCon 
            using assms(17) cpm2mLessThanTopMemSame 
            by meson
          have k2:"MCon (MTArray x11' x12') (m') stl2" using tp''Mcon x''def stl2MCon 
            using CompTypeRemainsMCon ppp by meson
          have k3:"MCon (MTArray x11 x12) m' stl1" using tp'''Mcon x''def k1
            using CompTypeRemainsMCon parentSame assms ppp stl2MCon by  blast
          then have k4:"\<nexists>a1 a2. x12 = MTValue a1 \<or> x12' = MTValue a2" using sharedLocationsParentsMustBeArray assms(14,13,15,12,11,10) k1 k3 k2 by blast
          have "stl1 \<noteq> dloc1 \<and> stl2 \<noteq> dloc1" 
            using assms by auto

          moreover have "MCon tp''' m' p'" 
            by (simp add: parentSame ppp tp'''Mcon)
          ultimately show ?thesis using sharedParentSharedSubLocTypes k4 k01 k0 k1 k2 k3 assms(11,12) 
            by metis

        qed
      qed
    next
      case parentNotSame:False
      then show ?thesis
      proof(cases tp'')
        case tp''MTA:(MTArray tp''L tp''T)
        then show ?thesis 
        proof(cases tp''')
          case tp'''MTA:(MTArray tp'''L tp'''T)
          then have c30:"if TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p' then CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'
                    else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p'' then CompMemType (memory st) tp''L tp''T (MTArray  tp'''L tp'''T) p' p''
                     else if TypedMemSubPrefPtrs (memory st) tp''L tp''T p' dloc1 \<and> TypedMemSubPrefPtrs (memory st)  tp'''L tp'''T p'' dloc1
                          then \<exists>dt.
                                  CompMemType (memory st)  tp'''L tp'''T dt p'' dloc1 \<and>
                                  CompMemType (memory st) tp''L tp''T dt p' dloc1 
                          else True" 
            using c30 parentNotSame tp''MTA  by simp
          then show ?thesis 
          proof(cases "TypedMemSubPrefPtrs (memory st) tp'''L tp'''T p'' p'")
            case t5:True
            then have h1:"CompMemType (memory st)  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'" using c30 by simp
            have h11:"CompMemType m'  tp'''L tp'''T (MTArray tp''L tp''T) p'' p'" using h1 ppp stl2MCon assms(17) cpm2mLessThanTopMemSame 
              by meson

            then show ?thesis
            proof(cases "p' = stl2")
              case t6:True
              then have "tp'' = MTArray tp''L tp''T" using c10 tp''MTA by auto
              then show ?thesis 
              proof(cases "p'' = stl1")
                case t7:True
                then have "tp''' = MTArray x11 x12" using c20 by simp
                moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1"

                  using k5 by auto
                moreover have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" 
                  by (simp add: k6)
                ultimately have tt:"\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                  using t6 t7 c10 h1 t5 tp'''MTA assms 
                  by (smt (verit, ccfv_threshold) MTypes.inject(1) compMemTypes_trns sharedLocationsParentsMustBeArray sharedParentSharedSubLocTypes stl2MCon tp''MTA tp''Mcon) 
                then have "\<exists>dt. CompMemType m' x11' x12' dt stl2 dloc1" using   cpm2mLessThanTopMemSame[of st m'] ppp assms by metis
                moreover have "\<exists>dt. CompMemType m' x11 x12 dt stl1 dloc1" using   tt cpm2mLessThanTopMemSame[of st m'] ppp assms by metis
                ultimately show ?thesis 
                  using CompMemType_imps_TypedMemSubPrefPtrs \<open>tp''' = MTArray x11 x12\<close> assms(14) h11 t6 t7 tp'''MTA by blast
              next
                case False
                then have h2:"(p'' \<noteq> stl1 \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11 x12) p'' stl1)" using c20 tp'''MTA assms by blast
                then have h21:" CompMemType m' tp'''L tp'''T (MTArray x11 x12) p'' stl1" 
                  using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
                have h3:"CompMemType (memory st)  tp'''L tp'''T (MTArray x11' x12') p'' stl2" using h1 t6 c10 tp''MTA assms by simp
                then have h31:"CompMemType m'  tp'''L tp'''T (MTArray x11' x12') p'' stl2"  
                  using CompMemTypeSameLocsSameType h1 h11 t6 tp'''MTA tp'''Mcon by blast
                have k2:"MCon (MTArray x11' x12') (memory st) stl2" using tp''Mcon c10
                  using CompTypeRemainsMCon assms(7)  by blast
                then have k21:"MCon (MTArray x11' x12') m' stl2" using ppp by blast
                have k3:"MCon (MTArray x11 x12) (memory st) stl1" using tp'''Mcon  
                  using CompTypeRemainsMCon assms  c20 by blast
                then have k31:"MCon (MTArray x11 x12) m' stl1" using ppp by blast
                then have k4:"\<nexists>a1 a2. x12 = MTValue a1 \<or> x12' = MTValue a2" using sharedLocationsParentsMustBeArray assms(14,13,15,10,12,11,9) k3 k2 by blast
                have "stl1 \<noteq> dloc1 \<and> stl2 \<noteq> dloc1" 
                  using assms by auto
                then show ?thesis  
                  using False assms(11) assms(12) assms(15) h21 h31 k21 k31 k4 sharedParentSharedSubLocTypes tp'''MTA tp'''Mcon by blast


              qed
            next
              case f6:False
              then have h2:"(p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2)" using c10 tp''MTA by simp
              then have h21:"CompMemType m' tp''L tp''T tp2 p' stl2" 
                using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
              then show ?thesis 
              proof(cases "p'' = stl1")
                case t6:True
                then have "tp''' = MTArray x11 x12" using c20 by simp
                then show ?thesis using t6 h21 h11  CompMemType_imps_TypedMemSubPrefPtrs MTypes.inject(1) TypedMemSubPrefPtrs_trns assms  tp'''MTA tp'''Mcon tp''Mcon 
                  by (metis compMemTypes_trns)
              next
                case False
                then have k0:"(stl1 \<noteq> p'' \<and> tp''' =MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11 x12) p'' stl1)" using c20 
                  by (simp add: tp'''MTA)
                then have k1:"CompMemType (m') tp'''L tp'''T (MTArray x11 x12) p'' stl1" 
                  using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast

                then show ?thesis 
                  by (smt (verit, ccfv_SIG) CompMemType_asc_withSharedTarget MConPtrsMustBeSubLocs2 assms(11) assms(12) assms(15) assms(7) compMemTypes_trns h11 h21 k2 k31 k4 sharedParentSharedSubLocTypes tp'''MTA tp'''Mcon)
              qed
            qed


          next
            case f2:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) tp''L tp''T p' p''")
              case t5:True
              then have h1:"CompMemType (memory st) tp''L tp''T (MTArray tp'''L tp'''T) p' p''" using c30 f2 parentNotSame by simp
              then have h11:"CompMemType m' tp''L tp''T (MTArray tp'''L tp'''T) p' p''" 
                using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
              then show ?thesis 
              proof(cases "p'' = stl1")
                case t6:True
                then have h2:"(MTArray tp'''L tp'''T) = MTArray x11 x12" using c20 tp'''MTA by simp
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  then have "CompMemType (memory st)  x11' x12' (MTArray x11 x12) stl2 stl1" using t6 True h3 h2 h1 
                    using assms f2 t5 by blast
                  then have "CompMemType m'  x11' x12' (MTArray x11 x12) stl2 stl1" 
                    using True h11 h2 h3 t6 by blast
                  then show ?thesis using     assms CompMemType_imps_TypedMemSubPrefPtrs by auto

                next
                  case False
                  then have k0:"p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st)tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                  then have "CompMemType m' tp''L tp''T tp2 p' stl2" 
                    using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
                  then show ?thesis 
                    by (metis False assms(11) assms(12) assms(15) assms(7) h11 h2 sharedParentSharedSubLocTypes t6 tp''MTA tp''Mcon)
                qed
              next
                case p''NotStl1:False
                then have h2:"(stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11 x12) p'' stl1)" using c20 tp'''MTA by simp
                then have h21:"CompMemType m' tp'''L tp'''T (MTArray x11 x12) p'' stl1" 
                  using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
                then show ?thesis 
                proof(cases "p' = stl2")
                  case True
                  then have h3:"MTArray tp''L tp''T =  MTArray x11' x12'" using c10 assms tp''MTA by blast
                  have "TypedMemSubPrefPtrs (memory st)  tp''L tp''T stl2 p''" using t5 h2 True by simp
                  then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using h1 h2 h3 True p''NotStl1 
                    using  CompTypeRemainsMCon  tp'''Mcon 
                    by (metis MTypes.inject(1) compMemTypes_trns)
                  then have "CompMemType m' x11' x12' (MTArray x11 x12) stl2 stl1" 
                    by (metis MTypes.inject(1) True compMemTypes_trns h11 h21 h3)
                  then show ?thesis using parentNotSame assms 
                    by (metis CompMemType_imps_TypedMemSubPrefPtrs)
                next
                  case False
                  then have h3:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by auto
                  moreover have "CompMemType m' tp''L tp''T tp2 p' stl2" 
                    using assms(15) assms(17) cpm2mLessThanTopMemSame h3 ncpOMemInDMem_def by blast

                  ultimately show ?thesis 
                    by (smt (verit, best) assms(11) assms(12) assms(13) assms(14) assms(15) assms(7) compMemTypes_trns h11 h21 k21 k31 k4 sharedParentSharedSubLocTypes tp''Mcon)
                qed
              qed
            next
              case f3:False
              then show ?thesis 
              proof(cases "p' = stl2")
                case t3:True
                then have h2:"tp'' = tp2" using c10 by simp
                then show ?thesis
                proof(cases "p''=stl1")
                  case t4:True
                  then have h3:"tp''' = MTArray x11 x12" using c20 by simp
                  then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"

                    using assms(7) c30 f2 f3 h2 k5 k6 t3 t4 tp'''MTA tp''MTA by force
                  then show ?thesis using cpm2mLessThanTopMemSame[of st m'] ppp assms(17)
                    by metis
                next
                  case f4:False
                  then have "stl1 \<noteq> p'' \<and> tp''' = MTArray tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11 x12) p'' stl1" using c20  tp'''MTA by simp
                  then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"  
                    by (metis CompMemType_asc_withSharedTarget CompTypeRemainsMCon MTypes.inject(1) TypedMemSubPrefPtrs_trns assms(7) c30 f2 f3 h2 k5 k6 t3 tp'''Mcon tp''MTA)

                  then show ?thesis using ppp assms(17) cpm2mLessThanTopMemSame[of st m']  by metis
                qed
              next
                case f4:False
                then have h2:" p' \<noteq> stl2 \<and> tp'' = MTArray tp''L tp''T \<and> CompMemType (memory st) tp''L tp''T tp2 p' stl2" using c10 tp''MTA by simp
                then have h21:" CompMemType m' tp''L tp''T tp2 p' stl2" 
                  using assms(15) assms(17) cpm2mLessThanTopMemSame ncpOMemInDMem_def by blast
                then show ?thesis 
                proof(cases "p'' = stl1")
                  case True
                  then have h3:"tp''' = MTArray x11 x12" using c20 by simp
                  have "MCon tp'' m' p'" using tp''Mcon 
                    using ppp by auto
                  obtain dt where " CompMemType (memory st) tp''L tp''T dt p' dloc1" 
                    by (metis assms(7) compMemTypes_trns h2 k6 sharedParentSharedSubLocTypes tp''Mcon)
                  moreover have "CompMemType (memory st) x11' x12' dt stl2 dloc1" 
                    using calculation  CompMemType_asc_withSharedTarget[of "memory st" tp''L tp''T x11' x12' p' stl2 dt dloc1] h2 assms(7,12) 

                    using CompTypeRemainsMCon k6 tp''Mcon by blast
                  moreover have "CompMemType (memory st) x11 x12 dt stl1 dloc1"  using h3 True assms f2 f3 h3 k2 k5 ppp c30 
                      calculation 
                    by (metis CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs MTypes.inject(1) tp'''MTA tp''MTA tp''Mcon)
                  ultimately have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                    by auto
                  then show ?thesis using ppp assms(17) stl2MCon cpm2mLessThanTopMemSame[of st m']
                    by metis
                next
                  case False
                  then have h3:"stl1 \<noteq> p'' \<and> tp''' = MTArray  tp'''L tp'''T \<and> CompMemType (memory st) tp'''L tp'''T (MTArray x11 x12) p'' stl1" using c20 tp'''MTA by simp
                  have h4:"TypedMemSubPrefPtrs (memory st) tp''L tp''T  p' stl2" using h2 CompMemType_imps_TypedMemSubPrefPtrs by blast
                  then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" using assms(7) k5 k6 using h4 h3 h2 f3 f2 tp''MTA     CompMemType_imps_TypedMemSubPrefPtrs CompMemType_asc_withSharedTarget CompTypeRemainsMCon TypedMemSubPrefPtrs_trns c30 tp'''Mcon tp''Mcon
                    by (metis )
                  then show ?thesis using ppp assms(17) cpm2mLessThanTopMemSame[of st m']  by metis
                qed
              qed

            qed
          qed
        next
          case (MTValue x2)
          then show ?thesis using c10 c20 by simp
        qed
      next
        case mtvin:(MTValue tp''Val)
        then have e3:"p' \<noteq> stl2" using c10 assms(7) by blast
        then show ?thesis using c10 mtvin by simp
      qed
    qed 
  qed
qed

lemma iter_ind:              
  assumes "iter f v 0 = v \<Longrightarrow> P 0 v"
    "\<And>x v''. (\<exists>v'. iter f v x = v' \<and> P x v' \<and> f x v' = v'') \<Longrightarrow> iter f v (Suc x) = v'' \<Longrightarrow> P (Suc x) v''"
  shows "iter f v x = v' \<Longrightarrow> P x v'" 
 apply (induction x arbitrary: v') using assms apply fastforce
proof -
  fix x v'
  assume xx:"\<And>v'. iter f v x = v' \<Longrightarrow> P x v'" and
    *: "iter f v (Suc x) = v'"

  from * obtain v'' where "f (Suc x-1) v'' = v'" and "iter f v x = v''" using iter.simps[of f v "Suc x"] by (auto split: option.split_asm)
  then have yy:"f x v'' = v'" and "iter f v x = v''" by simp+
  then show  "P (Suc x) v'" using assms(2)[OF _ *]  xx by blast
qed


lemma minitRec_SubPrefixes:
  "minitRec destl tp v' = v''' \<longrightarrow>
  (\<forall>destl'. (\<not>LSubPrefL2 destl' destl) \<longrightarrow> accessStore destl' v' = accessStore destl' v''')"
proof(induction tp arbitrary:destl v' v''' )
  case (MTArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume **:" minitRec destl (MTArray x1 t) v' = v'''"

    then have a5:"v''' = (let m = updateStore destl (MPointer destl) v' in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1)"
      using **  by (simp add: minitRec.simps(1))
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) v'" by auto
    have a20:"\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' v' = accessStore destl' m"
    proof -
      assume "\<not> LSubPrefL2 destl' destl"
      then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] by auto
      then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
      then show "accessStore destl' v' = accessStore destl' m" using mdef unfolding accessStore_def updateStore_def by auto
    qed

    then have v''def:"v''' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a5 mdef by metis 
    show "\<not> LSubPrefL2 destl' destl \<Longrightarrow> accessStore destl' v' = accessStore destl' v'''" using a20
    proof(induction rule: iter_ind[OF _ _ v''def[symmetric]]) 
      case (1)
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v2
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v2"
          and a20:"(\<not> LSubPrefL2 destl' destl \<longrightarrow>
          (\<not> LSubPrefL2 destl' destl \<longrightarrow> accessStore destl' v' = accessStore destl' m) \<longrightarrow> accessStore destl' v' = accessStore destl' v2)"
          and a30:"  minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v2 = v''" by blast
      then have b40:"accessStore destl' v' = accessStore destl' v2" using 2 by blast
      then show ?case
      proof(cases t)
        case mtr:(MTArray x11 x12)
        then have b10:"v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v2 in iter (\<lambda>i. minitRec (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m x11)"
          using a30 minitRec.simps(1)[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12] by simp

        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v2 = accessStore destl' v'')" 
          using MTArray mtr a30 by blast
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by blast
        then show ?thesis using b45 b40 by simp
      next
        case (MTValue x2)
        then have "v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v2" 
          using minitRec.simps(2)[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2] a30 by simp
        
        then have b45:"(\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v2 = accessStore destl' v'')" 
          using MTArray MTValue a30 by blast
        have "\<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using Not_Sub_More_Specific 2 by blast
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45 
          using b40 by auto
        then show ?thesis using b40 by simp
      qed
    qed
  qed
next
  case (MTValue x)
  show ?case
  proof intros
    fix destl'
    assume **:" minitRec destl (MTValue x) v' = v'''"
      and ***:"\<not> LSubPrefL2 destl' destl"

    then have mdef:"v''' = updateStore destl (MValue (ival x)) v'" using minitRec.simps(2)[of destl x ] by simp
    then have "\<not>((\<exists>i. destl' = hash destl i) \<or> destl' = destl)" using LSubPrefL2_def[of destl' destl] *** by auto
    then have "(\<forall>i. destl' \<noteq> hash destl i) \<and> destl' \<noteq> destl" by simp
    then show " accessStore destl' v' = accessStore destl' v'''" 
      using mdef unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma minitSingleChange:
  assumes "iter (\<lambda>i m'' . minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') m x = updM"
  shows "\<forall>t' locs. \<not>LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStore locs m = accessStore locs updM"
proof(induction rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter (\<lambda>i. minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
      and a20:"(\<forall>t' locs. \<not> LSubPrefL2 locs ld \<or> locs = ld \<longrightarrow> accessStore locs m = accessStore locs v') "
      and a30:"minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
  show ?case 
  proof intros
    fix locs t'
    assume *:"\<not> LSubPrefL2 locs ld \<or> locs = ld"
    then have "accessStore locs m = accessStore locs v'" using a20  by simp
    then show "accessStore locs m = accessStore locs v''" 
      using minitRec_SubPrefixes  a30 * Not_Sub_More_Specific 
      by (metis LSubPrefL2_def hash_inequality hash_suffixes_associative)
  qed
qed

lemma minitRec_SubPrefixes2:
  "minitRec destl tp a = v''' \<longrightarrow>
  (\<forall>destl'. destl' \<noteq> destl \<and> (\<not> TypedMemSubPref destl' destl tp) \<longrightarrow> accessStore destl' a = accessStore destl' v''')" 
proof(induction tp arbitrary:destl a v''' )
  case (MTArray x1 t)
  show ?case
  proof intros
    fix destl'
    assume **:"minitRec destl (MTArray x1 t) a = v'''"
    
    have a5:"(let m = updateStore destl (MPointer destl) a in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1) = v'''" 
      using **  unfolding minitRec.simps by simp
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto
    have a20:"destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' m"
    proof -
      assume asm:"destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t)"
      then have "\<not>(\<exists>i<x1. TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> destl' = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" 
        using TypedMemSubPref.simps(2)[of destl' destl x1 t] by auto
      then have "(\<forall>i<x1. \<not>TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<and> destl' \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      then show "accessStore destl' a = accessStore destl' m" using mdef asm unfolding accessStore_def updateStore_def by  auto
    qed

    then have v''def:"v''' =  iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" 
      using a5 mdef by metis 
    show "destl'  \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x1 t) \<Longrightarrow> accessStore destl' a = accessStore destl' v'''" using a20 
    proof(induction rule: iter_ind[OF _ _ v''def[symmetric]]) 
      case (1)
      then show ?case using 1 by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
          and a20:"(destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x t) \<longrightarrow>
          (destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTArray x t) \<longrightarrow> accessStore destl' a = accessStore destl' m) \<longrightarrow>
          accessStore destl' a = accessStore destl' v')"
          and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
      then have b40:"accessStore destl' a = accessStore destl' v'" using 2 
        by (metis less_Suc_eq TypedMemSubPref.simps(2))
      then show ?case
      proof(cases t)
        case mtr:(MTArray x11 x12)
        then have b10:"v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter (\<lambda>i. minitRec (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m x11)"
          using a30 minitRec.simps(1)[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12] by simp

        then have b45:"(\<forall>destl'. destl' \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> \<not> TypedMemSubPref destl'(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray mtr a30 by blast
        have "\<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using 2 
           using TypedMemSubPref.simps(2) by blast
        then show ?thesis using b45 b40  
          using "2.prems"(1) by force
      next
        case (MTValue x2)
        then have "v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'" 
          using minitRec.simps(2)[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2] using a30 by simp
        then have b45:"(\<forall>destl'. destl' \<noteq>  (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                        \<and> \<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t 
                        \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
          using MTArray MTValue a30 by blast
        have "\<not> TypedMemSubPref destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t" using 2 
          using TypedMemSubPref.simps(2) by blast
        then have b50:"accessStore destl' v' = accessStore destl' v''" using b45
          by (simp add: MTValue)
        then show ?thesis using b40  by simp
      qed
    qed
  qed
next
  case (MTValue x)
  show ?case
  proof intros
    fix destl'
    assume **:" minitRec destl (MTValue x) a = v'''"
    assume ***:"destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTValue x)"
    then have mdef:"v''' = updateStore destl (MValue (ival x)) a" 
      using ** minitRec.simps(2)[of destl x] by simp
    assume ***:" destl' \<noteq> destl \<and> \<not> TypedMemSubPref destl' destl (MTValue x)"
    then show "accessStore destl' a = accessStore destl' v'''" 
      using mdef unfolding accessStore_def updateStore_def 
      by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma minitSingleChange2:
  assumes "iter (\<lambda>i m'' . minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') m x = updM"
  shows "\<forall>locs.  \<not>TypedMemSubPref locs ld (MTArray x t) \<or> locs = ld \<longrightarrow> accessStore locs m = accessStore locs updM"
proof(induction rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter (\<lambda>i. minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
      and a20:"(\<forall>locs. \<not> TypedMemSubPref locs ld (MTArray x t) \<or> locs = ld \<longrightarrow> accessStore locs m = accessStore locs v')"
      and a30:"minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
  show ?case 
  proof intros
    fix locs 
    assume *:"\<not> TypedMemSubPref locs ld (MTArray (Suc x) t) \<or> locs = ld"
    then have "accessStore locs m =  accessStore locs v'" using a20 by auto
    then show "accessStore locs m = accessStore locs v''" using minitRec_SubPrefixes2 
      using "*" a30 
      by (metis LSubPrefL2_def hash_inequality hash_suffixes_associative lessI minitRec_SubPrefixes TypedMemSubPref.simps(2))
  qed
qed


lemma minitRecPtrsPointToSelf:
  shows "minitRec destl t destm = v'
          \<longrightarrow>  (\<forall>l l'. (TypedMemSubPref l destl t \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"
proof(induction t arbitrary: destl destm v')
  case (MTArray x1 t)
  show ?case
  proof intros
    fix l l'
    assume *:"minitRec destl (MTArray x1 t) destm = v'"
      and **:"(TypedMemSubPref l destl (MTArray x1 t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have a10:"v' = (let m = updateStore destl (MPointer destl) destm in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1)"
      using * minitRec.simps(1)[of destl x1 t ] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    then have a50:"v' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a10 a40 by presburger
    show "l' = l" using a45 **
    proof(induction rule: iter_ind[OF _ _ a50[symmetric]])
      case (1)
      then show ?case by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
          and a20:"(accessStore destl m = Some (MPointer destl) \<longrightarrow>
          (TypedMemSubPref l destl (MTArray x t) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"
          and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
      then have "accessStore destl m = Some (MPointer destl)" using 2 by blast
      then show ?case 
      proof(cases "l = destl")
        case True
        then show ?thesis using 2(1,3,4) 
          by (metis MTArray minitRec_SubPrefixes2)
      next
        case f1:False
        then show ?thesis 
        proof(cases "TypedMemSubPref l destl (MTArray x t)")
          case True
          then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
          then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
          then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
            by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
          have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
          then have b50:"accessStore l v' = accessStore l v''" 
            using * a30 by (meson minitRec_SubPrefixes)
          then show ?thesis using a20 2 using True by argo
        next
          case False
          then have b5:"TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using 2(4) TypedMemSubPref.simps(2)[of l destl "(Suc x)" t] f1 
            using less_Suc_eq by auto
          have b10:"accessStore l v'' = Some (MPointer l')" using 2(4) by auto

          have "(\<forall>l l'. (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> accessStore l v'' = Some (MPointer l') \<longrightarrow> l' = l)" 
            using  MTArray[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"] a30 by simp
          then show ?thesis using b5 b10 by blast
        qed
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix l l'
    assume *:"minitRec destl (MTValue x) destm = v'" 
      and **:"(TypedMemSubPref l destl (MTValue x) \<or> l = destl) \<and> accessStore l v' = Some (MPointer l')"
    have "v' =updateStore destl (MValue (ival x)) destm" 
      using minitRec.simps(2)[of destl x ] * by simp
    then obtain v where b10: "accessStore destl v' = Some (MValue v)" by (auto split:option.splits Memoryvalue.splits)
    show "l' = l" using b10 ** by auto
  qed
qed

lemma minitSelfPointers:
  assumes "iter (\<lambda>i m''. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') m x1 = v'"
  shows "(\<forall>l l'. TypedMemSubPref l destl (MTArray x1 t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)"  using assms(1)
proof(induction  rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10: "iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
      and a20: "(iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v' \<longrightarrow>
          (\<forall>l l'. TypedMemSubPref l destl (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l))"
      and a30: "minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
  show ?case 
  proof intros
    fix l l'
    assume *:"TypedMemSubPref l destl (MTArray (Suc x) t) \<and> accessStore l v'' = Some (MPointer l')"
    show "l' = l"
    proof(cases t)
      case (MTArray x11 x12)

      then show ?thesis 
      proof(cases "TypedMemSubPref l destl (MTArray x t)")
        case True
        then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
        then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
        then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
          by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
        have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
        then have b50:"accessStore l v' = accessStore l v''" 
          using * minitRec_SubPrefixes a30 by blast
        then show ?thesis using a20 True *  b50 
          using a10 by presburger
      next
        case False
        then have "TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" 
          using TypedMemSubPref.simps(2)[of l destl "(Suc x)" t] *
          using less_Suc_eq by auto
        then show ?thesis using a30 minitRecPtrsPointToSelf * by blast
      qed
    next
      case (MTValue x2)
      then have "v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'" 
        using a30 minitRec.simps(2)[of   "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 ] by simp
      have "(\<exists>i<Suc x. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t  \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using TypedMemSubPref.simps(2)[of l destl "Suc x" t] * by auto
      then obtain i where b400:"i< Suc x \<and> TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (MTValue x2)" using MTValue by auto
      then have "l =  (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" by simp
      
      then show ?thesis using  * MTValue \<open>v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'\<close> 
            a10 a20 accessStore_non_changed b400  less_Suc_eq
            minitRec.simps(2) minitRecPtrsPointToSelf
        by (metis TypedMemSubPref.simps(2))
    qed
  qed
qed

lemma minitRecValueTypeCon:
  shows "\<forall>st. minitRec destl t destm = v' \<longrightarrow> CompMemJustType t (MTValue st)
          \<longrightarrow>  (\<forall>l l'. (TypedMemSubPref l destl t \<or> l = destl) \<and> accessStore l v' = Some (MValue l') \<longrightarrow> typeCon st l')"
proof(induction t arbitrary: destl destm v')
  case (MTArray x1 t)
  show ?case
  proof intros
    fix l l' st
    assume *:"minitRec destl (MTArray x1 t) destm = v'"
      and ***:"CompMemJustType (MTArray x1 t) (MTValue st)"
      and **:"(TypedMemSubPref l destl (MTArray x1 t) \<or> l = destl) \<and> accessStore l v' = Some (MValue l')"
    have a10:"v' = (let m = updateStore destl (MPointer destl) destm in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1)"
      using * minitRec.simps(1)[of destl x1 t ] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    then have a50:"v' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a10 a40 by presburger
    show "typeCon st l'" using a45 ** ***
    proof(induction rule: iter_ind[OF _ _ a50[symmetric]])
      case (1)
      then show ?case by auto
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
          and a20:"(accessStore destl m = Some (MPointer destl) \<longrightarrow>
          (TypedMemSubPref l destl (MTArray x t) \<or> l = destl) \<and> accessStore l v' = Some (MValue l') \<longrightarrow>
          CompMemJustType (MTArray x t) (MTValue st) \<longrightarrow> typeCon st l')"
          and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
      then have "accessStore destl m = Some (MPointer destl)" using 2 by blast
      then show ?case 
      proof(cases "l = destl")
        case True
        then show ?thesis using a20 2 
          by (metis MTArray MTypes.distinct(1) minitRec_SubPrefixes2 CompMemJustType.simps(2))
      next
        case f1:False
        then show ?thesis 
        proof(cases "TypedMemSubPref l destl (MTArray x t)")
          case True
          then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
          then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
          then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
            by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
          have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
          then have b50:"accessStore l v' = accessStore l v''" 
            using * a30 by (meson minitRec_SubPrefixes)
          then show ?thesis using a20 2 using True 
            by (metis MTypes.distinct(1) CompMemJustType.simps(2))
        next
          case False
          then have b5:"TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t 
          \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using 2(4) TypedMemSubPref.simps(2)[of l destl "(Suc x)" t] f1 
            using less_Suc_eq by auto
          have b10:"accessStore l v'' = Some (MValue l')" using 2(4) by auto

          have "(\<forall>l l'. (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> accessStore l v'' = Some (MValue l') \<longrightarrow> typeCon st l')" 
            using  MTArray[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] a30 
            using "***" CompMemJustType.simps(2) by blast
          then show ?thesis using b5 b10 by blast
        qed
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix l l' st
    assume *:"minitRec destl (MTValue x) destm = v'" 
      and ***:"CompMemJustType (MTValue x) (MTValue st)"
      and **:"(TypedMemSubPref l destl (MTValue x) \<or> l = destl) \<and> accessStore l v' = Some (MValue l')"
    have "v' =updateStore destl (MValue (ival x)) destm" 
      using minitRec.simps(2)[of destl x ] * by simp
    then obtain v where b10: "accessStore destl v' = Some (MValue v)" by (auto split:option.splits Memoryvalue.splits)
    show " typeCon st l' " using b10 ** MTValue 
      using "*" "***" ivalTypeCon minitRec.simps(2) by force
  qed
qed

lemma minitRecMCon :
  "minitRec destl tp a = v''' \<longrightarrow> arraysGreaterZero tp
          \<longrightarrow> MCon tp v''' destl"
proof (induction tp arbitrary:destl a v''')
  case (MTArray x1 t)
  show ?case
  proof intros
    assume **:"minitRec destl (MTArray x1 t) a = v'''"
    and ***:"arraysGreaterZero (MTArray x1 t)"
    then have a5:"(let m = updateStore destl (MPointer destl) a in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1) = v'''" 
      using **  minitRec.simps(1)[of destl x1 t ] by simp
    then obtain m where mdef:"m =  updateStore destl (MPointer destl) a" by auto

(*We know this specific subset of srcMem is Mcon*)
    then show " MCon (MTArray x1 t) v''' destl"
    proof(cases "x1>0")
      case True
      then have agt:"arraysGreaterZero t" 
        using *** unfolding arraysGreaterZero.simps by auto
      have v''def:"v''' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a5 mdef by metis 

      have "\<forall>i<x1. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''' of None \<Rightarrow> False 
             | Some (MValue val) \<Rightarrow> (case t of MTValue typ \<Rightarrow> MCon t v''' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v''' loc2 | MTValue Types \<Rightarrow> False)"
        
      proof(induction rule: iter_ind[OF _ _ v''def[symmetric]])
        case (1)
        then show ?case by simp
      next
        case (2 x v'')
        then obtain v'
          where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
            and a20:"(\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False
                | Some (MValue val) \<Rightarrow> (case t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False))"
            and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
        then have a40:"(\<forall>i<x. case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                            | Some (MValue val) \<Rightarrow> (case t of  MTValue typ \<Rightarrow> MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
                            | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False))" 
          using 2 by fastforce
        have a55:"(\<exists>p. accessStore destl v' = Some (MPointer p)) \<or> accessStore destl v' = None" 
          using mdef minitSingleChange2[OF a10] by fastforce

        show ?case 
        proof intros
          fix i 
          assume iless:"i<Suc x"

          show "case accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t of MTValue x \<Rightarrow> MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
             | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)" 
          proof(cases "i < x")
            case True

            then have MCondestl:"MCon (MTArray x t) v' destl" using a40 MCon.simps(2)[of x t v' destl] a55 by simp

            then show ?thesis
            proof(cases t)
              case mtr:(MTArray x11 x12)
              then have b10:"MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and> 
                          (\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using MTArray a30 minitRec_SubPrefixes agt by blast
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)
              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using ShowLNatDot hash_int_prefix b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b19:"\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v''" 
                using b10 by auto
              have accessSt:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v'  = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))  v''" 
                by (simp add: b15 b16 b17)
              then obtain val where valdef:" accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MPointer val)" 
                using MConArrayPointers[of x x11 x12 v' destl i] a40 MCondestl True mtr by auto
              have "Suc x - 1 = x" by simp
              then have subPref:"TypedMemSubPref (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) destl (MTArray x t)" 
                using  MConIndexMin1[of "Suc x" t ]  True by auto
              then have b30:"( \<forall>l l'. TypedMemSubPref l destl (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" 
                using minitSelfPointers a10 by blast
              then have valeq:"val = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True valdef subPref by simp
              then have b20:"MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))"  using a40  mtr True valdef by fastforce 
              then have " \<forall>l l'. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l" 
                using b30 moreSpecificTypedSubPref[of destl x t v' ] True by blast
              then have "MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))"  t v' v'' ] a10 b17 b18 b20 b19 by blast
              then show ?thesis using accessSt valdef mtr valeq by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
            next
              case (MTValue x2)
              then have b10:"MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<and>
                          (\<forall>destl'. \<not> LSubPrefL2 destl' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
                using MTArray a30 minitRec_SubPrefixes agt by blast
              then have b15:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) 
                              \<and> \<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) 
                              \<longrightarrow> accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'')" by simp
              have " (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
                by (metis Read_Show_nat'_id less_irrefl_nat)
              then have b16:"hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" 
                by (simp add: hash_never_equal_sufix)

              have b17:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using ShowLNatDot hash_int_prefix b16 by simp
              have b18:"\<not> LSubPrefL2 (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using ShowLNatDot hash_int_prefix b16 by simp
              have b20:"MCon t v' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using a40  MTValue True by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              then have "MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)" "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" t v' v''] using MTValue b10 b17 b18 by simp
              moreover have "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'" 
                by (simp add: b15 b16 b17)
              moreover obtain val where "accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue val)" 
                using a40 MTValue True b20 by (auto split:option.splits Memoryvalue.splits MTypes.splits)
              ultimately show ?thesis 
                by (simp add: MTValue b15 b16 b17)
            qed


          next
            case False
            then have iIsx:"i = x" using iless by simp
            then show ?thesis 
            proof(cases t)
              case mtr:(MTArray x11 x12)
              then have b25:"v'' = (let m = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' in iter (\<lambda>i. minitRec (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m x11)"
                using a30 minitRec.simps(1)[of " (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12] by simp
              have mc:"MCon t v'' (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using MTArray[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" v' v''] a30 agt by simp
              then obtain m' where b30:"m' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by auto
              then have b40:"v'' = iter (\<lambda>i. minitRec (hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m' x11" using b25 by metis
              have b50:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)))" using b30 iIsx 
                by (meson accessStore_updateStore)
              have "\<forall>suffs. hash (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffs \<noteq> hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using hash_inequality by simp
              then have b60:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' " 
                using  b40  iIsx 
                by (metis minitSingleChange2)
              
              then show ?thesis using b50 b60 mtr mc by simp 
            next
              case (MTValue x2)
              then have b10:"v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'"
                using a30 minitRec.simps(2)[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2] by simp
              then have b40:"accessStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some ((MValue (ival x2)))" 
                using iIsx unfolding accessStore_def updateStore_def by auto
              then have "typeCon x2 (ival x2)" 
                using ivalTypeCon by auto
              then show ?thesis  using iIsx MTValue iless MCon.simps(1) b40 by simp
            qed
          qed
        qed
      qed

      moreover have "(\<exists>p. accessStore destl v''' = Some (MPointer p)) \<or> accessStore destl v''' = None" 
        by (metis "**" accessStore_updateStore minitRec.simps(1) minitSingleChange2)
      ultimately show ?thesis using MCon.simps(2)[of x1 t v''' destl]  by (simp add: True)
    next
      case False
      then show ?thesis using ***  by simp
    qed
  qed
next
  case (MTValue x)
  then show ?case
  proof intros
    assume ***:"minitRec destl (MTValue x) a = v'''"
      and *:"arraysGreaterZero (MTValue x)"
    have v''Def:"updateStore destl (MValue (ival x)) a = v'''" using *** unfolding minitRec.simps by simp
    moreover have "typeCon x (ival x)" 
      by (simp add: ivalTypeCon)
    ultimately show "MCon (MTValue x) v''' destl" 
      using  v''Def by (auto split:option.splits Memoryvalue.splits)
  qed
qed

lemma MConMinit: 
  assumes "iter (\<lambda>i m''. minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') md x = updM"
    and "accessStore (ld) md = None"
    and "arraysGreaterZero (MTArray x t)"
  shows " MCon (MTArray x t) updM ld" using assms(2,3) 
proof(induction rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10:"iter (\<lambda>i. minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) md x = v'"
      and a20:"(accessStore ld md = None \<longrightarrow> arraysGreaterZero (MTArray x t) \<longrightarrow> MCon (MTArray x t) v' ld)"
      and a30:"minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast

  have sameACC:" (\<forall>destl'. \<not> LSubPrefL2 destl' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) \<longrightarrow> accessStore destl' v' = accessStore destl' v'')" 
    using minitRec_SubPrefixes a30 by blast
  then have "accessStore ld v' = accessStore ld v''" 
    using a30 
    by (metis LSubPrefL2_def hash_inequality hash_suffixes_associative)


  then have ld:"(\<exists>p. accessStore (ld) v'' = Some (MPointer p)) \<or> accessStore (ld) v'' = None" 
  proof(cases "x =0")
    case True
    then have v'MD:"v' = md" using a10 by auto
    then have "minitRec (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t md = v''" using a30 by blast
    then have "accessStore ld md = accessStore ld v''" 
      using v'MD using \<open>accessStore ld v' = accessStore ld v''\<close> by blast
    then show ?thesis using assms(2) by simp
  next
    case False
    then have "arraysGreaterZero (MTArray x t)" using 2(4) by simp
    then have "MCon (MTArray x t) v' ld" using a20 2 False by blast
    then show ?thesis 
      by (metis \<open>accessStore ld v' = accessStore ld v''\<close> MCon.simps(2))
  qed


  have "\<forall>i<Suc x.
             case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)" 
  proof intros
    fix i assume *:"i<Suc x"
    show "case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' of None \<Rightarrow> False 
           | Some (MValue val) \<Rightarrow> (case t of  MTValue x \<Rightarrow> MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
           | Some (MPointer loc2) \<Rightarrow> (case t of MTArray x xa \<Rightarrow> MCon t v'' loc2 | MTValue Types \<Rightarrow> False)"
    proof(cases t)
      case (MTArray x11 x12)
      then show ?thesis 
      proof(cases "i<x")
        case True
        then have "arraysGreaterZero (MTArray x t)" using 2(4) by simp
        then have b10: "MCon (MTArray x t) v' ld" using a20 2
          using True by fastforce
        then obtain loc2 where l2Def:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' =  Some (MPointer loc2)"
          using True MCon.simps(2) MTArray MConArrayPointers by blast
        have b50:"\<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using True 
          by (metis Read_Show_nat'_id ShowLNatDot hash_int_prefix hash_never_equal_sufix nat_neq_iff)
        have b60:" \<not> LSubPrefL2 (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using True 
          using b50 ShowLNatDot hash_int_prefix by force
        then have b65:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" 
          using minitRec_SubPrefixes a30 b50 by blast
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using l2Def by simp
        have b70:" (\<forall>l l'. TypedMemSubPref l ld  (MTArray x t) \<and> accessStore l v' = Some (MPointer l') \<longrightarrow> l' = l)" 
          using minitSelfPointers a10 by blast
        have "\<forall>i<x. case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case t of MTArray n MTypes \<Rightarrow> False | MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" 
          using b10 by auto
        then have b80:"MCon t v' loc2" using b10 MCon.simps(2)[of x t v' ld] True l2Def MTArray True 
          by fastforce
        have "TypedMemSubPref (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) ld (MTArray x t)" 
          using True by auto
        then have loc2Same:"loc2 = (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using b70 l2Def by metis
        then have "MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MCon_nonSub_selfPointing[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i))" "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" "t" v' v''] b50 b60 b70 b80 b65
          using True a30 minitRec_SubPrefixes TypedMemSubPref.simps(2) by blast
        moreover have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' =  Some (MPointer loc2)" using b65 l2Def by auto
        ultimately show ?thesis using MTArray True loc2Same by (auto split:Memoryvalue.splits option.splits MTypes.splits)
      next
        case False
        then have iIsx:"i = x" using * by auto
        have "arraysGreaterZero t" using 2(4) by simp
        then have MCON:"MCon t v'' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" 
          using minitRecMCon[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t v' v''] a30 iIsx by simp
        have v''Def:" (let m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v' 
                        in iter (\<lambda>i. minitRec (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m x11) 
                          = v''" 
          using a30 minitRec.simps(1)[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x11 x12]  iIsx
          by (simp add: MTArray)
        then obtain m where mDef:"m = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))) v'" by simp
        then have v''Def:"v'' = iter (\<lambda>i. minitRec (hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) x12) m x11" 
          using v''Def by presburger
        have "(\<forall>suffix. hash (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) suffix \<noteq> hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using hash_inequality by simp
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) m = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) v''" 
           using minitSingleChange2 v''Def by blast 
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MPointer (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" 
          using iIsx mDef by simp
        then show ?thesis using MCON MTArray iIsx by (auto split:Memoryvalue.splits option.splits MTypes.splits)
      qed
    next
      case (MTValue x2)
      then show ?thesis 
      proof(cases "i<x")
        case True
        then have "arraysGreaterZero (MTArray x t)" using 2(4) by simp
        then have "MCon (MTArray x t)  v' ld" using a20 2 
          using True by blast
        then have MCON:"case accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case t of MTValue typ \<Rightarrow> MCon t v' (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) | _ \<Rightarrow> False)
              | Some (MPointer loc2) \<Rightarrow> (case t of MTArray len' arr' \<Rightarrow> MCon t v' loc2 | MTValue Types \<Rightarrow> False)" 
          using True MCon.simps(2)[of "x" t v' ld] 
          by simp
        then obtain v where vdef:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = Some (MValue v)" 
          using True MTValue by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        then have tc:"typeCon x2 v" using  MCon.simps vdef True MTValue MCON by auto
        have b10:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t x)" using True 
          by (simp add: Read_Show_nat'_id readLintNotEqual)
        then have b20:"(\<forall>x'. (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> hash (ShowL\<^sub>n\<^sub>a\<^sub>t x) x')" using True 
          by (metis LSubPrefL2_def hash_inequality ShowLNatDot hash_int_prefix hash_suffixes_associative)
        then have "accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v' = accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v''" 
          using a30 b10 
          by (simp add: MTValue accessStore_non_changed hash_never_equal_sufix minitRec.simps(2))
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue v)" 
          using vdef by simp
        then show ?thesis using  MCon.simps vdef True  MTValue v''Store tc by auto
      next
        case False

        then have iIsx: "i = x" using * by simp
        have sv'':"v'' = updateStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'" 
          using minitRec.simps(2)[of "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2] a30 MTValue by simp
        then have v''Store:"accessStore (hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t i)) v'' = Some (MValue (ival x2))" 
          using sv'' iIsx unfolding accessStore_def updateStore_def by (auto split:option.splits Memoryvalue.splits MTypes.splits)
        have "typeCon x2 ((ival x2))" 
          by (simp add: ivalTypeCon)
        then show ?thesis using  MCon.simps iIsx  MTValue v''Store by auto
      qed
    qed
  qed
  then show ?case using MCon.simps(2)[of "Suc x" t v'' "(hash ld (ShowL\<^sub>n\<^sub>a\<^sub>t x))"] ld by simp
qed

lemma minitRecSomeOldNew:
  shows "minitRec destl t destm = v' 
          \<longrightarrow> (\<forall>l. (TypedMemSubPref l destl t \<or> l = destl) \<longrightarrow> accessStore l destm = None)
          \<longrightarrow>  (\<forall>l accx. accessStore l destm = Some accx \<longrightarrow> accessStore l v' = Some accx)"
proof(induction t arbitrary: destl destm v')
  case (MTArray x1 t)
  show ?case
  proof intros
    fix l accx
    assume *:"minitRec destl (MTArray x1 t) destm = v'"
      and ***:"\<forall>l. TypedMemSubPref l destl (MTArray x1 t) \<or> l = destl \<longrightarrow> accessStore l destm = None"
      and **:"accessStore l destm = Some accx "
    have a10:"v' = (let m = updateStore destl (MPointer destl) destm in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1)"
      using * minitRec.simps(1)[of destl x1 t ] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    then have a50:"v' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a10 a40 by presburger
    show "accessStore l v' = Some accx" using a45 ** ***
    proof(induction rule: iter_ind[OF _ _ a50[symmetric]])
      case (1)
      then show ?case 
        by (metis a40 accessStore_non_changed option.discI)
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
          and a20:"(accessStore destl m = Some (MPointer destl) \<longrightarrow>
          accessStore l destm = Some accx \<longrightarrow>
          (\<forall>l l'. TypedMemSubPref l destl (MTArray x t) \<or> l = destl \<longrightarrow> accessStore l destm = None) \<longrightarrow> accessStore l v' = Some accx)"
          and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by metis
      then have "accessStore destl m = Some (MPointer destl)" using 2 by blast
      then show ?case 
      proof(cases "l = destl")
        case True
        then show ?thesis using a20 2 
          by fastforce
      next
        case f1:False
        then show ?thesis 
        proof(cases "TypedMemSubPref l destl (MTArray x t)")
          case True
          then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
          then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
          then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
            by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
          have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
          then have b50:"accessStore l v' = accessStore l v''" 
            using * a30 by (meson minitRec_SubPrefixes)
          then show ?thesis using a20 2 using True 
            by (metis less_Suc_eq TypedMemSubPref.simps(2))
        next
          case False
          have b10:"accessStore l destm = Some accx" using 2(4) by auto

          then show ?thesis 
            by (metis "2.hyps" "2.prems"(3) a40 minitRec.simps(1) minitRec_SubPrefixes2 option.distinct(1))
        qed
      qed
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix l accx
    assume *:"minitRec destl (MTValue x) destm = v'" 
      and ***:"\<forall>l. TypedMemSubPref l destl (MTValue x) \<or> l = destl \<longrightarrow> accessStore l destm = None"
      and **:" accessStore l destm = Some accx"
    have "v' =updateStore destl (MValue (ival x)) destm" 
      using minitRec.simps(2)[of destl x ] * by simp
    then obtain v where b10: "accessStore destl v' = Some (MValue v)" by (auto split:option.splits Memoryvalue.splits)
    show "accessStore l v' = Some accx" 
      by (metis "*" "**" "***" accessStore_non_changed minitRec.simps(2) option.distinct(1))
  qed
qed


lemma minitSomeOldNew:
  assumes "iter (\<lambda>i m''. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') m x1 = v'"
    and "\<forall>l. (TypedMemSubPref l destl (MTArray x1 t) \<or> l = destl) \<longrightarrow> accessStore l m = None"
  shows "(\<forall>l accx. accessStore l m = Some accx \<longrightarrow> accessStore l v' = Some accx)" using assms(2)
proof(induction  rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by simp
next
  case (2 x v'')
  then obtain v'
    where a10: "iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
      and a20: "((\<forall>l. TypedMemSubPref l destl (MTArray x t) \<or> l = destl \<longrightarrow> accessStore l m = None) \<longrightarrow>
          (\<forall>l accx. accessStore l m = Some accx \<longrightarrow> accessStore l v' = Some accx))"
      and a30: "minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by metis
  show ?case 
  proof intros
    fix l accx
    assume *:"accessStore l m = Some accx "
    show "accessStore l v'' = Some accx"
    proof(cases t)
      case (MTArray x11 x12)

      then show ?thesis 
      proof(cases "TypedMemSubPref l destl (MTArray x t)")
        case True
        then obtain i where  b10:"i<x \<and> (TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l = (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)))" by auto
        then have b15:"LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using typedPrefix_imp_SubPref[of l "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i))" t] unfolding LSubPrefL2_def by auto
        then have b20:"(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using b10
          by (metis Read_Show_nat'_id hash_never_equal_sufix less_not_refl)
        have "\<not> LSubPrefL2 l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" using LSubPrefL2_def[of l "hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)"] b15 b20 Mutual_NonSub_SpecificNonSub hash_int_prefix ShowLNatDot by auto
        then have b50:"accessStore l v' = accessStore l v''" 
          using * minitRec_SubPrefixes a30 by blast
        then show ?thesis using a20 True *  b50 
          using a10 
          by (metis "2.prems" less_Suc_eq TypedMemSubPref.simps(2))
      next
        case False
        have "\<forall>l. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) \<longrightarrow> \<not> TypedMemSubPref l destl (MTArray x t)"
          by (smt (verit) LSubPrefL2_def TypedMemSubPref.simps(2) hash_flatten_right hashesInts nat_neq_iff
              neg_MemLSubPrefL2_imps_TypedMemSubPref)
        then have cc1:"\<forall>l . TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) \<longrightarrow> accessStore l m = accessStore l v'" 
          using minitSingleChange2[OF a10] by blast
        then have cc2:"(\<forall>l. TypedMemSubPref l (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t \<or> l = hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x) \<longrightarrow> accessStore l v' = None)"
          using 2(3) MTArray 
          by (metis lessI TypedMemSubPref.simps(2))
        have cc3:"(\<forall>l accx. accessStore l v' = Some accx \<longrightarrow> accessStore l v'' = Some accx)"
          using a30 minitRecSomeOldNew[of "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" t v' v''] cc2 by blast
        then have "accessStore l v' = Some accx" using * cc1 
          by (metis False a10 minitSingleChange2)
        then have "accessStore l v'' = Some accx" using cc3 by simp
        then show ?thesis by blast
      qed
    next
      case (MTValue x2)
      then have "v'' = updateStore (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) (MValue (ival x2)) v'" 
        using a30 minitRec.simps(2)[of   "(hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x))" x2 ] by simp
      then show ?thesis using  * 
        by (metis "2.hyps" "2.prems" minitSingleChange2 option.distinct(1))
    qed
  qed
qed

lemma minitRectoploc:
  shows "minitRec destl t destm = v'
          \<longrightarrow>  toploc destm = toploc v'"
proof(induction t arbitrary: destl destm v')
  case (MTArray x1 t)
  show ?case
  proof intros
    assume *:"minitRec destl (MTArray x1 t) destm = v'"
    have a10:"v' = (let m = updateStore destl (MPointer destl) destm in iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1)"
      using * minitRec.simps(1)[of destl x1 t ] by simp
    then obtain m where a40:"m =  updateStore destl (MPointer destl) destm" by auto
    then have a45:"accessStore destl m = Some(MPointer destl)" by simp
    have a46:"toploc destm = toploc m" using a40 unfolding updateStore_def by simp
    then have a50:"v' = iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x1" using a10 a40 by presburger
    show "toploc destm = toploc v'" using a46
    proof(induction rule: iter_ind[OF _ _ a50[symmetric]])
      case (1)
      then show ?case by simp
    next
      case (2 x v'')
      then obtain v'
        where a10:"iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
          and a20:"(toploc destm = toploc m \<longrightarrow> toploc destm = toploc v')"
          and a30:"minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
      then have "toploc destm = toploc v'" using 2 by blast
      then show ?case 
        by (metis "2.IH" MTArray a46)
    qed
  qed
next
  case (MTValue x)
  then show ?case 
  proof intros
    fix l l' st
    assume *:"minitRec destl (MTValue x) destm = v'" 
      
    have "v' =updateStore destl (MValue (ival x)) destm" 
      using minitRec.simps(2)[of destl x ] * by simp
    then show "toploc destm = toploc v'" unfolding updateStore_def by simp
  qed
qed

lemma minitToploc:
  assumes "iter (\<lambda>i m''. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t m'') m x1 = v'"
  shows "toploc m = toploc v'"
proof(induction  rule: iter_ind[OF _ _ assms(1)])
  case (1)
  then show ?case by fastforce
next
  case (2 x v'')
  then obtain v'
    where a10: "iter (\<lambda>i. minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x = v'"
      and a20: " toploc m = toploc v'"
      and a30: "minitRec (hash destl (ShowL\<^sub>n\<^sub>a\<^sub>t x)) t v' = v''" by blast
  then show ?case using minitRectoploc by metis
qed

subsubsection \<open>Typesafety of Decl\<close>
text \<open>Given a typsafe source env, a type consistent copy vlaue and a successful decl command
              The result of decl must be typesafe\<close>
lemma typeSafeDeclNone:
  assumes "TypeSafe ev' (accounts st) sck' mem' (storage st ) cd'"
    and "decl ip tp None cp cd (memory st) (storage st (address ev)) (cd', mem',  sck', ev') = Some (c, m', k', e)"

shows "TypeSafe e (accounts st) k' m' (storage st) c
         
\<and> (\<forall>x l. (\<nexists>y y'. x = Memory y \<or> x = Value y') \<and> (x, l) |\<in>| fmran(denvalue e) \<longrightarrow> (x,l)|\<in>| fmran(denvalue ev') )
\<and> (\<forall>sckl ptr. accessStore sckl k' = Some (ptr) \<and> (\<nexists>y y'. ptr = KMemptr y \<or> ptr = KValue y') \<longrightarrow> accessStore sckl sck' = Some ptr)
\<and> cd' = c
"  using assms(2)                                                
proof(cases rule:decl.elims)
  case (1 t uu uv uw ux c' m k e')
  have tsOld:"TypeSafe e' (accounts st) k m' (storage st ) c'"
    using 1 assms by simp
  have a1:"(k', e) = (case denvalue e' $$ ip of None \<Rightarrow> (push (KValue (ival t)) k, updateEnv ip (Value t) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))) e') 
                  | Some x \<Rightarrow> (k, e'))" using 1 unfolding astack_dup.simps by simp


  show ?thesis 
  proof(cases "denvalue e' $$ ip")
    case (Some a)
    then have same:"k' = k \<and> e = e'" using a1 by simp
    have ts1:"TypeSafe e (accounts st) k' m' (storage st) c"
      using 1(7,8) assms(1) 
      using same by fastforce
    moreover have sameMem:"mem' = m" using 1 by blast
    then have "mapping mem' \<subseteq>\<^sub>f mapping m" using fmsubset_def 
      by (simp add: fmsubset.rep_eq)
    moreover have "(\<forall>t id' loc. denvalue ev' $$ id' = Some (Storage t, loc) \<longrightarrow> denvalue e $$ id' = Some (Storage t, loc))" 
      using same "1"(7) by force
    moreover have "(\<forall>loc. accessStore loc mem' \<noteq> accessStore loc m' \<longrightarrow> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')))"
      using sameMem 1 by simp
    moreover have "toploc mem' \<le> toploc m'" using 1 by blast
    moreover have "(\<forall>loc v. accessStore loc k' = Some (KStoptr v) \<longrightarrow> accessStore loc sck' = Some (KStoptr v))"
      using same 1 by blast
    moreover have "cd' = c" using 1 by simp
    moreover have "ReachableMem e k' m' = ReachableMem ev' sck' mem'" 
      unfolding ReachableMem.simps using 1 sameMem same by blast
    moreover have " AllocatedMem_between mem' m' = {}" using 1 sameMem unfolding AllocatedMem_between_def by simp
    ultimately show ?thesis using ts1 same 1 by blast
  next
    case None
    then have eDef:"updateEnv ip (Value t) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))) e' = e" using a1 by simp
    have k'Def:"k' = push (KValue (ival t)) k" using a1 None by simp
    have sameMem:"m' = mem'" using 1 by blast
    have sameAddress:"address e = address ev'" using eDef 1 by auto
    have sameCd:"c = cd'" using 1 by blast
    have lessTop:"lessThanTopLocs sck'" using  assms(1) unfolding TypeSafe_def by blast
    show ?thesis 
    proof(intros)
      show "TypeSafe e (accounts st) k' m' (storage st) c" 
        unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st)" using assms(1) unfolding TypeSafe_def by simp 
      next
        show "safeContract (storage st)" using assms(1) unfolding TypeSafe_def by simp 
      next 
        show "unique_locations (denvalue e)" unfolding unique_locations_def
        proof intros
          fix x y

          assume *:"x |\<in>| fmran (denvalue e) \<and> y |\<in>| fmran (denvalue e) \<and> snd x = snd y"
          then obtain i1 i2 where i1def:"(denvalue e) $$ i1 = Some x" and i2def:"denvalue e $$ i2 = Some y" by blast
          show "x = y"
          proof(cases "i1 = ip")
            case True
            then have xIs:"x = (Value t, Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)))" using i1def eDef unfolding updateEnv.simps by auto
            then show ?thesis 
            proof(cases "i2 = ip")
              case t2:True
              then show ?thesis using True i1def i2def by simp
            next
              case False
              then have "y |\<in>| fmran (denvalue e')" using eDef i2def * unfolding updateEnv.simps 
                by (metis denvalueChange fmranI)
              then show ?thesis using stackLocs_imp_NotDen[OF _ assms(1)] 1(7)  * xIs 
                by (metis fmranE snd_conv stackLocs_imp_NotDen tsOld TypeSafe_def)
            qed
          next
            case False
            then have xOld:"x |\<in>| fmran (denvalue e')" using eDef i1def * unfolding updateEnv.simps 
              by (metis "1"(7) assms(2) decl_env_not_i fmranI)
            then show ?thesis 
            proof(cases "i2 = ip")
              case True
              then have yIs:"y = (Value t, Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)))" using i2def eDef unfolding updateEnv.simps by auto
              then show ?thesis using stackLocs_imp_NotDen[OF _ assms(1)] 1(7)  * xOld 
                by (metis eq_snd_iff fmranE stackLocs_imp_NotDen tsOld TypeSafe_def)
            next
              case False
              then have "y |\<in>| fmran (denvalue e')" using eDef i2def * unfolding updateEnv.simps 
                by (metis denvalueChange fmranI)
              then show ?thesis using xOld * assms(1) 1(7) unfolding TypeSafe_def unique_locations_def by blast
            qed
          qed
        qed
      next 
        show "compPointers k'  (denvalue e)" unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume in1:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
         (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
         (l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
         (l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then have "(Storage tp1, l1) |\<in>| fmran (denvalue e') \<and>
         (Storage tp2, l2) |\<in>| fmran (denvalue e')" using eDef unfolding updateEnv.simps 

            by (smt (z3) "1"(1,7) None Type.distinct(5) assms(2) decl_env_kval decl_env_not_i fmlookup_ran_iff option.inject prod.inject)
          moreover have "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<longrightarrow> l1 = Stackloc l1' \<and> accessStore l1' k = Some (KStoptr stl1)"
            using k'Def in1 unfolding push_def allocate_def updateStore_def accessStore_def by simp
          moreover have "l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<longrightarrow> l2 = Stackloc l2' \<and> accessStore l2' k = Some (KStoptr stl2)"
            using k'Def in1 unfolding push_def allocate_def updateStore_def accessStore_def by simp
          ultimately show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2
         else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
            using assms(1) 1(7) in1 unfolding TypeSafe_def compPointers_def by blast
        qed
      next 
        show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def
        proof intros
          fix tp1 tp2 l1 l2 stl1 stl2 dloc1
          assume in1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
         (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
         accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
          then obtain i1 i2 where "(denvalue e) $$ i1 = Some (Memory tp1, Stackloc l1) \<and> (denvalue e) $$ i2 = Some (Memory tp2, Stackloc l2)" by blast
          moreover have "i1 \<noteq> ip \<and> i2 \<noteq> ip " using eDef calculation unfolding updateEnv.simps by auto
          moreover have "denvalue e' $$ i1 = Some (Memory tp1, Stackloc l1) \<and> denvalue e' $$ i2 = Some (Memory tp2, Stackloc l2)" 
            using calculation eDef unfolding updateEnv.simps by auto
          ultimately have oldD:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e') \<and> (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e') " using fmranI by fast
          have l1Acc:"accessStore l1 k = Some (KMemptr stl1)" using in1 k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis Stackvalue.distinct(3) accessStore_def accessStore_non_changed accessStore_updateStore allocateSameAccess k'Def
                option.inject push_def)
          have l2Acc:"accessStore l2 k = Some (KMemptr stl2)" using in1 k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis Stackvalue.distinct(3) accessStore_def accessStore_non_changed accessStore_updateStore allocateSameAccess k'Def
                option.inject push_def)
          show " if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                       else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType m' len2 arr2 dt stl2 dloc1 \<and> CompMemType m' len arr dt stl1 dloc1 else True
                | MTValue val2 \<Rightarrow>
                    if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of
                  MTArray len2 arr2 \<Rightarrow>
                    if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True
                  | MTValue val2 \<Rightarrow> True)" 
            using assms(1) unfolding TypeSafe_def compMemPtrs_def using oldD l1Acc l2Acc 1(7) sameMem by blast
        qed
      next
        show "methodVarsNoPref" using assms(1) unfolding TypeSafe_def by simp 
      next 
        show "balanceTypes (accounts st)" using assms(1) unfolding TypeSafe_def by simp 
      next 
        show "addressFormat (address e)" using eDef unfolding updateEnv.simps using 1(7) assms(1) unfolding TypeSafe_def by auto
      next 
        show "addressFormat (sender e)" using eDef unfolding updateEnv.simps using 1(7) assms(1) unfolding TypeSafe_def by auto
      next 
        show " svalueTypes (svalue e)" using eDef unfolding updateEnv.simps using 1(7) assms(1) unfolding TypeSafe_def by auto
      next 
        show "lessThanTopLocs k'" unfolding lessThanTopLocs_def
        proof intros
          fix tloc loc
          assume *:"toploc k' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
          then show "accessStore loc k' = None" 
            by (metis k'Def lessThanTopLocs_def stackPushToplocSafe tsOld TypeSafe_def)
        next 
          fix loc y
          assume *:"accessStore loc k' = Some y "
          then show "\<exists>tloc<toploc k'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
            by (metis k'Def lessThanTopLocs_def stackPushToplocSafe tsOld TypeSafe_def)
        qed
      next 
        show "lessThanTopLocs c"  using 1 assms(1) unfolding TypeSafe_def by simp 
      next 
        show "lessThanTopLocs m'"  using 1 assms(1) unfolding TypeSafe_def by simp 
      next 
        show "typeCompat (denvalue e) k' m' (storage st (address e)) c " 
          unfolding typeCompat_def
        proof intros
          fix t' l'
          assume inDen:"(t', l') |\<in>| fmran (denvalue e)"
          then obtain i1 where i1Def:"(denvalue e) $$ i1 = Some (t', l')" by blast
          show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
               | Some (KValue val) \<Rightarrow> (case t' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
               | Some (KCDptr stloc) \<Rightarrow> (case t' of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
               | Some (KMemptr stloc) \<Rightarrow> (case t' of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
               | Some (KStoptr stloc) \<Rightarrow> (case t' of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t' of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
          proof(cases l')
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "x1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))")
              case True
              then have acc:"accessStore x1 k' = Some (KValue (ival t))" 
                using k'Def unfolding push_def allocate_def updateStore_def accessStore_def by simp
              have t'Def:"(Value t) = t'" 
              proof(rule ccontr)
                assume "Value t \<noteq> t'"
                then have "i1 \<noteq> ip" using i1Def eDef by auto
                then have "(t', l') |\<in>| fmran (denvalue e')" using i1Def inDen fmranI 
                  by (metis "1"(7) assms(2) decl_env_not_i)
                then show False using Stackloc True stackLocs_imp_NotDen[OF _ assms(1)] 1(7) 
                  by (metis fmranE snd_eqD stackLocs_imp_NotDen tsOld TypeSafe_def)
              qed
              have "typeCon t (ival t)" 
                by (simp add: ivalTypeCon)
              then show ?thesis using acc Stackloc inDen t'Def by auto
            next
              case False
              then have sameACC:"accessStore x1 k' = accessStore x1 sck'" 
                using k'Def 1(7) unfolding push_def allocate_def accessStore_def updateStore_def by simp
              obtain i where  iDef:"(denvalue e) $$ i = Some (t', l')" using inDen by blast
              then have "i \<noteq> ip" using eDef False Stackloc by auto
              then have "denvalue e' $$ i = Some (t', l')" using iDef eDef by auto
              then have inOld:"(t', l') |\<in>| fmran (denvalue e')" using fmranI by metis
              have "(case accessStore x1 sck' of None \<Rightarrow> False 
                    | Some (KValue val) \<Rightarrow> (case t' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                    | Some (KCDptr stloc) \<Rightarrow> (case t' of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                    | Some (KMemptr stloc) \<Rightarrow> (case t' of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                    | Some (KStoptr stloc) \<Rightarrow> (case t' of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev')) | _ \<Rightarrow> False))"
                using inOld sameACC sameMem Stackloc using assms(1) 1(7) unfolding TypeSafe_def typeCompat_def by fastforce
              then show ?thesis using Stackloc sameACC sameCd sameMem sameAddress  
                by (metis Denvalue.simps(5))
            qed
          next
            case (Storeloc x2)
            then have inOld:"(t', l') |\<in>| fmran (denvalue e')"using eDef inDen unfolding updateEnv.simps 

              by (metis "1"(1,7) None Type.distinct(5) assms(2) decl_env_storage denvalueChange fmranI i1Def)
            then have "(case t' of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev')) | _ \<Rightarrow> False)"
              using assms(1) 1(7) Storeloc inDen sameAddress unfolding TypeSafe_def typeCompat_def by fastforce
            then obtain struct where "t' = Storage struct" by (cases t', simp+)
            then show ?thesis using assms(1) 1(7) Storeloc inDen sameAddress inOld 
              unfolding TypeSafe_def typeCompat_def by fastforce
          qed
        qed
      qed
    next
      fix x l
      assume *:"(\<nexists>y y'. x = Memory y \<or> x = Value y') \<and> (x, l) |\<in>| fmran (denvalue e)"
      then obtain ip' where **:"denvalue e $$ ip' = Some (x, l)" by blast
      then have "ip' \<noteq> ip" using eDef * unfolding updateEnv.simps by auto
      then have "denvalue ev' $$ ip' =  Some (x, l)" 
        using eDef ** decl_env_not_i 1  by force
      then show "(x, l) |\<in>| fmran (denvalue ev')" using fmranI by metis
    next 
      fix sckl ptr
      assume *:" accessStore sckl k' = Some ptr \<and> (\<nexists>y y'. ptr = KMemptr y \<or> ptr = KValue y')"
      have "\<exists>v. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)) k' = (Some (KValue v))"
        using k'Def unfolding push_def allocate_def updateStore_def accessStore_def by simp
      then have "sckl \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))" using * by auto
      then have "accessStore sckl k' =accessStore sckl sck'" 
        using k'Def 1 unfolding push_def allocate_def updateStore_def accessStore_def by simp
      then show "accessStore sckl sck' = Some ptr " using * by simp
    next 
      show "cd' = c" using 1 by blast 
    qed
  qed
next
  case (2 t v t' uy uz va vb c m k e)
  then show ?thesis by simp
next
  case (3 vd ve vb vf vg vh vi vj)
  then show ?thesis by simp
next
  case (4 vd ve vb vf vg vh vi vj)
  then show ?thesis by simp
next
  case (5 vd ve vb vf vg vh vi vj)
  then show ?thesis by simp
next
  case (6 vd va ve vf vg vh vi vj)
  then show ?thesis by simp
next
  case (7 vd va ve vf vg vh vi vj)
  then show ?thesis by simp
next
  case (8 vd va ve vf vg vh vi vj)
  then show ?thesis by simp
next
  case (9 x t p t' cd vk vl c m k e)
  then show ?thesis by simp
next
  case (10 x t p t' vm mem vn c m k e)
  then show ?thesis by simp
next
  case (11 v vp vq vr vs vt vu)
  then show ?thesis by simp
next
  case (12 vo vq vr vs vt vu)
  then show ?thesis by simp
next
  case (13 vo vc vb vq vr vs vt vu)
  then show ?thesis by simp
next
  case (14 v vc vb vq vr vs vt vu)
  then show ?thesis by simp
next
  case (15 vo vc vb vr vs vt vu)
  then show ?thesis by simp
next
  case (16 vo vc vb vq vr vs vt vu)
  then show ?thesis by simp
next
  case (17 vo vp vr vs vt vu)
  then show ?thesis by simp
next
  case (18 x t vv vw vx vy c' m k e')
  have tsOld:"TypeSafe e' (accounts st) k m (storage st ) c'"
    using 18 assms(1) by simp
  have NoneIP:"denvalue e' $$ ip = None  \<and> arraysGreaterZero (MTArray x t)" using 18 by (simp split:if_splits)

  then have "(k', e) =  (push (KMemptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))) k, updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))) e')" using 18 by simp
  then have k'Def:"k' = push (KMemptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))) k" and eDef:"e = updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))) e'"
    by blast+
  have m'Def:"m' = minit x t m" using 18 by (auto split:if_split_asm)
  then obtain mm where mmDef:"mm = iter (\<lambda>i. minitRec (hash ((ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))) (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t) m x" unfolding minit_def by blast
  then have topMM:"toploc mm = toploc m" using minitToploc mmDef by metis
  have m'Def2:"snd (allocate mm) = m'" using m'Def unfolding minit_def using mmDef by metis

  have sameAddress:"address e = address ev'" using eDef 18 by auto
  have sameCd:"c = cd'" using 18 by (simp split:if_splits)
  have lessTop:"lessThanTopLocs sck'" using  assms(1) unfolding TypeSafe_def by blast
  have mLim:"((\<forall>tloc loc. toploc m \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc m = None) \<and>
     (\<forall>loc y. accessStore loc m = Some y \<longrightarrow> (\<exists>tloc<toploc m. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))"
    using assms(1) unfolding TypeSafe_def lessThanTopLocs_def using 18(7) by blast
  then have noneTop:"\<forall>l. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<or> l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<longrightarrow> accessStore l m = None" 
    by (meson LSubPrefL2_def le_refl typedPrefix_imp_SubPref)
  then have SameAccM_mm:"\<forall>l accx. accessStore l m = Some accx \<longrightarrow> accessStore l mm = Some accx"
    using minitSomeOldNew[OF mmDef[symmetric] ] by blast
  have mM'Acc:"\<forall>l accx. accessStore l m = Some accx \<longrightarrow> accessStore l m' = Some accx"  
  proof intros
    fix l accx 
    assume *:"accessStore l m = Some accx "
    have "accessStore  (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) m = None" using mLim 
      using LSubPrefL2_def by blast
    then show "accessStore l m' = Some accx" using * m'Def SameAccM_mm mmDef unfolding minit_def 
      by (metis allocateSameAccess)
  qed

  have selfPoint:"\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t)
                    \<and> accessStore l m' = Some (MPointer l') \<longrightarrow> l' = l"  
  proof intros
    have in5:"\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<and> accessStore l mm = Some (MPointer l') \<longrightarrow> l' = l" 
    using minitSelfPointers[OF mmDef[symmetric]] by blast
    fix l l'
    assume *:"TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<and> accessStore l m' = Some (MPointer l')"
    have sameAcc:"\<forall>l. accessStore l m' = accessStore l mm" using m'Def allocateSameAccess mmDef unfolding minit_def by metis
    then show "l' = l " using in5 * by metis
  qed

  then have prefPtrs_imps_Pref:"\<forall>l. TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) l \<longrightarrow> TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t)"
    using selfPoint_imps_TypedMemSubPref by blast

  have nonLocChanged:"\<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<longrightarrow> accessStore locs m = accessStore locs m'"
    using minitSingleChange2[OF mmDef[symmetric]]  m'Def allocateSameAccess mmDef unfolding minit_def by metis
  have nonLocChanged2:"\<forall>t' locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<longrightarrow> accessStore locs m = accessStore locs m'" 
    using minitSingleChange[OF mmDef[symmetric]] allocateSameAccess m'Def2 by auto
  have mcTop:"MCon (MTArray x t) mm (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
    using MConMinit[of "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" t m x mm] mmDef noneTop NoneIP by metis
  then have mcTop:"MCon (MTArray x t) m' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" using allocateMCon m'Def2 by blast

  have a120:"lessThanTopLocs sck'" using assms(1) TypeSafe_def 18(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(1) typeSafeAllStacklocsExist fmranI 18(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using eDef lessThanTopLocs_def fmranI 18(7) by auto

  show ?thesis 
  proof(intros)
    show "TypeSafe e (accounts st) k' m' (storage st) c" 
      unfolding TypeSafe_def
    proof intros
      show "AddressTypes (accounts st)" using assms(1) unfolding TypeSafe_def by simp 
    next
      show "safeContract (storage st)" using assms(1) unfolding TypeSafe_def by simp 
    next 
      show "unique_locations (denvalue e)" unfolding unique_locations_def
      proof intros
        fix x' y
        assume *:"x' |\<in>| fmran (denvalue e) \<and> y |\<in>| fmran (denvalue e) \<and> snd x' = snd y"
        then obtain i1 i2 where i1def:"(denvalue e) $$ i1 = Some x'" and i2def:"denvalue e $$ i2 = Some y" by blast
        show "x' = y"
        proof(cases "i1 = ip")
          case True
          then have xIs:"x' = (Memory (MTArray x t), Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)))" using i1def eDef unfolding updateEnv.simps by simp
          then show ?thesis 
          proof(cases "i2 = ip")
            case t2:True
            then show ?thesis using True i1def i2def by simp
          next
            case False
            then have "y |\<in>| fmran (denvalue e')" using eDef i2def * unfolding updateEnv.simps 
              by (simp add: fmranI)
            then show ?thesis using stackLocs_imp_NotDen[OF lessTop assms(1)] 18(7)  * xIs by fastforce
          qed
        next
          case False
          then have xOld:"x' |\<in>| fmran (denvalue e')" using eDef i1def * unfolding updateEnv.simps 
            by (simp add: fmranI)
          then show ?thesis 
          proof(cases "i2 = ip")
            case True
            then have yIs:"y = (Memory (MTArray x t), Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)))" using i2def eDef unfolding updateEnv.simps by simp
            then show ?thesis using stackLocs_imp_NotDen[OF lessTop assms(1)] 18(7)  * xOld by fastforce
          next
            case False
            then have "y |\<in>| fmran (denvalue e')" using eDef i2def * unfolding updateEnv.simps 
              by (simp add: fmranI)
            then show ?thesis using xOld * assms(1) 18(7) unfolding TypeSafe_def unique_locations_def by blast
          qed
        qed
      qed
    next 
      show "compPointers k'  (denvalue e)" unfolding compPointers_def
      proof intros
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume in1:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then have "(Storage tp1, l1) |\<in>| fmran (denvalue e') \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e')" using eDef unfolding updateEnv.simps 
          by (smt (z3) "18"(1,7) NoneIP Type.distinct(11) assms(2) decl_env_not_i decl_env_storage fmranE fmranI)

        moreover have "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<longrightarrow> l1 = Stackloc l1' \<and> accessStore l1' k = Some (KStoptr stl1)"
          using k'Def in1 unfolding push_def allocate_def updateStore_def accessStore_def by simp
        moreover have "l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<longrightarrow> l2 = Stackloc l2' \<and> accessStore l2' k = Some (KStoptr stl2)"
          using k'Def in1 unfolding push_def allocate_def updateStore_def accessStore_def by simp
        ultimately show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2
       else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
          using assms(1) 18(7) in1 unfolding TypeSafe_def compPointers_def by blast
      qed
    next 
      show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        assume in1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
        then obtain i1 i2 where inLook:"(denvalue e) $$ i1 = Some (Memory tp1, Stackloc l1) 
                                  \<and> (denvalue e) $$ i2 = Some (Memory tp2, Stackloc l2)" by blast
        then consider (bothIP) "i1 = ip \<and> i2 = ip"
          | (i1IP) "i1 = ip \<and> i2 \<noteq> ip"
          | (i2IP) "i2 = ip \<and> i1 \<noteq> ip"
          | (notIP) "i1 \<noteq> ip \<and> i2 \<noteq> ip" by blast
        then show " if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType m' len2 arr2 dt stl2 dloc1 \<and> CompMemType m' len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow>
                  if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)" 
        proof(cases)
          case bothIP
          then have areNew:"(Memory tp1, Stackloc l1) = ((Memory (MTArray x t)), (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))))
                      \<and>(Memory tp2, Stackloc l2) = ((Memory (MTArray x t)), (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))))" 
            using eDef inLook by auto
          then have "accessStore l1 k' = accessStore l2 k'" by simp
          then have "stl1 = stl2" using in1 by simp
          then show ?thesis using areNew by auto
        next
          case i1IP
          then have tp1New:"(Memory tp1, Stackloc l1) = ((Memory (MTArray x t)), (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))))" 
            using eDef inLook by simp
          then have stl1Top:"stl1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
            using k'Def in1 unfolding push_def allocate_def accessStore_def updateStore_def by simp
          have stl2Old:"(denvalue e') $$ i2 = Some (Memory tp2, Stackloc l2)" 
            using inLook i1IP eDef by auto 
          then have stl2Old':"(Memory tp2, Stackloc l2) |\<in>| fmran(denvalue e')" using fmranI by metis
          then have "\<exists>v. accessStore l2 k = Some v" 
            using tsOld typeSafeAllStacklocsExist[OF tsOld] in1 by (metis)
          then have sameACC:"accessStore l2 k = accessStore l2 k'" 
            using k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis "18"(8) accessStore_def decl.simps(18) decl_stack_change snd_eqD stackLocs_imp_NotDen TypeSafe_def
                 stl2Old tsOld)
          then have acc2:"accessStore l2 k = Some (KMemptr stl2)" using in1 by simp
          have "\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<and> accessStore l mm = Some (MPointer l') \<longrightarrow> l' = l" 
            using mmDef minitSelfPointers[of "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" t m x mm] by blast
          moreover have " \<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<longrightarrow> accessStore locs m = accessStore locs mm" 
            using mmDef minitSingleChange2[of "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" t m x mm] by blast
          have notSame:"stl1 \<noteq> stl2" using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by auto
          have mc2:"MCon tp2 m stl2" using stl2Old' tsOld sameACC in1 unfolding TypeSafe_def typeCompat_def by fastforce
          
          consider (ArrArr)  len2 arr2 where "tp1 = MTArray x t \<and> tp2 = MTArray len2 arr2"
            | (ArrVal) v where "tp1 = MTArray x t \<and> tp2 = MTValue v"
            | (ValArr) v len2 arr2 where "tp2 = MTArray len2 arr2 \<and> tp1 = MTValue v"
            | (ValVal) v1 v2 where "tp1 = MTValue v1 \<and> tp2 = MTValue v2" using tp1New apply (cases tp1) apply (cases tp2) apply simp apply blast 
            by (metis extractType.cases)

          then show ?thesis 
          proof(cases)
            case ArrArr
            then have ol:"\<not> TypedMemSubPrefPtrs m x t stl1 stl2 \<and> \<not> TypedMemSubPrefPtrs m len2 arr2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))
              \<and> (\<nexists>dloc. TypedMemSubPrefPtrs m len2 arr2 stl2 dloc \<and> TypedMemSubPrefPtrs m x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc)"
              using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by simp
            have cc1:"\<not>TypedMemSubPrefPtrs m' x t stl1 stl2"
            proof
              assume "TypedMemSubPrefPtrs m' x t stl1 stl2"
              then have "TypedMemSubPref stl2 stl1 (MTArray x t)"
                using prefPtrs_imps_Pref tp1New ArrArr stl1Top  by blast
              then show False 
                using acc2 statement_with_gas.typeSafeAllPtrsNotTop2 
                    typedPrefix_imp_SubPref statement_with_gas_axioms stl1Top stl2Old' tsOld
                by blast
            qed
            have cc2:"\<not> TypedMemSubPrefPtrs m' len2 arr2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
            proof
              have mc2:"MCon (MTArray len2 arr2) m stl2" using ArrArr mc2 by blast
              assume "TypedMemSubPrefPtrs m' len2 arr2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
              then show False using  noneTop mc2
              proof(induction arr2 arbitrary:len2 stl2)
                case (MTArray x1 arr2)
                then obtain i l where iDef:"i<len2 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) 
                                          \<and> (l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<or> TypedMemSubPrefPtrs m' x1 arr2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)))"
                  unfolding TypedMemSubPrefPtrs.simps by blast
                have mcL:"MCon (MTArray x1 arr2) m l" 
                  using MTArray.prems(3) MCon.simps(2)[of len2 "MTArray x1 arr2" m stl2] 
                  by (metis MConArrayPointers MCon_imps_sub_Mcon iDef nonLocChanged noneTop option.discI)
                then have tps:" \<not> TypedMemSubPref (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<or> (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" 
                  by (metis MCon_imps_Some MTArray.prems(3) LSubPrefL2_def MemLSubPrefL2_specific_imps_general Not_Sub_More_Specific mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                      nle_le not_None_eq)
                then show ?case 
                proof(cases "l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))")
                  case True
                  then show ?thesis 
                    by (metis MCon_imps_Some LSubPrefL2_def True less_or_eq_imp_le mLim mcL option.discI)
                next
                  case False
                  then have "TypedMemSubPrefPtrs m' x1 arr2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" using iDef by simp
                  then show ?thesis using MTArray.IH[of x1 l ] mcL 
                    using noneTop by blast
                qed
              next
                case (MTValue x')
                then show ?case unfolding TypedMemSubPrefPtrs.simps   
                  by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative)
              qed
            qed
            have cc3:"(\<nexists>dloc. TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc \<and> TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc)"
            proof
              assume in5:"\<exists>dloc. TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc \<and> TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc"
              then obtain dloc where in10:"TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc" 
                                 and in20:"TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc" by blast
              then have "TypedMemSubPref dloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t)" using prefPtrs_imps_Pref by auto
              then show False using in10 acc2 MemLSubPrefL2_specific_imps_general typedPrefix_imp_SubPref statement_with_gas.typeSafeAllPtrsNotTop2
                      statement_with_gas_axioms stl2Old' tsOld 
                by (smt (verit, best) ArrArr TS_imps_InDenLessStack inv_cpm2mTPrefOld_imps_TPref le_refl mLim mc2 nonLocChanged)
            qed
            then show ?thesis using notSame ArrArr cc1 cc2 cc3 
              using stl1Top by auto
          next
            case ArrVal
            then have ol:"\<not> TypedMemSubPrefPtrs m x t stl1 stl2"
              using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by simp
            have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2"
            proof
              assume "TypedMemSubPrefPtrs m' x t stl1 stl2"
              then have "TypedMemSubPref stl2 stl1 (MTArray x t)"
                using prefPtrs_imps_Pref tp1New ArrVal stl1Top  by blast
              then show False 
                using acc2 typeSafeAllPtrsNotTop2 
                    typedPrefix_imp_SubPref stl1Top stl2Old' tsOld
                by blast
            qed
            then show ?thesis using notSame ArrVal by simp
          next
            case ValArr
            then have "\<not>TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1"
              using stl1Top tp1New by blast
            then show ?thesis using ValArr notSame by simp
          next
            case ValVal
            then show ?thesis using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by auto
          qed
        next
          case i2IP
          then have tp1New:"(Memory tp2, Stackloc l2) = ((Memory (MTArray x t)), (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))))" 
            using eDef inLook by simp
          then have stl1Top:"stl2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
            using k'Def in1 unfolding push_def allocate_def accessStore_def updateStore_def by simp
          have stl2Old:"(denvalue e') $$ i1 = Some (Memory tp1, Stackloc l1)" 
            using inLook i2IP eDef by auto 
          then have stl2Old':"(Memory tp1, Stackloc l1) |\<in>| fmran(denvalue e')" using fmranI by metis
          then have "\<exists>v. accessStore l1 k = Some v" 
            using tsOld typeSafeAllStacklocsExist[OF tsOld] in1 by (metis)
          then have sameACC:"accessStore l1 k = accessStore l1 k'" 
            using k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis "18"(8) accessStore_def decl.simps(18) decl_stack_change snd_eqD stackLocs_imp_NotDen statement_with_gas.TypeSafe_def
                statement_with_gas_axioms stl2Old tsOld)
          then have acc2:"accessStore l1 k = Some (KMemptr stl1)" using in1 by simp
          have "\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<and> accessStore l mm = Some (MPointer l') \<longrightarrow> l' = l" 
            using mmDef minitSelfPointers[of "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" t m x mm] by blast
          moreover have " \<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<longrightarrow> accessStore locs m = accessStore locs mm" 
            using mmDef minitSingleChange2[of "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" t m x mm] by blast
          have notSame:"stl1 \<noteq> stl2" using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by auto
          have mc2:"MCon tp1 m stl1" using stl2Old' tsOld sameACC in1 unfolding TypeSafe_def typeCompat_def by fastforce
                  
          consider (ArrArr)  len2 arr2 where "tp2 = MTArray x t \<and> tp1 = MTArray len2 arr2"
            | (ArrVal) v where "tp2 = MTArray x t \<and> tp1 = MTValue v"
            | (ValArr) v len2 arr2 where "tp1 = MTArray len2 arr2 \<and> tp2 = MTValue v"
            | (ValVal) v1 v2 where "tp2 = MTValue v1 \<and> tp1 = MTValue v2" using tp1New apply (cases tp2) apply (cases tp1) apply simp apply blast 
            by (metis extractType.cases)

          then show ?thesis 
          proof(cases)
            case ArrArr
            then have ol:"\<not> TypedMemSubPrefPtrs m len2 arr2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) stl1 \<and> \<not> TypedMemSubPrefPtrs m len2 arr2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))
              \<and> (\<nexists>dloc. TypedMemSubPrefPtrs m len2 arr2 stl1 dloc \<and> TypedMemSubPrefPtrs m x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc)"
              using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by auto
            have cc1:"\<not>TypedMemSubPrefPtrs m' x t stl2 stl1"
            proof
              assume "TypedMemSubPrefPtrs m' x t stl2 stl1"
              then have "TypedMemSubPref stl1 stl2 (MTArray x t)"
                using prefPtrs_imps_Pref tp1New ArrArr stl1Top  by blast
              then show False 
                using acc2 typeSafeAllPtrsNotTop2 
                    typedPrefix_imp_SubPref stl1Top stl2Old' tsOld
                by blast
            qed
            have cc2:"\<not> TypedMemSubPrefPtrs m' len2 arr2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
            proof
              have mc2:"MCon (MTArray len2 arr2) m stl1" using ArrArr mc2 by blast
              assume "TypedMemSubPrefPtrs m' len2 arr2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
              then show False using  noneTop mc2
              proof(induction arr2 arbitrary:len2 stl1)
                case (MTArray x1 arr2)
                then obtain i l where iDef:"i<len2 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) 
                                          \<and> (l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<or> TypedMemSubPrefPtrs m' x1 arr2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)))"
                  unfolding TypedMemSubPrefPtrs.simps by blast
                have mcL:"MCon (MTArray x1 arr2) m l" 
                  using MTArray.prems(3) MCon.simps(2)[of len2 "MTArray x1 arr2" m stl1] 
                  by (metis MConArrayPointers MCon_imps_sub_Mcon iDef nonLocChanged noneTop option.discI)
                then have tps:" \<not> TypedMemSubPref (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<or> (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" 
                  by (metis MCon_imps_Some MTArray.prems(3) LSubPrefL2_def MemLSubPrefL2_specific_imps_general Not_Sub_More_Specific mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                      nle_le not_None_eq)
                then show ?case 
                proof(cases "l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))")
                  case True
                  then show ?thesis 
                    by (metis MCon_imps_Some LSubPrefL2_def True less_or_eq_imp_le mLim mcL option.discI)
                next
                  case False
                  then have "TypedMemSubPrefPtrs m' x1 arr2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" using iDef by simp
                  then show ?thesis using MTArray.IH[of x1 l ] mcL 
                    using noneTop by blast
                qed
              next
                case (MTValue x')
                then show ?case unfolding TypedMemSubPrefPtrs.simps   
                  by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative)
              qed
            qed
            have cc3:"(\<nexists>dloc. TypedMemSubPrefPtrs m' len2 arr2 stl1 dloc \<and> TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc)"
            proof
              assume in5:"\<exists>dloc. TypedMemSubPrefPtrs m' len2 arr2 stl1 dloc \<and> TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc"
              then obtain dloc where in10:"TypedMemSubPrefPtrs m' len2 arr2 stl1 dloc" 
                                 and in20:"TypedMemSubPrefPtrs m' x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) dloc" by blast
              then have "TypedMemSubPref dloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t)" using prefPtrs_imps_Pref by auto
              then show False using in10 acc2 MemLSubPrefL2_specific_imps_general typedPrefix_imp_SubPref statement_with_gas.typeSafeAllPtrsNotTop2
                      statement_with_gas_axioms stl2Old' tsOld 
                by (smt (verit, best) ArrArr TS_imps_InDenLessStack inv_cpm2mTPrefOld_imps_TPref le_refl mLim mc2 nonLocChanged)
            qed
            then show ?thesis using notSame ArrArr cc1 cc2 cc3 
              using stl1Top by auto
          next
            case ArrVal
            then have ol:"\<not> TypedMemSubPrefPtrs m x t stl2 stl1"
              using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by simp
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1"
            proof
              assume "TypedMemSubPrefPtrs m' x t stl2 stl1"
              then have "TypedMemSubPref stl1 stl2 (MTArray x t)"
                using prefPtrs_imps_Pref tp1New ArrVal stl1Top  by blast
              then show False 
                using acc2 typeSafeAllPtrsNotTop2 
                    typedPrefix_imp_SubPref stl1Top stl2Old' tsOld
                by blast
            qed
            then show ?thesis using notSame ArrVal by simp
          next
            case ValArr
            then have "\<not>TypedMemSubPrefPtrs m' len2 arr2 stl1 stl2"
              using stl1Top tp1New by blast
            then show ?thesis using ValArr notSame by simp
          next
            case ValVal
            then show ?thesis using typeSafeAllPtrsNotTop[OF tsOld stl2Old' acc2] stl1Top by auto
          qed
        next
          case notIP
          have stl1Old:"(denvalue e') $$ i1 = Some (Memory tp1, Stackloc l1)" 
            using inLook  eDef 
            using "18"(7) assms(2) decl_env_not_i notIP by blast
          then have stl1Old':"(Memory tp1, Stackloc l1) |\<in>| fmran(denvalue e')" using fmranI by metis
          then have "\<exists>v. accessStore l1 k = Some v" 
            using tsOld typeSafeAllStacklocsExist[OF tsOld] in1 
            by (metis)
          then have sameACC1:"accessStore l1 k = accessStore l1 k'" 
            using k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis "18"(8) accessStore_def decl.simps(18) decl_stack_change snd_eqD stackLocs_imp_NotDen stl1Old tsOld TypeSafe_def)
          have stl2Old:"(denvalue e') $$ i2 = Some (Memory tp2, Stackloc l2)" 
            using inLook  eDef 
            using "18"(7) assms(2) decl_env_not_i notIP by blast
          then have stl2Old':"(Memory tp2, Stackloc l2) |\<in>| fmran(denvalue e')" using fmranI by metis
          then have "\<exists>v. accessStore l2 k = Some v" 
            using tsOld typeSafeAllStacklocsExist[OF tsOld] in1 
            by (metis)
          then have sameACC2:"accessStore l2 k = accessStore l2 k'" 
            using k'Def unfolding push_def allocate_def accessStore_def updateStore_def 
            by (metis "18"(7) accessStore_def assms(2) decl_stack_change snd_conv statement_with_gas.stackLocs_imp_NotDen statement_with_gas.TypeSafe_def
                statement_with_gas_axioms stl2Old tsOld)
          have old:"(if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs m len2 arr2 stl2 stl1 then CompMemType m len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs m len arr stl1 stl2 then CompMemType m len arr (MTArray len2 arr2) stl1 stl2
                       else if TypedMemSubPrefPtrs m len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType m len2 arr2 dt stl2 dloc1 \<and> CompMemType m len arr dt stl1 dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m len arr stl1 stl2 then CompMemType m len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of
                  MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m len2 arr2 stl2 stl1 then CompMemType m len2 arr2 (MTValue val) stl2 stl1 else True
                  | MTValue val2 \<Rightarrow> True))"
              using 18(7) tsOld sameACC1 sameACC2 stl1Old' stl2Old' in1
              unfolding TypeSafe_def compMemPtrs_def by simp
            
            then show ?thesis
            proof(cases "stl1 = stl2")
              case True
              then show ?thesis 
                using old by auto
            next
              case notSame:False

            consider (ArrArr) len arr len2 arr2 where "tp1 = MTArray len arr \<and> tp2 = MTArray len2 arr2"
            | (ArrVal) arr2 len2 v where "tp2 = MTArray len2 arr2 \<and> tp1 = MTValue v"
            | (ValArr) v len2 arr2 where "tp1 = MTArray len2 arr2 \<and> tp2 = MTValue v"
            | (ValVal) v1 v2 where "tp2 = MTValue v1 \<and> tp1 = MTValue v2"  apply (cases tp2) apply (cases tp1) apply simp apply blast 
            by (metis extractType.cases)
          then show ?thesis
          proof(cases)
            case ArrArr
            then have old:"if TypedMemSubPrefPtrs m len2 arr2 stl2 stl1 then CompMemType m len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs m len arr stl1 stl2 then CompMemType m len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m len2 arr2 stl2 dloc1
                       then \<exists>dt. CompMemType m len2 arr2 dt stl2 dloc1 \<and> CompMemType m len arr dt stl1 dloc1 else True" 
              using old notSame by simp
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs m len2 arr2 stl2 stl1")
              case t1:True
              then have tmN:"TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1" 
                using ArrArr cpm2mTPrefOld_imps_TPref in1 le_eq_less_or_eq mLim neg_MemLSubPrefL2_imps_TypedMemSubPref nonLocChanged
                    sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld by metis
              then have "CompMemType m len2 arr2 (MTArray len arr) stl2 stl1" using old t1 by simp
              then have "CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1" 
                using ArrArr cpm2mCompMemTypeOld_imps_CompMemType in1 le_eq_less_or_eq mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                    nonLocChanged sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld
                by metis
              then show ?thesis using tmN notSame ArrArr by simp
            next
              case f1:False
              then have fo:"\<not> TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 " 
                by (smt (verit, ccfv_SIG) ArrArr in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs m len arr stl1 stl2")
                case True
                then have tmN:"TypedMemSubPrefPtrs m' len arr stl1 stl2" 
                  using ArrArr cpm2mTPrefOld_imps_TPref in1 le_eq_less_or_eq mLim neg_MemLSubPrefL2_imps_TypedMemSubPref nonLocChanged
                        sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld 
                  by (metis sameACC1 stl1Old')
                then have "CompMemType m len arr (MTArray len2 arr2) stl1 stl2"
                  using old f1 True by auto
                then have "CompMemType m' len arr (MTArray len2 arr2) stl1 stl2" 
                  using ArrArr cpm2mCompMemTypeOld_imps_CompMemType in1 le_eq_less_or_eq 
                        mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                        nonLocChanged sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld 
                  by (metis (mono_tags, lifting) sameACC1 stl1Old')
                then show ?thesis using tmN fo notSame ArrArr by simp
              next
                case f2:False
                then have f2':"\<not> TypedMemSubPrefPtrs m' len arr stl1 stl2"
                  using ArrArr in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref 
                  by (metis sameACC1 stl1Old')
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs m len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m len2 arr2 stl2 dloc1")
                  case True
                  then have t1:"TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1"
                    using ArrArr in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref sameACC1 stl1Old' 
                    by (smt (verit, best) cpm2mTPrefOld_imps_TPref)
                  have "\<exists>dt. CompMemType m len2 arr2 dt stl2 dloc1 \<and> CompMemType m len arr dt stl1 dloc1" 
                    using old True f1 f2 notSame by simp
                  then have "\<exists>dt. CompMemType m' len2 arr2 dt stl2 dloc1 \<and> CompMemType m' len arr dt stl1 dloc1" 
                    using ArrArr cpm2mCompMemTypeOld_imps_CompMemType in1 le_eq_less_or_eq 
                        mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                        nonLocChanged sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld 
                        sameACC1 stl1Old' 
                    by metis
                  then show ?thesis using ArrArr notSame t1 f2' fo by simp
                next
                  case False
                  then have " \<not> (TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1)"
                    using ArrArr in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref sameACC1 stl1Old' 
                    by metis
                  then show ?thesis using f2' fo notSame ArrArr by auto
                qed
              qed
            qed
          next
            case ArrVal
            then show ?thesis 
            proof(cases " TypedMemSubPrefPtrs m len2 arr2 stl2 stl1")
              case True
              then have tn:"TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1"
                using ArrVal cpm2mTPrefOld_imps_TPref in1 le_eq_less_or_eq mLim neg_MemLSubPrefL2_imps_TypedMemSubPref nonLocChanged
                        sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld 
                by metis
              have "CompMemType m len2 arr2 (MTValue v) stl2 stl1" using old notSame ArrVal 
                using True by auto
              then have "CompMemType m' len2 arr2 (MTValue v) stl2 stl1"
                using ArrVal cpm2mCompMemTypeOld_imps_CompMemType in1 le_eq_less_or_eq 
                      mLim neg_MemLSubPrefL2_imps_TypedMemSubPref
                      nonLocChanged sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld by metis
              then show ?thesis using ArrVal tn notSame by simp
            next
              case False
              then have "\<not> TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1"
                 using ArrVal in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref by metis
              then show ?thesis using ArrVal notSame by simp
            qed
          next
            case ValArr
            then show ?thesis 
            proof(cases " TypedMemSubPrefPtrs m len2 arr2 stl1 stl2")
              case True
                
              then have tn:"TypedMemSubPrefPtrs m' len2 arr2 stl1 stl2" 
                using ValArr cpm2mTPrefOld_imps_TPref in1 le_eq_less_or_eq mLim neg_MemLSubPrefL2_imps_TypedMemSubPref nonLocChanged
                        sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld 
                by (metis (mono_tags, lifting) sameACC1 stl1Old')
                
              then have "CompMemType m len2 arr2 (MTValue v) stl1 stl2" using old notSame ValArr True by simp

              then have "CompMemType m' len2 arr2 (MTValue v) stl1 stl2"
                using ValArr cpm2mCompMemTypeOld_imps_CompMemType in1 le_eq_less_or_eq 
                      mLim neg_MemLSubPrefL2_imps_TypedMemSubPref sameACC1 stl1Old'
                      nonLocChanged sameACC2 sameMemTSafe typeSafeAllPtrsNotTop2 stl2Old' tsOld by metis
              then show ?thesis using ValArr tn notSame by simp
            next
              case False
              then have "\<not> TypedMemSubPrefPtrs m' len2 arr2 stl1 stl2"
                 using ValArr in1 inv_cpm2mTPrefOld_imps_TPref le_refl mLim nonLocChanged sameACC2 sameMemTSafe
                    typeSafeAllPtrsNotTop2  stl2Old' tsOld typedPrefix_imp_SubPref sameACC1 stl1Old' by metis
              then show ?thesis using ValArr notSame by simp
            qed
          next
            case ValVal
            then show ?thesis using old by auto
          qed
        qed
      qed
    qed
    next
      show "methodVarsNoPref" using assms(1) unfolding TypeSafe_def by simp 
    next 
      show "balanceTypes (accounts st)" using assms(1) unfolding TypeSafe_def by simp 
    next 
      show "addressFormat (address e)" using eDef unfolding updateEnv.simps using 18(7) assms(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender e)" using eDef unfolding updateEnv.simps using 18(7) assms(1) unfolding TypeSafe_def by simp
    next 
      show " svalueTypes (svalue e)" using eDef unfolding updateEnv.simps using 18(7) assms(1) unfolding TypeSafe_def by simp
    next 
      show "lessThanTopLocs k'" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc k' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
        then show "accessStore loc k' = None" 
          by (metis k'Def lessThanTopLocs_def stackPushToplocSafe tsOld TypeSafe_def)
      next 
        fix loc y
        assume *:"accessStore loc k' = Some y "
        then show "\<exists>tloc<toploc k'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
          by (metis k'Def lessThanTopLocs_def stackPushToplocSafe tsOld TypeSafe_def)
      qed
    next 
      show "lessThanTopLocs c"  using NoneIP 18 assms(1) unfolding TypeSafe_def by simp 
    next 
      show "lessThanTopLocs m'" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc m' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then have "toploc m' > toploc m" using topMM m'Def2 unfolding allocate_def by auto
        then have "\<not>LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"  using * 
          by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative hashesIntSame nat_less_le
              order_antisym_conv)
        then have "\<not> TypedMemSubPref loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) (MTArray x t) \<or> loc = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))"
          using neg_MemLSubPrefL2_imps_TypedMemSubPref by blast
        then show "accessStore loc m' = None"
          using 18 assms(1) nonLocChanged unfolding TypeSafe_def lessThanTopLocs_def 
          by (metis "*" \<open>toploc m < toploc m'\<close> dual_order.trans mLim nat_less_le)
      next
        fix loc y
        assume *:"accessStore loc m' = Some y"
        then have "toploc m' > toploc m" using topMM m'Def2 unfolding allocate_def by auto
        then show "\<exists>tloc<toploc m'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using * 
          by (metis mLim neg_MemLSubPrefL2_imps_TypedMemSubPref nonLocChanged order_less_trans)
      qed
    next 
      show "typeCompat (denvalue e) k' m' (storage st (address e)) c " 
        unfolding typeCompat_def
      proof intros
        fix t' l'
        assume inDen:"(t', l') |\<in>| fmran (denvalue e)"
        then obtain i1 where i1Def:"(denvalue e) $$ i1 = Some (t', l')" by blast
        show "case l' of
           Stackloc loc \<Rightarrow>
             (case accessStore loc k' of None \<Rightarrow> False 
             | Some (KValue val) \<Rightarrow> (case t' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
             | Some (KCDptr stloc) \<Rightarrow> (case t' of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
             | Some (KMemptr stloc) \<Rightarrow> (case t' of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
             | Some (KStoptr stloc) \<Rightarrow> (case t' of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t' of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) 
                                | _ \<Rightarrow> False)"
        proof(cases l')
          case (Stackloc x1)
          then show ?thesis 
          proof(cases "x1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))")
            case True
            then have acc:"accessStore x1 k' = Some (KMemptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)))" 
              using k'Def unfolding push_def allocate_def updateStore_def accessStore_def by auto
            have t'Def:"t' = (Memory (MTArray x t))" using eDef inDen True Stackloc i1Def a150 
              using "18"(7) by fastforce
            have "MCon (MTArray x t) m' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" using mcTop by simp
            then show ?thesis using Stackloc acc t'Def by simp
          next
            case False
            then have sameACC:"accessStore x1 k' = accessStore x1 sck'" 
              using k'Def 18(7) unfolding push_def allocate_def accessStore_def updateStore_def by simp
            obtain i where  iDef:"(denvalue e) $$ i = Some (t', l')" using inDen by blast
            then have "i \<noteq> ip" using eDef False Stackloc by auto
            then have "denvalue e' $$ i = Some (t', l')" using iDef eDef by simp
            then have inOld:"(t', l') |\<in>| fmran (denvalue e')" using fmranI by metis
            have ol:"(case accessStore x1 sck' of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case t' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                  | Some (KCDptr stloc) \<Rightarrow> (case t' of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                  | Some (KMemptr stloc) \<Rightarrow> (case t' of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                  | Some (KStoptr stloc) \<Rightarrow> (case t' of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev')) | _ \<Rightarrow> False))"
              using inOld sameACC sameAddress Stackloc using assms(1) 18(7) unfolding TypeSafe_def typeCompat_def by fastforce
            then show ?thesis 
            proof(cases "accessStore x1 k'")
              case None
              then show ?thesis using inOld sameACC Stackloc ol by simp
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1)
                then show ?thesis using Some inOld sameACC Stackloc ol by simp
              next
                case (KCDptr x2)
                then show ?thesis using Some inOld sameACC Stackloc ol 18(7) sameCd by auto
              next
                case (KMemptr x3)
                then obtain struct where structdef:"t' = Memory struct" 
                  using ol Some sameACC by (cases t', simp+)
                then have lims:"\<not> LSubPrefL2 x3 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<and> \<not> LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) x3" 
                  using typeSafeAllPtrsNotTop2[OF assms(1), of struct x1 x3]  Stackloc inOld 18(7) sameACC Some KMemptr by simp
                have lim2:"\<forall>len arr loc. struct = MTArray len arr \<and> TypedMemSubPrefPtrs mem' len arr x3 loc 
                          \<longrightarrow> \<not> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) \<and> \<not> LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) loc"
                  using typeSafeAllMemPtrsCantTop[OF assms(1), of struct x1 x3] structdef
                                       Stackloc inOld 18(7) sameACC Some KMemptr by simp
                have mcO:"MCon struct mem' x3" using ol Some KMemptr structdef sameACC by simp
                then have "MCon struct m' x3" using lims lim2
                proof(induction struct arbitrary:x3)
                  case (MTArray x1 struct)
                  have "x1 > 0" using MTArray.prems(1) unfolding MCon.simps 
                    using bot_nat_0.not_eq_extremum by fastforce
                  moreover have "(\<exists>p. accessStore x3 m' = Some (MPointer p)) \<or> accessStore x3 m' = None"
                    using MTArray.prems(1,2) unfolding MCon.simps  using nonLocChanged2 18(7) calculation(1) by simp
                  moreover have "\<forall>i<x1.
            (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' of None \<Rightarrow> False
             | Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct m' (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
             | Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct m' loc2 | MTValue val \<Rightarrow> False))"
                  proof intros
                    fix i 
                    assume *:"i<x1"
                    then have notSub:"\<not> LSubPrefL2 (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<or> (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m))" 
                      using MTArray.prems(2) Mutual_NonSub_SpecificNonSub by auto
                    show "(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' of None \<Rightarrow> False
             | Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct m' (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
             | Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct m' loc2 | MTValue val \<Rightarrow> False))"
                    proof(cases struct)
                      case (MTArray x11 x12)
                      obtain loc2 where loc2Def:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MPointer loc2) 
                                        \<and> MCon struct mem' loc2" 
                        using MTArray.prems(1) * 
                        by (metis MConArrayPointers MCon_imps_sub_Mcon MTArray calculation(1))
                      then have o1:"\<forall>loc. TypedMemSubPrefPtrs mem' x1 struct x3 loc \<longrightarrow>
                                 \<not> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) \<and> \<not> LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) loc" 
                        using MTArray.prems by simp
                      have "\<forall>len arr loc. struct = MTArray len arr \<and> TypedMemSubPrefPtrs mem' len arr loc2 loc \<longrightarrow>
                            \<not> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) \<and> \<not> LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem')) loc"
                        using o1 loc2Def * by fastforce
                      moreover have "TypedMemSubPrefPtrs mem' x1 struct x3 loc2"
                        using o1 loc2Def * 18(7) 
                        using MTArray TypedMemSubPrefPtrs.simps(2) by blast
                      moreover have "\<not> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) \<and> \<not> LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc m)) loc2"
                        using o1 calculation 18(7) by simp
                      ultimately have "MCon struct m' loc2" using MTArray.IH[of loc2] loc2Def by simp
                      moreover have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer loc2) "
                        using loc2Def * nonLocChanged2 notSub 18(7) by simp
                      ultimately show ?thesis 
                        using MTArray by force
                    next
                      case (MTValue x2)
                      then obtain v where vDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) mem' = Some (MValue v)
                                            \<and> MCon (MTValue x2) mem' (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i))"
                        using * MTArray.prems(1) 
                        by (meson MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
                      then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MValue v)" 
                        using nonLocChanged2 notSub 18(7) by simp
                      then show ?thesis  using vDef MTValue unfolding MCon.simps 
                        using notSub nonLocChanged2 18(7) by simp
                    qed
                  qed
                  ultimately show ?case unfolding MCon.simps by simp
                next
                  case (MTValue x)
                  then show ?case using  nonLocChanged2 18(7) unfolding MCon.simps by simp
                qed
                then show ?thesis using sameAddress Some inOld sameACC Stackloc ol 18(7) KMemptr structdef by simp
              next
                case (KStoptr x4)
                then show ?thesis using sameAddress Some inOld sameACC Stackloc ol 18(7) by (cases t',simp+)
              qed
            qed
          qed
        next
          case (Storeloc x2)
          then have inOld:"(t', l') |\<in>| fmran (denvalue e')"using eDef inDen unfolding updateEnv.simps 

            using "18"(7) assms(2) decl_env_not_i fmlookup_ran_iff by fastforce
          then have "(case t' of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev')) | _ \<Rightarrow> False)"
            using assms(1) 18(7) Storeloc inDen sameAddress unfolding TypeSafe_def typeCompat_def by fastforce
          then obtain struct where "t' = Storage struct" by (cases t', simp+)
          then show ?thesis using assms(1) 18(7) Storeloc inDen sameAddress inOld 
            unfolding TypeSafe_def typeCompat_def by fastforce
        qed
      qed
    qed
  next
    fix x l 
    assume *:"(\<nexists>y y'. x = Memory y \<or> x = Value y') \<and> (x, l) |\<in>| fmran (denvalue e)"
    then obtain ip' where **: "denvalue e $$ ip' = Some (x, l)" by blast
    then have "ip' \<noteq> ip " using * eDef unfolding updateEnv.simps by auto
    then have "denvalue ev' $$ ip' = Some (x, l)" using 18 ** decl_env_not_i by (auto split:if_splits)
    then show "(x, l) |\<in>| fmran (denvalue ev')" using fmranI by metis
  next
    fix sckl ptr
    assume *:" accessStore sckl k' = Some ptr \<and> (\<nexists>y y'. ptr = KMemptr y \<or> ptr = KValue y')"
    have "\<exists>v. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k)) k' = (Some (KMemptr v))"
      using k'Def unfolding push_def allocate_def updateStore_def accessStore_def by simp
    then have "sckl \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc k))" using * by auto
    then have "accessStore sckl k' =accessStore sckl sck'" 
      using k'Def 18 unfolding push_def allocate_def updateStore_def accessStore_def by simp
    then show "accessStore sckl sck' = Some ptr " using * by simp
  next 
    show "cd' = c" using sameCd by auto
  qed
next
  case (19 x t p t' vz mem wa c m k e)
  then show ?thesis by simp
next
  case (20 x t p t' wb wc wd c m k e)
  then show ?thesis by simp
next
  case (21 x t p t' we cd wf wg c m k e)
  then show ?thesis by simp
next
  case (22 x t p x' t' wh wi wj s c m k e)
  then show ?thesis by simp
next
  case (23 v wm wn wo wp wq wr)
  then show ?thesis by simp
next
  case (24 va v wn wo wp wq wr)
  then show ?thesis by simp
next
  case (25 wl vc vb wn wo wp wq wr)
  then show ?thesis by simp
next
  case (26 v vc vb wn wo wp wq wr)
  then show ?thesis by simp
next
  case (27 v vc vb wn wo wp wq wr)
  then show ?thesis by simp
next
  case (28 wl vc v wn wo wp wq wr)
  then show ?thesis by simp
next
  case (29 wl vc v wn wo wp wq wr)
  then show ?thesis by simp
next
  case (30 wl vc v wn wo wp wq wr)
  then show ?thesis by simp
next
  case (31 wl vc va vd wn wo wp wq wr)
  then show ?thesis by simp
next
  case (32 wl vc va wn wo wp wq wr)
  then show ?thesis by simp
next
  case (33 va v wo wp wq wr)
  then show ?thesis by simp
next
  case (34 wl vc vb wo wp wq wr)
  then show ?thesis by simp
next
  case (35 v vc vb wo wp wq wr)
  then show ?thesis by simp
next
  case (36 v vc vb wo wp wq wr)
  then show ?thesis by simp
next
  case (37 wl vc v wo wp wq wr)
  then show ?thesis by simp
next
  case (38 wl vc v wo wp wq wr)
  then show ?thesis by simp
next
  case (39 wl vc v wo wp wq wr)
  then show ?thesis by simp
next
  case (40 wl vc va vd wo wp wq wr)
  then show ?thesis by simp
next
  case (41 wl vc va wo wp wq wr)
  then show ?thesis by simp
next
  case (42 x t p t' ws wt wu wv c m k e)
  then show ?thesis by simp
next
  case (43 t t' p t'' ww wx wy wz c m k e)
  then show ?thesis by simp
next
  case (44 v va xd xe xf xg xh)
  then show ?thesis by simp
next
  case (45 v va ve vd xd xe xf xg xh)
  then show ?thesis by simp
next
  case (46 v va ve vd xd xe xf xg xh)
  then show ?thesis by simp
next
  case (47 v va ve vd xd xe xf xg xh)
  then show ?thesis by simp
next
  case (48 v xc xd xe xf xg xh)
  then show ?thesis by simp
next
  case (49 xb xd xe xf xg xh)
  then show ?thesis by simp
next
  case (50 xb vc vb xd xe xf xg xh)
  then show ?thesis by simp
next
  case (51 xb vc vb xd xe xf xg xh)
  then show ?thesis by simp
next
  case (52 xb vc vb xd xe xf xg xh)
  then show ?thesis by simp
qed

lemma typeSafeDecl:
  assumes "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
  assumes "(case t'' of Value typ \<Rightarrow> typeCon typ (extractValueType v)
        | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v)
        | Memory struct \<Rightarrow> MCon struct (memory st) (extractValueType v)
        | Storage struct \<Rightarrow> SCon struct (extractValueType v) (storage st (address ev)))" 
    and "TypeSafe ev' (accounts st) sck' mem' (storage st ) cd'"
    and "decl ip tp (Some (v,t'')) cp cd (memory st) (storage st (address ev)) (cd', mem',  sck', ev') = Some (c, m', k', e)"
    and "\<not>cp  \<longrightarrow> (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) \<and> toploc (memory st) \<le> toploc (mem')
                  \<and> ncpDenvalueLimit ev' ev sck' (stack st) (memory st) 
                  \<and> ncpOMemInDMem (memory st) mem'
                  \<and> ncpElementsNoSubPref (memory st) mem'
                  \<and> ncpNewSelfPoint (memory st) mem'"
    and "\<forall>struct.
       t'' = Memory struct \<longrightarrow>
       (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore stloc (stack st) = Some (KMemptr p) \<and> (tp'' = struct \<and> v = (KMemptr p)
      \<or> (\<exists>len arr. p \<noteq> (extractValueType v) \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))"
    and "\<forall>struct.
       t'' = Calldata struct \<longrightarrow>
       (\<exists>stloc tp'' p. (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore stloc (stack st) = Some (KCDptr p) \<and> (tp'' = struct \<and> v = (KCDptr p)
      \<or> (\<exists>len arr. p \<noteq> (extractValueType v) \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))"
    and "\<forall>struct. tp = Storage struct \<longrightarrow> (\<forall>locs tp. SCon tp locs (storage st (address ev)) \<longrightarrow> SCon tp locs (storage st (address ev'))) \<and> (\<exists>loc tp'' p. (Storage tp'', loc) |\<in>| fmran (denvalue ev')
                                                \<and>(case loc of Stackloc stloc \<Rightarrow> 
                                                                  (accessStore stloc sck' =Some (KStoptr p) \<and> ((tp'' = struct \<and>  v = KStoptr p) \<or> 
                                                                  ((extractValueType v) \<noteq> p \<and> CompStoType tp'' struct p (extractValueType v))))
                                                              | Storeloc stloc \<Rightarrow> 
                                                                  (((tp'' = struct \<and>  v = KStoptr stloc) \<or> 
                                                                  ((extractValueType v) \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))
                                                              ))"
  shows "TypeSafe e (accounts st) k' m' (storage st) c \<and>
        (\<not>cp \<longrightarrow> (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) 
                  \<and> toploc (memory st) \<le> toploc (m') 
                  \<and> ncpDenvalueLimit e ev k' (stack st ) (memory st)
                  \<and> ncpOMemInDMem (memory st) m'
                  \<and> ncpElementsNoSubPref (memory st) m'
                  \<and> ncpNewSelfPoint (memory st) m' 
        ) \<and> toploc m' \<ge> toploc mem'
           "  using assms(4) 
proof(cases rule:decl.elims)
  case (1 t uu uv uw ux c m k e)
  then show ?thesis using assms by blast
next
  case (2 t v t' uy uz va vb cd' mem'' sck'' ev'')
  then obtain v' where a10:"(convert t' t v) = Some v'" using decl.simps(2) by fastforce
  then have a20:"v' = v" using convertSame by metis
  have "typeCon t' v" using assms(2) 2 by simp
  then have a30:"typeCon t v" using a10 a20 typeSafeConvert by simp
  show ?thesis
  proof(cases "denvalue ev' $$ ip")
    case (Some a)
    then have same:"(cd', mem', sck', ev') = (c, m', k', e)" using 2 a10 unfolding astack_dup.simps by simp
    show ?thesis 
    proof intros
      show "TypeSafe e (accounts st) k' m' (storage st) c" using assms(3) same 2(7) by blast
      show "\<And>locs tp. \<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) same 2(7) by simp
      show "\<not> cp \<Longrightarrow> toploc (memory st) \<le> toploc m'" using assms(5) same 2(7) by simp
      show "\<not> cp \<Longrightarrow> ncpDenvalueLimit e ev k' (stack st) (memory st)"  using assms(5) same 2(7) by simp
      show "\<not> cp \<Longrightarrow> ncpOMemInDMem (memory st) m'" using assms(5) same 2(7) by simp
      show "\<not> cp \<Longrightarrow> ncpElementsNoSubPref (memory st) m'" using assms(5) same 2(7) by simp
      show "\<not> cp \<Longrightarrow> ncpNewSelfPoint (memory st) m'" using assms(5) same 2(7) by simp
      show "toploc mem' \<le> toploc m'" using assms(5) same 2(7) by simp
    qed
  next
    case None
    then have a40:"(Some (cd', mem', astack ip (Value t) (KValue v) (sck', ev'))) = Some (c, m', k', e)" using 2 decl.simps(2) a10 assms(1) a20 by simp
    then have a50:"k' = push (KValue v) sck'" using 2 by force

    have a60:"e = (updateEnv ip (Value t) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev')" using a40 a10 by simp
    then have a70:"denvalue e = denvalue(ev' \<lparr> denvalue := fmupd ip ((Value t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev') \<rparr>)" by simp
    then have a80:"(denvalue e) $$ ip = Some  ((Value t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp

    show ?thesis unfolding TypeSafe_def
    proof(intros)

      show "unique_locations (denvalue e)" using assms(3) 2(7) updateEnvUniqueLocs a40 by fastforce
    next
      have b2: "compPointers sck' (denvalue ev')" using assms(3) 2(7) unfolding TypeSafe_def by auto
      have "address ev' = address e"using a70 a60 
        by simp
      moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 2(7) by simp
      ultimately show "compPointers k' (denvalue e)"
        using compPointersNonStackUpd[of sck'  ev' e ip "Value t" k' "KValue v"   ] a70 a50 assms(3) 2(7) b2 by simp
    next
      have *:"safeContract (storage st)" using assms(3) unfolding TypeSafe_def using 2(7) by auto
      have **:"address ev' = address e"using a70 a60 
        by simp
      have ***:"contract ev' = contract e" using a70 a60 by simp
      show "safeContract (storage st) " using * by auto
    next 
      show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
    next
      show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
    next
      show "svalueTypes (svalue e)" using a60 2(7) assms(3) TypeSafe_def svalueTypes_def by simp
    next
      have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 2(7) by simp
      then show "lessThanTopLocs k'" using stackPushToplocSafe a50 2(7) by metis
    next
      have "lessThanTopLocs cd'" using assms(3) TypeSafe_def 2(7) by simp
      then show "lessThanTopLocs c" using stackPushToplocSafe a50 2(7) a40 by simp
    next
      have "lessThanTopLocs mem'" using assms(3) TypeSafe_def 2(7) by simp
      then show "lessThanTopLocs m'" using  2(7) a40 by simp
    next
      have "addressFormat (address ev')" using assms(3) TypeSafe_def 2(7) by simp
      then show "addressFormat(address e)" using 2(7) a40 by auto
    next
      have "addressFormat (sender ev')" using assms(3) TypeSafe_def 2(7) by simp
      then show "addressFormat (sender e)" using 2(7) a40 by auto
    next
      show "typeCompat (denvalue e) k' m' (storage st (address e)) c " unfolding typeCompat_def
      proof intros
        fix tDen lDen 
        assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
        then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
        then have a100:"(storage st (address ev')) = (storage st (address e))" using assms(3) a60 by simp
        have a110:"m' = mem'" and a115:"cd' = c" using a40 by simp+
        have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 2(7) by simp
        have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''" using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def assms(3) TypeSafe_def 2(7) by auto
        then have a140:"\<forall>x y. \<not>((denvalue ev') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 2(7) by fastforce
        have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" using a70 a140 fmranI by auto
        then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using a70 lessThanTopLocs_def fmranI by auto
        show "case lDen of
               Stackloc loc \<Rightarrow>
                 (case accessStore loc k' of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                 | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                 | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                 | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
               | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
        proof(cases lDen)
          case (Stackloc x1)
          then show ?thesis
          proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
            case True
            then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KValue v)" using a50 by (simp add:push_def allocate_def updateStore_def accessStore_def)

            then show ?thesis
            proof(cases "accessStore x1 k'")
              case None
              then show ?thesis using True a170 Stackloc by simp
            next
              case some:(Some a)
              then have a180:"a = (KValue v) " using a170 True by simp
              have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KValue v)" using a50 by (simp add:push_def allocate_def updateStore_def accessStore_def)
              then have "ip'' = ip" using a150 True a90 Stackloc by simp
              then have "tDen = Value t" using a90 a80 by simp
              then show ?thesis using Stackloc some a180 a30 a190 True by simp
            qed
          next
            case False

            then have "ip'' \<noteq> ip" using a160 a90 Stackloc by simp
            then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using a70 Stackloc fmranI a90 False * by fastforce
            then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 2(7) by blast
            then have a190:"accessStore x1 k' = accessStore x1 sck'" using a50 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
            then show ?thesis
            proof(cases "accessStore x1 k'")
              case None
              then show ?thesis using a180 a190 Stackloc by simp
            next
              case some:(Some a) 
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
                using a190 some Stackloc a170 * a180 a110 a115 a100 2(7)
                by (cases a; cases tDen; force+)
            qed
          qed
        next
          case (Storeloc x2)
          then have a170:"ip'' \<noteq> ip" using a70 Storeloc a90 by auto
          then have a180: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using a70 Storeloc fmranI a90 by fastforce 
          then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def using Storeloc a100 2(7) by (cases tDen;force)
        qed
      qed
    next 
      show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
    next
      have b2: "compMemPtrs sck' mem' (denvalue ev')" using assms(3) 2(7) unfolding TypeSafe_def by auto
      have b5:"address ev' = address e"using a70 a60 
        by simp
      have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 2(7) by simp
      show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1 
        assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
         (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
         accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
        then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" by auto
        then have b40:"ip' \<noteq> ip" using a70 by auto
        then have b50:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev')" using a70 b30 fmranI by fastforce

        then obtain ip'' where  b30:"denvalue(e) $$ ip'' = Some((Memory tp2, Stackloc l2))" using b20 by auto
        then have b40:"ip'' \<noteq> ip" using a70 by auto
        then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')" using a70 b30 fmranI by fastforce

        have b70:"\<forall>l''. (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l'' \<longrightarrow> accessStore l'' k' = accessStore l'' sck'" 
          using a50 unfolding push_def updateStore_def allocate_def accessStore_def by simp
        have b80:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KValue v)" using a50  unfolding push_def updateStore_def allocate_def accessStore_def by simp 
        then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l1" using b70 b80 b20 by auto
        then have b90:"accessStore l1 sck' = accessStore l1 k'" using b70 b80 b20 by simp

        then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l2" using b70 b80 b20 by auto
        then have b95:"accessStore l2 sck' = accessStore l2 k'" using b70 b80 b20 by simp

        show "if stl1 = stl2 then tp1 = tp2
             else case tp1 of
                  MTArray len arr \<Rightarrow>
                    (case tp2 of
                    MTArray len2 arr2 \<Rightarrow>
                      if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                      else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                        else if TypedMemSubPrefPtrs m' len arr stl1 dloc1\<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                            then \<exists>dt.
                                    CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                    CompMemType m' len arr dt stl1 dloc1
                                   
                      else True
                    | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
                  | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
          using 2(7) a40 b2 b50 b60 b20 compMemPtrs_def b90 b95 by simp
      qed
    next 
      have a110:"m' = mem'" using a40 by simp
      then show "\<And>locs tp. \<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) 2(7) assms(5) by (simp)
    next
      assume "\<not> cp"
      then show "toploc (memory st) \<le> toploc m'"  using assms(5) 2(7)  a40 by blast
    next 
      assume notCP:"\<not>cp" 
      show "ncpDenvalueLimit e ev k' (stack st) (memory st) " 
        unfolding ncpDenvalueLimit_def
      proof intros
        fix tp' locs p i
        assume a120:" (Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p) \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
        have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''" using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def assms(3) TypeSafe_def 2(7) by auto
        then have a140:"\<forall>x y. \<not>((denvalue ev') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
          using lessThanTopLocs_def Read_Show_nat'_id assms(3) typeSafeAllStacklocsExist fmranI 2(7) by fastforce
        have a150: "\<forall>ip''' . denvalue e $$ ip''' = Some  ((Value t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" using a70 a140 fmranI by auto
        then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using a70 lessThanTopLocs_def fmranI by auto
        show " \<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))
            " 
        proof -
          obtain ip'' where ip''def:"(denvalue e) $$ ip'' = Some (Memory tp', Stackloc locs)" using a120 by blast
          then have a170:"ip'' \<noteq> ip" using a70 by auto
          then have a180: "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev')" using a70  fmranI ip''def  by fastforce
          have a190:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a160 a170 
            by (metis a140 a180 fmlookup_ran_iff snd_eqD)
          then obtain y' where  a200:"accessStore locs sck' = Some y' " using typeSafeAllStacklocsExist assms(3) 2(7) a180 by blast
          then have "accessStore locs k' = accessStore locs sck'" using a50  a120 a190 unfolding push_def allocate_def updateStore_def accessStore_def by simp
          then show " \<exists>tp'' loc2 p'.
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))" 
            using assms(5) 2(7) a120 a40 a60 a120 a180 notCP ncpDenvalueLimit_def
            by (metis)
        qed
      qed
    next
      assume notCP:"\<not>cp"
      then show "ncpOMemInDMem (memory st) m'" using a40 2(7) assms by simp
    next 
      assume notCP:"\<not>cp"
      then show "ncpElementsNoSubPref (memory st) m'" using a40 assms 2 by blast
    next
      assume notCP:"\<not>cp"
      then show "ncpNewSelfPoint (memory st) m'" using a40 assms 2 by blast
    next
      show "toploc mem' \<le> toploc m' " using a40 by simp     
    qed
  qed
next
  case (3 vd ve vb vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (4 vd ve vb vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (5 vd ve vb vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (6 vd va ve vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (7 vd va ve vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (8 vd va ve vf vg vh vi vj)
  then show ?thesis using assms(1) by simp
next
  case (9 x t p vk cd vl vm cd' mem'' sck'' ev'')
  then obtain l where a1:"l = ShowL\<^sub>n\<^sub>a\<^sub>t(toploc cd')" by simp
  have vk:"vk = Calldata (MTArray x t)" using decl.simps(9) 9(8) by (simp split:if_split_asm)
  then have locationscd':"(\<forall>tloc loc. toploc cd' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc cd' = None)" using assms 9 unfolding TypeSafe_def lessThanTopLocs_def by simp
  then have b1:"accessStore l cd' = None" using a1 using Read_Show_nat'_id using LSubPrefL2_def by auto
  have b2:"x>0" using 9(8) vk a1 by (metis not_None_eq)
  then have Mconcd:"MCon (MTArray x t) cd (extractValueType v)" using assms(2) 9(2) 9(4) vk by simp
  obtain c' where a2:"\<exists>dud. (dud, c') = allocate cd'"  by (simp add: allocate_def)
  then have lNotInC':"accessStore l c' = None" using b1 a1 unfolding allocate_def accessStore_def by simp
  obtain c'' where a3:"cpm2m p l x t cd c' = Some c''" using 9 a1 a2 assms 
    by (metis (no_types, lifting) bind.bind_lzero case_prod_conv option.discI option.exhaust)

  have NoneIp:"denvalue ev'' $$ ip = None" using 9 by (auto split:if_splits)
  then have a4:"Some (c, m', k', e) = Some (c'', mem'', astack_dup ip (Calldata (MTArray x t)) (KCDptr l) (sck', ev''))" 
    using a1 a2 a3 9(7,8) b2 vk 
    by (metis bind.bind_lunit case_prod_conv)
  then have a20:"k' = push (KCDptr l) sck'" using 9 NoneIp vk a3 unfolding astack_dup.simps by simp
  have a30:"e = (updateEnv ip (Calldata (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev'')" using a4 NoneIp unfolding astack_dup.simps by simp
  then have a40:"denvalue e = denvalue(ev' \<lparr> denvalue := fmupd ip (Calldata (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev'') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some  (Calldata (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  show ?thesis unfolding TypeSafe_def 
  proof(intros)
    show "unique_locations (denvalue e)" using assms(3) 9(7) astack_dup_is_astack NoneIp updateEnvUniqueLocs a4 by fastforce
  next
    have b2: "compPointers sck' (denvalue ev'')" using assms(3) 9(7) unfolding TypeSafe_def by auto
    have "address ev'' = address e"using a30 by simp
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 9(7) by simp
    ultimately show "compPointers k'  (denvalue e)"
      using compPointersNonStackUpd[of sck'  ev' e ip " Calldata (MTArray x t)" k' "KCDptr l"   ] 
        a40 a50 assms(3) 9(7) b2 a20 by simp
  next
    have b2: "compMemPtrs sck' mem' (denvalue ev'')" using assms(3) 9(7) unfolding TypeSafe_def by auto
    have b5:"address ev'' = address e"using a30  
      by simp
    have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 9(7) by simp
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
    proof intros
      fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1
      assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" by auto
      then have b40:"ip' \<noteq> ip" using a30 by auto
      then have b50:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'')" using a30 b30 fmranI by fastforce

      then obtain ip'' where  b30:"denvalue(e) $$ ip'' = Some((Memory tp2, Stackloc l2))" using b20 by auto
      then have b40:"ip'' \<noteq> ip" using a30 by auto
      then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" using a30 b30 fmranI by fastforce

      have b70:"\<forall>l''. (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l'' \<longrightarrow> accessStore l'' k' = accessStore l'' sck'" 
        using a20 unfolding push_def updateStore_def allocate_def accessStore_def by simp
      have b80:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" using a20  unfolding push_def updateStore_def allocate_def accessStore_def by simp 
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l1" using b70 b80 b20 by auto
      then have b90:"accessStore l1 sck' = accessStore l1 k'" using b70 b80 b20 by simp

      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l2" using b70 b80 b20 by auto
      then have b95:"accessStore l2 sck' = accessStore l2 k'" using b70 b80 b20 by simp
      show " if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1 
                                 
                                  else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
        using 9(7) a4 b2 b50 b60 b20 compMemPtrs_def b90 b95 by fastforce
    qed
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 9(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 9(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 9(7) by metis
  next
    have "addressFormat (address ev') " using assms(3) TypeSafe_def 9(7) by simp
    then show "addressFormat(address e)" using 9(7) a4 NoneIp by auto
  next
    have "addressFormat  (sender ev')" using assms(3) TypeSafe_def 9(7) by simp
    then show "addressFormat (sender e)" using 9(7) a4 NoneIp by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev'')) = (storage st (address e))" using a30 by simp
      have a110:"m' = mem''" using a4 by simp
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 9(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''" using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 9(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using a40 fmranI by auto
      show "case lDen of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KCDptr l " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = Calldata (MTArray x t)" using a90 a50 by simp
            then have a210:"t'' = tDen" using  9(2) vk by simp
            have a220:"v = KCDptr p" using 9(2) by simp
            have "c = c''" using a4 by simp
            then have "MCon (MTArray x t) c'' l" using a3 unfolding cpm2m_def 
              using MCon_cpm2m[of p l t cd c' x] Mconcd 9(2)  
              by (metis a220 lNotInC' extractValueType.simps(2))
            then have "MCon (MTArray x t) c l" using a4 a110 9(7) by blast
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 9(2) by simp
          qed
        next
          case False
          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs c''" 
            using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x c''] by fastforce

          have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc cd' = None" using locationscd' a2 lNotInC' a1 by auto
          have "\<forall>locations. accessStore locations cd' = accessStore locations c'" using a2 accessAllocate[of c' cd'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs cd' = accessStore locs c''" using b100 a2 unfolding allocate_def by simp

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc False by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 9 by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis 
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis 
            proof(cases a)
              case (KValue x1)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
                using a190 some Stackloc a170 * a180 a110 a100 9(7) by (cases tDen, fastforce+)
            next
              case (KCDptr x2)
              then have b10:"(case tDen of Calldata struct \<Rightarrow> MCon struct cd' x2 | _ \<Rightarrow> False)" 
                using some KCDptr a170 Stackloc a190 using assms(3) 9(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Calldata struct" by (auto split:Type.splits) 
              then have "MCon struct cd' x2" using b10 by simp
              then have "MCon struct c'' x2" using mconCopySingle[of l cd' c'' struct x2] b110 b105 by auto
              then show ?thesis using Stackloc some KCDptr tden a110 a4 by simp
            next
              case (KMemptr x3)
              then have b10:"(case tDen of Memory struct \<Rightarrow> MCon struct mem' x3 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 9(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Memory struct" by (auto split:Type.splits) 
              then have "MCon struct mem' x3" using b10 by simp
              then show ?thesis using Stackloc some KMemptr tden a110 a4 9 by simp
            next
              case (KStoptr x4)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
                using a190 some Stackloc a170 * a180 a110 a100 9(7) by (cases tDen; fastforce)
            qed
          qed 
        qed
      next
        case (Storeloc x2)
        then have "ip'' \<noteq> ip" using a160 a90 by simp
        then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Storeloc fmranI a90 * by fastforce
        then have a180:"(case tDen of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev'')) | _ \<Rightarrow> False)"  using  a170 Storeloc using assms(3) 9(7) 
          unfolding TypeSafe_def typeCompat_def by force
        then obtain typ' where tdent:"tDen =  Storage typ'"  by (auto split: Type.splits)
        then have "SCon typ' x2 (storage st (address ev''))" using a180 by simp
        then have "SCon typ' x2 (storage st (address e))" using a100 by simp
        then show ?thesis  using  a170 Storeloc using assms(3) 9(7) tdent 
          by simp
      qed
    qed
  next 
    have b100:"lessThanTopLocs cd'" using assms(3) 9(7) unfolding TypeSafe_def by blast
    have b99:"toploc c' = toploc c" using  a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x c''] b2 by simp
    have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs c" 
      using cpm2mSingleChange[of p l t cd c' x] a4 a3 cpm2m_def[of p l x t cd c' ] by fastforce
    moreover have "\<forall>locations. accessStore locations cd' = accessStore locations c'" using a2 accessAllocate[of c' cd'] by auto
    ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs cd' = accessStore locs c" by simp
    then show "lessThanTopLocs c" using cdMemLocsToploc[of cd' l c' c] a1 a2 b100 b99 by auto
  next 
    show "lessThanTopLocs m'" using assms(3) 9(7) a4 unfolding TypeSafe_def by auto

  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    have a110:"m' = mem'" using a4 9 by simp
    then show "\<And>locs tp. \<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) 9(7) assms(5) by (simp)
  next
    assume notCp:"\<not>cp"
    then show "toploc (memory st) \<le> toploc m'" using a4 assms 9 by auto
    then show "ncpDenvalueLimit e ev k' (stack st) (memory st) " using 9(3) notCp by simp
    show "ncpOMemInDMem (memory st) m'" using a4 assms 9 notCp by blast
    show "ncpElementsNoSubPref (memory st) m'"
      using a4 assms 9 notCp by blast     
  next
    assume notCP:"\<not>cp"
    then show "ncpNewSelfPoint (memory st) m'" using a40 assms 9 by blast
  next 
    show "toploc mem' \<le> toploc m' " using 9 assms a4 by blast
  qed
next
  case (10 x t p vn vo mem vp cd' mem''' sck'' ev'')
  then obtain l where a1:"l = ShowL\<^sub>n\<^sub>a\<^sub>t(toploc cd')" by simp
  have vk:"vn = Memory (MTArray x t)" using decl.simps(9) 10(8) by (simp split:if_split_asm)
  then have locationscd':"(\<forall>tloc loc. toploc cd' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc cd' = None)" using assms 10 unfolding TypeSafe_def lessThanTopLocs_def by simp
  then have b1:"accessStore l cd' = None" using a1 using Read_Show_nat'_id using LSubPrefL2_def by auto
  have b2:"x>0" using 10(8) vk a1 by (metis not_None_eq)
  then have Mconcd:"MCon (MTArray x t) mem (extractValueType v)" using assms(2) 10(2) 10(4) vk 10(5) by simp
  obtain c' where a2:"\<exists>dud. (dud, c') = allocate cd'"  by (simp add: allocate_def)
  then have lNotInC':"accessStore l c' = None" using b1 a1 unfolding allocate_def accessStore_def by simp
  obtain c'' where a3:"cpm2m p l x t mem c' = Some c''" using 10 a1 a2 assms by (metis (no_types, lifting) bind.bind_lzero case_prod_conv option.discI option.exhaust)
  have NoneIp:"denvalue ev'' $$ ip = None" using 10 by (auto split:if_splits)
  then have a4:"Some (c, m', k', e) = Some (c'', mem''', astack_dup ip (Calldata (MTArray x t)) (KCDptr l) (sck'', ev''))" 
    using a1 a2 a3 10 assms decl.simps(9) vk
    by (metis (no_types, lifting) b2 bind.bind_lunit case_prod_conv)
  then have a4:"Some (c, m', k', e) = Some (c'', mem''', astack_dup ip (Calldata (MTArray x t)) (KCDptr l) (sck', ev''))"
    using 10(7) by blast
  then have a20:"k' = push (KCDptr l) sck'" using 10 NoneIp by force
  have a30:"e = (updateEnv ip (Calldata (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev'')" using a4 NoneIp by simp
  then have a40:"denvalue e = denvalue(ev' \<lparr> denvalue := fmupd ip (Calldata (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev'') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some  (Calldata (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  show ?thesis unfolding TypeSafe_def 
  proof(intros)
    show "unique_locations (denvalue e)" using assms(3) 10(7) updateEnvUniqueLocs a4 NoneIp by fastforce
  next
    have b2: "compPointers sck' (denvalue ev'')" using assms(3) 10(7) unfolding TypeSafe_def by auto
    have "address ev'' = address e"using a30 by simp
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 10(7) by simp
    ultimately show "compPointers k'  (denvalue e)"
      using compPointersNonStackUpd[of sck' ev' e ip " Calldata (MTArray x t)" k' "KCDptr l"] 
        a40 a50 assms(3) 10(7) b2 a20 by simp
  next
    have b2: "compMemPtrs sck' mem' (denvalue ev')" using assms(3) 10(7) unfolding TypeSafe_def by auto
    have b5:"address ev'' = address e"using a30  
      by simp
    have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 10(7) by simp
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
    proof intros
      fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1 
      assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" by auto
      then have b40:"ip' \<noteq> ip" using a30 by auto
      then have b50:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'')" using a30 b30 fmranI by fastforce

      then obtain ip'' where  b30:"denvalue(e) $$ ip'' = Some((Memory tp2, Stackloc l2))" using b20 by auto
      then have b40:"ip'' \<noteq> ip" using a30 by auto
      then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" using a30 b30 fmranI by fastforce

      have b70:"\<forall>l''. (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l'' \<longrightarrow> accessStore l'' k' = accessStore l'' sck'" 
        using a20 unfolding push_def updateStore_def allocate_def accessStore_def by simp
      have b80:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" using a20  unfolding push_def updateStore_def allocate_def accessStore_def by simp 
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l1" using b70 b80 b20 by auto
      then have b90:"accessStore l1 sck' = accessStore l1 k'" using b70 b80 b20 by simp

      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l2" using b70 b80 b20 by auto
      then have b95:"accessStore l2 sck' = accessStore l2 k'" using b70 b80 b20 by simp
      show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1 
                 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
        using 10(7) a4 b2 b50 b60 b20 compMemPtrs_def b90 b95 by fastforce
    qed
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 10(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "addressFormat (address ev') " using assms(3) TypeSafe_def 10(7) by simp
    then show "addressFormat (address e)" using 10(7) a4 NoneIp by auto
  next
    have "addressFormat (sender ev')" using assms(3) TypeSafe_def 10(7) by simp
    then show "addressFormat (sender e)" using 10(7) a4 NoneIp by auto
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 10(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 10(7) by metis
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev'')) = (storage st (address e))" using a30 by simp
      have a110:"m' = mem'''" using a4 by simp
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 10(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''" using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 10(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using a40 fmranI by auto
      show "case lDen of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" 
            using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KCDptr l " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KCDptr l)" 
              using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = Calldata (MTArray x t)" using a90 a50 by simp
            have a220:"v = KMemptr p" using 10(2) by simp
            have "c = c''" using a4 by simp
            then have "MCon (MTArray x t) c'' l" using a3 unfolding cpm2m_def 
              using MCon_cpm2m[of p l t mem c' x c'' ] Mconcd 10(2)
              by (metis a220 lNotInC' extractValueType.simps(3))
            then have "MCon (MTArray x t) c l" using a4 a110 10(7) by blast
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 10(2) by simp
          qed
        next
          case False
          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs c''" 
            using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x c''] by fastforce

          have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc cd' = None" using locationscd' a2 lNotInC' a1 by auto
          have "\<forall>locations. accessStore locations cd' = accessStore locations c'" using a2 accessAllocate[of c' cd'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs cd' = accessStore locs c''" 
            using b100 a2 unfolding allocate_def by simp

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc False by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" 
            using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " 
            using typeSafeAllStacklocsExist assms(3) Stackloc 10 by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" 
            using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis 
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis 
            proof(cases a)
              case (KValue x1)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
                using a190 some Stackloc a170 * a180 a110 a100 10(7) by (cases tDen, fastforce+)
            next
              case (KCDptr x2)
              then have b10:"(case tDen of Calldata struct \<Rightarrow> MCon struct cd' x2 | _ \<Rightarrow> False)" 
                using some KCDptr a170 Stackloc a190 using assms(3) 10(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Calldata struct" by (auto split:Type.splits) 
              then have "MCon struct cd' x2" using b10 by simp
              then have "MCon struct c'' x2" using mconCopySingle[of l cd' c'' struct] b110 b105 by auto
              then show ?thesis using Stackloc some KCDptr tden a110 a4 by simp
            next
              case (KMemptr x3)
              then have b10:"(case tDen of Memory struct \<Rightarrow> MCon struct mem' x3 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 10(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Memory struct" by (auto split:Type.splits) 
              then have "MCon struct mem''' x3" using b10 10 by simp
              then show ?thesis using Stackloc some KMemptr tden a110 a4 by simp
            next
              case (KStoptr x4)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
                using a190 some Stackloc a170 * a180 a110 a100 10(7) by (cases tDen; fastforce)
            qed
          qed 
        qed
      next
        case (Storeloc x2)
        then have "ip'' \<noteq> ip" using a160 a90 by simp
        then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Storeloc fmranI a90 * by fastforce
        then have a180:"(case tDen of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev'')) | _ \<Rightarrow> False)"  
          using a170 Storeloc using assms(3) 10(7) 
          unfolding TypeSafe_def typeCompat_def by force
        then obtain typ' where tdent:"tDen =  Storage typ'"  by (auto split: Type.splits)
        then have "SCon typ' x2 (storage st (address ev''))" using a180 by simp
        then have "SCon typ' x2 (storage st (address e))" using a100 by simp
        then show ?thesis  using  a170 Storeloc using assms(3) 10(7) tdent 
          by simp
      qed
    qed
  next 
    have b100:"lessThanTopLocs cd'" using assms(3) 10(7) unfolding TypeSafe_def by blast
    have b99:"toploc c' = toploc c" using a3 a4 cpm2m_def[of p l x t mem c' ] cpm2mTopLocSame[of  p l t mem c' x c''] b2 by simp
    have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs c" 
      using cpm2mSingleChange[of p l t mem c' x] a4 a3 cpm2m_def[of p l x t mem c' ] by fastforce
    moreover have "\<forall>locations. accessStore locations cd' = accessStore locations c'" using a2 accessAllocate[of c' cd'] by auto
    ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs cd' = accessStore locs c" by simp
    then show "lessThanTopLocs c" using cdMemLocsToploc[of cd' l c' c] a1 a2 b100 b99 by auto
  next 
    show "lessThanTopLocs m'" using assms(3) 10(7) a4 unfolding TypeSafe_def by auto
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    assume notCp:"\<not>cp"
    then show "toploc (memory st) \<le> toploc m'" using a4 assms 10 by auto
    then show "ncpDenvalueLimit e ev k' (stack st) (memory st) " using 10(3) notCp by simp
    show "ncpOMemInDMem (memory st) m'" using a4 assms 10 notCp by blast
    show "ncpElementsNoSubPref (memory st) m'"
      using a4 assms 10 notCp by blast
  next 
    fix locs tp assume "\<not>cp"
    then show "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using a4 assms 10 by blast
  next
    assume notCP:"\<not>cp"
    then show "ncpNewSelfPoint (memory st) m'" using a40 assms 10 by blast
  next 
    show "toploc mem' \<le> toploc m' " using 10 assms a4 by blast
  qed
next
  case (11 v vr vs vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (12 vq vs vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (13 vq vc vb vs vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (14 v vc vb vs vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (15 vq vc vb vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (16 vq vc vb vs vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (17 vq vr vt vu vv vw)
  then show ?thesis using assms(1) by simp
next
  case (18 x t vx vy vz wa c m k e)
  then show ?thesis using assms(1) by simp
next
  case (19 x t p wb wc mem wd cd' mem''' sck'' ev'')
  then obtain l where a1:"l = ShowL\<^sub>n\<^sub>a\<^sub>t(toploc mem')" by simp
  have vk:"wb = Memory (MTArray x t)" using decl.simps(9) 19(8) by (simp split:if_split_asm)
  then have locationscd':"(\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None)" 
    using assms 19 unfolding TypeSafe_def lessThanTopLocs_def by simp
  then have b1:"accessStore l mem' = None" using a1 using Read_Show_nat'_id using LSubPrefL2_def by auto
  have b2:"x>0" using 19(8) vk a1 by (metis not_None_eq)
  then have Mconcd:"MCon (MTArray x t) mem (extractValueType v)" using assms(2) 19(2) 19(4) vk 19(5) by simp
  obtain c' where a2:"\<exists>dud. (dud, c') = allocate mem'"  by (simp add: allocate_def)
  then have aloc:"snd (allocate mem') = c'" by (simp add: allocate_def)
  then have lNotInC':"accessStore l c' = None" using b1 a1 unfolding allocate_def accessStore_def by auto
  have NoneIp:"denvalue ev'' $$ ip = None" using 19 by (simp split:if_splits)
  then obtain mm' where a3:"cpm2m p l x t mem c' = Some mm'" using 19 a1 a2 assms
    using b2 vk aloc by fastforce

  have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
  have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
  then have b27:"\<forall>locs. \<not> LSubPrefL2 locs l \<or> locs = l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
    using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x mm']  a2   unfolding allocate_def by fastforce

  then have subMapping:"mapping mem' \<subseteq>\<^sub>f mapping mm'" using b105  unfolding fmsubset_alt_def 
    by (metis (mono_tags, lifting) accessStore_def fmpredI option.discI)
  then have a4:"Some (c, m', k', e) = Some (cd', mm', astack_dup ip (Memory (MTArray x t)) (KMemptr l) (sck', ev'))" 
    using a1 a2 a3 19 assms decl.simps(9) vk b2 aloc NoneIp
    by simp

  then have a20:"k' = push (KMemptr l) sck'" using NoneIp 19 unfolding astack_dup.simps by simp
  have b3:"address ev' = address e" using a4 NoneIp 19(7) by simp

  have a30:"e = (updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev')" using a4 NoneIp 19(7) by simp
  then have a40:"denvalue e = denvalue(ev' \<lparr> denvalue := fmupd ip (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  have selfPoint:"\<forall>la l'. TypedMemSubPref la l (MTArray x t) \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
    using cpm2mSelfPointers[of p l t mem c' x mm'] a3 a1 cpm2m_def[of p l x t mem c'] by argo
  have a110:"m' = mm'" using a4 by simp

  show ?thesis unfolding TypeSafe_def 
  proof(intros)
    fix locs tp assume "\<not>cp"
    then show "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using 19 assms(5) by (simp split:if_splits)
  next
    show "unique_locations (denvalue e)" using assms(3) 19(7) updateEnvUniqueLocs a4 NoneIp by fastforce
  next
    have b2: "compPointers sck'  (denvalue ev')" using assms(3) 19(7) unfolding TypeSafe_def by auto
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 19(7) by simp
    ultimately show "compPointers k' (denvalue e)"
      using compPointersNonStackUpd[of sck' ev' e ip "Memory (MTArray x t)" k' "KMemptr l" ] 
        a40 a50 assms(3) 19(7) b2 a20 b3 by simp
  next
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def
    proof(intros)
      fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1
      assume c10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 19(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
        using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
        using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 19(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                      \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using a40 lessThanTopLocs_def fmranI by auto

      show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                      else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1 
                            else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 
                                                                then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)"
      proof(cases "l1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case t1:True
        then have b10:"tp1 = (MTArray x t)" using a150 c10 a50 by fastforce
        have b15:"stl1 = l"  using a20 c10 t1 unfolding push_def updateStore_def accessStore_def allocate_def by auto
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 by fastforce
          then show ?thesis using c10 b10 b20 t1 True TypedMemSubPrefPtrs.simps a20 unfolding push_def updateStore_def accessStore_def by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')" 
            using "19"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env fmlookup_ran_iff  NoneIp 
            by (metis (no_types, lifting) decl_env_not_i)
          have " accessStore l2 k' = accessStore l2 sck'" using a20 c10 False a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp2 mem' stl2" using 19(7) assms(3) c10 b20 unfolding TypeSafe_def  
            by (metis  assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl1 \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x mm']  a2 a110 b15 unfolding allocate_def by fastforce
          then have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem' mm' ] using b105 a110 b15 by simp

          then have b23:"MCon tp2 m' stl2" using b22 by (simp add: a110)

          have b30:"\<not>(LSubPrefL2 stl2 l)" using b15 b20 False 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp2 mem' stl2\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl2 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl2))" using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedMemSubPref la stl1 (MTArray x t) \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b10 b15 a110 by blast
          have b70:" MCon tp1 m' stl1"
            using MCon_cpm2m[of p l t mem c' x mm'] a3 a1 cpm2m_def[of p l x t mem c'] Mconcd extractValueType.simps  19(2) b10 a110 b15 
            by (metis lNotInC' option.inject prod.inject)
          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl2 stl1)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl1. \<not>(LSubPrefL2 stl1 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl1 \<longrightarrow> accessStore loc mem' = None" using b105 b15 by auto
          have "case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray x t) stl2 stl1
             else if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' x t dt stl1 dloc1 
                                else True
          | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTValue val2) stl1 stl2 else True" 
          proof(cases tp2)
            case (MTArray x11 x12)
            then have b130:"MCon (MTArray x11 x12) m' stl2" using b23 by auto
            have b140:"MCon (MTArray x11 x12) mem' stl2" using b22 MTArray by simp
            have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using b130 b100 b120 b90 b140 b27 cpm2mNotSubPrefsOfOriginal by auto
            moreover have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cpm2mNotSubPrefsOfChanged b70 b10 by simp
            moreover have "\<not>(TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2 
                using b10 b2 b60 b70 b15 CompMemType_imps_TypedMemSubPrefPtrs by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1" using b30  b130  b120  b140 b27 b15 b45 cpm2mLocationRelatedToTopNotInOrig c10
                by (metis)
              then show False using c10 by simp 
            qed
            ultimately show ?thesis using MTArray by auto
          next
            case (MTValue x2)
            have "MCon (MTArray x t) m' stl1" using b70 by (simp add: b10)           
            then have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cpm2mNotSubPrefsOfChanged by simp
            then show ?thesis using MTValue by simp
          qed
          then show ?thesis using b80 b10 by simp
        qed
      next
        case f1:False
        then have b10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev')" using "19"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b15:"stl2 = l"  using a20 c10  unfolding push_def updateStore_def accessStore_def allocate_def by auto

          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 True by fastforce
          have " accessStore l1 k' = accessStore l1 sck'" using a20 c10 f1 a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp1 mem' stl1" using 19(7) assms(3) c10 b20 b10 unfolding TypeSafe_def  
            by (metis assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl2 \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x mm']  a2 a110 b15 unfolding allocate_def by fastforce
          then have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem' mm' ] using b105 a110 b15 by simp

          then have b23:"MCon tp1 m' stl1" using b22 by (simp add: a110)

          have b30:"\<not>(LSubPrefL2 stl1 l)" using b15 b20 f1 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl1 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl1))" using a1 unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedMemSubPref la stl2 tp2 \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b20 b15 a110 by blast
          have b65:"(\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" by (simp add: lNotInC')
          then have b70:" MCon tp2 m' stl2" 
            using MCon_cpm2m[of p l t mem c' x mm'] a3 a1 cpm2m_def[of p l x t mem c'] 
              Mconcd extractValueType.simps  19(2) b10 a110 b15 b20 b60 by fastforce

          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl1 stl2)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl2. \<not>(LSubPrefL2 stl2 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl2 \<longrightarrow> accessStore loc mem' = None" using b105 b15 by auto

          have "case tp1 of
         MTArray len arr \<Rightarrow>
           (case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' len arr dt stl1 dloc1 
                         else True
           | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
         | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True 
                                     | MTValue val2 \<Rightarrow> True)" 
          proof(cases tp1)
            case (MTArray x11 x12)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cpm2mNotSubPrefsOfChanged  b2 b20 b60 b70 by presburger
            moreover have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using b100 b23 b80 b27 b90 b22 b120 cpm2mNotSubPrefsOfOriginal MTArray by auto
            moreover have "\<not>(TypedMemSubPrefPtrs m' x11 x12  stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2[of  x t m' stl2]  b15 a1 b60 b20 b70  
                using CompMemType_imps_TypedMemSubPrefPtrs b2 by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1" using cpm2mLocationRelatedToTopNotInOrig b100 b23 b80 b27 b90 b22 b120 
                using MTArray b15 by (metis)
              then show False using c10 by simp
            qed
            ultimately show ?thesis using MTArray 
              using b20 by auto
          next
            case (MTValue x2)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cpm2mNotSubPrefsOfChanged  b2 b20 b60 b70 by presburger
            then have "if TypedMemSubPrefPtrs m' x t stl2 stl1 then CompMemType m' x t (MTValue x2) stl2 stl1 else True" by simp
            then show ?thesis using b20 
              by (simp add: MTValue)
          qed
          then show ?thesis using CompMemType_imps_TypedMemSubPrefPtrs using b80 b20 by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')" using "19"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
          have b30:"accessStore l2 k' = accessStore l2 sck'" using a20 c10 False a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          have b40:" accessStore l1 k' = accessStore l1 sck'" using b20 b10 a20 c10 False a130 f1 unfolding push_def updateStore_def accessStore_def allocate_def by auto

          have b50:"MCon tp1 mem' stl1" using 19(7)  c10 b10 b40 unfolding TypeSafe_def
            by (metis assms(3) sameMemTSafe)
          have b60:"\<not>(LSubPrefL2 stl1 l)" by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          have b50b:"MCon tp2 mem' stl2" using 19(7) c10 b20 b30 unfolding TypeSafe_def
            by (metis assms(3) sameMemTSafe)
          then have b60b:"\<not> LSubPrefL2 stl2 l " by (metis MCon_imps_Some LSubPrefL2_def  b105 Not_Sub_More_Specific option.distinct(1))

          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x mm'] by fastforce

          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using b100 a2 a110 unfolding allocate_def by simp

          have "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev') \<and>
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev') \<and> accessStore l1 sck' = Some (KMemptr stl1) \<and> accessStore l2 sck' = Some (KMemptr stl2)" 
            using b10 assms(3) 19(7) c10 b30 b40 b20 b30 by simp
          then have c1:"(if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs mem' len arr  stl1 dloc1 \<and> TypedMemSubPrefPtrs mem' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType mem' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType mem' len arr dt stl1 dloc1 
                       else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> 
                              if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTValue val) stl2 stl1 else True 
                                | MTValue val2 \<Rightarrow> True))" 
            using b10 assms(3) 19(7) c10 b30 b40 b20 b30 unfolding TypeSafe_def compMemPtrs_def by blast

          show ?thesis 
          proof(cases "stl1 = stl2")
            case True
            then show ?thesis using c1 by simp
          next
            case f1:False
            then show ?thesis 
            proof(cases tp1)
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases tp2)
                case mta:(MTArray x11' x12')
                have "if TypedMemSubPrefPtrs m' x11' x12' stl2 stl1 then CompMemType m' x11' x12' tp1 stl2 stl1
                  else if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 
                    else if CompMemType m' x11 x12 dtp1 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt stl1 dloc1 
                else True"
                proof(cases "TypedMemSubPrefPtrs mem' x11' x12' stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray mta by simp
                  then have " CompMemType mem' x11' x12' tp1 stl2 stl1" using c1 f1 mta MTArray  True by simp
                  then have " CompMemType m' x11' x12' tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis using c1 f1 mta MTArray  True  
                    using \<open>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1\<close> by auto
                next
                  case False
                  then have b40:"\<not>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis
                  proof(cases " TypedMemSubPrefPtrs mem' x11 x12 stl1 stl2")
                    case t2:True
                    then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                      using MTArray mta b50 by blast
                    then have " CompMemType mem' x11 x12 (MTArray x11' x12') stl1 stl2" using c1 f1 mta MTArray  t2  False MTypes.simps(5) b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref
                      by (smt (verit, best))
                    then show ?thesis using c1 f1 mta MTArray
                      using b105 b110 b40 b50 b60 cpm2mCompMemTypeOld_imps_CompMemType  
                      using t2  
                      using \<open>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2\<close> by presburger
                  next
                    case f2:False
                    then show ?thesis
                    proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs mem' x11' x12' stl2 dloc1")
                      case True
                      then have d10:"TypedMemSubPrefPtrs  m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1"
                        using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b b50 b60 using MTArray mta
                        using cpm2mCompMemTypeOld_imps_CompMemType by auto
                      have d20:"\<exists>dt.
                               CompMemType mem' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType mem' x11 x12 dt stl1 dloc1 "
                        using True c1 f2 f1 False by (simp add: MTArray mta)
                      then obtain intimLoc where d25: "\<exists>dt.
                               CompMemType mem' x11' x12' dt stl2 intimLoc \<and>
                               CompMemType mem' x11 x12 dt stl1 intimLoc" by blast
                      then have "\<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt  stl1 dloc1" 
                        using MTArray b105 b110 b50 b50b b60 b60b cpm2mCompMemTypeOld_imps_CompMemType mta d20 d25 by (metis)
                      then show ?thesis using d10 b40 f2  
                        using MTArray b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref by simp
                    next
                      case f3:False
                      then have "\<not>(TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1)" 
                        using inv_cpm2mTPrefOld_imps_TPref MTArray b105 b110 b50b b60b mta  b50 b60  
                        using inv_cpm2mCompMemTypeOld_imps_CompMemType by blast
                      then show ?thesis using False mta MTArray f1 f2 b40 f3
                        using b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref 
                        by (metis CompMemType_imps_TypedMemSubPrefPtrs)
                    qed
                  qed
                qed
                then show ?thesis using mta MTArray f1 
                  by (smt (verit) MTypes.simps(5) b105 b110 b50 b50b b60 b60b c1 compMemTypes_trns cpm2mCompMemTypeOld_imps_CompMemType cpm2mTPrefOld_imps_TPref inv_cpm2mTPrefOld_imps_TPref)
              next
                case mtv2:(MTValue x2)
                have " if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 else True" 
                proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl1 stl2")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray b50 by blast
                  then have " CompMemType mem' x11 x12 tp2 stl1 stl2" using c1 f1 mtv2 MTArray  True by auto
                  then have " CompMemType m' x11 x12 tp2 stl1 stl2" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis using c1 f1 mtv2 MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTArray f1 mtv2  by auto
              qed
            next
              case (MTValue x2)
              then show ?thesis 
              proof(cases tp2)
                case (MTArray x11 x12)
                have "if TypedMemSubPrefPtrs m' x11 x12 stl2 stl1 then CompMemType m' x11 x12 tp1 stl2 stl1  else True" 
                proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray by blast
                  then have " CompMemType mem' x11 x12 tp1 stl2 stl1" using c1 f1 MTValue MTArray  True by simp
                  then have " CompMemType m' x11 x12 tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis using c1 f1 MTValue MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTValue MTArray f1 by auto
              next
                case mtv2:(MTValue x2)
                then show ?thesis using MTValue f1 by simp
              qed
            qed
          qed
        qed
      qed
    qed
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 19(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 19(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 19(7) by metis
  next
    have "addressFormat  (sender ev')" using assms(3) TypeSafe_def 19(7) by simp
    then show "addressFormat (sender e)" using 19(7) a4  NoneIp 19(7) by auto
  next
    have "addressFormat (address ev')" using assms(3) TypeSafe_def 19(7) by simp
    then show "addressFormat(address e) " using 19(7) a4  NoneIp 19(7) by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev')) = (storage st (address e))" using a30 by simp
      have a110:"m' = mm'" using a4 by simp
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 19(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
        using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
        using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 19(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                        \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      show "case lDen of
               Stackloc loc \<Rightarrow>
                 (case accessStore loc k' of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                  | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                  | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                  | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
               | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KMemptr l " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = Memory (MTArray x t)" using a90 a50 by simp
            have a220:"v = KMemptr p" using 19(2) by simp
            have "c = cd'" using a4 by simp
            then have "MCon (MTArray x t) mm' l" using a3 unfolding cpm2m_def 
              using MCon_cpm2m[of p l t mem c' x mm' ] Mconcd 19(2) b2  
              by (metis a220 lNotInC' extractValueType.simps(3))
            then have "MCon (MTArray x t) m' l" using a4 a110 19(7) by blast
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 19(2) by simp
          qed
        next
          case False
          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cpm2m_def[of p l x t mem c'] cpm2mSingleChange[of p l t mem c' x mm'] by fastforce

          have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
            using b100 a2 unfolding allocate_def by simp

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc False by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 19 by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" 
            using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis 
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis 
            proof(cases a)
              case (KValue x1)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 19(7) by (cases tDen; fastforce)
            next
              case (KCDptr x2)
              then have b10:"(case tDen of Calldata struct \<Rightarrow> MCon struct cd' x2 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 19(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Calldata struct" by (auto split:Type.splits) 
              then have "MCon struct cd' x2" using b10 by simp
              then show ?thesis using Stackloc some KCDptr tden a110 a4 by simp
            next
              case (KMemptr x3)
              then have b10:"(case tDen of Memory struct \<Rightarrow> MCon struct mem' x3 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 19(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Memory struct" by (auto split:Type.splits) 
              then have "MCon struct mem' x3" using b10 by simp
              then have "MCon struct mm' x3" using mconCopySingle[of l mem' mm' struct] b110 b105 by auto
              then show ?thesis using Stackloc some KMemptr tden a110 a4 by simp
            next
              case (KStoptr x4)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 19(7) by (cases tDen; fastforce)
            qed
          qed 
        qed
      next
        case (Storeloc x2)
        then have "ip'' \<noteq> ip" using a160 a90 by simp
        then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using a40 Storeloc fmranI a90 * by fastforce
        then have a180:"(case tDen of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev')) | _ \<Rightarrow> False)"  
          using a170 Storeloc using assms(3) 19(7) 
          unfolding TypeSafe_def typeCompat_def by force
        then obtain typ' where tdent:"tDen =  Storage typ'"  by (auto split: Type.splits)
        then have "SCon typ' x2 (storage st (address ev'))" using a180 by simp
        then have "SCon typ' x2 (storage st (address e))" using a100 by simp
        then show ?thesis  using  a170 Storeloc using assms(3) 19(7) tdent 
          by simp
      qed
    qed
  next 
    show "lessThanTopLocs c" using assms(3) 19(7) a4 unfolding TypeSafe_def by auto
  next 
    have b100:"lessThanTopLocs mem'" using assms(3) 19(7) unfolding TypeSafe_def by blast
    have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t mem c' ] cpm2mTopLocSame[of  p l t mem c' x mm'] b2 by simp
    have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs m'" 
      using cpm2mSingleChange[of p l t mem c' x mm'] a4 a3 cpm2m_def[of p l x t mem c'] by fastforce
    moreover have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
    ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs m' = accessStore locs mem'" by simp
    show "lessThanTopLocs m'" using cdMemLocsToploc[of mem' l c' m'] b100 a1 a2 b99 using b10 by presburger
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    assume notCp:"\<not>cp"
    then show "toploc (memory st) \<le> toploc m'" using  19(3) by auto
    then show "ncpDenvalueLimit e ev k' (stack st) (memory st)" using 19(3) notCp by simp
    show "ncpOMemInDMem (memory st) m'" using  19 notCp by blast
    show "ncpElementsNoSubPref (memory st) m'" using 19(3) notCp by blast
    show "ncpNewSelfPoint (memory st) m'" using a40 assms 19(3) notCp by blast
  next 
    have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t mem c' ] cpm2mTopLocSame[of  p l t mem c' x mm'] b2 by simp
    then show "toploc mem' \<le> toploc m' " using aloc unfolding allocate_def by auto
  qed
next
  case (20 x t p we wf wg wh cd' mem''' sck'' ev'')

  then have a5:"we = (Memory (MTArray x t))" using assms(4)  by (metis option.distinct(1))
  have b2:"x>0" using 20(8) a5 by (metis not_None_eq)
  have NoneIp:"denvalue ev'' $$ ip = None" using 20 by (simp split:if_splits)
  then have a10:"Some (c, m', k', e) = Some (cd', mem''', astack_dup ip (Memory (MTArray x t)) (KMemptr p) (sck'', ev''))" 
    using 20 assms b2 a5  
    by (metis)
  then have a10:"Some (c, m', k', e) = Some (cd', mem''', astack_dup ip (Memory (MTArray x t)) (KMemptr p) (sck', ev''))"
    using 20(7) by simp
  then have a20:"k' = push (KMemptr p) sck'" using 20 NoneIp by force

  have b3:"address e = address ev''" using a10 NoneIp by auto
  have a30:"e = (updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev'')" using a10 NoneIp by simp

  then have a40:
    "denvalue e = denvalue(ev'' \<lparr> denvalue := fmupd ip ((Memory (MTArray x t)),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev'') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some  ((Memory (MTArray x t)),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  have a4:"address ev'' = address e"using a30 by simp

  have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 20(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 20(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                      \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  show ?thesis unfolding TypeSafe_def
  proof(intros)
    fix locs tp assume "\<not>cp"
    then show "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using 20 assms(5) by (simp split:if_splits)
  next
    show "unique_locations (denvalue e)" using assms(3) 20(7) updateEnvUniqueLocs a10 NoneIp by fastforce
  next
    have b2: "compPointers sck' (denvalue ev'')" using assms(3) 20(7) unfolding TypeSafe_def by auto
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 20(7) by simp
    ultimately show "compPointers k'  (denvalue e)"
      using compPointersNonStackUpd[of sck' ev'' e ip " Memory (MTArray x t)" k' "KMemptr p"] 
        a40 a50 assms(3) 20(7) b2 a20 a4 by simp
  next
    have p1:"mem''' = m'" using a10 by auto
    have b3:"compMemPtrs  (stack st) (memory st) (denvalue ev)" using 20(7) assms(1) unfolding TypeSafe_def by simp

    have b4:"compMemPtrs sck' mem' (denvalue ev'')" using 20(7) assms(3) unfolding TypeSafe_def by simp
    have b5:"address ev'' = address e" using a30  assms(1)
      by simp
    have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 20(7) by simp

    have c10:"(\<forall>tp' locs p i.
        (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i)\<longrightarrow>
        (\<exists>tp'' loc2 p' . 
            (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
            accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))))" 
      using assms(5) 20(3,7) unfolding ncpDenvalueLimit_def by blast
    have c20:"(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  (MTArray x t) \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x t) p' p)))" 
      using assms(6) a5 20(2,3,7) by fastforce

    have "KMemptr p = v" using 20 by simp
    then have mconp:" MCon (MTArray x t) (memory st) p" using assms(2) extractValueType.simps 20(2,8)  
      by (metis Type.simps(19) decl.simps(20) option.discI)
    then obtain x' y where ne2:" accessStore (hash p y) (memory st) = Some x'" using MCon.simps 
      by (meson b2 mcon_accessStore)
    have ne3:"((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
   (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      using assms(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    then have ne4:"\<exists>y tloc. tloc <toploc (memory st) \<and> LSubPrefL2 (hash p y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ne2 by blast
    then have ne6:"\<exists>tloc. tloc <toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using MemLSubPrefL2_specific_imps_general by auto

    have ne5:"(\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
               toploc (memory st) \<le> toploc m' \<and> ncpDenvalueLimit ev'' ev sck' (stack st) (memory st)  \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m'" 
      using assms(3,5) 20(3,7) p1 by blast

    have oldLimit:"((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
   (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      using assms(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
    proof intros
      fix tp1 tp2 l1 l2 stl1 stl2  dtp1 dloc1
      assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"

      then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" using b20 by auto
      show " if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1 
                                else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)"
      proof(cases "stl1 = stl2")
        case same:True
        then show ?thesis 
        proof(cases "l1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case l1Top:True
          then have b40:"stl1 = p" using a20 b20 unfolding push_def accessStore_def updateStore_def allocate_def by simp
          then have b50:"stl2 = p" using same by simp
          have b45:"tp1 = (MTArray x t)" using a150 l1Top b20 a50 by fastforce
          then show ?thesis 
          proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have "tp2 = (MTArray x t)"  using a150 l1Top b20 a50 by fastforce
            then show ?thesis using b45 same by simp
          next
            case l2NotTop:False
            then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI by fastforce
            have b65:"accessStore l2 sck' = accessStore l2 k'" using l2NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
            obtain tp'' loc2 p'  where  c10:"
                 ((Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl1 \<and> tp'' = tp2 \<or>
                 (\<exists>len arr. p' \<noteq> stl1 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp2 p' stl1)) )" 
              using b60 b65 b20 b50 c10 same ne6 by metis
            obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                        \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                         (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))" 
              using c20 extractValueType.simps(3) b45 b40 20(2) b20 by blast

(*MIGHT NEED TO BE RESTRICTIVE WITH C10 AND ITS *)
            have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
                (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by blast
            then  have c30:"(if p' = p'' then tp'' = tp'''
                 else case tp'' of
                    MTArray len arr \<Rightarrow>
                      (case tp''' of
                      MTArray len2 arr2 \<Rightarrow>
                        if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                        else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                        else if TypedMemSubPrefPtrs (memory st) len arr p' stl1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 p'' stl1
                            then \<exists>dt.
                                    CompMemType (memory st) len2 arr2 dt p'' stl1 \<and>
                                    CompMemType (memory st) len arr dt p' stl1 
                        else True
                      | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
                    | MTValue val \<Rightarrow>
                        (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                       | MTValue val2 \<Rightarrow> True))" using assms(1) unfolding TypeSafe_def compMemPtrs_def by blast
            have tp'''Mcon:"MCon tp''' (memory st) p''" using assms 20 c20 unfolding TypeSafe_def 
              by (metis assms(1) sameMemTSafe)
            have tp''Mcon:"MCon tp'' (memory st) p'" using assms 20 c10 unfolding TypeSafe_def 
              by (metis assms(1) sameMemTSafe)
            then have "tp2 = (MTArray x t)" using SameLocsSameTypescpm2m using b45 same b40 c30 c20 c10 tp'''Mcon tp''Mcon by blast
            then show ?thesis 
              by (simp add: b45 same)
          qed

        next
          case l1NotTop:False
          then have b60:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI by fastforce
          have b65:"accessStore l1 sck' = accessStore l1 k'" using l1NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
          then show ?thesis 
          proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have b40:"stl2 = p" using a20 b20 unfolding push_def accessStore_def updateStore_def allocate_def by simp
            then have b50:"stl1 = p" using same by simp
            then have b45:"tp2 = (MTArray x t)"  using a150 b20 a50 True by fastforce
            obtain tp'' loc2 p' where  c10:"
                     (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = stl1 \<and> tp'' = tp1 \<or>
                     (\<exists>len arr. p' \<noteq> stl1 \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp1 p' stl1))" 
              using b60 b65 b20 b50 c10 same ne6 by metis
            obtain stloc tp''' p'' where c20:"(Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) 
                                            \<and> accessStore stloc (stack st) = Some (KMemptr p'') \<and>
                                             (tp''' = MTArray x t \<and> stl1 = p'' \<or> (\<exists>len arr. stl1 \<noteq> p'' \<and>tp''' = MTArray len arr \<and> CompMemType (memory st) len arr (MTArray x t) p'' stl1))" 
              using c20 extractValueType.simps(3) b45 b40 20(2) b20 b50 by blast
            have "(Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
                    (Memory tp''', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and> accessStore loc2 (stack st) = Some (KMemptr p') \<and> accessStore stloc (stack st) = Some (KMemptr p'')" using c10 c20 by simp
            then  have c30:"(if p' = p'' then tp'' = tp'''
                     else case tp'' of
                        MTArray len arr \<Rightarrow>
                          (case tp''' of
                          MTArray len2 arr2 \<Rightarrow>
                            if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTArray len arr) p'' p'
                            else if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTArray len2 arr2) p' p'' 
                            else if TypedMemSubPrefPtrs (memory st) len arr p' stl1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2  p'' stl1
                                then \<exists>dt.
                                        CompMemType (memory st) len2 arr2 dt p'' stl1 \<and>
                                        CompMemType (memory st) len arr dt p' stl1 
                            else True
                          | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr p' p'' then CompMemType (memory st) len arr (MTValue val2) p' p'' else True)
                        | MTValue val \<Rightarrow>
                            (case tp''' of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 p'' p' then CompMemType (memory st) len2 arr2 (MTValue val) p'' p' else True
                           | MTValue val2 \<Rightarrow> True))" using assms(1) unfolding TypeSafe_def compMemPtrs_def by simp
            have tp'''Mcon:"MCon tp''' (memory st) p''" using assms 20 c20 unfolding TypeSafe_def 
              by (metis assms(1) sameMemTSafe)
            have tp''Mcon:"MCon tp'' (memory st) p'" using assms 20 c10 unfolding TypeSafe_def 
              by (metis assms(1) sameMemTSafe)
            then have "tp1 = (MTArray x t)"  using SameLocsSameTypescpm2m using b45 same b40 c30 c20 c10 tp'''Mcon tp''Mcon by blast

            then show ?thesis using same b45 by simp  
          next
            case l2NotTop:False
            then have b70 :"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI by fastforce
            have b75:"accessStore l2 sck' = accessStore l2 k'" using l2NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
            then show ?thesis using b60 b65 b70 b75 assms 20 unfolding TypeSafe_def 
              by (simp add: b20 compMemPtrs_def same)
          qed
        qed
      next
        case notSame:False
        then show ?thesis 
        proof(cases tp1)
          case mta1:(MTArray x11 x12)
          then show ?thesis 
          proof(cases tp2)
            case mta2:(MTArray x11' x12')
            then show ?thesis
            proof(cases "l1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
              case True
              then have e1:"MTArray x11 x12 = MTArray x t" using a150 b20 a50 True 
                by (metis Type.inject(3) \<open>\<And>thesis. (\<And>ip'. denvalue e $$ ip' = Some (Memory tp1, Stackloc l1) \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> mta1 old.prod.inject option.inject)
              have e2:"stl1 = p" using True a50 
                by (metis Stackvalue.inject(3) a20 accessAllocate accessStore_updateStore b20 old.prod.exhaust option.inject push_def snd_eqD)
              then show ?thesis 
              proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
                case t2:True
                have "stl1 = stl2" using t2 True b20 a20 unfolding push_def updateStore_def allocate_def accessStore_def by auto
                then show ?thesis using notSame by simp
              next
                case l2NotTop:False
                then have l2InOld:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mta2 by fastforce
                have l2SckK:"accessStore l2 sck' = accessStore l2 k'" using l2NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
                have "(\<forall>t l. (t, l) |\<in>| fmran (denvalue ev'') \<longrightarrow>
                       (case l of
                        Stackloc loc \<Rightarrow>
                          (case accessStore loc sck' of None \<Rightarrow> False 
                            | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                            | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                            | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                            | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev'')) | _ \<Rightarrow> False))
                        | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address ev'')) | _ \<Rightarrow> False)))"  
                  using assms(3) 20(7) unfolding TypeSafe_def typeCompat_def by blast
                then have stl2MCon:"MCon (MTArray x11' x12') mem''' stl2" using  20(7) l2InOld b20 mta2 l2SckK by fastforce
                then have "x11' >0 " using MCon.simps(2)[of x11' x12' mem''' stl2] by presburger
                then obtain x'' y' where nf2:" accessStore (hash stl2 y') mem''' = Some x''" 
                  using stl2MCon MCon.simps mcon_accessStore[of x11' x12' mem''' stl2 ] by metis
                have nf3:"((\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None) \<and>
                              (\<forall>loc y. accessStore loc mem' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
                  using assms(3) 20(7) unfolding TypeSafe_def lessThanTopLocs_def by simp
                then have nf4:"\<exists>y tloc. tloc <toploc mem' \<and> LSubPrefL2 (hash stl2 y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using nf2 nf3 20 by blast

                then have nf6:"\<exists>tloc. tloc <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using MemLSubPrefL2_specific_imps_general a10 20 by auto
                have nf7:"MCon (MTArray x11 x12) (memory st) stl1" using mconp e2 e1 by simp
                then show ?thesis
                proof(cases " TypedMemSubPrefPtrs m' x11' x12' stl2 stl1")
                  case t1:True
                  then have "CompMemType m' x11' x12' (MTArray x11 x12) stl2 stl1" 
                    using  cpm2mSublocationDoubleArray[of ev'' sck'  st ev x t p stl1 l2 k' tp2 x11 x12 tp1 x11' x12' l1 e stl2 cd m' ] 
                      c10 c20 e2 l2SckK l2InOld mta1 e1 mta2 b20 assms(1) notSame t1 ne5 ne2 ne3 nf6 ne6 nf7  by blast

                  then show ?thesis using mta1 mta2 notSame True t1 by simp
                next
                  case f3:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2")
                    case t1:True
                    then have "CompMemType m' x11 x12 (MTArray x11' x12') stl1 stl2" using  
                        cpm2mSublocationDoubleArray2[of ev'' sck' st ev x t p stl1 l2 k' tp2 x11 x12 tp1 x11' x12' l1 e stl2 cd m' ] (*NEED TO REMOVE THE MEMORY ASSM SEE DOUBLE ARRAY 1*)
                        c10 c20 e2 l2SckK l2InOld mta1 e1 mta2 b20 assms(1) notSame t1 ne5 ne3 nf6 ne6 nf7 by blast
                    then show ?thesis using mta1 mta2 notSame True f3 t1 by simp
                  next
                    case f4:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1")
                      case t1:True
                      then have "MCon (MTArray x11' x12') m' stl2" using stl2MCon 
                        using p1 20 by auto
                      then have "\<exists>dt. CompMemType m' x11' x12' dt stl2 dloc1 \<and> CompMemType m' x t dt stl1 dloc1" 
                        using cpm2mSublocationDoubleArray3[of ev'' sck'  st ev x t p stl1 l2 k' tp2 tp1 x11' x12' l1 e  stl2 _ m' dloc1] 
                          c10 c20 e2 l2SckK l2InOld mta1 e1 mta2 b20 assms(1) notSame t1 f3 f4 ne5 ne2 ne3 nf6 ne6 nf7 by blast

                      then show ?thesis using f4 f3 notSame mta1 mta2 True e1 by simp
                    next
                      case False
                      then show ?thesis using f4 f3 notSame mta1 mta2 by auto
                    qed
                  qed
                qed
              qed
            next
              case l1NotTop:False
              then have l1InOld:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mta2 by fastforce
              have l1SckK:"accessStore l1 sck' = accessStore l1 k'" using l1NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
              have "(\<forall>t l. (t, l) |\<in>| fmran (denvalue ev'') \<longrightarrow>
                       (case l of
                        Stackloc loc \<Rightarrow>
                          (case accessStore loc sck' of None \<Rightarrow> False 
                            | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                            | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                            | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                            | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev'')) | _ \<Rightarrow> False))
                        | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address ev'')) | _ \<Rightarrow> False)))"  
                using assms(3) 20(7) unfolding TypeSafe_def typeCompat_def by blast
              then have stl1MCon:"MCon (MTArray x11 x12) mem''' stl1" using  20(7) l1InOld b20 mta1 l1SckK 
                by fastforce
              then have "x11 >0 " using MCon.simps(2)[of x11 x12 mem''' stl1] by presburger
              then obtain x'' y' where nf2:" accessStore (hash stl1 y') mem''' = Some x''" using stl1MCon MCon.simps mcon_accessStore[of x11 x12 mem''' stl1 ] by metis
              have nf3:"((\<forall>tloc loc. toploc mem''' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem''' = None) \<and>
                              (\<forall>loc y. accessStore loc mem''' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'''. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
                using assms(3) 20(7) unfolding TypeSafe_def lessThanTopLocs_def by simp
              then have nf4:"\<exists>y tloc. tloc <toploc mem''' \<and> LSubPrefL2 (hash stl1 y) (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using nf2 nf3 by blast

              then have nf6:"\<exists>tloc. tloc <toploc m' \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using MemLSubPrefL2_specific_imps_general a10 by auto

              then show ?thesis 
              proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
                case True
                then have e1:"MTArray x11' x12' = MTArray x t" using a150 b20 a50 True Type.inject(3)  mta2 old.prod.inject option.inject
                  by fastforce
                have e2:"stl2 = p" using True a50 
                  by (metis Stackvalue.inject(3) a20 accessAllocate accessStore_updateStore b20 old.prod.exhaust option.inject push_def snd_eqD)

                then show ?thesis 
                proof(cases " TypedMemSubPrefPtrs m' x11' x12' stl2 stl1")
                  case t1:True
                  then have "CompMemType m' x11' x12' (MTArray x11 x12) stl2 stl1" 
                    using  cpm2mSublocationDoubleArray2[of ev'' sck' st ev x t p stl2 l1 k' tp1 x11' x12' tp2 x11 x12 l2 e stl1 cd m' ] 
                      c10 c20 e2 l1SckK l1InOld mta1 e1 mta2 b20 assms(1) notSame t1 ne5 ne3  ne6  nf6 ne6 mconp by blast
                  then show ?thesis using mta1 mta2 notSame True t1 by simp
                next
                  case f3:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2")
                    case t1:True
                    then have "CompMemType m' x11 x12 (MTArray x11' x12') stl1 stl2" using  
                        cpm2mSublocationDoubleArray[of  ev'' sck'  st ev x t p stl2 l1 k' tp1 x11' x12' tp2 x11 x12 l2 e stl1 cd m' ] 
                        c10 c20 e2 l1SckK l1InOld mta1 e1 mta2 b20 assms(1) notSame t1 ne5 ne2 ne3 nf6 ne6 mconp  by blast
                    then show ?thesis using mta1 mta2 notSame True f3 t1 by simp
                  next
                    case f4:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1")
                      case t1:True
                      have "MCon (MTArray x11 x12) m' stl1" 
                        using p1 stl1MCon  by auto
                      then have "\<exists>dt. CompMemType m' x t dt stl2 dloc1 \<and> CompMemType m' x11 x12 dt stl1 dloc1"
                        using cpm2mSublocationDoubleArray3[of ev'' sck' st ev x t p stl2 l1 k' tp1 tp2 x11 x12 l2 e  stl1 _ m' dloc1] 
                          c10 c20 e2 l1SckK l1InOld mta1 e1 mta2 b20 assms(1) notSame t1 f3 f4 ne5 ne2 ne3 nf6 ne6 mconp by blast
                      then show ?thesis using f4 f3 notSame mta1 mta2 True e1 by simp
                    next
                      case False
                      then show ?thesis using f4 f3 notSame mta1 mta2 by auto
                    qed
                  qed
                qed
              next
                case l2NotTop:False
                then have l2InOld:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mta2 by fastforce
                moreover have l2SckK:"accessStore l2 sck' = accessStore l2 k'" using l2NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
                moreover have l1InOld:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mta1 l1NotTop by fastforce
                moreover have l2SckK:"accessStore l1 sck' = accessStore l1 k'" using l1NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
                ultimately have "(
                        
                        (if stl1 = stl2 then tp1 = tp2
                         else case tp1 of
                              MTArray len arr \<Rightarrow>
                                (case tp2 of
                                MTArray len2 arr2 \<Rightarrow>
                                  if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTArray len arr) stl2 stl1
                                  else if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTArray len2 arr2) stl1 stl2
                                       else if TypedMemSubPrefPtrs mem' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs mem' len2 arr2 stl2 dloc1
                                            then \<exists>dt. CompMemType mem' len2 arr2 dt stl2 dloc1 \<and> CompMemType mem' len arr dt stl1 dloc1 else True
                                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTValue val2) stl1 stl2 else True)
                              | MTValue val \<Rightarrow>
                                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)))"
                  using b20 assms(3) 20(7)  ne3 ne4 ne5 notSame unfolding TypeSafe_def compMemPtrs_def  by fastforce
                then show ?thesis using  ne3 ne4 ne5 20(7)  
                  using p1 by fastforce
              qed
            qed
          next
            case mtv2:(MTValue x2)
            then have l2NotTop:"l2 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))"  using a150 a50 a20 b20 unfolding push_def accessStore_def updateStore_def allocate_def by fastforce
            then have l2InOld:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mtv2 by fastforce
            have l2SckK:"accessStore l2 sck' = accessStore l2 k'" using l2NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
            have "(\<forall>t l. (t, l) |\<in>| fmran (denvalue ev'') \<longrightarrow>
                       (case l of
                        Stackloc loc \<Rightarrow>
                          (case accessStore loc sck' of None \<Rightarrow> False 
                            | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                            | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                            | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                            | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev'')) | _ \<Rightarrow> False))
                        | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address ev'')) | _ \<Rightarrow> False)))"  
              using assms(3) 20(7) unfolding TypeSafe_def typeCompat_def by blast
            then have stl2MCon:"MCon (MTValue x2) mem' stl2" using  20(7) l2InOld b20 mtv2 l2SckK by fastforce
            then obtain x'' where nf2:" accessStore stl2  mem' = Some x''" using stl2MCon MCon.simps  by fastforce
            have nf3:"((\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None) \<and>
                          (\<forall>loc y. accessStore loc mem' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
              using assms(3) 20(7) unfolding TypeSafe_def lessThanTopLocs_def by simp
            then have nf4:"\<exists>y tloc. tloc <toploc mem' \<and> LSubPrefL2  stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using nf2 nf3 by blast
            then have nf6:"\<exists>tloc. tloc <toploc m' \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using MemLSubPrefL2_specific_imps_general a10 20 by auto            
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2")
              case True
              have "Some (c, m', k', e) = Some (cd', mem''', astack ip (Memory (MTArray x t)) (KMemptr p) (sck', ev''))" 
                using a10 NoneIp astack_dup_is_astack by simp
              then have "CompMemType m' x11 x12 tp2 stl1 stl2"
                using  oneValueoneArray[of k' e ip x t p sck' ev'' tp2 l2 tp1 l1 stl2 stl1  st ev cd x2 x11 x12 m' cd'] 
                  b20 a50 l2InOld l2SckK c10 c20 assms(1) mtv2 mta1 a150 True  notSame assms(3) 20(7) ne5 oldLimit ne6 nf6 mconp by blast
              then show ?thesis using  mta1 mtv2 True notSame by simp              
            next
              case False
              then show ?thesis using notSame mta1 mtv2 by simp
            qed
          qed
        next
          case mtv1:(MTValue x2)
          then have l1NotTop:"l1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a150 a50 using a20 b20 unfolding push_def accessStore_def updateStore_def allocate_def by fastforce
          then have l1InOld:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') " using a40 b20 a160 fmranI mtv1 by fastforce
          have l1SckK:"accessStore l1 sck' = accessStore l1 k'" using l1NotTop a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
          have "(\<forall>t l. (t, l) |\<in>| fmran (denvalue ev'') \<longrightarrow>
                       (case l of
                        Stackloc loc \<Rightarrow>
                          (case accessStore loc sck' of None \<Rightarrow> False 
                          | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                          | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
                          | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct mem' stloc | _ \<Rightarrow> False)
                          | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev'')) | _ \<Rightarrow> False))
                        | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address ev'')) | _ \<Rightarrow> False)))"  
            using assms(3) 20(7) unfolding TypeSafe_def typeCompat_def by blast
          then have stl2MCon:"MCon (MTValue x2) mem' stl1" using  20(7) l1InOld b20 mtv1 l1SckK by fastforce
          then obtain x'' where nf2:" accessStore stl1  mem' = Some x''" using stl2MCon MCon.simps  by fastforce
          have nf3:"((\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None) \<and>
                        (\<forall>loc y. accessStore loc mem' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
            using assms(3) 20(7) unfolding TypeSafe_def lessThanTopLocs_def by simp
          then have nf4:"\<exists>y tloc. tloc <toploc mem' \<and> LSubPrefL2  stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using nf2 nf3 by blast
          then have nf6:"\<exists>tloc. tloc <toploc m' \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using MemLSubPrefL2_specific_imps_general a10 20 by auto      

          then show ?thesis
          proof (cases tp2)
            case mta1:(MTArray x11' x12')
            then show ?thesis
            proof(cases "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1")
              case t1:True
              have "(k', e) = astack ip (Memory (MTArray x t)) (KMemptr p) (sck', ev'')" using NoneIp astack_dup_is_astack a10 by simp
              then have "CompMemType m' x11' x12' (MTValue x2) stl2 stl1" 
                using  b20 
                  oneValueoneArray[of k' e ip x t p sck' ev'' tp1 l1 tp2 l2 stl1 stl2  st ev cd x2 x11' x12' m' cd'] 
                  20(7) l1InOld a50 l1InOld l1SckK c10 c20  assms(1,3) mtv1 mta1 a150 notSame t1 p1 ne3 ne4 ne5 oldLimit ne6 nf6 mconp  by blast
              then show ?thesis using notSame mtv1 mta1 by auto
            next
              case False
              then show ?thesis using notSame mtv1 mta1 by auto
            qed
          next
            case (MTValue x2)
            then show ?thesis using notSame mtv1 by simp
          qed
        qed
      qed
    qed
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 20(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 20(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 20(7) by metis
  next
    have "addressFormat (address ev'')" using assms(3) TypeSafe_def 20(7) by simp
    then show "addressFormat (address e)" using 20(7) a4 by (metis)
  next
    have "addressFormat  (sender ev'')" using assms(3) TypeSafe_def 20(7) by simp
    then show "addressFormat  (sender e)" using 20(7) a4 by (metis assms(4) decl_env)
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev'')) = (storage st (address e))" using a30 by simp
      have a110:"m' = mem'" and a115:"cd' = c" using a10 20 by simp+
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 20(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''" using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 20(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" using a40  fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" using a40 fmranI by auto
      show "case lDen of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr p)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)

          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KMemptr p " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr p)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = (Memory (MTArray x t))" using a90 a50 by simp
            then have a210:"t'' = tDen" using a5 20(2) by simp
            have "v = KMemptr p" using 20(2) by simp
            have a220:"MCon (MTArray x t) (memory st) (extractValueType v)" using a200 a210 assms(2) by simp
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 20(2) assms(3) a110 20(7) assms(5) 20(3)  unfolding TypeSafe_def 
              by (metis Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(19) Type.simps(19) a220 prod.inject extractValueType.simps(3))
          qed
        next
          case False
          then have "ip'' \<noteq> ip" using a160 a90 Stackloc by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 20(7) by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
              using a190 some Stackloc a170 * a180 a110 a115 a100 20(7) 
              by (cases a; cases tDen; fastforce)
          qed
        qed
      next
        case (Storeloc x2)
        then have a170:"ip'' \<noteq> ip" using a40 Storeloc a90 by auto
        then have a180: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Storeloc fmranI a90 by fastforce 
        then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
          using Storeloc a100 20(7) by (cases tDen;force)
      qed
    qed
  next
    have "lessThanTopLocs cd'" using assms(3) TypeSafe_def 20(7) by simp
    then show "lessThanTopLocs c" using a10 by simp
  next 
    have "lessThanTopLocs mem'" using assms(3) TypeSafe_def 20(7) by simp
    then show "lessThanTopLocs m'" using a10 20 by simp
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    assume notCp:"\<not>cp"
    then show "toploc (memory st) \<le> toploc m'" using  20(7) a10 assms by auto

    show "ncpOMemInDMem (memory st) m'" using   20(7) a10 assms notCp by blast
    show "ncpElementsNoSubPref (memory st) m'" using  20(7) a10 assms notCp by blast
    show ncp:"ncpDenvalueLimit e ev k' (stack st) (memory st)" unfolding ncpDenvalueLimit_def
    proof  intros
      fix tp' locs p''' i''
      assume asm:"(Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p''') 
                  \<and> i'' < toploc (memory st) \<and> LSubPrefL2 p''' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')"
      then obtain i where idef:"denvalue e $$ i = Some (Memory tp', Stackloc locs)" by blast

      have "ncpDenvalueLimit ev'' ev sck' (stack st) (memory st)" using 20 assms(5) by blast
      then have old:"\<forall>tp' locs p i.
     (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
     (\<exists>tp'' loc2 p'.
         (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
         accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p)))" 
        unfolding ncpDenvalueLimit_def by blast
      show "\<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p''' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p''' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p'''))"
      proof(cases "locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case True
        then have b45:"tp' = (MTArray x t)"  using a150 a50 True 
          using idef by fastforce
        have b50:"p''' = p" using a40 a20 push_def 
          by (metis Stackvalue.inject(3) True accessStore_def accessStore_updateStore allocateMapping asm old.prod.exhaust option.inject snd_eqD)

        have c20:"(\<exists>stloc tp'' p'.
           (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
           accessStore stloc (stack st) = Some (KMemptr p') \<and>
           (tp'' =  (MTArray x t) \<and> p = p' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x t) p' p)))" 
          using assms a5 20(2,3,7) by fastforce
        then show ?thesis using old a40 a20 asm b45 b50 by blast
      next
        case False
        then have b5:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a20 a40 asm 
          by (metis)
        then have "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'')"  using a40  a160 fmranI asm by fastforce
        moreover have "accessStore locs sck' = accessStore locs k'" using b5 a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
        ultimately show ?thesis using old asm by metis 
      qed
    qed
  next
    assume notCP:"\<not>cp"
    then show "ncpNewSelfPoint (memory st) m'" using a40 assms 20  a10 by blast
  next 
    show "toploc mem' \<le> toploc m'" using a10 20 by blast
  qed
next
  case (21 x t p wi wj cd wk wl cd' mem''' sck'' ev'')
  then obtain l where a1:"l = ShowL\<^sub>n\<^sub>a\<^sub>t(toploc mem')" by simp
  have vk:"wi = Calldata (MTArray x t)" using decl.simps(9) 21(8) by (simp split:if_split_asm)
  then have locationscd':"(\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None)" 
    using assms(3) 21 unfolding TypeSafe_def lessThanTopLocs_def by simp
  then have b1:"accessStore l mem' = None" using a1 using Read_Show_nat'_id using LSubPrefL2_def by auto
  have b2:"x>0" using 21(8) vk a1 by (metis not_None_eq)
  then have Mconcd:"MCon (MTArray x t) cd (extractValueType v)" using assms(2) 21(2) 21(4) vk 21(5) by simp
  have NoneIp:"denvalue ev'' $$ ip = None" using 21 by (simp split:if_split_asm)
  obtain c' where a2:"\<exists>dud. (dud, c') = allocate mem'"  by (simp add: allocate_def)
  then have aloc:"snd (allocate mem') = c'" by (simp add: allocate_def)
  then have lNotInC':"accessStore l c' = None" using b1 a1 unfolding allocate_def accessStore_def by auto
  obtain mm' where a3:"cpm2m p l x t cd c' = Some mm'" using 21 a1 a2 
    using b2 vk aloc NoneIp by fastforce
  then have a4:"Some (c, m', k', e) = Some (cd', mm', astack ip (Memory (MTArray x t)) (KMemptr l) (sck', ev''))" 
    using a1 a2 a3 21 decl.simps(9) vk b2 aloc NoneIp
    by simp
  then have a20:"k' = push (KMemptr l) sck'" by force
  have a30:"e = (updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev'')" using a4 by simp
  then have a40:"denvalue e = denvalue(ev'' \<lparr> denvalue := fmupd ip (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev'') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp

  then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
    using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce
  have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
  have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
  then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
    using b100 a2 unfolding allocate_def by simp
  then have subMapping:"mapping mem' \<subseteq>\<^sub>f mapping mm'" using b105  unfolding fmsubset_alt_def 
    by (metis (mono_tags, lifting) accessStore_def fmpredI option.distinct(1))

  have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 21(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 21(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                    \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  have mcTop:"MCon (MTArray x t) mm' l" using a3 unfolding cpm2m_def a4
              using MCon_cpm2m[of p l t cd c' x mm' ] Mconcd 21(2) b2 lNotInC' by fastforce
  show ?thesis unfolding TypeSafe_def 
  proof(intros)
    have a110:"m' = mm'" using a4 by simp
    then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
    have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
    then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def by simp

    fix locs tp assume ncp:"\<not>cp"
    then have a120:"\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs" using assms(5) 21(7) by simp
    moreover have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp mm' locs" using mconCopySingle[of l mem' mm' ] using b110 b105 by simp
    moreover have "toploc c' > toploc mem'" using a2 unfolding allocate_def by simp
    moreover have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
    ultimately show "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using 21 assms(5)  21(7) a110 a120 ncp by blast
  next
    show "unique_locations (denvalue e)" using assms(3) 21(7) updateEnvUniqueLocs a4 by blast
  next
    have b2: "compPointers sck' (denvalue ev'')" using assms(3) 21(7) unfolding TypeSafe_def by auto
    have "address ev'' = address e"using a30 by simp
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 21(7) by simp
    ultimately show "compPointers k' (denvalue e)"
      using compPointersNonStackUpd[of sck' ev'' e ip " Memory (MTArray x t)" k' "KMemptr l" ] 
        a40 a50 assms(3) 21(7) b2 a20 by simp
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 21(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 21(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 21(7) by metis
  next
    have "addressFormat (address ev'') " using assms(3) TypeSafe_def 21(7) by simp
    then show "addressFormat(address e) " using 21(7) a4 by auto
  next
    have "addressFormat(sender ev'')" using assms(3) TypeSafe_def 21(7) by simp
    then show "addressFormat (sender e)" using 21(7) a4 by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev'')) = (storage st (address e))" using a30 by simp
      have a110:"m' = mm'" using a4 by simp
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 21(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
        using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
        using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 21(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                        \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      show "case lDen of
               Stackloc loc \<Rightarrow>
                 (case accessStore loc k' of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                  | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                  | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                  | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
               | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KMemptr l " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = Memory (MTArray x t)" using a90 a50 by simp
            have a220:"v = KCDptr p" using 21(2) by simp
            have "c = cd'" using a4 by simp
            then have "MCon (MTArray x t) mm' l" using a3 unfolding cpm2m_def 
              using MCon_cpm2m[of p l t cd c' x mm' ] Mconcd 21(2) b2 
              by (metis a220 lNotInC' extractValueType.simps(2))
            then have "MCon (MTArray x t) m' l" using a4 a110 21(7) by blast
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 21(2) by simp
          qed
        next
          case False
          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce

          have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
            using b100 a2 unfolding allocate_def by simp

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc False by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 21 by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" 
            using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis 
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis 
            proof(cases a)
              case (KValue x1)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 21(7) by (cases tDen; fastforce)
            next
              case (KCDptr x2)
              then have b10:"(case tDen of Calldata struct \<Rightarrow> MCon struct cd' x2 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 21(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Calldata struct" by (auto split:Type.splits) 
              then have "MCon struct cd' x2" using b10 by simp
              then show ?thesis using Stackloc some KCDptr tden a110 a4 by simp
            next
              case (KMemptr x3)
              then have b10:"(case tDen of Memory struct \<Rightarrow> MCon struct mem' x3 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 21(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Memory struct" by (auto split:Type.splits) 
              then have "MCon struct mem' x3" using b10 by simp
              then have "MCon struct mm' x3" using mconCopySingle[of l mem' mm' struct] b110 b105 by auto
              then show ?thesis using Stackloc some KMemptr tden a110 a4 by simp
            next
              case (KStoptr x4)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 21(7) by (cases tDen; fastforce)
            qed
          qed 
        qed
      next
        case (Storeloc x2)
        then have "ip'' \<noteq> ip" using a160 a90 by simp
        then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Storeloc fmranI a90 * by fastforce
        then have a180:"(case tDen of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev'')) | _ \<Rightarrow> False)"  
          using a170 Storeloc using assms(3) 21(7) 
          unfolding TypeSafe_def typeCompat_def by force
        then obtain typ' where tdent:"tDen =  Storage typ'"  by (auto split: Type.splits)
        then have "SCon typ' x2 (storage st (address ev''))" using a180 by simp
        then have "SCon typ' x2 (storage st (address e))" using a100 by simp
        then show ?thesis  using  a170 Storeloc using assms(3) 21(7) tdent 
          by simp
      qed
    qed
  next 
    show "lessThanTopLocs c" using assms(3) 21(7) a4 unfolding TypeSafe_def by auto
  next 
    have b100:"lessThanTopLocs mem'" using assms(3) 21(7) unfolding TypeSafe_def by blast
    have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
    have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs m'" 
      using cpm2mSingleChange[of p l t cd c' x mm'] a4 a3 cpm2m_def[of p l x t cd c'] by fastforce
    moreover have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
    ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs m' = accessStore locs mem'" by simp
    show "lessThanTopLocs m'" using cdMemLocsToploc[of mem' l c' m'] b100 a1 a2 b99 using b10 by presburger
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    have selfPoint:"\<forall>la l'. TypedMemSubPref la l (MTArray x t) \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
      using cpm2mSelfPointers[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] by argo
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def
    proof(intros)
      fix tp1 tp2 l1 l2 stl1 stl2 dloc1 
      assume c10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 21(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
        using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
        using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 21(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                      \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using a40 lessThanTopLocs_def fmranI by auto

      show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                      else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1
                                  
                            else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
      proof(cases "l1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case t1:True
        then have b10:"tp1 = (MTArray x t)" using a150 c10 a50 by fastforce
        have b15:"stl1 = l"  using a20 c10 t1 unfolding push_def updateStore_def accessStore_def allocate_def by auto
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 by fastforce
          then show ?thesis using c10 b10 b20 t1 True TypedMemSubPrefPtrs.simps a20 unfolding push_def updateStore_def accessStore_def by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" 
            using "21"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff NoneIp by fast
          have " accessStore l2 k' = accessStore l2 sck'" using a20 c10 False a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp2 mem' stl2" using 21(7) assms(3) c10 b20 unfolding TypeSafe_def  
            by (metis Pair_inject assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl1 \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm']  a2  b15 a4 unfolding allocate_def  by fastforce
          then have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem' mm' ] using b105 b15 a4 by blast

          then have b23:"MCon tp2 m' stl2" using b22  a4 by blast

          have b30:"\<not>(LSubPrefL2 stl2 l)" using b15 b20 False 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp2 mem' stl2\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl2 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl2))" using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedMemSubPref la stl1 (MTArray x t) \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b10 b15 a4 by blast
          have "(\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" 
            by (simp add: lNotInC')
          then have b70:" MCon tp1 m' stl1"
            using MCon_cpm2m[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] Mconcd extractValueType.simps  21(2) b10 a4 b15 by fastforce
          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl2 stl1)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl1. \<not>(LSubPrefL2 stl1 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl1 \<longrightarrow> accessStore loc mem' = None" using b105 b15 by auto
          have "case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray x t) stl2 stl1
             else if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' x t dt stl1 dloc1 
                               else True
          | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTValue val2) stl1 stl2 else True
         " 
          proof(cases tp2)
            case (MTArray x11 x12)
            then have b130:"MCon (MTArray x11 x12) m' stl2" using b23 by auto
            have b140:"MCon (MTArray x11 x12) mem' stl2" using b22 MTArray by simp
            have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using b130 b100 b120 b90 b140 b27 cpm2mNotSubPrefsOfOriginal by auto
            moreover have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cpm2mNotSubPrefsOfChanged b70 b10 by simp
            moreover have "\<not>(TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2 
                using b10 b2 b60 b70 b15 CompMemType_imps_TypedMemSubPrefPtrs by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1" using b30  b130  b120  b140 b27 b15 b45 cpm2mLocationRelatedToTopNotInOrig c10
                by (metis)
              then show False using c10 by simp 
            qed
            ultimately show ?thesis using MTArray by auto
          next
            case (MTValue x2)
            have "MCon (MTArray x t) m' stl1" using b70 by (simp add: b10)           
            then have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cpm2mNotSubPrefsOfChanged by simp
            then show ?thesis using MTValue by simp
          qed
          then show ?thesis using b80 b10 by simp
        qed
      next
        case f1:False
        then have b10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'')" using "21"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b15:"stl2 = l"  using a20 c10  unfolding push_def updateStore_def accessStore_def allocate_def by auto

          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 True by fastforce
          have " accessStore l1 k' = accessStore l1 sck'" using a20 c10 f1 a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp1 mem' stl1" using 21(7) assms(3) c10 b20 b10 unfolding TypeSafe_def  
            by (metis Pair_inject assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl2 \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm']  a2 a4 b15 unfolding allocate_def by fastforce
          then have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem' mm' ] using b105 a4 b15 by simp

          then have b23:"MCon tp1 m' stl1" using b22 by (simp add: a4)

          have b30:"\<not>(LSubPrefL2 stl1 l)" using b15 b20 f1 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl1 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl1))" using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedMemSubPref la stl2 tp2 \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b20 b15 a4 by blast
          have b65:"(\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" by (simp add: lNotInC')
          then have b70:" MCon tp2 m' stl2" 
            using MCon_cpm2m[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] Mconcd extractValueType.simps  21(2) b10 a4 b15 b20 b60 by fastforce

          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl1 stl2)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl2. \<not>(LSubPrefL2 stl2 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl2 \<longrightarrow> accessStore loc mem' = None" using b105 b15 by auto

          have "case tp1 of
         MTArray len arr \<Rightarrow>
           (case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' len arr dt stl1 dloc1 
                         else True
           | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
         | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
          proof(cases tp1)
            case (MTArray x11 x12)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cpm2mNotSubPrefsOfChanged  b2 b20 b60 b70 by presburger
            moreover have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using b100 b23 b80 b27 b90 b22 b120 cpm2mNotSubPrefsOfOriginal MTArray by auto
            moreover have "\<not>(TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2[of  x t m' stl2]  b15 a1 b60 b20 b70  
                using CompMemType_imps_TypedMemSubPrefPtrs b2 by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1" using cpm2mLocationRelatedToTopNotInOrig b100 b23 b80 b27 b90 b22 b120 
                using MTArray b15 by metis
              then show False using c10 by simp 
            qed
            ultimately show ?thesis using MTArray 
              using b20 by auto

          next
            case (MTValue x2)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cpm2mNotSubPrefsOfChanged  b2 b20 b60 b70 by presburger
            then have "if TypedMemSubPrefPtrs m' x t stl2 stl1 then CompMemType m' x t (MTValue x2) stl2 stl1 else True" by simp
            then show ?thesis using b20 
              by (simp add: MTValue)
          qed
          then show ?thesis 
            using CompMemType_imps_TypedMemSubPrefPtrs using b80 b20 by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" using "21"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
          have b30:"accessStore l2 k' = accessStore l2 sck'" using a20 c10 False a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          have b40:" accessStore l1 k' = accessStore l1 sck'" using b20 b10 a20 c10 False a130 f1 unfolding push_def updateStore_def accessStore_def allocate_def by auto

          have b50:"MCon tp1 mem' stl1" using 21(7)  c10 b10 b40 unfolding TypeSafe_def
            by (metis Pair_inject assms(3) sameMemTSafe)
          have b60:"\<not>(LSubPrefL2 stl1 l)" by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          have b50b:"MCon tp2 mem' stl2" using 21(7) c10 b20 b30 unfolding TypeSafe_def
            by (metis Pair_inject assms(3) sameMemTSafe)
          then have b60b:"\<not> LSubPrefL2 stl2 l " by (metis MCon_imps_Some LSubPrefL2_def  b105 Not_Sub_More_Specific option.distinct(1))

          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce

          have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs m'" 
            using b100 a2 21 a4 unfolding allocate_def by force

          have "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') \<and>
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') \<and> accessStore l1 sck' = Some (KMemptr stl1) \<and> accessStore l2 sck' = Some (KMemptr stl2)" 
            using b10 assms(3) 21(7) c10 b30 b40 b20 b30 by simp
          then have c1:"(if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs mem' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs mem' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType mem' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType mem' len arr dt stl1 dloc1 
                       else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs mem' len arr stl1 stl2 then CompMemType mem' len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs mem' len2 arr2 stl2 stl1 then CompMemType mem' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True))" 
            using b10 assms(3) 21(7) c10 b30 b40 b20 b30 unfolding TypeSafe_def compMemPtrs_def by blast

          show ?thesis 
          proof(cases "stl1 = stl2")
            case True
            then show ?thesis using c1 by simp
          next
            case f1:False
            then show ?thesis 
            proof(cases tp1)
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases tp2)
                case mta:(MTArray x11' x12')
                have "if TypedMemSubPrefPtrs m' x11' x12' stl2 stl1 then CompMemType m' x11' x12' tp1 stl2 stl1
                  else if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 
                    else if TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt stl1 dloc1 
                else True"
                proof(cases "TypedMemSubPrefPtrs mem' x11' x12' stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray mta by simp
                  then have " CompMemType mem' x11' x12' tp1 stl2 stl1" using c1 f1 mta MTArray  True by simp
                  then have " CompMemType m' x11' x12' tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis using c1 f1 mta MTArray  True  
                    using \<open>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1\<close> by auto
                next
                  case False
                  then have b40:"\<not>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis
                  proof(cases " TypedMemSubPrefPtrs mem' x11 x12 stl1 stl2")
                    case t2:True
                    then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                      using MTArray mta b50 by blast
                    then have " CompMemType mem' x11 x12 (MTArray x11' x12') stl1 stl2" using c1 f1 mta MTArray  t2  False MTypes.simps(5) b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref
                      by (smt (verit, best))
                    then show ?thesis using c1 f1 mta MTArray
                      using b105 b110 b40 b50 b60 cpm2mCompMemTypeOld_imps_CompMemType  
                      using t2  
                      using \<open>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2\<close> by presburger
                  next
                    case f2:False
                    then show ?thesis
                    proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs mem' x11' x12' stl2 dloc1")
                      case True
                      then have d10:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1"
                        using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b b50 b60 using MTArray mta
                        using cpm2mCompMemTypeOld_imps_CompMemType by blast
                      have d20:"\<exists>dt.
                               CompMemType mem' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType mem' x11 x12 dt stl1 dloc1 "
                        using True c1 f2 f1 False MTArray mta by simp
                      then have "\<not> LSubPrefL2 dloc1 l" 
                        by (metis CompTypeRemainsMCon MCon_imps_Some MTArray LSubPrefL2_def a1 b50 hash_suffixes_associative le_refl locationscd' option.distinct(1))
                      then have "\<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt stl1 dloc1" 
                        using MTArray b105 b110 b50 b50b b60 b60b cpm2mCompMemTypeOld_imps_CompMemType mta d20 by (metis)
                      then show ?thesis using d10 b40 f2  
                        using MTArray b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref by presburger
                    next
                      case f3:False
                      then have "\<not>(TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1)" 
                        using inv_cpm2mTPrefOld_imps_TPref MTArray b105 b110 b50b b60b mta  b50 b60  
                        using inv_cpm2mCompMemTypeOld_imps_CompMemType by blast
                      then show ?thesis using False mta MTArray f1 f2 b40 f3
                        using b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref by metis
                    qed
                  qed
                qed
                then show ?thesis using mta MTArray f1 by auto
              next
                case mtv2:(MTValue x2)
                have " if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 else True" 
                proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl1 stl2")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray b50 by blast
                  then have " CompMemType mem' x11 x12 tp2 stl1 stl2" using c1 f1 mtv2 MTArray  True by auto
                  then have " CompMemType m' x11 x12 tp2 stl1 stl2" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis using c1 f1 mtv2 MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTArray f1 mtv2  by auto
              qed
            next
              case (MTValue x2)
              then show ?thesis 
              proof(cases tp2)
                case (MTArray x11 x12)
                have "if TypedMemSubPrefPtrs m' x11 x12 stl2 stl1 then CompMemType m' x11 x12 tp1 stl2 stl1  else True" 
                proof(cases "TypedMemSubPrefPtrs mem' x11 x12 stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray by blast
                  then have " CompMemType mem' x11 x12 tp1 stl2 stl1" using c1 f1 MTValue MTArray  True by simp
                  then have " CompMemType m' x11 x12 tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis using c1 f1 MTValue MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTValue MTArray f1 by auto
              next
                case mtv2:(MTValue x2)
                then show ?thesis using MTValue f1 by simp
              qed
            qed
          qed
        qed
      qed
    qed
  next 
    assume notCP:"\<not>cp"
    show "ncpDenvalueLimit e ev k' (stack st) (memory st)" unfolding ncpDenvalueLimit_def
    proof  intros
      fix tp' locs p''' i''
      assume asm:" (Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p''') \<and> i'' < toploc (memory st) \<and> LSubPrefL2 p''' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')"
      then obtain i where idef:"denvalue e $$ i = Some (Memory tp', Stackloc locs)" by blast

      have "ncpDenvalueLimit ev'' ev sck' (stack st) (memory st)" using 21 notCP assms(5) by blast
      then have old:"\<forall>tp' locs p i.
     (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
     (\<exists>tp'' loc2 p'.
         (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
         accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p)))" 
        unfolding ncpDenvalueLimit_def by blast
      show "\<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p''' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p''' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p'''))"
      proof(cases "locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case True
        then have b45:"tp' = (MTArray x t)"  using a150 a50 True 
          using idef by fastforce
        have b50:"p''' = l" using a40 a20 push_def 
          by (metis Stackvalue.inject(3) True accessStore_def accessStore_updateStore allocateMapping asm old.prod.exhaust option.inject snd_eqD)
        then have " p''' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem'))" using a1 by blast
        moreover have "toploc mem' \<ge> toploc (memory st)" using 21 notCP assms(5) by blast
        ultimately show ?thesis using asm 
          by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative hashesIntSame le_antisym nat_less_le)
      next
        case False
        then have b5:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a20 a40 asm 
          by (metis)
        then have "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'')"  using a40  a160 fmranI asm by fastforce
        moreover have "accessStore locs sck' = accessStore locs k'" using b5 a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
        ultimately show ?thesis using old asm by metis 
      qed
    qed
  next 
    assume notCP:"\<not>cp"
    show "ncpOMemInDMem (memory st) m'" unfolding ncpOMemInDMem_def
    proof intros
      fix i loc 
      assume c10:" i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
      then have " accessStore loc (memory st) = accessStore loc mem'" using assms(5) 21(7) notCP c10 ncpOMemInDMem_def by simp
      have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs m'" 
        using cpm2mSingleChange[of p l t cd c' x mm'] a4 a3 cpm2m_def[of p l x t cd c'] by fastforce
      moreover have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
      ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs m' = accessStore locs mem'" by simp
      have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
      have "toploc (memory st) \<le> toploc mem'" using assms(5) c10 21(7) notCP by simp
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> l" using a1 assms(5) c10 b99 
        by (metis hashesIntSame leD)
      then show "accessStore loc (memory st) = accessStore loc m'" using c10 a1 b99 a2 cdMemLocsToploc[of mem' l c' m']  
        using "21"(3) 
        by (metis LSubPrefL2_def \<open>accessStore loc (memory st) = accessStore loc mem'\<close> b10 hash_suffixes_associative hashesInts)
    qed
  next
    assume notCP:"\<not>cp"
    have b99:"toploc c' = toploc m'"  using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp

    have a110:"m' = mm'" using a4 by simp
    then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
    have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
    then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def by simp

    fix locs tp assume ncp:"\<not>cp"
    then have a120:"\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs" using assms(5) 21(7) by simp
    moreover have "\<forall>locs tp. MCon tp mem' locs \<longrightarrow> MCon tp mm' locs" using mconCopySingle[of l mem' mm' ] using b110 b105 by simp
    moreover have b98:"toploc c' > toploc mem'" using a2 unfolding allocate_def by simp
    moreover have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
    ultimately have "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using 21 assms(5)  21(7) a110 a120 ncp by blast

    have selfPoint:"\<forall>la l'. TypedMemSubPref la l (MTArray x t) \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
      using cpm2mSelfPointers[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] by argo 

    have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedMemSubPref locs l (MTArray x t) \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using cpm2mSingleChange2[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] by fastforce
    then have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedMemSubPref locs l (MTArray x t) \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def a2 accessAllocate[of c' mem'] 
      by (simp add: \<open>\<forall>locations. accessStore locations c' = accessStore locations mem'\<close>)

    have limitsOld:" ((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
     (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))"
      using assms(1) unfolding TypeSafe_def lessThanTopLocs_def using 21(7) by auto

    have limits:"((\<forall>tloc loc. toploc mem' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem' = None) \<and>
                    (\<forall>loc y. accessStore loc mem' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      using assms(3) 21(7) unfolding TypeSafe_def lessThanTopLocs_def  by simp

    have old:"ncpElementsNoSubPref (memory st) mem' \<and> ncpOMemInDMem (memory st) mem' \<and> ncpNewSelfPoint (memory st) mem'" using 21 notCP assms(5) by blast
    then have sameLocs:"(\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc mem')" unfolding ncpOMemInDMem_def by blast
    have selfPointMem':"  (\<forall>i loc loc2. i < toploc mem' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc mem' = Some (MPointer loc2) \<longrightarrow> loc = loc2)" 
      using old unfolding ncpNewSelfPoint_def by blast
    then have old:"\<forall>i l1 t1 l2 t2 loc i2 loc2.
     i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc \<longrightarrow>
     \<not> TypedMemSubPrefPtrs mem' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs mem' l1 t1 loc loc2" using old unfolding ncpElementsNoSubPref_def by blast

    show "ncpElementsNoSubPref (memory st) m' " unfolding ncpElementsNoSubPref_def
    proof intros
      fix i l1 t1 l2 t2 loc i2 loc2
      assume c10:"i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc"
      then have "accessStore loc (memory st) = accessStore loc mem'"using sameLocs by auto
      have MConnew:"MCon (MTArray l1 t1) (memory st) loc" using c10 by blast
      have locdef:"i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)" using c10 by simp

      then have inotl:"i < toploc  mem'" using b99 21(7) assms(5) ncp b98 c10 by simp
      then have inotlString:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> l" using a1 
        by (metis Read_Show_nat'_id linorder_neq_iff)
      have typeMemOld:"\<not> TypedMemSubPrefPtrs mem' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs mem' l1 t1 loc loc2" using old c10 MConnew by auto

      have "\<not> LSubPrefL2 loc l" using c10 inotlString
        by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general a1 hash_inequality hash_suffixes_associative)
      then have conc1:" \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2" using b105  b110  a110 MConnew a120 typeMemOld 
        using inv_cpm2mTPrefOld_imps_TPref by blast
      then have hashlimit:"\<forall>f. hash loc2 f \<noteq> loc" using c10 
        by (metis (no_types, opaque_lifting) MCon_imps_Some LSubPrefL2_def Not_Sub_More_Specific limitsOld not_Some_eq)

      have conc2:"\<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
      proof(cases " i2 < toploc mem'")
        case True
        then have f2:" (\<forall>p loc2. i2 < toploc mem' \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> accessStore loc2 mem' = Some (MPointer p) \<longrightarrow> loc2 = p)" 
          using selfPointMem' c10 by blast
        have "(ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t i)" using c10 
          by (metis hashesIntSame leD)

        then have loc2NotSub:"\<not>LSubPrefL2 loc2 l" using a1 True 
          by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general c10 hash_inequality hash_suffixes_associative hashesIntSame nat_neq_iff)
        show ?thesis 
        proof
          assume asm:"TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
          then show False using hashlimit f2 c10 b110 loc2NotSub
          proof(induction t2 arbitrary:loc2 l2)
            case (MTArray x1 t2)
            then obtain i''' l''' where  i'''def:"(i'''<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = Some (MPointer l''') \<and> (l''' = loc \<or> TypedMemSubPrefPtrs m' x1 t2 l''' loc))" 
              using TypedMemSubPrefPtrs.simps(2)[of m' l2 x1 t2 loc2 loc] by blast
            then have "LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) (ShowL\<^sub>n\<^sub>a\<^sub>t i2)" using MTArray(5) 
              by (metis LSubPrefL2_def Not_Sub_More_Specific)
            moreover have "\<not> LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) l" using MTArray(7) 
              using MemLSubPrefL2_specific_imps_general a1 by blast

            ultimately have l'''Exp:"l''' = (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i'''))" using MTArray(4,6) i'''def  
              by (metis True a110 c10)

            then show ?case 
            proof(cases "l''' = loc")
              case True
              then show ?thesis using MTArray(3) l'''Exp by simp
            next
              case False
              then have "TypedMemSubPrefPtrs m' x1 t2 l''' loc" using i'''def by simp
              then show ?thesis using MTArray.IH[of x1 l'''] l'''Exp MTArray(3) 
                using \<open>LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) (ShowL\<^sub>n\<^sub>a\<^sub>t i2)\<close> \<open>\<not> LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) l\<close> b110 c10 f2 hash_suffixes_associative by force
            qed
          next
            case (MTValue x)
            then have "(\<exists>i<l2. hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc)" using TypedMemSubPrefPtrs.simps(1)[of m' l2 x loc2 loc] by auto
            then show ?case using MTValue by simp
          qed
        qed
      next
        case False
        then show ?thesis 
        proof(cases "i2 = toploc mem'")
          case True
          then have g1:"(ShowL\<^sub>n\<^sub>a\<^sub>t i2) = l" using a1 by blast
          show ?thesis
          proof
            assume asm:" TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
            then show False using hashlimit c10 b105 selfPoint sameaccess
            proof(induction t2 arbitrary:loc2 l2)
              case (MTArray x1 t2)
              then obtain iIn lIn where idef: " (iIn<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m' = Some (MPointer lIn) \<and> (lIn = loc \<or> TypedMemSubPrefPtrs m' x1 t2 lIn loc))" 
                using TypedMemSubPrefPtrs.simps(2)[of m' l2 x1 t2 loc2 loc] by blast
              have g2:"\<forall>i. (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> l" using g1 MTArray(4) LSubPrefL2_def 
                by (metis hash_inequality hash_suffixes_associative) 
              show ?case 
              proof(cases "TypedMemSubPref (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) l (MTArray x t)")
                case True
                then have g4:"lIn = (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn))" using MTArray idef 
                  using a110 by blast
                then show ?thesis 
                proof(cases "lIn = loc")
                  case True
                  then show ?thesis using g4 MTArray by blast
                next
                  case False
                  then have "TypedMemSubPrefPtrs m' x1 t2 lIn loc" using idef by simp
                  then show ?thesis 
                    by (smt (verit, best) MTArray.IH LSubPrefL2_def True \<open>\<not> LSubPrefL2 loc l\<close> b105 c10 Not_Sub_More_Specific g1 g4 sameaccess selfPoint typedPrefix_imp_SubPref)
                qed
              next
                case False
                then have " accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mem' = accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mm'" using g2 MTArray by blast
                moreover have "LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) l" using g1 MTArray LSubPrefL2_def 
                  by (metis hash_suffixes_associative)
                ultimately have "accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mm' = None" using MTArray by metis
                then show ?thesis using idef 
                  by (simp add: a110)
              qed
            next
              case (MTValue x')
              then show ?case by auto
            qed
          qed
        next
          case f4:False
          then have "i2> toploc mem'" using False by auto 
          then have loc2NotSub:"\<not>LSubPrefL2 loc2 l" using a1 c10 
            by (metis LSubPrefL2_def f4 hash_suffixes_associative hashesInts)
          show ?thesis 
          proof
            assume asm:"TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
            show False
            proof(cases t2)
              case (MTArray x11 x12)
              then have h1:"(\<exists>i<l2. \<exists>l. accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l = loc \<or> TypedMemSubPrefPtrs m' x11 x12 l loc))" 
                using TypedMemSubPrefPtrs.simps(2)[of m' l2 x11 x12 loc2 loc] asm by blast
              then obtain i''' l''' where i'''def:"i'''<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = Some (MPointer l''') \<and> (l''' = loc \<or> TypedMemSubPrefPtrs m' x11 x12 l''' loc)" by blast
              then have " accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = None" using  loc2NotSub 
                by (metis False LSubPrefL2_def MemLSubPrefL2_specific_imps_general a1 a110 b110 c10 Not_Sub_More_Specific leI locationscd')
              then show ?thesis using i'''def by simp
            next
              case (MTValue x2)
              then have "(\<exists>i<l2. hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc)" 
                using asm TypedMemSubPrefPtrs.simps(1)[of m' l2 x2 loc2 loc] by blast
              then show ?thesis using hashlimit by simp
            qed
          qed

        qed
      qed
      then show "\<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc" using inv_cpm2mTPrefOld_imps_TPref conc2 by blast
      show "\<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2" using conc1 by simp
    qed
  next 
    assume notCP:"\<not>cp"
    have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
    have "toploc (memory st) \<le> toploc mem'" using assms(5) 21(7) notCP by simp
    moreover have "toploc c' > toploc mem'" using a2 unfolding allocate_def by simp
    then show " toploc (memory st) \<le> toploc m' " using b99 notCP assms 21 by simp
  next
    assume notCP:"\<not>cp"
    show "ncpNewSelfPoint (memory st) m'" unfolding ncpNewSelfPoint_def
    proof intros
      fix i loc loc2
      assume asm:"i < toploc m' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc m' = Some (MPointer loc2)"
      have old:"(\<forall>i loc loc2. i < toploc mem' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc mem' = Some (MPointer loc2) \<longrightarrow> loc = loc2)" 
        using assms(5) notCP 21(7) unfolding ncpNewSelfPoint_def by blast
      have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp

      have a110:"m' = mm'" using a4 by simp
      then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
        using a3 a1 cpm2m_def[of p l x t cd c'] cpm2mSingleChange[of p l t cd c' x mm'] by fastforce
      have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem' = None" using locationscd' a2 lNotInC' a1 by auto
      have "\<forall>locations. accessStore locations c' = accessStore locations mem'" using a2 accessAllocate[of c' mem'] by auto
      then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
        using b100 a2 unfolding allocate_def by simp

      have g1:"toploc c' = Suc (toploc mem')" using a2 unfolding allocate_def by simp
      show "loc = loc2"
      proof(cases "i < toploc mem'")
        case True
        then have "\<not> LSubPrefL2 loc l" using a1 LSubPrefL2_def 
          by (metis MemLSubPrefL2_specific_imps_general Read_Show_nat'_id asm hash_inequality hash_suffixes_associative less_not_refl)
        then show ?thesis using old asm b110 a1 True a110 by auto
      next
        case False
        then have iIsTop:"i = toploc mem'" using asm g1 b99 by simp
        have selfPoint:"\<forall>la l'. TypedMemSubPref la l (MTArray x t) \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
          using cpm2mSelfPointers[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] by argo 

        have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedMemSubPref locs l (MTArray x t) \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
          using cpm2mSingleChange2[of p l t cd c' x mm'] a3 a1 cpm2m_def[of p l x t cd c'] by fastforce
        then have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedMemSubPref locs l (MTArray x t) \<longrightarrow> accessStore locs mem' = accessStore locs mm'" 
          using b100 a2  allocate_def  accessAllocate[of c' mem']  by simp
        then show ?thesis using asm iIsTop 
          by (metis a1 a110 a3 accessPrePost1 b105 cpm2m_def hash_inequality lNotInC' not_Some_eq selfPoint)
      qed
    qed
  next 
    have b99:"toploc c' = toploc m'" using a3 a4 cpm2m_def[of p l x t cd c' ] cpm2mTopLocSame[of  p l t cd c' x mm'] b2 by simp
    then show "toploc mem' \<le> toploc m' " using aloc unfolding allocate_def by auto
  qed
next
  case (22 x t p x' t' wm wn wo s cd' mem''' sck'' ev'')
  then obtain l where a1:"l = ShowL\<^sub>n\<^sub>a\<^sub>t(toploc mem''')" by simp
  then have locationscd':"(\<forall>tloc loc. toploc mem''' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem''' = None)" 
    using assms(3) 22 unfolding TypeSafe_def lessThanTopLocs_def by simp
  then have b1:"accessStore l mem''' = None" using a1 using Read_Show_nat'_id using LSubPrefL2_def by auto
  have b2:"0 < x" using 22(8) a1 cps2mTypeCompatible.simps(2)[of x' t' x t]  
    by fastforce
  then have b3:"0 < x'" using 22(8) by (auto split:if_split_asm)
  have b4:"x = x'" using 22(8) by (auto split:if_split_asm)
  then have Mconcd:" SCon (STArray x' t') (extractValueType v) (storage st (address ev))" using assms(2) 22(2) 22(4) 22(5) by simp
  then have MConcd2:" SCon (STArray x' t') p s" using 22 by simp
  obtain c' where a2:"\<exists>dud. (dud, c') = allocate mem'''"  by (simp add: allocate_def)
  then have aloc:"snd (allocate mem''') = c'" by (simp add: allocate_def)
  then have lNotInC':"accessStore l c' = None" using b1 a1 unfolding allocate_def accessStore_def by auto
  obtain mm' where a3:"cps2m p l x' t' s c' = Some mm'" using 22 a1 a2 assms 
    using b2 aloc b3 by (metis (no_types, lifting) bind_eq_Some_conv option.discI)
  have NoneIp:"denvalue ev'' $$ ip = None" using 22(8) by (auto split:if_split_asm)
  then have a4:"Some (c, m', k', e) = Some (cd', mm', astack_dup ip (Memory (MTArray x t)) (KMemptr l) (sck'', ev''))" 
    using a1 a2 a3 22 assms decl.simps(9) b2 aloc b3 NoneIp 
    by (metis bind.bind_lunit not_None_eq)
  then have a4:"Some (c, m', k', e) = Some (cd', mm', astack_dup ip (Memory (MTArray x t)) (KMemptr l) (sck', ev''))"
    using 22(7) by simp
  then have a20:"k' = push (KMemptr l) sck'" using 22(7) NoneIp by force
  have a30:"e = (updateEnv ip (Memory (MTArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev'')" using a4 NoneIp by simp
  then have a40:"denvalue e = denvalue(ev'' \<lparr> denvalue := fmupd ip (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) (denvalue ev'') \<rparr>)" by simp
  then have a50:"(denvalue e) $$ ip = Some (Memory (MTArray x t),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp

  have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 22(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 22(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                    \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
    using a40 lessThanTopLocs_def fmranI by auto
  have cps2mTypeComp:"cps2mTypeCompatible (STArray x' t') (MTArray x t)" using 22(8) a1 by (meson option.discI)
  have a110:"m' = mm'" using a4 by simp

  then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
    using a3 a1 cps2m_def[of p l x' t' " s" c'] cps2mSingleChange[of p l t' "s" c' x' mm'] by fastforce
  have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
  have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
  then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
    using b100 a2 unfolding allocate_def by simp
  then have subMapping:"mapping mem' \<subseteq>\<^sub>f mapping mm'" using b105 22(7)  unfolding fmsubset_alt_def 
    by (smt (verit, ccfv_SIG) Pair_inject accessStore_def fmpred_iff option.distinct(1))
  have mcTop1:"MCon (MTArray x t) mm' l" using a3 unfolding cpm2m_def 
              using cps2m[of p l t' "s" c' x' mm' ] b3 Mconcd 22(2) b2 
                cps2m_def[of p l x' t' "s" c'] b4 extractValueType.simps(4) "22"(6) 22(7)  
              using MConcd2 cps2mTypeComp lNotInC' by presburger
  then have mcTop2:"MCon (MTArray x t) m' l" using a4 a110 22(7) by blast
  show ?thesis unfolding TypeSafe_def
  proof(intros)

    show "unique_locations (denvalue e)" using assms(3) 22(7) updateEnvUniqueLocs a4 NoneIp astack_dup_is_astack by fastforce
  next
    have b2: "compPointers sck'  (denvalue ev'')" using assms(3) 22(7) unfolding TypeSafe_def by auto
    have "address ev'' = address e"using a30 by simp
    moreover have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 22(7) by simp
    ultimately show "compPointers k' (denvalue e)"
      using compPointersNonStackUpd[of sck'  ev'' e ip " Memory (MTArray x t)" k' "KMemptr l"] 
        a40 a50 assms(3) 22(7) b2 a20 by simp
  next
    show "safeContract (storage st)" using assms(1) TypeSafe_def by simp
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using a30 22(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 22(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe a20 22(7) by metis
  next
    have "addressFormat (address ev'')" using assms(3) TypeSafe_def 22(7) by simp
    then show "addressFormat(address e)" using 22(7) a4 NoneIp  by auto
  next
    have "addressFormat  (sender ev'')" using assms(3) TypeSafe_def 22(7) by simp
    then show "addressFormat (sender e)" using 22(7) a4 NoneIp  by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c" unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev'')) = (storage st (address e))" using a30 by simp

      show "case lDen of
               Stackloc loc \<Rightarrow>
                 (case accessStore loc k' of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                  | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                  | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                  | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
               | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = KMemptr l " using a170 True by simp
            have a190:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KMemptr l)" using a20 by (simp add:push_def allocate_def updateStore_def accessStore_def)
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have a200:"tDen = Memory (MTArray x t)" using a90 a50 by simp
            have a220:"v = KStoptr p" using 22(2) by simp
            have a230:"cps2mTypeCompatible (STArray x' t') (MTArray x t)" using 22(8) a1 by (meson option.discI)
            have "c = cd'" using a4 by simp
            moreover have " (\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" 
              by (simp add: lNotInC')
            ultimately have "MCon (MTArray x t) mm' l" using a3 unfolding cpm2m_def 
              using cps2m[of p l t' "s" c' x' mm' ] b3 Mconcd 22(2) b2 
                cps2m_def[of p l x' t' "s" c'] b4 extractValueType.simps(4) "22"(6) 22(7) a100 by (metis a220 a230)
            then have "MCon (MTArray x t) m' l" using a4 a110 22(7) by blast
            then show ?thesis using Stackloc some a180 a200 extractValueType.simps(4) 22(2) by simp
          qed
        next
          case False
          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cps2m_def[of p l x' t' " s" c'] cps2mSingleChange[of p l t' "s" c' x' mm'] by fastforce

          have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
            using b100 a2 unfolding allocate_def by simp

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc False by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Stackloc fmranI a90 False * by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 22 by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" 
            using a20 False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis 
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis 
            proof(cases a)
              case (KValue x1)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 22(7) by (cases tDen; fastforce)
            next
              case (KCDptr x2)
              then have b10:"(case tDen of Calldata struct \<Rightarrow> MCon struct cd' x2 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 22(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Calldata struct" by (auto split:Type.splits) 
              then have "MCon struct cd' x2" using b10 by simp
              then show ?thesis using Stackloc some KCDptr tden a110 a4 by simp
            next
              case (KMemptr x3)
              then have b10:"(case tDen of Memory struct \<Rightarrow> MCon struct mem' x3 | _ \<Rightarrow> False)" 
                using some a170 Stackloc a190 using assms(3) 22(7) unfolding TypeSafe_def typeCompat_def by force
              then obtain struct where tden: "tDen = Memory struct" by (auto split:Type.splits) 
              then have "MCon struct mem''' x3" using b10 22 by simp
              then have "MCon struct mm' x3" using mconCopySingle[of l mem''' mm' struct] b110 b105 by auto
              then show ?thesis using Stackloc some KMemptr tden a110 a4 by simp
            next
              case (KStoptr x4)
              then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def
                using a190 some Stackloc a170 * a180 a110 a100 22(7) by (cases tDen; fastforce)
            qed
          qed 
        qed
      next
        case (Storeloc x2)
        then have "ip'' \<noteq> ip" using a160 a90 by simp
        then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev'')" using a40 Storeloc fmranI a90 * by fastforce
        then have a180:"(case tDen of Storage typ \<Rightarrow> SCon typ x2 (storage st (address ev'')) | _ \<Rightarrow> False)"  
          using a170 Storeloc using assms(3) 22(7) 
          unfolding TypeSafe_def typeCompat_def by force
        then obtain typ' where tdent:"tDen =  Storage typ'"  by (auto split: Type.splits)
        then have "SCon typ' x2 (storage st (address ev''))" using a180 by simp
        then have "SCon typ' x2 (storage st (address e))" using a100 by simp
        then show ?thesis  using  a170 Storeloc using assms(3) 22(7) tdent 
          by simp
      qed
    qed
  next 
    show "lessThanTopLocs c" using assms(3) 22(7) a4 unfolding TypeSafe_def by auto
  next 
    have b100:"lessThanTopLocs mem'''" using assms(3) 22(7) unfolding TypeSafe_def by blast
    have b99:"toploc c' = toploc m'" using a3 a4 cps2m_def[of p l x' t' "s" c'] cps2mTopLocSame[of  p l t' "s" c' x' mm'] b3 by simp
    have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs m'" 
      using cps2mSingleChange[of p l t' "s" c' x' mm'] a4 a3 cps2m_def[of p l x' t' "s" c'] by fastforce
    moreover have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem''']  22 by auto
    ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs m' = accessStore locs mem'''" by simp
    show "lessThanTopLocs m'" using cdMemLocsToploc[of mem''' l c' m'] b100 a1 a2 b99 using b10   by presburger
  next 
    have selfPoint:"\<forall>la l'. TypedStoSubPref la l (STArray x' t') \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
      using cps2mSelfPointers[of p l t' "s" c' x' mm'] a3 a1 cps2m_def by metis
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def
    proof(intros)
      fix tp1 tp2 l1 l2 stl1 stl2 dloc1 
      assume c10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 22(7) by simp
      then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
        using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
      then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
        using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 22(7) by fastforce
      then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
        using a40 lessThanTopLocs_def fmranI by auto
      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') 
                      \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using a40 lessThanTopLocs_def fmranI by auto

      show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                      else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1
                                  
                            else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
      proof(cases "l1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case t1:True
        then have b10:"tp1 = (MTArray x t)" using a150 c10 a50 by fastforce
        have b15:"stl1 = l"  using a20 c10 t1 unfolding push_def updateStore_def accessStore_def allocate_def by auto
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 by fastforce
          then show ?thesis using c10 b10 b20 t1 True TypedMemSubPrefPtrs.simps a20 unfolding push_def updateStore_def accessStore_def by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" using "22"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
          have " accessStore l2 k' = accessStore l2 sck'" using a20 c10 False a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp2 mem''' stl2" using 22(7) assms(3) c10 b20 unfolding TypeSafe_def  
            by (metis Pair_inject assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl1 \<longrightarrow> accessStore locs mem''' = accessStore locs m'" 
            using a3 a1 cps2m_def cps2mSingleChange[of p l t' "s" c' x' mm']  a2  b15 a4 unfolding allocate_def  by fastforce
          then have "\<forall>locs tp. MCon tp mem''' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem''' mm' ] using b105 b15 a4 by blast

          then have b23:"MCon tp2 m' stl2" using b22  a4 22 by blast

          have b30:"\<not>(LSubPrefL2 stl2 l)" using b15 b20 False 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp2 mem''' stl2\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl2 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl2))" using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'''"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'''"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedStoSubPref la l (STArray x' t') \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b10 b15 a4 by blast
          have "(\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" 
            by (simp add: lNotInC')
          then have b70:" MCon tp1 m' stl1"
            using cps2m[of p l t' "s" c' x' mm' t] a3 a1 cps2m_def MConcd2 cps2mTypeComp b4 b3 b10 b15 a110 by simp
          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl2 stl1)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl1. \<not>(LSubPrefL2 stl1 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl1 \<longrightarrow> accessStore loc mem''' = None" using b105 b15 by auto
          have "case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray x t) stl2 stl1
             else if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' x t dt stl1 dloc1 
                               else True
          | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' x t stl1 stl2 then CompMemType m' x t (MTValue val2) stl1 stl2 else True
         " 
          proof(cases tp2)
            case (MTArray x11 x12)
            then have b130:"MCon (MTArray x11 x12) m' stl2" using b23 by auto
            have b140:"MCon (MTArray x11 x12) mem''' stl2" using b22 MTArray by simp
            have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using b130 b100 b120 b90 b140 b27 cpm2mNotSubPrefsOfOriginal by auto
            moreover have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cps2mNotSubPrefsOfChanged[of x t m' stl1 stl2] b70 b10 cps2mTypeComp b15 by blast
            moreover have "\<not>(TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x t stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2 
                using b10 b2 b60 b70 b15 CompMemType_imps_TypedMemSubPrefPtrs  
                using cps2mNotSubPrefsOfChanged cps2mTypeComp by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 dloc1" using b30  b130  b120  b140 b27 b15 b45 cpm2mLocationRelatedToTopNotInOrig c10
                by (metis)
              then show False using c10 by simp 
            qed
            ultimately show ?thesis using MTArray by auto
          next
            case (MTValue x2)
            have "MCon (MTArray x t) m' stl1" using b70 by (simp add: b10)           
            then have "\<not>TypedMemSubPrefPtrs m' x t stl1 stl2" using b90 b60 b2 cps2mNotSubPrefsOfChanged b10 cps2mTypeComp b15 by blast
            then show ?thesis using MTValue by simp
          qed
          then show ?thesis using b80 b10 by simp
        qed
      next
        case f1:False
        then have b10:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'')" using "22"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
        then show ?thesis
        proof(cases "l2 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have b15:"stl2 = l"  using a20 c10  unfolding push_def updateStore_def accessStore_def allocate_def by auto

          then have b20:"tp2 = (MTArray x t)" using a150 c10 a50 True by fastforce
          have " accessStore l1 k' = accessStore l1 sck'" using a20 c10 f1 a130 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          then have b22:"MCon tp1 mem''' stl1" using 22(7) assms(3) c10 b20 b10 unfolding TypeSafe_def  
            by (metis Pair_inject assms(3) sameMemTSafe)
          have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
          then have b27:"\<forall>locs. \<not> LSubPrefL2 locs stl2 \<longrightarrow> accessStore locs mem''' = accessStore locs m'" 
            using a3 a1 cps2m_def cps2mSingleChange[of p l t' "s" c' x' mm']    a2 a4 b15 unfolding allocate_def by fastforce
          then have "\<forall>locs tp. MCon tp mem''' locs \<longrightarrow> MCon tp m' locs" using mconCopySingle[of l mem''' mm' ] using b105 a4 b15 by simp

          then have b23:"MCon tp1 m' stl1" using b22 by (simp add: a4)

          have b30:"\<not>(LSubPrefL2 stl1 l)" using b15 b20 f1 
            by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem''' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          then have b40:"stl1 \<noteq> l" using LSubPrefL2_def by auto
          have "\<not>(\<exists>i. l = i + (STR ''.'' + stl1))" using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'''"] subPrefCannotBeInt by simp
          then have b45:"\<forall>l' \<noteq> l. \<not>(LSubPrefL2 l l')"  using a1  unfolding hash_def using ShowLNatDot[of "toploc mem'''"] subPrefCannotBeInt
            by (simp add: LSubPrefL2_def hash_def)
          have b60:" \<forall>la l'. TypedStoSubPref la stl2 (STArray x' t') \<and> accessStore la m' = Some (MPointer l') \<longrightarrow> l' = la" using selfPoint using b10 b15 a4 by blast
          have b65:"(\<exists>p. accessStore l c' = Some (MPointer p)) \<or> accessStore l c' = None" by (simp add: lNotInC')
          then have b70:" MCon tp2 m' stl2" 
            using cps2m[of p l t' "s" c' x' mm']  a3 a1 cps2m_def 22(2) MConcd2 cps2mTypeComp b4 b3 b10 b15 a110 
            by (metis b20)

          have b80:"stl1 \<noteq> stl2" using b40 b15 by auto
          have b90:"\<not>(LSubPrefL2 stl1 stl2)" using b15 b30 by auto
          have b100:"\<forall>l' \<noteq> stl2. \<not>(LSubPrefL2 stl2 l')" using b45 b15 by auto
          have b120:" \<forall>loc. LSubPrefL2 loc stl2 \<longrightarrow> accessStore loc mem''' = None" using b105 b15 by auto

          have " case tp1 of
         MTArray len arr \<Rightarrow>
           (case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs m' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType m' len arr dt stl1 dloc1 
                         else True
           | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
         | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
          proof(cases tp1)
            case (MTArray x11 x12)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cps2mNotSubPrefsOfChanged  b2 b20 b60 b70  
              using cps2mTypeComp by blast
            moreover have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using b100 b23 b80 b27 b90 b22 b120 cpm2mNotSubPrefsOfOriginal MTArray by auto
            moreover have "\<not>(TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1)"
            proof
              assume c10:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x t stl2 dloc1"
              then have "LSubPrefL2 dloc1 l" using TypedMemSubPrefPtrsChanged_imps_MemLSubPrefL2[of  x t m' stl2]  b15 a1 b60 b20 b70   
                using cps2mNotSubPrefsOfChanged cps2mTypeComp
                using CompMemType_imps_TypedMemSubPrefPtrs b2 by blast
              then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1" using cpm2mLocationRelatedToTopNotInOrig b100 b23 b80 b27 b90 b22 b120 
                using MTArray b15 by (metis)
              then show False using c10 by simp 
            qed
            ultimately show ?thesis using MTArray 
              using b20 by auto

          next
            case (MTValue x2)
            have "\<not>TypedMemSubPrefPtrs m' x t stl2 stl1" using b90 cps2mNotSubPrefsOfChanged  b2 b20 b60 b70 using cps2mTypeComp by blast
            then have "if TypedMemSubPrefPtrs m' x t stl2 stl1 then CompMemType m' x t (MTValue x2) stl2 stl1 else True" by simp
            then show ?thesis using b20 
              by (simp add: MTValue)
          qed
          then show ?thesis 
            using CompMemType_imps_TypedMemSubPrefPtrs using b80 b20 by auto
        next
          case False
          then have b20:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'')" using "22"(7) Denvalue.inject(1) a160 assms(4) c10 decl_env_not_i fmlookup_ran_iff by fastforce
          have b30:"accessStore l2 k' = accessStore l2 sck'" using a20 False unfolding push_def updateStore_def accessStore_def allocate_def by auto
          have b40:" accessStore l1 k' = accessStore l1 sck'" using b20 b10 a20 c10 False a130 f1 unfolding push_def updateStore_def accessStore_def allocate_def by auto
          have b50:"MCon tp1 mem''' stl1" using 22(7)  c10 b10 b40 unfolding TypeSafe_def
            by (metis Pair_inject assms(3) sameMemTSafe)
          have b60:"\<not>(LSubPrefL2 stl1 l)" by (metis MCon_imps_Some LSubPrefL2_def \<open>MCon tp1 mem''' stl1\<close> b105 Not_Sub_More_Specific option.distinct(1))
          have b50b:"MCon tp2 mem''' stl2" using 22(7) c10 b20 b30 unfolding TypeSafe_def
            by (metis Pair_inject assms(3) sameMemTSafe)
          then have b60b:"\<not> LSubPrefL2 stl2 l " by (metis MCon_imps_Some LSubPrefL2_def  b105 Not_Sub_More_Specific option.distinct(1))

          then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
            using a3 a1 cps2m_def cps2mSingleChange[of p l t' "s" c' x' mm']  by fastforce

          have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
          then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs m'" 
            using b100 a2 22 a4 unfolding allocate_def by force

          have "(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev'') \<and>
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev'') \<and> accessStore l1 sck' = Some (KMemptr stl1) \<and> accessStore l2 sck' = Some (KMemptr stl2)" 
            using b10 assms(3) 22(7) c10 b30 b40 b20 b30 by simp
          then have c1:"(if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs mem''' len2 arr2 stl2 stl1 then CompMemType mem''' len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs mem''' len arr stl1 stl2 then CompMemType mem''' len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs mem''' len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs mem''' len2 arr2 stl2 dloc1
                       then \<exists>dt.
                               CompMemType mem''' len2 arr2 dt stl2 dloc1 \<and>
                               CompMemType mem''' len arr dt stl1 dloc1 
                       else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs mem''' len arr stl1 stl2 then CompMemType mem''' len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs mem''' len2 arr2 stl2 stl1 then CompMemType mem''' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True))" 
            using b10 assms(3) 22(7) c10 b30 b40 b20 b30 unfolding TypeSafe_def compMemPtrs_def by blast
          show ?thesis 
          proof(cases "stl1 = stl2")
            case True
            then show ?thesis using c1 by simp
          next
            case f1:False
            then show ?thesis 
            proof(cases tp1)
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases tp2)
                case mta:(MTArray x11' x12')
                have "if TypedMemSubPrefPtrs m' x11' x12' stl2 stl1 then CompMemType m' x11' x12' tp1 stl2 stl1
                  else if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 
                    else if TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1
                       then \<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt stl1 dloc1 
                else True"
                proof(cases "TypedMemSubPrefPtrs mem''' x11' x12' stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray mta by simp
                  then have " CompMemType mem''' x11' x12' tp1 stl2 stl1" using c1 f1 mta MTArray  True by simp
                  then have " CompMemType m' x11' x12' tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis using c1 f1 mta MTArray  True  
                    using \<open>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1\<close> by auto
                next
                  case False
                  then have b40:"\<not>TypedMemSubPrefPtrs m' x11' x12' stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b mta by blast
                  then show ?thesis
                  proof(cases " TypedMemSubPrefPtrs mem''' x11 x12 stl1 stl2")
                    case t2:True
                    then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                      using MTArray mta b50 by blast
                    then have " CompMemType mem''' x11 x12 (MTArray x11' x12') stl1 stl2" using c1 f1 mta MTArray  t2  False MTypes.simps(5) b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref
                      by (smt (verit, best))
                    then show ?thesis using c1 f1 mta MTArray
                      using b105 b110 b40 b50 b60 cpm2mCompMemTypeOld_imps_CompMemType  
                      using t2  
                      using \<open>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2\<close> by presburger
                  next
                    case f2:False
                    then show ?thesis
                    proof(cases "TypedMemSubPrefPtrs mem''' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs mem''' x11' x12' stl2 dloc1")
                      case True
                      then have d10:"TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1"
                        using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b b50 b60 using MTArray mta
                        using cpm2mCompMemTypeOld_imps_CompMemType by blast
                      have d20:"\<exists>dt.
                               CompMemType mem''' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType mem''' x11 x12 dt stl1 dloc1 "
                        using True c1 f2 f1 False MTArray mta by simp
                      then have "\<not> LSubPrefL2 dloc1 l" 
                        by (metis CompTypeRemainsMCon MCon_imps_Some MTArray LSubPrefL2_def a1 b50 hash_suffixes_associative le_refl locationscd' option.distinct(1))
                      then have "\<exists>dt.
                               CompMemType m' x11' x12' dt stl2 dloc1 \<and>
                               CompMemType m' x11 x12 dt stl1 dloc1" 
                        using MTArray b105 b110 b50 b50b b60 b60b cpm2mCompMemTypeOld_imps_CompMemType mta d20 by (metis)
                      then show ?thesis using d10 b40 f2  
                        using MTArray b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref by presburger
                    next
                      case f3:False
                      then have "\<not>(TypedMemSubPrefPtrs m' x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs m' x11' x12' stl2 dloc1)" 
                        using inv_cpm2mTPrefOld_imps_TPref MTArray b105 b110 b50b b60b mta  b50 b60  
                        using inv_cpm2mCompMemTypeOld_imps_CompMemType by blast
                      then show ?thesis using False mta MTArray f1 f2 b40 f3
                        using b105 b110 b50 b60 inv_cpm2mTPrefOld_imps_TPref by metis
                    qed
                  qed
                qed
                then show ?thesis using mta MTArray f1 by auto
              next
                case mtv2:(MTValue x2)
                have " if TypedMemSubPrefPtrs m' x11 x12 stl1 stl2 then CompMemType m' x11 x12 tp2 stl1 stl2 else True" 
                proof(cases "TypedMemSubPrefPtrs mem''' x11 x12 stl1 stl2")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray b50 by blast
                  then have " CompMemType mem''' x11 x12 tp2 stl1 stl2" using c1 f1 mtv2 MTArray  True by auto
                  then have " CompMemType m' x11 x12 tp2 stl1 stl2" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis using c1 f1 mtv2 MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl1 stl2" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50 b60 by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTArray f1 mtv2  by auto
              qed
            next
              case (MTValue x2)
              then show ?thesis 
              proof(cases tp2)
                case (MTArray x11 x12)
                have "if TypedMemSubPrefPtrs m' x11 x12 stl2 stl1 then CompMemType m' x11 x12 tp1 stl2 stl1  else True" 
                proof(cases "TypedMemSubPrefPtrs mem''' x11 x12 stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using cpm2mTPrefOld_imps_TPref b105 b60 b110 b50b b60b 
                    using MTArray by blast
                  then have " CompMemType mem''' x11 x12 tp1 stl2 stl1" using c1 f1 MTValue MTArray  True by simp
                  then have " CompMemType m' x11 x12 tp1 stl2 stl1" using cpm2mCompMemTypeOld_imps_CompMemType 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis using c1 f1 MTValue MTArray  True 
                    by simp
                next
                  case False
                  then have "\<not>TypedMemSubPrefPtrs m' x11 x12 stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref 
                    using MTArray b105 b110 b50b b60b by blast
                  then show ?thesis by simp
                qed
                then show ?thesis using MTValue MTArray f1 by auto
              next
                case mtv2:(MTValue x2)
                then show ?thesis using MTValue f1 by simp
              qed
            qed
          qed
        qed
      qed
    qed
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next 
    fix locs tp assume ncp:"\<not>cp"
    have a110:"m' = mm'" using a4 by simp
    then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using a3 a1 cps2m_def[of p l x' t' s c'] cps2mSingleChange[of p l t' "s" c' x' mm'] by fastforce
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
    have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
    then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def by simp
    have a120:"\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs" using assms(5) 22(7) ncp  by simp
    moreover have "\<forall>locs tp. MCon tp mem''' locs \<longrightarrow> MCon tp mm' locs" using mconCopySingle[of l mem''' mm' ] using b110 b105 by simp
    moreover have "toploc c' > toploc mem'''" using a2 unfolding allocate_def by simp
    moreover have b99:"toploc c' = toploc mm'" using a1 a3 a4 cps2m_def[of p l x' t' s c'] cps2mTopLocSame[of p l t' "s" c' x' mm'] b2 by fastforce
    ultimately show "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) 22(7) a110 a120 ncp by blast
  next
    assume notCP:"\<not>cp"
    show "ncpDenvalueLimit e ev k' (stack st) (memory st)" unfolding ncpDenvalueLimit_def
    proof  intros
      fix tp' locs p''' i''
      assume asm:" (Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p''') \<and> i'' < toploc (memory st) \<and> LSubPrefL2 p''' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')"
      then obtain i where idef:"denvalue e $$ i = Some (Memory tp', Stackloc locs)" by blast

      have "ncpDenvalueLimit ev'' ev sck' (stack st) (memory st)" using 22 notCP assms(5) by blast
      then have old:"\<forall>tp' locs p i.
     (Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'') \<and> accessStore locs sck' = Some (KMemptr p)  \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow>
     (\<exists>tp'' loc2 p'.
         (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
         accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p)))" 
        unfolding ncpDenvalueLimit_def by blast
      show "\<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p''' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p''' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p'''))"
      proof(cases "locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
        case True
        have b50:"p''' = l" using a40 a20 push_def 
          by (metis Stackvalue.inject(3) True accessStore_def accessStore_updateStore allocateMapping asm old.prod.exhaust option.inject snd_eqD)
        then have " p''' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc mem'''))" using a1 by blast
        moreover have "toploc mem''' \<ge> toploc (memory st)" using 22 notCP assms(5) by blast
        ultimately show ?thesis using asm 
          by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general hash_inequality hash_suffixes_associative hashesIntSame le_antisym nat_less_le)
      next
        case False
        then have b5:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a20 a40 asm 
          by (metis)
        then have "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev'')"  using a40  a160 fmranI asm by fastforce
        moreover have "accessStore locs sck' = accessStore locs k'" using b5 a20 unfolding push_def accessStore_def updateStore_def allocate_def by auto
        ultimately show ?thesis using old asm by metis 
      qed
    qed
  next 
    assume ncp:"\<not>cp"
    show "ncpOMemInDMem (memory st) m'" unfolding ncpOMemInDMem_def
    proof intros
      fix i loc 
      assume c10:"i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
      then have " accessStore loc (memory st) = accessStore loc mem'''" using assms(5) 22(7) ncpOMemInDMem_def ncp by auto
      have " \<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs m'" 
        using cps2mSingleChange[of p l t' "s" c' x' mm'] a4 a3 cps2m_def[of p l x' t' s c'] by fastforce
      moreover have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
      ultimately have b10:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs m' = accessStore locs mem'''" by simp
      have b99:"toploc c' = toploc m'" using a3 a4 cps2m_def[of p l x' t' s c'] cps2mTopLocSame[of p l t' "s" c' x' mm'] b2 
        by fastforce
      have "toploc (memory st) \<le> toploc mem'''" using assms(5) c10 22(7) ncpOMemInDMem_def ncp by simp
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> l" using a1 assms(5) c10 b99 
        by (metis hashesIntSame leD)
      then show "accessStore loc (memory st) = accessStore loc m'" using c10 a1 b99 a2 cdMemLocsToploc[of mem''' l c' m']  
        using "22"(3) 
        by (metis LSubPrefL2_def \<open>accessStore loc (memory st) = accessStore loc mem'''\<close> b10 hash_suffixes_associative hashesInts)
    qed
  next
    assume notCP:"\<not>cp"
    have a110:"m' = mm'" using a4 by simp
    then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using a3 a1  cps2m_def[of p l x' t' s c'] cps2mSingleChange[of p l t' "s" c' x' mm'] by fastforce
    have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
    have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
    then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def by simp

    fix locs tp 
    have a120:"\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem''' locs" using assms(5) 22(7) notCP by simp
    moreover have "\<forall>locs tp. MCon tp mem''' locs \<longrightarrow> MCon tp mm' locs" using mconCopySingle[of l mem''' mm' ] using b110 b105 by simp
    moreover have b98:"toploc c' > toploc mem'''" using a2 unfolding allocate_def by simp
    moreover have b99:"toploc c' = toploc m'"  using a3 a4 cps2m_def[of p l x' t' s c'] cps2mTopLocSame[of p l t' "s" c' x' mm'] b2 by fastforce
    ultimately have "MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using 22 assms(5)  22(7) a110 a120 notCP by blast

    have selfPoint:"\<forall>la l'. TypedStoSubPref la l (STArray x' t') \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
      using cps2mSelfPointers[of p l t' "s" c' x' mm'] a3 a1  cps2m_def[of p l x' t' s c'] by argo

    have sameaccess:" \<forall>locs. locs \<noteq> l \<and> \<not> TypedStoSubPref locs l (STArray x' t') \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
      using cps2mSingleChange2[of p l t' "s" c' x' mm'] a3 a1 cps2m_def[of p l x' t' s c'] by fastforce
    then have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedStoSubPref locs l (STArray x' t') \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
      using b100 a2 unfolding allocate_def a2 accessAllocate[of c' mem'''] 
      by (simp add: \<open>\<forall>locations. accessStore locations c' = accessStore locations mem'''\<close>)

    have limitsOld:" ((\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None) \<and>
     (\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))"
      using assms(1) unfolding TypeSafe_def lessThanTopLocs_def using 22(7) by auto

    have limits:"((\<forall>tloc loc. toploc mem''' \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc mem''' = None) \<and>
                    (\<forall>loc y. accessStore loc mem''' = Some y \<longrightarrow> (\<exists>tloc<toploc mem'''. LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))))" 
      using assms(3) 22(7) unfolding TypeSafe_def lessThanTopLocs_def  by simp

    have old:"ncpElementsNoSubPref (memory st) mem''' \<and> ncpOMemInDMem (memory st) mem''' \<and> ncpNewSelfPoint (memory st) mem'''" using 22 notCP assms(5) by blast
    then have sameLocs:"(\<forall>i loc. i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<longrightarrow> accessStore loc (memory st) = accessStore loc mem''')" unfolding ncpOMemInDMem_def by blast
    have selfPointMem':"  (\<forall>i loc loc2. i < toploc mem''' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc mem''' = Some (MPointer loc2) \<longrightarrow> loc = loc2)" 
      using old unfolding ncpNewSelfPoint_def by blast
    then have old:"\<forall>i l1 t1 l2 t2 loc i2 loc2.
     i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc \<longrightarrow>
     \<not> TypedMemSubPrefPtrs mem''' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs mem''' l1 t1 loc loc2" using old unfolding ncpElementsNoSubPref_def by blast

    show "ncpElementsNoSubPref (memory st) m' " unfolding ncpElementsNoSubPref_def
    proof intros
      fix i l1 t1 l2 t2 loc i2 loc2
      assume c10:"i < toploc (memory st) \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> MCon (MTArray l1 t1) (memory st) loc"
      then have "accessStore loc (memory st) = accessStore loc mem'''"using sameLocs by auto
      have MConnew:"MCon (MTArray l1 t1) (memory st) loc" using c10 by blast
      have locdef:"i < toploc (memory st) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)" using c10 by simp

      then have inotl:"i < toploc  mem'''" using b99 22(7) assms(5) notCP b98 c10 by simp
      then have inotlString:"(ShowL\<^sub>n\<^sub>a\<^sub>t i) \<noteq> l" using a1 22(7)
        by (metis Read_Show_nat'_id linorder_neq_iff)
      have typeMemOld:"\<not> TypedMemSubPrefPtrs mem''' l2 t2 loc2 loc \<and> \<not> TypedMemSubPrefPtrs mem''' l1 t1 loc loc2" using old c10 MConnew by auto

      have "\<not> LSubPrefL2 loc l" using c10 inotlString
        by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general a1 hash_inequality hash_suffixes_associative)
      then have conc1:" \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2" using b105  b110  a110 MConnew a120 typeMemOld 
        using inv_cpm2mTPrefOld_imps_TPref by blast
      then have hashlimit:"\<forall>f. hash loc2 f \<noteq> loc" using c10 
        by (metis (no_types, opaque_lifting) MCon_imps_Some LSubPrefL2_def Not_Sub_More_Specific limitsOld not_Some_eq)

      have conc2:"\<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
      proof(cases " i2 < toploc mem'''")
        case True
        then have f2:" (\<forall>p loc2. i2 < toploc mem''' \<and> toploc (memory st) \<le> i2 \<and> LSubPrefL2 loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<and> accessStore loc2 mem''' = Some (MPointer p) \<longrightarrow> loc2 = p)" 
          using selfPointMem' c10 by blast
        have "(ShowL\<^sub>n\<^sub>a\<^sub>t i2) \<noteq>  (ShowL\<^sub>n\<^sub>a\<^sub>t i)" using c10 
          by (metis hashesIntSame leD)

        then have loc2NotSub:"\<not>LSubPrefL2 loc2 l" using a1 True 
          by (metis LSubPrefL2_def MemLSubPrefL2_specific_imps_general c10 hash_inequality hash_suffixes_associative hashesIntSame nat_neq_iff)
        show ?thesis 
        proof
          assume asm:"TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
          then show False using hashlimit f2 c10 b110 loc2NotSub
          proof(induction t2 arbitrary:loc2 l2)
            case (MTArray x1 t2)
            then obtain i''' l''' where  i'''def:"(i'''<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = Some (MPointer l''') \<and> (l''' = loc \<or> TypedMemSubPrefPtrs m' x1 t2 l''' loc))" 
              using TypedMemSubPrefPtrs.simps(2)[of m' l2 x1 t2 loc2 loc] by blast
            then have "LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) (ShowL\<^sub>n\<^sub>a\<^sub>t i2)" using MTArray(5) 
              by (metis LSubPrefL2_def Not_Sub_More_Specific)
            moreover have "\<not> LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) l" using MTArray(7) 
              using MemLSubPrefL2_specific_imps_general a1 by blast

            ultimately have l'''Exp:"l''' = (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i'''))" using MTArray(4,6) i'''def  
              by (metis True a110 c10)

            then show ?case 
            proof(cases "l''' = loc")
              case True
              then show ?thesis using MTArray(3) l'''Exp by simp
            next
              case False
              then have "TypedMemSubPrefPtrs m' x1 t2 l''' loc" using i'''def by simp
              then show ?thesis using MTArray.IH[of x1 l'''] l'''Exp MTArray(3) 
                using \<open>LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) (ShowL\<^sub>n\<^sub>a\<^sub>t i2)\<close> \<open>\<not> LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) l\<close> b110 c10 f2 hash_suffixes_associative by force
            qed
          next
            case (MTValue x)
            then have "(\<exists>i<l2. hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc)" using TypedMemSubPrefPtrs.simps(1)[of m' l2 x loc2 loc] by auto
            then show ?case using MTValue by simp
          qed
        qed
      next
        case False
        then show ?thesis 
        proof(cases "i2 = toploc mem'''")
          case True
          then have g1:"(ShowL\<^sub>n\<^sub>a\<^sub>t i2) = l" using a1 by blast
          show ?thesis
          proof
            assume asm:" TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
            then show False using hashlimit c10 b105 selfPoint sameaccess
            proof(induction t2 arbitrary:loc2 l2)
              case (MTArray x1 t2)
              then obtain iIn lIn where idef: " (iIn<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m' = Some (MPointer lIn) \<and> (lIn = loc \<or> TypedMemSubPrefPtrs m' x1 t2 lIn loc))" 
                using TypedMemSubPrefPtrs.simps(2)[of m' l2 x1 t2 loc2 loc] by blast
              have g2:"\<forall>i. (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> l" using g1 MTArray(4) LSubPrefL2_def 
                by (metis hash_inequality hash_suffixes_associative) 
              show ?case 
              proof(cases "TypedStoSubPref (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) l (STArray x' t')")
                case True
                then have g4:"lIn = (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn))" using MTArray idef 
                  using a110 by blast
                then show ?thesis 
                proof(cases "lIn = loc")
                  case True
                  then show ?thesis using g4 MTArray by blast
                next
                  case False
                  then have "TypedMemSubPrefPtrs m' x1 t2 lIn loc" using idef by simp
                  then show ?thesis 
                    by (smt (verit, ccfv_threshold) MTArray.IH LSubPrefL2_def True \<open>\<not> LSubPrefL2 loc l\<close> b105 c10 Not_Sub_More_Specific g1 g4 sameaccess selfPoint stoTypedPrefix_imp_SubPref)
                qed
              next
                case False
                then have " accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mem''' = accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mm'" using g2 MTArray by blast
                moreover have "LSubPrefL2 (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) l" using g1 MTArray LSubPrefL2_def 
                  by (metis hash_suffixes_associative)
                ultimately have "accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) mm' = None" using MTArray by metis
                then show ?thesis using idef 
                  by (simp add: a110)
              qed
            next
              case (MTValue x')
              then show ?case by auto
            qed
          qed
        next
          case f4:False
          then have "i2> toploc mem'''" using False by auto 
          then have loc2NotSub:"\<not>LSubPrefL2 loc2 l" using a1 c10 
            by (metis LSubPrefL2_def f4 hash_suffixes_associative hashesInts)
          show ?thesis 
          proof
            assume asm:"TypedMemSubPrefPtrs m' l2 t2 loc2 loc"
            show False
            proof(cases t2)
              case (MTArray x11 x12)
              then have h1:"(\<exists>i<l2. \<exists>l. accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m' = Some (MPointer l) \<and> (l = loc \<or> TypedMemSubPrefPtrs m' x11 x12 l loc))" 
                using TypedMemSubPrefPtrs.simps(2)[of m' l2 x11 x12 loc2 loc] asm by blast
              then obtain i''' l''' where i'''def:"i'''<l2 \<and> accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = Some (MPointer l''') \<and> (l''' = loc \<or> TypedMemSubPrefPtrs m' x11 x12 l''' loc)" by blast
              then have " accessStore (hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i''')) m' = None" using  loc2NotSub 
                by (metis False LSubPrefL2_def MemLSubPrefL2_specific_imps_general a1 a110 b110 c10 Not_Sub_More_Specific leI locationscd')
              then show ?thesis using i'''def by simp
            next
              case (MTValue x2)
              then have "(\<exists>i<l2. hash loc2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) = loc)" 
                using asm TypedMemSubPrefPtrs.simps(1)[of m' l2 x2 loc2 loc] by blast
              then show ?thesis using hashlimit by simp
            qed
          qed
        qed
      qed
      then show "\<not> TypedMemSubPrefPtrs m' l2 t2 loc2 loc" using inv_cpm2mTPrefOld_imps_TPref conc2 by blast
      show " \<not> TypedMemSubPrefPtrs m' l1 t1 loc loc2" using conc1 by simp
    qed
  next 
    assume ncp:"\<not>cp"
    have b99:"toploc c' = toploc m'" using a3 a4 cps2m_def[of p l x' t' s c'] cps2mTopLocSame[of p l t' "s" c' x' mm'] b2 by fastforce
    have "toploc (memory st) \<le> toploc mem'''" using assms(5) 22(7) ncp by simp
    moreover have "toploc c' > toploc mem'''" using a2 unfolding allocate_def by simp
    then show " toploc (memory st) \<le> toploc m' " using b99 ncp assms 22 by simp
  next
    assume notCP:"\<not>cp"
    show "ncpNewSelfPoint (memory st) m'" unfolding ncpNewSelfPoint_def
    proof intros
      fix i loc loc2
      assume asm:"i < toploc m' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc m' = Some (MPointer loc2)"
      have old:"(\<forall>i loc loc2. i < toploc mem''' \<and> toploc (memory st) \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc mem''' = Some (MPointer loc2) \<longrightarrow> loc = loc2)" 
        using assms(5) notCP 22(7) unfolding ncpNewSelfPoint_def by blast
      have b99:"toploc c' = toploc m'" using a3 a4 cps2m_def[of p l x' t' s c'] cps2mTopLocSame[of p l t' "s" c' x' mm'] b2 by fastforce

      have a110:"m' = mm'" using a4 by simp
      then have b100:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
        using a3 a1 cps2m_def cps2mSingleChange[of p l t' "s" c' x' mm'] by fastforce
      have b105:"\<forall>loc. LSubPrefL2 loc l \<longrightarrow> accessStore loc mem''' = None" using locationscd' a2 lNotInC' a1 by auto
      have "\<forall>locations. accessStore locations c' = accessStore locations mem'''" using a2 accessAllocate[of c' mem'''] by auto
      then have b110:"\<forall>locs. \<not> LSubPrefL2 locs l \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
        using b100 a2 unfolding allocate_def by simp

      have g1:"toploc c' = Suc (toploc mem''')" using a2 unfolding allocate_def by simp
      show "loc = loc2"
      proof(cases "i < toploc mem'''")
        case True
        then have "\<not> LSubPrefL2 loc l" using a1 LSubPrefL2_def 
          by (metis MemLSubPrefL2_specific_imps_general Read_Show_nat'_id asm hash_inequality hash_suffixes_associative less_not_refl)
        then show ?thesis using old asm b110 a1 True a110 by auto
      next
        case False
        then have iIsTop:"i = toploc mem'''" using asm g1 b99 by simp
        have selfPoint:" \<forall>la l'. TypedStoSubPref la l (STArray x' t') \<and> accessStore la mm' = Some (MPointer l') \<longrightarrow> l' = la" 
          using cps2mSelfPointers[of p l t' "s" c' x' mm'] a3 a1 cps2m_def by metis 

        have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedStoSubPref locs l (STArray x' t') \<longrightarrow> accessStore locs c' = accessStore locs mm'" 
          using cps2mSingleChange2[of p l t' "s" c' x' mm'] a3 a1 cps2m_def by fastforce
        then have sameaccess:"\<forall>locs. locs \<noteq> l \<and> \<not> TypedStoSubPref locs l (STArray x' t') \<longrightarrow> accessStore locs mem''' = accessStore locs mm'" 
          using b100 a2  allocate_def  accessAllocate[of c' mem''']  by simp
        then show ?thesis using asm iIsTop 
          by (metis a1 a110 a3 b105 cps2mAccessPrePost cps2m_def hash_inequality lNotInC' not_Some_eq selfPoint)
      qed
    qed
  next 
    have b99:"toploc c' = toploc m'" using a3 a4 cps2m_def[of p l x' t' "s" c'] cps2mTopLocSame[of  p l t' "s" c' x' mm'] b3 by simp
    then show "toploc mem' \<le> toploc m' " using aloc 22  unfolding allocate_def by auto
  qed
next
  case (23 v wr ws wt wu wv ww)
  then show ?thesis using assms(1) by simp
next
  case (24 va v ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (25 wq vc vb ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (26 v vc vb ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (27 v vc vb ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (28 wq vc v ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (29 wq vc v ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (30 wq vc v ws wt wu wv ww)
  then show ?thesis by simp
next
  case (31 wq vc va vd ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (32 wq vc va ws wt wu wv ww)
  then show ?thesis  by simp
next
  case (33 va v wt wu wv ww)
  then show ?thesis  by simp
next
  case (34 wq vc vb wt wu wv ww)
  then show ?thesis by simp
next
  case (35 v vc vb wt wu wv ww)
  then show ?thesis by simp
next
  case (36 v vc vb wt wu wv ww)
  then show ?thesis  by simp
next
  case (37 wq vc v wt wu wv ww)
  then show ?thesis  by simp
next
  case (38 wq vc v wt wu wv ww)
  then show ?thesis  by simp
next
  case (39 wq vc v wt wu wv ww)
  then show ?thesis  by simp
next
  case (40 wq vc va vd wt wu wv ww)
  then show ?thesis  by simp
next
  case (41 wq vc va wt wu wv ww)
  then show ?thesis by simp
next
  case (42 x t p wx wy wz xa xb cd' mem'' sck'' ev'')
  then have a10:"t'' = Storage (STArray x t)" using decl.simps(2) by (simp split:if_splits)
  have NoneIp:" denvalue ev'' $$ ip = None" using 42 by (simp split:if_splits)
  then have a40:"Some (c, m', k', e) = Some (cd', mem'', astack ip (Storage (STArray x t)) (KStoptr p) (sck', ev''))"
    using 42 decl.simps(2) a10 assms(1) by simp
  then have k'Def:"k' = push (KStoptr p) sck'" by force

  have eDef:"e = updateEnv ip (Storage (STArray x t)) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev''"using a40 unfolding astack.simps by blast
  then have eIP:"(denvalue e) $$ ip = Some  ((Storage (STArray x t)),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  have sameADD:"address ev' = address e"
    using assms(4) decl_env by blast

  have wxDef:"wx = Storage (STArray x t)" using 42(8) by (simp split:if_splits)

  have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 42(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 42(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using a40 lessThanTopLocs_def fmranI by auto

  obtain locO tpO pO where oldAccess:"(
         (Storage tpO, locO) |\<in>| fmran (denvalue ev') \<and>
         (case locO of
          Stackloc stloc \<Rightarrow>
            accessStore stloc sck' = Some (KStoptr pO) \<and> (tpO = (STArray x t) \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STArray x t) pO (extractValueType v))
          | Storeloc stloc \<Rightarrow> tpO = (STArray x t) \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tpO (STArray x t) stloc (extractValueType v)))" 
    using assms 42 wxDef by blast

  have compOld: " (\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
        (Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
        (Storage tp2, l2) |\<in>| fmran (denvalue ev') \<and>
        (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
        (l2 = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
    using assms(3) 42 unfolding TypeSafe_def compPointers_def by blast
  then have compOld':"(\<forall>tp1  l1  l1' l2' stl1 stl2.
        (Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
        (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
        (locO = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2) \<and> stl2 = pO \<or> locO = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tpO stl1 stl2 else if TypedStoSubpref stl1 stl2 tpO then CompStoType tpO tp1 stl2 stl1 else True))"
    using oldAccess by blast
  show ?thesis unfolding TypeSafe_def
  proof(intros)
    show "unique_locations (denvalue e)" using assms(3) 42(7) updateEnvUniqueLocs a40 by fastforce
  next
    have b2: "compPointers sck' (denvalue ev')" using assms(3) 42(7) unfolding TypeSafe_def by auto

    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 42(7) by simp
    show "compPointers k' (denvalue e)" unfolding compPointers_def
    proof intros
      fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
      assume in1:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
      then obtain i1 i2 where iDef:" denvalue e $$ i1 = Some (Storage tp1, l1) \<and> denvalue e$$ i2 = Some (Storage tp2, l2)" by blast

      consider (bothStacks) "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) 
                    \<and> l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2)"
        | (StackLoc1) "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<and> l2 = Storeloc stl2"
        | (StackLoc2) "l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<and> l1 = Storeloc stl1"
        | (StoreLocs) "l1 = Storeloc stl1 \<and> l2 = Storeloc stl2" using in1 by auto

      then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
      proof(cases)
        case bothStacks
        then show ?thesis 
        proof(cases "l1 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True  
          then have stl1IsP:"stl1 = p" using in1 k'Def assms 42 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i1 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp1 = STArray x t" using iDef eDef by auto
          then show ?thesis 
          proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have stl2IsP:"stl2 = p" using in1 k'Def assms 42 unfolding push_def allocate_def accessStore_def updateStore_def by auto
            have "i2 = ip" using iDef eDef a150 True by blast
            then have tp2IsStArray:"tp2 = STArray x t" using iDef eDef by auto
            then show ?thesis using stl2IsP tp2IsStArray tp1IsStArray stl1IsP by auto
          next
            case False
            then have acc2:"accessStore l2' k' = accessStore l2' sck'" 
              using k'Def bothStacks
              by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)
            then have i2NotIP:"i2 \<noteq> ip" using eDef iDef False by auto
            then have tp2InOld:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
              using fmranI iDef by fastforce
            have sameAcc2:" accessStore l2' sck' = Some (KStoptr stl2)" using acc2 in1 bothStacks by auto
            then show ?thesis 
            proof(cases locO)
              case (Stackloc x1)
              then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
              then have cc:"(tpO = STArray x t \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STArray x t) pO (extractValueType v))" 
                using compOld oldAccess using 42(7) Stackloc by simp
              have comps:"(if TypedStoSubpref pO stl2 tp2 then CompStoType tp2 tpO stl2 pO else 
                            if TypedStoSubpref stl2 pO tpO then CompStoType tpO tp2 pO stl2 else True)"
                using compOld' sameAcc2 bothStacks tp2InOld Stackloc 42(7) acc by blast
              then show ?thesis 
              proof(cases "v = KStoptr pO")
                case True
                then have "tpO = STArray x t" using cc True by simp
                then have sames:"stl1 = pO \<and> tp1 = tpO" using tp1IsStArray True 42 stl1IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis 
                    using comps sames 
                    by (metis CompStoType_sameLoc_sameType)
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames 
                        using False by force
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STArray x t) pO stl1" using stl1IsP cc 42 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                          typedStoSub_imps_negInv)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            next
              case (Storeloc x2)
              then have cc:"(tpO = STArray x t \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STArray x t) x2 (extractValueType v))" 
                using compOld oldAccess using 42(7)  by simp
              have comps:"(if TypedStoSubpref x2 stl2 tp2 then CompStoType tp2 tpO stl2 x2 else 
                            if TypedStoSubpref stl2 x2 tpO then CompStoType tpO tp2 x2 stl2 else True)"
                using compOld' sameAcc2 bothStacks tp2InOld Storeloc 42(7) by blast
              then show ?thesis 
              proof(cases "v = KStoptr x2")
                case True
                then have "tpO = STArray x t" using cc True by simp
                then have sames:"stl1 = x2\<and> tp1 = tpO" using tp1IsStArray True 42 stl1IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps sames 
                    by (metis CompStoType_sameLoc_sameType)
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames 
                        using False by presburger
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STArray x t) x2 stl1" using stl1IsP cc 42 by simp
                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                          typedStoSub_imps_negInv)                    
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            qed
          qed
        next
          case False
          then have acc1:"accessStore l1' k' = accessStore l1' sck'" 
            using k'Def bothStacks 
            by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)

          then have i1NotIp:"i1 \<noteq> ip" using False eDef iDef by auto
          then have In''1:"(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
            using fmranI iDef by fastforce
          then show ?thesis 
          proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have stl2IsP:"stl2 = p" using in1 k'Def assms 42 unfolding push_def allocate_def accessStore_def updateStore_def by auto
            have "i2 = ip" using iDef eDef a150 True by blast
            then have tp2IsStArray:"tp2 = STArray x t" using iDef eDef by auto
            have tp1InOld:"(Storage tp1, l1) |\<in>| fmran (denvalue ev')" using In''1 42(7) by blast
            then show ?thesis 
            proof(cases locO)
              case (Stackloc x1)
              then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
              then have cc:"(tpO = STArray x t \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STArray x t) pO (extractValueType v))" 
                using compOld oldAccess using 42(7) Stackloc by simp
              have comps:"(if TypedStoSubpref pO stl1 tp1 then CompStoType tp1 tpO stl1 pO else 
                            if TypedStoSubpref stl1 pO tpO then CompStoType tpO tp1 pO stl1 else True)"
                using compOld' acc1 in1 bothStacks tp1InOld Stackloc 42(7) acc by metis
              then show ?thesis 
              proof(cases "v = KStoptr pO")
                case True
                then have "tpO = STArray x t" using cc True by simp
                then have sames:"stl2 = pO \<and> tp2 = tpO" using tp2IsStArray True 42 stl2IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps sames by blast
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames by blast
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed

                qed

              next
                case False
                then have comps2:"CompStoType tpO (STArray x t) pO stl2" using stl2IsP cc 42 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp2IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp2IsStArray)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp2IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            next
              case (Storeloc x2)
              then have cc:"(tpO = STArray x t \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STArray x t) x2 (extractValueType v))" 
                using compOld oldAccess using 42(7)  by simp
              have comps:"(if TypedStoSubpref x2 stl1 tp1 then CompStoType tp1 tpO stl1 x2 else 
                            if TypedStoSubpref stl1 x2 tpO then CompStoType tpO tp1 x2 stl1 else True)"
                using compOld' acc1 in1 bothStacks tp1InOld Storeloc 42(7) by metis
              then show ?thesis 
              proof(cases "v = KStoptr x2")
                case True
                then have "tpO = STArray x t" using cc True by simp
                then have sames:"stl2 = x2\<and> tp2 = tpO" using tp2IsStArray True 42 stl2IsP in1 by blast
                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis 
                    using comps sames by blast
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames by blast
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STArray x t) x2 stl2" using stl2IsP cc 42 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp2IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp2IsStArray)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp2IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            qed
          next
            case f2:False
            then have acc2:"accessStore l2' k' = accessStore l2' sck'" 
              using k'Def bothStacks
              by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)
            then have i2NotIP:"i2 \<noteq> ip" using eDef iDef f2 by auto
            then have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
              using fmranI iDef by fastforce
            have "(Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
     (Storage tp2, l2) |\<in>| fmran (denvalue ev') \<and>
     (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1)) \<and>
     (l2 = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2))" using 42(7) In''2 In''1 bothStacks  acc1 acc2 in1 by auto
            then show ?thesis using b2 unfolding compPointers_def by blast
          qed
        qed
      next
        case StackLoc1
        then have "i2 \<noteq> ip" using iDef eDef by auto
        then have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef by fastforce
        then show ?thesis 
        proof(cases "l1 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have stl1IsP:"stl1 = p" using in1 k'Def assms 42 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i1 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp1 = STArray x t" using iDef eDef by auto
          then show ?thesis 
          proof(cases locO)
            case (Stackloc x1)
            then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
            then have cc:"(tpO = STArray x t \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STArray x t) pO (extractValueType v))" 
              using compOld oldAccess using 42(7) Stackloc by simp
            have comps:"(if TypedStoSubpref pO stl2 tp2 then CompStoType tp2 tpO stl2 pO else 
                            if TypedStoSubpref stl2 pO tpO then CompStoType tpO tp2 pO stl2 else True)"
              using compOld' In''2 Stackloc 42(7) acc StackLoc1 by blast
            then show ?thesis 
            proof(cases "v = KStoptr pO")
              case True
              then have "tpO = STArray x t" using cc True by simp
              then have sames:"stl1 = pO \<and> tp1 = tpO" using tp1IsStArray True 42 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis 
                  using comps sames 
                  by (metis CompStoType_sameLoc_sameType)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by force
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STArray x t) pO stl1" using stl1IsP cc 42 by simp
              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                        typedStoSub_imps_negInv)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          next
            case (Storeloc x2)
            then have cc:"(tpO = STArray x t \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STArray x t) x2 (extractValueType v))" 
              using compOld oldAccess using 42(7)  by simp
            have comps:"(if TypedStoSubpref x2 stl2 tp2 then CompStoType tp2 tpO stl2 x2 else 
                            if TypedStoSubpref stl2 x2 tpO then CompStoType tpO tp2 x2 stl2 else True)"
              using compOld' StackLoc1  In''2 Storeloc 42(7) by blast
            then show ?thesis 
            proof(cases "v = KStoptr x2")
              case True
              then have "tpO = STArray x t" using cc True by simp
              then have sames:"stl1 = x2\<and> tp1 = tpO" using tp1IsStArray True 42 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps sames 
                  by (metis CompStoType_sameLoc_sameType)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by presburger
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STArray x t) x2 stl1" using stl1IsP cc 42 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                        typedStoSub_imps_negInv)                    
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          qed
        next
          case False
          then have "i1 \<noteq> ip" using iDef eDef by auto
          then have "(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" 
            using eDef iDef fmranI by fastforce
          moreover have "accessStore l1' sck' = Some (KStoptr stl1)" 
            using StackLoc1 k'Def False unfolding push_def allocate_def accessStore_def updateStore_def by auto
          ultimately show ?thesis using compOld 42(7) StackLoc1 using In''2 by blast
        qed
      next
        case StackLoc2
        then have "i1 \<noteq> ip" using iDef eDef by auto
        then have In''2:"(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef by fastforce
        then show ?thesis 
        proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have stl1IsP:"stl2 = p" using in1 k'Def assms 42 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i2 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp2 = STArray x t" using iDef eDef by auto
          then show ?thesis 
          proof(cases locO)
            case (Stackloc x1)
            then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
            then have cc:"(tpO = STArray x t \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STArray x t) pO (extractValueType v))" 
              using compOld oldAccess using 42(7) Stackloc by simp
            have comps:"(if TypedStoSubpref pO stl1 tp1 then CompStoType tp1 tpO stl1 pO else 
                            if TypedStoSubpref stl1 pO tpO then CompStoType tpO tp1 pO stl1 else True)"
              using compOld' In''2 Stackloc 42(7) acc StackLoc2 by blast
            then show ?thesis 
            proof(cases "v = KStoptr pO")
              case True

              then have "tpO = STArray x t" using cc True by simp
              then have sames:"stl2 = pO \<and> tp2 = tpO" using tp1IsStArray True 42 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps sames by metis
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by force
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STArray x t) pO stl2" using stl1IsP cc 42 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          next
            case (Storeloc x2)
            then have cc:"(tpO = STArray x t \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STArray x t) x2 (extractValueType v))" 
              using compOld oldAccess using 42(7)  by simp
            have comps:"(if TypedStoSubpref x2 stl1 tp1 then CompStoType tp1 tpO stl1 x2 else 
                            if TypedStoSubpref stl1 x2 tpO then CompStoType tpO tp1 x2 stl1 else True)"
              using compOld' StackLoc2  In''2 Storeloc 42(7) by blast
            then show ?thesis 
            proof(cases "v = KStoptr x2")
              case True

              then have "tpO = STArray x t" using cc True by simp
              then have sames:"stl2 = x2\<and> tp2 = tpO" using tp1IsStArray True 42 stl1IsP in1 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps sames by metis
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames False by presburger
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STArray x t) x2 stl2" using stl1IsP cc 42 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          qed
        next
          case False
          then have "i2 \<noteq> ip" using iDef eDef by auto
          then have "(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" 
            using eDef iDef fmranI by fastforce
          moreover have "accessStore l2' sck' = Some (KStoptr stl2)" 
            using StackLoc2 k'Def False unfolding push_def allocate_def accessStore_def updateStore_def by auto
          ultimately show ?thesis using compOld 42(7) StackLoc2 using In''2 by blast
        qed
      next
        case StoreLocs
        then have "i1 \<noteq> ip" using iDef eDef by auto
        moreover have "(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef calculation by fastforce
        moreover have "i2 \<noteq> ip" using iDef eDef StoreLocs by auto
        moreover have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef calculation
          using fmranI iDef by fastforce
        ultimately show ?thesis using compOld StoreLocs 42(7) by blast
      qed
    qed
  next
    have *:"safeContract (storage st)" using assms(3) unfolding TypeSafe_def using 42(7) by auto
    have **:"address ev' = address e" using eDef 42(7) by simp
    have ***:"contract ev' = contract e" using eDef 42(7) by simp
    show "safeContract (storage st) " using * by auto
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using eDef 42(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 42(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe k'Def 42(7) by metis
  next
    have "lessThanTopLocs cd'" using assms(3) TypeSafe_def 42(7) by simp
    then show "lessThanTopLocs c" using stackPushToplocSafe 42(7) a40 by simp
  next
    have "lessThanTopLocs mem''" using assms(3) TypeSafe_def 42(7) by simp
    then show "lessThanTopLocs m'" using  42(7) a40 by simp
  next
    have "addressFormat (address ev')" using assms(3) TypeSafe_def 42(7) by simp
    then show "addressFormat(address e)" using 42(7) a40 by auto
  next
    have "addressFormat (sender ev')" using assms(3) TypeSafe_def 42(7) by simp
    then show "addressFormat (sender e)" using 42(7) a40 by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c " unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev')) = (storage st (address e))" using assms(3) eDef 
        using sameADD by presburger
      have a110:"m' = mem''" and a115:"cd' = c" using a40 by simp+

      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using eDef lessThanTopLocs_def fmranI by auto
      show "case lDen of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KStoptr p)" 
            using k'Def by (simp add:push_def allocate_def updateStore_def accessStore_def)

          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = (KStoptr p) " using a170 True by simp
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have "tDen = Storage (STArray x t)" using a90 eDef by simp
            moreover have "(\<forall>locs tp. SCon tp locs (storage st (address ev)) \<longrightarrow> SCon tp locs (storage st (address ev')))"
              using assms(8) 42 wxDef by simp
            moreover have "SCon (STArray x t) p (storage st (address e))"
              using assms(2) 42(2) wxDef calculation sameADD by simp
            ultimately show ?thesis using Stackloc some a180 by simp
          qed
        next
          case False

          then have "ip'' \<noteq> ip" using a160 a90 Stackloc by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using eDef Stackloc fmranI a90 False * 42(7) by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 42(7) by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" using k'Def False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
              using a190 some Stackloc a170 * a180 a110 a115 a100 42(7) by (cases a; cases tDen; force+)
          qed
        qed
      next
        case (Storeloc x2)
        then have a170:"ip'' \<noteq> ip" using eDef Storeloc a90 by auto
        then have a180: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using eDef 42(7) Storeloc fmranI a90 by fastforce 
        then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def using Storeloc a100 42(7) by (cases tDen;force)
      qed
    qed
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next
    have b2: "compMemPtrs sck' mem'' (denvalue ev')" using assms(3) 42(7) unfolding TypeSafe_def by auto
    have b5:"address ev' = address e"using sameADD by simp
    have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 42(7) by simp
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
    proof intros
      fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1 
      assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" by auto
      then have b40:"ip' \<noteq> ip" using eDef by auto
      then have b50:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev')" using eDef b30 fmranI 42(7) by fastforce

      then obtain ip'' where  b30:"denvalue(e) $$ ip'' = Some((Memory tp2, Stackloc l2))" using b20 by auto
      then have b40:"ip'' \<noteq> ip" using eDef by auto
      then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')" using eDef 42(7) b30 fmranI by fastforce

      have b70:"\<forall>l''. (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l'' \<longrightarrow> accessStore l'' k' = accessStore l'' sck'" 
        using k'Def unfolding push_def updateStore_def allocate_def accessStore_def by simp
      have b80:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KStoptr p)" using k'Def  unfolding push_def updateStore_def allocate_def accessStore_def by simp 
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l1" using b70 b80 b20 by auto
      then have b90:"accessStore l1 sck' = accessStore l1 k'" using b70 b80 b20 by simp

      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l2" using b70 b80 b20 by auto
      then have b95:"accessStore l2 sck' = accessStore l2 k'" using b70 b80 b20 by simp

      show "if stl1 = stl2 then tp1 = tp2
           else case tp1 of
                MTArray len arr \<Rightarrow>
                  (case tp2 of
                  MTArray len2 arr2 \<Rightarrow>
                    if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                    else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                      else if TypedMemSubPrefPtrs m' len arr stl1 dloc1\<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1
                                 
                    else True
                  | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
                | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
        using 42(7) a40 b2 b50 b60 b20 compMemPtrs_def b90 b95 by fastforce
    qed
  next 
    have a110:"m' = mem''" using a40 by simp
    then show "\<And>locs tp. \<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) 42(7) assms(5) by (simp)
  next
    assume "\<not> cp"
    then show "toploc (memory st) \<le> toploc m'"  using assms(5) 42(7)  a40 by blast
  next 
    assume notCP:"\<not>cp" 
    show "ncpDenvalueLimit e ev k' (stack st) (memory st) " 
      unfolding ncpDenvalueLimit_def
    proof intros
      fix tp' locs p'' i
      assume a120:" (Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p'') \<and> i < toploc (memory st) \<and> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)"

      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using eDef lessThanTopLocs_def fmranI by auto
      show " \<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p'' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p'' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p''))
          " 
      proof -
        obtain ip'' where ip''def:"(denvalue e) $$ ip'' = Some (Memory tp', Stackloc locs)" using a120 by blast
        then have a170:"ip'' \<noteq> ip" using eDef by auto
        then have a180: "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev')" using eDef 42(7)  fmranI ip''def  by fastforce
        have a190:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a160 a170 k'Def 
          using a150 ip''def by blast

        then obtain y' where  a200:"accessStore locs sck' = Some y' " using typeSafeAllStacklocsExist assms(3) 42(7) a180 by blast
        then have "accessStore locs k' = accessStore locs sck'" using k'Def a120 a190 unfolding push_def allocate_def updateStore_def accessStore_def by simp
        then show " \<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p'' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p'' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p''))" 
          using assms(5) 42(7) a120 a40 eDef k'Def a120 a180 notCP ncpDenvalueLimit_def
          by (metis)
      qed
    qed
  next
    assume notCP:"\<not>cp"
    then show "ncpOMemInDMem (memory st) m'" using a40 42(7) assms by simp
  next 
    assume notCP:"\<not>cp"
    then show "ncpElementsNoSubPref (memory st) m'" using a40 assms 42 by blast
  next
    assume notCP:"\<not>cp"
    then show "ncpNewSelfPoint (memory st) m'" using a40 assms 42 by blast
  next 
    show "toploc mem' \<le> toploc m' " using a40 42 by simp
  qed
next
  case (43 t t' p xc xd xe xf xg cd' mem'' sck'' ev'')
  then have a10:"t'' = Storage (STMap t t')" using decl.simps(2) by (simp split:if_splits)
  have NoneIp:" denvalue ev'' $$ ip = None" using 43 by (simp split:if_splits)
  then have a40:"Some (c, m', k', e) = Some (cd', mem'', astack ip (Storage (STMap t t')) (KStoptr p) (sck', ev''))"
    using 43 decl.simps(2) a10 assms(1) by simp
  then have k'Def:"k' = push (KStoptr p) sck'" by force

  have eDef:"e = updateEnv ip (Storage (STMap t t')) (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) ev''"using a40 unfolding astack.simps by blast
  then have eIP:"(denvalue e) $$ ip = Some  ((Storage (STMap t t')),(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" by simp
  have sameADD:"address ev' = address e"
    using assms(4) decl_env by blast

  have wxDef:"xc = Storage (STMap t t')" using 43(8) by (simp split:if_splits)

  have a120:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 43(7) by simp
  then have a130:"\<forall>v'''. accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) sck' \<noteq> Some v'''"
    using lessThanTopLocs_def Read_Show_nat'_id using LSubPrefL2_def by auto
  then have a140:"\<forall>x y. \<not>((denvalue ev'') $$ x = Some y \<and> (snd y) = (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))))" 
    using TypeSafe_def assms(3) typeSafeAllStacklocsExist fmranI 43(7) by fastforce
  then have a150: "\<forall>ip''' t'''. denvalue e $$ ip''' = Some  (t''',(Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')))) \<longrightarrow> ip''' = ip" 
    using a40 lessThanTopLocs_def fmranI by auto

  obtain locO tpO pO where oldAccess:"(
         (Storage tpO, locO) |\<in>| fmran (denvalue ev') \<and>
         (case locO of
          Stackloc stloc \<Rightarrow>
            accessStore stloc sck' = Some (KStoptr pO) \<and> (tpO = (STMap t t') \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STMap t t') pO (extractValueType v))
          | Storeloc stloc \<Rightarrow> tpO = (STMap t t') \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tpO (STMap t t') stloc (extractValueType v)))" 
    using assms 43 wxDef by blast

  have compOld: " (\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
        (Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
        (Storage tp2, l2) |\<in>| fmran (denvalue ev') \<and>
        (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
        (l2 = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
    using assms(3) 43 unfolding TypeSafe_def compPointers_def by blast
  then have compOld':"(\<forall>tp1  l1  l1' l2' stl1 stl2.
        (Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
        (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
        (locO = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2) \<and> stl2 = pO \<or> locO = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tpO stl1 stl2 else if TypedStoSubpref stl1 stl2 tpO then CompStoType tpO tp1 stl2 stl1 else True))"
    using oldAccess by blast
  show ?thesis unfolding TypeSafe_def
  proof(intros)
    show "unique_locations (denvalue e)" using assms(3) 43(7) updateEnvUniqueLocs a40 by fastforce
  next
    have b2: "compPointers sck' (denvalue ev')" using assms(3) 43(7) unfolding TypeSafe_def by auto

    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 43(7) by simp
    show "compPointers k' (denvalue e)" unfolding compPointers_def
    proof intros
      fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
      assume in1:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
      then obtain i1 i2 where iDef:" denvalue e $$ i1 = Some (Storage tp1, l1) \<and> denvalue e$$ i2 = Some (Storage tp2, l2)" by blast

      consider (bothStacks) "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) 
                    \<and> l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2)"
        | (StackLoc1) "l1 = Stackloc l1' \<and> accessStore l1' k' = Some (KStoptr stl1) \<and> l2 = Storeloc stl2"
        | (StackLoc2) "l2 = Stackloc l2' \<and> accessStore l2' k' = Some (KStoptr stl2) \<and> l1 = Storeloc stl1"
        | (StoreLocs) "l1 = Storeloc stl1 \<and> l2 = Storeloc stl2" using in1 by auto

      then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
      proof(cases)
        case bothStacks
        then show ?thesis 
        proof(cases "l1 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True  
          then have stl1IsP:"stl1 = p" using in1 k'Def assms 43 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i1 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp1 = STMap t t'" using iDef eDef by auto
          then show ?thesis 
          proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have stl2IsP:"stl2 = p" using in1 k'Def assms 43 unfolding push_def allocate_def accessStore_def updateStore_def by auto
            have "i2 = ip" using iDef eDef a150 True by blast
            then have tp2IsStArray:"tp2 = STMap t t'" using iDef eDef by auto
            then show ?thesis using stl2IsP tp2IsStArray tp1IsStArray stl1IsP by auto
          next
            case False
            then have acc2:"accessStore l2' k' = accessStore l2' sck'" 
              using k'Def bothStacks
              by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)
            then have i2NotIP:"i2 \<noteq> ip" using eDef iDef False by auto
            then have tp2InOld:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
              using fmranI iDef by fastforce
            have sameAcc2:" accessStore l2' sck' = Some (KStoptr stl2)" using acc2 in1 bothStacks by auto
            then show ?thesis 
            proof(cases locO)
              case (Stackloc x1)
              then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
              then have cc:"(tpO = STMap t t' \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STMap t t') pO (extractValueType v))" 
                using compOld oldAccess using 43(7) Stackloc by simp
              have comps:"(if TypedStoSubpref pO stl2 tp2 then CompStoType tp2 tpO stl2 pO else 
                            if TypedStoSubpref stl2 pO tpO then CompStoType tpO tp2 pO stl2 else True)"
                using compOld' sameAcc2 bothStacks tp2InOld Stackloc 43(7) acc by blast
              then show ?thesis 
              proof(cases "v = KStoptr pO")
                case True

                then have "tpO = STMap t t'" using cc True by simp
                then have sames:"stl1 = pO \<and> tp1 = tpO" using tp1IsStArray True 43 stl1IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis 
                    using comps sames 
                    by (metis CompStoType_sameLoc_sameType)
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames 
                        using False by force
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STMap t t') pO stl1" using stl1IsP cc 43 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                          typedStoSub_imps_negInv)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            next
              case (Storeloc x2)
              then have cc:"(tpO = STMap t t' \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STMap t t') x2 (extractValueType v))" 
                using compOld oldAccess using 43(7)  by simp
              have comps:"(if TypedStoSubpref x2 stl2 tp2 then CompStoType tp2 tpO stl2 x2 else 
                            if TypedStoSubpref stl2 x2 tpO then CompStoType tpO tp2 x2 stl2 else True)"
                using compOld' sameAcc2 bothStacks tp2InOld Storeloc 43(7) by blast
              then show ?thesis 
              proof(cases "v = KStoptr x2")
                case True

                then have "tpO = STMap t t'" using cc True by simp
                then have sames:"stl1 = x2\<and> tp1 = tpO" using tp1IsStArray True 43 stl1IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps sames 
                    by (metis CompStoType_sameLoc_sameType)
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames 
                        using False by presburger
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STMap t t') x2 stl1" using stl1IsP cc 43 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 

                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                          typedStoSub_imps_negInv)                    
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed

            qed
          qed
        next
          case False
          then have acc1:"accessStore l1' k' = accessStore l1' sck'" 
            using k'Def bothStacks 
            by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)

          then have i1NotIp:"i1 \<noteq> ip" using False eDef iDef by auto
          then have In''1:"(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
            using fmranI iDef by fastforce
          then show ?thesis 
          proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
            case True
            then have stl2IsP:"stl2 = p" using in1 k'Def assms 43 unfolding push_def allocate_def accessStore_def updateStore_def by auto
            have "i2 = ip" using iDef eDef a150 True by blast
            then have tp2IsStArray:"tp2 = STMap t t'" using iDef eDef by auto
            have tp1InOld:"(Storage tp1, l1) |\<in>| fmran (denvalue ev')" using In''1 43(7) by blast
            then show ?thesis 
            proof(cases locO)
              case (Stackloc x1)
              then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
              then have cc:"(tpO = STMap t t' \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STMap t t') pO (extractValueType v))" 
                using compOld oldAccess using 43(7) Stackloc by simp
              have comps:"(if TypedStoSubpref pO stl1 tp1 then CompStoType tp1 tpO stl1 pO else 
                            if TypedStoSubpref stl1 pO tpO then CompStoType tpO tp1 pO stl1 else True)"
                using compOld' acc1 in1 bothStacks tp1InOld Stackloc 43(7) acc by metis
              then show ?thesis 
              proof(cases "v = KStoptr pO")
                case True

                then have "tpO = STMap t t'" using cc True by simp
                then have sames:"stl2 = pO \<and> tp2 = tpO" using tp2IsStArray True 43 stl2IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis 
                    using comps sames by blast
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames by blast
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STMap t t') pO stl2" using stl2IsP cc 43 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp2IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp2IsStArray)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp2IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            next
              case (Storeloc x2)
              then have cc:"(tpO = STMap t t' \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STMap t t') x2 (extractValueType v))" 
                using compOld oldAccess using 43(7)  by simp
              have comps:"(if TypedStoSubpref x2 stl1 tp1 then CompStoType tp1 tpO stl1 x2 else 
                            if TypedStoSubpref stl1 x2 tpO then CompStoType tpO tp1 x2 stl1 else True)"
                using compOld' acc1 in1 bothStacks tp1InOld Storeloc 43(7) by metis
              then show ?thesis 
              proof(cases "v = KStoptr x2")
                case True
                then have "tpO = STMap t t'" using cc True by simp
                then have sames:"stl2 = x2\<and> tp2 = tpO" using tp2IsStArray True 43 stl2IsP in1 by blast

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis 
                    using comps sames by blast
                next
                  case notSame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                    then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                    then show ?thesis using True by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2")
                      case True
                      then show ?thesis using comps sames by blast
                    next
                      case f3:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              next
                case False
                then have comps2:"CompStoType tpO (STMap t t') x2 stl2" using stl2IsP cc 43 by simp

                then show ?thesis 
                proof(cases "stl1 = stl2")
                  case True
                  then show ?thesis using comps comps2 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp2IsStArray typedStoSub_imps_negInv)
                next
                  case notsame:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl2 stl1 tp1")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp2IsStArray)
                  next
                    case False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                      case True
                      then show ?thesis using comps comps2 notsame 
                        by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp2IsStArray)
                    next
                      case f2:False
                      then show ?thesis using False by auto
                    qed
                  qed
                qed
              qed
            qed
          next
            case f2:False
            then have acc2:"accessStore l2' k' = accessStore l2' sck'" 
              using k'Def bothStacks
              by (metis accessStore_def accessStore_non_changed allocateMapping k'Def push_def snd_conv surj_pair)
            then have i2NotIP:"i2 \<noteq> ip" using eDef iDef f2 by auto
            then have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
              using fmranI iDef by fastforce
            have "(Storage tp1, l1) |\<in>| fmran (denvalue ev') \<and>
     (Storage tp2, l2) |\<in>| fmran (denvalue ev') \<and>
     (l1 = Stackloc l1' \<and> accessStore l1' sck' = Some (KStoptr stl1)) \<and>
     (l2 = Stackloc l2' \<and> accessStore l2' sck' = Some (KStoptr stl2))" using 43(7) In''2 In''1 bothStacks  acc1 acc2 in1 by auto
            then show ?thesis using b2 unfolding compPointers_def by blast
          qed
        qed
      next
        case StackLoc1
        then have "i2 \<noteq> ip" using iDef eDef by auto
        then have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef by fastforce
        then show ?thesis 
        proof(cases "l1 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have stl1IsP:"stl1 = p" using in1 k'Def assms 43 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i1 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp1 = STMap t t'" using iDef eDef by auto
          then show ?thesis 
          proof(cases locO)
            case (Stackloc x1)
            then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
            then have cc:"(tpO = STMap t t' \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STMap t t') pO (extractValueType v))" 
              using compOld oldAccess using 43(7) Stackloc by simp
            have comps:"(if TypedStoSubpref pO stl2 tp2 then CompStoType tp2 tpO stl2 pO else 
                            if TypedStoSubpref stl2 pO tpO then CompStoType tpO tp2 pO stl2 else True)"
              using compOld' In''2 Stackloc 43(7) acc StackLoc1 by blast
            then show ?thesis 
            proof(cases "v = KStoptr pO")
              case True

              then have "tpO = STMap t t'" using cc True by simp
              then have sames:"stl1 = pO \<and> tp1 = tpO" using tp1IsStArray True 43 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis 
                  using comps sames 
                  by (metis CompStoType_sameLoc_sameType)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by force
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STMap t t') pO stl1" using stl1IsP cc 43 by simp
              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                        typedStoSub_imps_negInv)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          next
            case (Storeloc x2)
            then have cc:"(tpO = STMap t t' \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STMap t t') x2 (extractValueType v))" 
              using compOld oldAccess using 43(7)  by simp
            have comps:"(if TypedStoSubpref x2 stl2 tp2 then CompStoType tp2 tpO stl2 x2 else 
                            if TypedStoSubpref stl2 x2 tpO then CompStoType tpO tp2 x2 stl2 else True)"
              using compOld' StackLoc1  In''2 Storeloc 43(7) by blast
            then show ?thesis 
            proof(cases "v = KStoptr x2")
              case True
              then have "tpO = STMap t t'" using cc True by simp
              then have sames:"stl1 = x2\<and> tp1 = tpO" using tp1IsStArray True 43 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps sames 
                  by (metis CompStoType_sameLoc_sameType)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by presburger
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STMap t t') x2 stl1" using stl1IsP cc 43 by simp
              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray
                        typedStoSub_imps_negInv)                    
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns False NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          qed
        next
          case False
          then have "i1 \<noteq> ip" using iDef eDef by auto
          then have "(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" 
            using eDef iDef fmranI by fastforce
          moreover have "accessStore l1' sck' = Some (KStoptr stl1)" 
            using StackLoc1 k'Def False unfolding push_def allocate_def accessStore_def updateStore_def by auto
          ultimately show ?thesis using compOld 43(7) StackLoc1 using In''2 by blast
        qed
      next
        case StackLoc2
        then have "i1 \<noteq> ip" using iDef eDef by auto
        then have In''2:"(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef by fastforce
        then show ?thesis 
        proof(cases "l2 = Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))")
          case True
          then have stl1IsP:"stl2 = p" using in1 k'Def assms 43 unfolding push_def allocate_def accessStore_def updateStore_def by auto
          have "i2 = ip" using iDef eDef a150 True by blast
          then have tp1IsStArray:"tp2 = STMap t t'" using iDef eDef by auto
          then show ?thesis 
          proof(cases locO)
            case (Stackloc x1)
            then have acc:"accessStore x1 sck' = Some (KStoptr pO)" using oldAccess by simp
            then have cc:"(tpO = STMap t t' \<and> v = KStoptr pO \<or> extractValueType v \<noteq> pO \<and> CompStoType tpO (STMap t t') pO (extractValueType v))" 
              using compOld oldAccess using 43(7) Stackloc by simp
            have comps:"(if TypedStoSubpref pO stl1 tp1 then CompStoType tp1 tpO stl1 pO else 
                            if TypedStoSubpref stl1 pO tpO then CompStoType tpO tp1 pO stl1 else True)"
              using compOld' In''2 Stackloc 43(7) acc StackLoc2 by blast
            then show ?thesis 
            proof(cases "v = KStoptr pO")
              case True

              then have "tpO = STMap t t'" using cc True by simp
              then have sames:"stl2 = pO \<and> tp2 = tpO" using tp1IsStArray True 43 stl1IsP in1 by blast

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis 
                  using comps sames 
                  by (metis)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by force
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            next
              case False
              then have comps2:"CompStoType tpO (STMap t t') pO stl2" using stl1IsP cc 43 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sharedSub tp1IsStArray)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          next
            case (Storeloc x2)
            then have cc:"(tpO = STMap t t' \<and> v = KStoptr x2 \<or> extractValueType v \<noteq> x2 \<and> CompStoType tpO (STMap t t') x2 (extractValueType v))" 
              using compOld oldAccess using 43(7)  by simp
            have comps:"(if TypedStoSubpref x2 stl1 tp1 then CompStoType tp1 tpO stl1 x2 else 
                            if TypedStoSubpref stl1 x2 tpO then CompStoType tpO tp1 x2 stl1 else True)"
              using compOld' StackLoc2  In''2 Storeloc 43(7) by blast
            then show ?thesis 
            proof(cases "v = KStoptr x2")
              case True
              then have "tpO = STMap t t'" using cc True by simp
              then have sames:"stl2 = x2\<and> tp2 = tpO" using tp1IsStArray True 43 stl1IsP in1 by simp

              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps sames 
                  by (metis)
              next
                case notSame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then have "\<not>TypedStoSubpref stl1 stl2 tp2" using typedStoSub_imps_negInv[OF notSame] by blast
                  then have "CompStoType tp1 tp2 stl1 stl2" using comps sames True by simp
                  then show ?thesis using True by simp
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2")
                    case True
                    then show ?thesis using comps sames 
                      using False by presburger
                  next
                    case f3:False
                    then show ?thesis using False by auto
                  qed
                qed

              qed

            next
              case False
              then have comps2:"CompStoType tpO (STMap t t') x2 stl2" using stl1IsP cc 43 by simp
              then show ?thesis 
              proof(cases "stl1 = stl2")
                case True
                then show ?thesis using comps comps2 
                  by (metis CompStoType_imps_TypedStoSubpref CompStoType_sameLocNdTyp CompStoType_sameLocs_sameType tp1IsStArray typedStoSub_imps_negInv)
              next
                case notsame:False
                then show ?thesis 
                proof(cases "TypedStoSubpref stl2 stl1 tp1")
                  case True
                  then show ?thesis using comps comps2 notsame 
                    by (metis CompStoType_imps_TypedStoSubpref CompStoType_sharedSub CompStoType_trns NotRelatedPrnt_imps_notRelatedChild tp1IsStArray)
                next
                  case False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref stl1 stl2 tp2 ")
                    case True
                    then show ?thesis using comps comps2 notsame 
                      by (metis CompStoType_sameLocNdTyp CompStoType_sharedSub CompStoType_trns NotReachablePrnt_imps_notReachableChild tp1IsStArray)
                  next
                    case f2:False
                    then show ?thesis using False by auto
                  qed
                qed
              qed
            qed
          qed
        next
          case False
          then have "i2 \<noteq> ip" using iDef eDef by auto
          then have "(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" 
            using eDef iDef fmranI by fastforce
          moreover have "accessStore l2' sck' = Some (KStoptr stl2)" 
            using StackLoc2 k'Def False unfolding push_def allocate_def accessStore_def updateStore_def by auto
          ultimately show ?thesis using compOld 43(7) StackLoc2 using In''2 by blast
        qed
      next
        case StoreLocs
        then have "i1 \<noteq> ip" using iDef eDef by auto
        moreover have "(Storage tp1, l1) |\<in>| fmran (denvalue ev'')" using eDef 
          using fmranI iDef calculation by fastforce
        moreover have "i2 \<noteq> ip" using iDef eDef StoreLocs by auto
        moreover have In''2:"(Storage tp2, l2) |\<in>| fmran (denvalue ev'')" using eDef calculation
          using fmranI iDef by fastforce
        ultimately show ?thesis using compOld StoreLocs 43(7) by blast
      qed
    qed
  next
    have *:"safeContract (storage st)" using assms(3) unfolding TypeSafe_def using 43(7) by auto
    have **:"address ev' = address e" using eDef 43(7) by simp
    have ***:"contract ev' = contract e" using eDef 43(7) by simp
    show "safeContract (storage st) " using * by auto
  next 
    show "methodVarsNoPref" using assms(1) TypeSafe_def by simp
  next
    show "balanceTypes (accounts st)" using assms(1) TypeSafe_def by simp
  next
    show "svalueTypes (svalue e)" using eDef 43(7) assms(3) TypeSafe_def svalueTypes_def by simp
  next
    have "lessThanTopLocs sck'" using assms(3) TypeSafe_def 43(7) by simp
    then show "lessThanTopLocs k'" using stackPushToplocSafe k'Def 43(7) by metis
  next
    have "lessThanTopLocs cd'" using assms(3) TypeSafe_def 43(7) by simp
    then show "lessThanTopLocs c" using stackPushToplocSafe 43(7) a40 by simp
  next
    have "lessThanTopLocs mem''" using assms(3) TypeSafe_def 43(7) by simp
    then show "lessThanTopLocs m'" using  43(7) a40 by simp
  next
    have "addressFormat (address ev')" using assms(3) TypeSafe_def 43(7) by simp
    then show "addressFormat(address e)" using 43(7) a40 by auto
  next
    have "addressFormat (sender ev')" using assms(3) TypeSafe_def 43(7) by simp
    then show "addressFormat (sender e)" using 43(7) a40 by auto
  next
    show "typeCompat (denvalue e) k' m' (storage st (address e)) c " unfolding typeCompat_def
    proof intros
      fix tDen lDen 
      assume *: "(tDen, lDen) |\<in>| fmran (denvalue e)"
      then obtain ip'' where a90:"denvalue e $$ ip'' = Some (tDen, lDen)" using * by auto
      then have a100:"(storage st (address ev')) = (storage st (address e))" using assms(3) eDef 
        using sameADD by presburger
      have a110:"m' = mem''" and a115:"cd' = c" using a40 by simp+

      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using eDef lessThanTopLocs_def fmranI by auto
      show "case lDen of
             Stackloc loc \<Rightarrow>
               (case accessStore loc k' of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tDen of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tDen of Calldata struct \<Rightarrow> MCon struct c stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tDen of Memory struct \<Rightarrow> MCon struct m' stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tDen of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tDen of Storage typ \<Rightarrow> SCon typ loc (storage st (address e)) | _ \<Rightarrow> False)"
      proof(cases lDen)
        case (Stackloc x1)
        then show ?thesis
        proof (cases "x1 = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')")
          case True
          then have a170: "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KStoptr p)" 
            using k'Def by (simp add:push_def allocate_def updateStore_def accessStore_def)

          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using True a170 Stackloc by simp
          next
            case some:(Some a)
            then have a180:"a = (KStoptr p) " using a170 True by simp
            then have "ip'' = ip" using a150 True a90 Stackloc by simp
            then have "tDen = Storage (STMap t t')" using a90 eDef by simp
            moreover have "(\<forall>locs tp. SCon tp locs (storage st (address ev)) \<longrightarrow> SCon tp locs (storage st (address ev')))"
              using assms(8) 43 wxDef by simp
            moreover have "SCon (STMap t t') p (storage st (address e))"
              using assms(2) 43(2) wxDef calculation sameADD by simp
            ultimately show ?thesis using Stackloc some a180 by simp
          qed
        next
          case False
          then have "ip'' \<noteq> ip" using a160 a90 Stackloc by simp
          then have a170: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using eDef Stackloc fmranI a90 False * 43(7) by fastforce
          then obtain y' where  a180:"accessStore x1 sck' = Some y' " using typeSafeAllStacklocsExist assms(3) Stackloc 43(7) by blast
          then have a190:"accessStore x1 k' = accessStore x1 sck'" using k'Def False by (simp add:push_def allocate_def updateStore_def accessStore_def) 
          then show ?thesis
          proof(cases "accessStore x1 k'")
            case None
            then show ?thesis using a180 a190 Stackloc by simp
          next
            case some:(Some a) 
            then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def 
              using a190 some Stackloc a170 * a180 a110 a115 a100 43(7) by (cases a; cases tDen; force+)
          qed
        qed
      next
        case (Storeloc x2)
        then have a170:"ip'' \<noteq> ip" using eDef Storeloc a90 by auto
        then have a180: "(tDen, lDen) |\<in>| fmran (denvalue ev')" using eDef 43(7) Storeloc fmranI a90 by fastforce 
        then show ?thesis using assms(3) unfolding TypeSafe_def typeCompat_def using Storeloc a100 43(7) by (cases tDen;force)
      qed
    qed
  next 
    show "AddressTypes (accounts st)" using assms(3) unfolding TypeSafe_def by simp
  next
    have b2: "compMemPtrs sck' mem'' (denvalue ev')" using assms(3) 43(7) unfolding TypeSafe_def by auto
    have b5:"address ev' = address e"using sameADD by simp
    have b10:"lessThanTopLocs sck'" using assms(3) TypeSafe_def 43(7) by simp
    show "compMemPtrs k' m' (denvalue e)" unfolding compMemPtrs_def 
    proof intros
      fix tp1 tp2 l1 l2 stl1 stl2 dtp1 dloc1 
      assume b20: " (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue e) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue e) \<and>
       accessStore l1 k' = Some (KMemptr stl1) \<and> accessStore l2 k' = Some (KMemptr stl2)"
      then obtain ip' where  b30:"denvalue(e) $$ ip' = Some((Memory tp1, Stackloc l1))" by auto
      then have b40:"ip' \<noteq> ip" using eDef by auto
      then have b50:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue ev')" using eDef b30 fmranI 43(7) by fastforce

      then obtain ip'' where  b30:"denvalue(e) $$ ip'' = Some((Memory tp2, Stackloc l2))" using b20 by auto
      then have b40:"ip'' \<noteq> ip" using eDef by auto
      then have b60:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue ev')" using eDef 43(7) b30 fmranI by fastforce

      have b70:"\<forall>l''. (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l'' \<longrightarrow> accessStore l'' k' = accessStore l'' sck'" 
        using k'Def unfolding push_def updateStore_def allocate_def accessStore_def by simp
      have b80:"accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) k' = Some (KStoptr p)" using k'Def  unfolding push_def updateStore_def allocate_def accessStore_def by simp 
      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l1" using b70 b80 b20 by auto
      then have b90:"accessStore l1 sck' = accessStore l1 k'" using b70 b80 b20 by simp

      then have "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck')) \<noteq> l2" using b70 b80 b20 by auto
      then have b95:"accessStore l2 sck' = accessStore l2 k'" using b70 b80 b20 by simp

      show "if stl1 = stl2 then tp1 = tp2
           else case tp1 of
                MTArray len arr \<Rightarrow>
                  (case tp2 of
                  MTArray len2 arr2 \<Rightarrow>
                    if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTArray len arr) stl2 stl1
                    else if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTArray len2 arr2) stl1 stl2
                      else if TypedMemSubPrefPtrs m' len arr stl1 dloc1\<and> TypedMemSubPrefPtrs m' len2 arr2 stl2 dloc1
                          then \<exists>dt.
                                  CompMemType m' len2 arr2 dt stl2 dloc1 \<and>
                                  CompMemType m' len arr dt stl1 dloc1
                                 
                    else True
                  | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs m' len arr stl1 stl2 then CompMemType m' len arr (MTValue val2) stl1 stl2 else True)
                | MTValue val \<Rightarrow> (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs m' len2 arr2 stl2 stl1 then CompMemType m' len2 arr2 (MTValue val) stl2 stl1 else True | MTValue val2 \<Rightarrow> True)" 
        using 43(7) a40 b2 b50 b60 b20 compMemPtrs_def b90 b95 by fastforce
    qed
  next 
    have a110:"m' = mem''" using a40 by simp
    then show "\<And>locs tp. \<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m' locs" using assms(5) 43(7) assms(5) by (simp)
  next
    assume "\<not> cp"
    then show "toploc (memory st) \<le> toploc m'"  using assms(5) 43(7)  a40 by blast
  next 
    assume notCP:"\<not>cp" 
    show "ncpDenvalueLimit e ev k' (stack st) (memory st) " 
      unfolding ncpDenvalueLimit_def
    proof intros
      fix tp' locs p'' i
      assume a120:" (Memory tp', Stackloc locs) |\<in>| fmran (denvalue e) \<and> accessStore locs k' = Some (KMemptr p'') \<and> i < toploc (memory st) \<and> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)"

      then have a160:"\<forall>ip''' t''' l'''. denvalue e $$ ip''' = Some(t''', l''') \<and> l''' \<noteq> (Stackloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))) \<longrightarrow> ip''' \<noteq> ip" 
        using eDef lessThanTopLocs_def fmranI by auto
      show " \<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p'' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p'' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p''))
          " 
      proof -
        obtain ip'' where ip''def:"(denvalue e) $$ ip'' = Some (Memory tp', Stackloc locs)" using a120 by blast
        then have a170:"ip'' \<noteq> ip" using eDef by auto
        then have a180: "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue ev')" using eDef 43(7)  fmranI ip''def  by fastforce
        have a190:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc sck'))" using a160 a170 k'Def 
          using a150 ip''def by blast

        then obtain y' where  a200:"accessStore locs sck' = Some y' " using typeSafeAllStacklocsExist assms(3) 43(7) a180 by blast
        then have "accessStore locs k' = accessStore locs sck'" using k'Def a120 a190 unfolding push_def allocate_def updateStore_def accessStore_def by simp
        then show " \<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue ev) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p'' \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p'' \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p''))" 
          using assms(5) 43(7) a120 a40 eDef k'Def a120 a180 notCP ncpDenvalueLimit_def
          by (metis)
      qed
    qed
  next
    assume notCP:"\<not>cp"
    then show "ncpOMemInDMem (memory st) m'" using a40 43(7) assms by simp
  next 
    assume notCP:"\<not>cp"
    then show "ncpElementsNoSubPref (memory st) m'" using a40 assms 43 by blast
  next
    assume notCP:"\<not>cp"
    then show "ncpNewSelfPoint (memory st) m'" using a40 assms 43 by blast
  next 
    show "toploc mem' \<le> toploc m' " using a40 43 by simp
  qed
next
  case (44 v va xk xl xm xn xo)
  then show ?thesis by simp
next
  case (45 v va ve vd xk xl xm xn xo)
  then show ?thesis by simp
next
  case (46 v va ve vd xk xl xm xn xo)
  then show ?thesis by simp
next
  case (47 v va ve vd xk xl xm xn xo)
  then show ?thesis by simp
next
  case (48 v xj xk xl xm xn xo)
  then show ?thesis by simp
next
  case (49 xi xk xl xm xn xo)
  then show ?thesis by simp
next
  case (50 xi vc vb xk xl xm xn xo)
  then show ?thesis by simp
next
  case (51 xi vc vb xk xl xm xn xo)
  then show ?thesis by simp
next
  case (52 xi vc vb xk xl xm xn xo)
  then show ?thesis by simp
qed


subsection \<open>Proof that expressions do not violate type consistency\<close>
text \<open>The following lemma proves that given a typesafe environment 
    all expressions, memory selections, storage selections and rexpressions return type consistent
    values. I.e. the string values returned are conform to the types that are expected. 
    This demonstrates that the semantics of expressions do not alter the values in any way which may
    violate type consistency
    Further this lemma also ensures that the env, mem, cd, store that are created by load typesafe
    with respect to one another.\<close>


(*Includes assumptions that the environment being used is fully intialised. using ffold_init
  I.e. it exist in accounts and also all the contract variables have be initialised using ffold init
  This is true from the context of statements. 
*)
lemma exprTypeconInduct[rule_format]:
  "\<forall>l1'  t1' g1' arr. msel c1 t1 l1 xe1 ev1 cd1 st1 g1 = Normal ((l1', t1'), g1') \<and> 
                            MCon t1 (if c1 then memory st1 else cd1) l1 \<and> 
                            TypeSafe ev1 (accounts st1) (stack st1) (memory st1) (storage st1) cd1 \<and>
                            fullyInitialised ev1 (accounts st1) (stack st1) \<longrightarrow> 
                            (xe1 \<noteq> Nil \<longrightarrow> (\<exists>len arr. (t1 = MTArray len arr) \<and> 
                                            (case t1' of MTValue val \<Rightarrow>  CompMemType (if c1 then memory st1 else cd1) len arr t1' l1 l1'
                                                        |(MTArray l' ar') \<Rightarrow> (\<exists>p. accessStore l1' (if c1 then memory st1 else cd1) = Some (MPointer p) \<and>
                                                                               CompMemType (if c1 then memory st1 else cd1) len arr t1' l1 p))))"
  "\<forall>l2' v2' t2' g2'. ssel t2 l2 xe2 ev2 cd2 st2 g2 = Normal ((l2', t2'), g2') \<and>  
                            SCon t2 l2  (storage st2 (address ev2))  \<and> 
                            TypeSafe ev2 (accounts st2) (stack st2) (memory st2) (storage st2) cd2 \<and>
                            fullyInitialised ev2 (accounts st2) (stack st2) \<longrightarrow> 
                            (xe2 \<noteq> Nil \<longrightarrow> CompStoType t2 t2' l2 l2')"
"\<forall>v t g4'. expr e4 ev4 cd4 st4 g4 = Normal ((v, t), g4') \<and> 
                TypeSafe ev4 (accounts st4) (stack st4) (memory st4) (storage st4 ) cd4 \<and>
                  fullyInitialised ev4 (accounts st4) (stack st4) \<longrightarrow> 
                    (case t of Value typ \<Rightarrow> (typeCon typ (extractValueType(v)) \<and> (\<exists>xx. v = KValue xx))
                     | Calldata struct \<Rightarrow> (MCon struct cd4 (extractValueType(v)) \<and> (\<exists>xx. v = KCDptr xx)
                                              \<and> (\<exists>stloc tp'' p. (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev4)\<and> accessStore stloc (stack st4) =Some (KCDptr p)
                                              \<and> ((tp'' = struct \<and>  v = KCDptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd4 len arr struct p (extractValueType v)))))
                     | Memory struct \<Rightarrow> (MCon struct (memory st4) (extractValueType(v)) \<and> (\<exists>xx. v = KMemptr xx) \<and> 
                                          (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev4)\<and> accessStore stloc (stack st4) =Some (KMemptr p)
                                              \<and> ((tp'' = struct \<and> v = (KMemptr p)) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and>tp'' = MTArray len arr \<and> CompMemType (memory st4) len arr struct p (extractValueType v)))))
                     | Storage struct \<Rightarrow> (SCon struct (extractValueType(v)) (storage st4 (address ev4))) \<and> (\<exists>xx. v = KStoptr xx)
                                                \<and> (\<exists>stloc tp''. (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev4)
                                                \<and>((((tp'' = struct \<and>  v = KStoptr stloc) \<or> 
                                                                  ((extractValueType v) \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))
                                                              )))" 

"\<forall>ev cd k m g'. load lcp lis lxs lev0 lcd0 lk lm lev lcd lst lg = Normal ((ev, cd, k, m), g') \<and>
                      (\<not>lcp \<longrightarrow> (\<forall>locs tp. MCon tp (memory lst) locs \<longrightarrow> MCon tp lm locs) 
                                        \<and> toploc (memory lst) \<le> toploc lm
                                        \<and> ncpDenvalueLimit lev0 lev lk (stack lst) (memory lst) 
                                        \<and> ncpOMemInDMem (memory lst) lm
                                        \<and> ncpElementsNoSubPref (memory lst) lm
                                        \<and> ncpNewSelfPoint (memory lst) lm) \<and>
                    (TypeSafe lev (accounts lst) (stack lst) (memory lst) (storage lst ) lcd) \<and> 
                    (TypeSafe lev0 (accounts lst) lk lm (storage lst ) lcd0) \<and>
                     fullyInitialised lev (accounts lst) (stack lst) \<and>  fullyInitialised lev0 (accounts lst) lk
\<longrightarrow>
                    (TypeSafe ev (accounts lst) k m (storage lst ) cd) \<and>
 fullyInitialised ev (accounts lst) k
\<and> (\<not>lcp \<longrightarrow> (\<forall>locs tp. MCon tp (memory lst) locs \<longrightarrow> MCon tp m locs) 
                                        \<and> toploc (memory lst) \<le> toploc m
                                        \<and> ncpDenvalueLimit ev lev k (stack lst) (memory lst)  
                                        \<and> ncpOMemInDMem (memory lst) m
                                        \<and> ncpElementsNoSubPref (memory lst) m
                                        \<and> ncpNewSelfPoint (memory lst) m)"
"\<forall>v3' t3'  g3'. rexp l3 ev3 cd3 st3 g3 = Normal ((v3', t3'), g3') \<and> TypeSafe ev3 (accounts st3) (stack st3) (memory st3) (storage st3 ) cd3 
                                          \<and> fullyInitialised ev3 (accounts st3) (stack st3)\<longrightarrow> 
                     (case t3' of Value typ \<Rightarrow> (typeCon typ (extractValueType(v3')) \<and> (\<exists>xx. v3' = KValue xx))
                                         | Calldata struct \<Rightarrow> (MCon struct cd3 (extractValueType(v3')) \<and> (\<exists>xx. v3' = KCDptr xx)
                                              \<and> (\<exists>stloc tp'' p. (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev3)\<and> accessStore stloc (stack st3) =Some (KCDptr p)
                                              \<and> ((tp'' = struct \<and>  v3' = KCDptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v3') \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd3 len arr struct p (extractValueType v3')))))
                                         | Memory struct \<Rightarrow> (MCon struct (memory st3) (extractValueType(v3'))\<and> (\<exists>xx. v3' = KMemptr xx)
                                          \<and> (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev3)\<and> accessStore stloc (stack st3) =Some (KMemptr p)
                                              \<and> ((tp'' = struct \<and>  v3' = KMemptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v3') \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st3) len arr struct p (extractValueType v3')))))
                                         | Storage struct \<Rightarrow>  (SCon struct (extractValueType(v3')) (storage st3 (address ev3))) \<and> (\<exists>xx. v3' = KStoptr xx)
                                                \<and> (\<exists>stloc tp''. (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev3)
                                                \<and>(
                                                                  (((tp'' = struct \<and>  v3' = KStoptr stloc) \<or> 
                                                                  ((extractValueType v3') \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3'))))
                                                              )))"
proof (induct rule: msel_ssel_expr_load_rexp.induct
    [where ?P1.0="\<lambda>c1 t1 l1 xe1 ev1 cd1 st1 g1. (\<forall>l1'  t1' g1' arr. msel c1 t1 l1 xe1 ev1 cd1 st1 g1 = Normal ((l1',  t1'), g1') 
                                        
                                        \<and> MCon t1 (if c1 then memory st1 else cd1) l1 
                                        \<and> TypeSafe ev1 (accounts st1) (stack st1) (memory st1) (storage st1) cd1 \<and>
                                            fullyInitialised ev1 (accounts st1) (stack st1)
                                          \<longrightarrow> (xe1 \<noteq> Nil \<longrightarrow>  
                                                  (\<exists>len arr. (t1 = MTArray len arr) \<and> 
                                                      (case t1' of MTValue val \<Rightarrow>  CompMemType (if c1 then memory st1 else cd1) len arr t1' l1 l1'
                                                                  |(MTArray l' ar') \<Rightarrow> (\<exists>p. accessStore l1' (if c1 then memory st1 else cd1) = Some (MPointer p) \<and> 
                                                                                       CompMemType (if c1 then memory st1 else cd1) len arr t1' l1 p )))))
"
      and ?P2.0="\<lambda>t2 l2 xe2 ev2 cd2 st2 g2. (\<forall>l2' v2' t2' g2'. ssel t2 l2 xe2 ev2 cd2 st2 g2 = Normal ((l2',  t2'), g2')\<and> SCon t2 l2  (storage st2 (address ev2)) 
                                            \<and> TypeSafe ev2 (accounts st2) (stack st2) (memory st2) (storage st2 ) cd2 
                                            \<and> fullyInitialised ev2 (accounts st2) (stack st2) \<longrightarrow> 
                                              (xe2 \<noteq> Nil \<longrightarrow> CompStoType t2 t2' l2 l2'))"
      and ?P3.0="\<lambda>e4 ev4 cd4 st4 g4. (\<forall>v t g4'. expr e4 ev4 cd4 st4 g4 = Normal ((v, t), g4') \<and> 
                    TypeSafe ev4 (accounts st4) (stack st4) (memory st4) (storage st4 ) cd4 \<and>
                 fullyInitialised ev4 (accounts st4) (stack st4) \<longrightarrow> 
                    (case t of Value typ \<Rightarrow> (typeCon typ (extractValueType(v)) \<and> (\<exists>xx. v = KValue xx))
                     | Calldata struct \<Rightarrow> (MCon struct cd4 (extractValueType(v)) \<and> (\<exists>xx. v = KCDptr xx)
\<and> (\<exists>stloc tp'' p. (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev4)\<and> accessStore stloc (stack st4) =Some (KCDptr p)
                                              \<and> ((tp'' = struct \<and>  v = KCDptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd4 len arr struct p (extractValueType v)))))
                     | Memory struct \<Rightarrow> (MCon struct (memory st4) (extractValueType(v)) \<and> (\<exists>xx. v = KMemptr xx) \<and> 
                                          (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev4)\<and> accessStore stloc (stack st4) =Some (KMemptr p)
                                              \<and> ((tp'' = struct \<and> v = (KMemptr p)) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and>  tp'' = MTArray len arr \<and> CompMemType (memory st4) len arr struct p (extractValueType v)))))
                     | Storage struct \<Rightarrow> (SCon struct (extractValueType(v)) (storage st4 (address ev4))) \<and> (\<exists>xx. v = KStoptr xx)
                                                \<and> (\<exists>stloc tp''. (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev4)
                                                \<and>(
                                                                  (((tp'' = struct \<and>  v = KStoptr stloc) \<or> 
                                                                  ((extractValueType v) \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))
                                                              ))))"
      and ?P4.0="\<lambda>lcp lis lxs lev0 lcd0 lk lm lev lcd lst lg. (\<forall>ev cd k m g'. load lcp lis lxs lev0 lcd0 lk lm lev lcd lst lg = Normal ((ev, cd, k, m), g') \<and>
                                            (\<not>lcp \<longrightarrow> (\<forall>locs tp. MCon tp (memory lst) locs \<longrightarrow> MCon tp lm locs) 
                                        \<and> toploc (memory lst) \<le> toploc lm
                                        \<and> ncpDenvalueLimit lev0 lev lk (stack lst) (memory lst)  
                                        \<and> ncpOMemInDMem (memory lst) lm
                                        \<and> ncpElementsNoSubPref (memory lst) lm
                                        \<and> ncpNewSelfPoint (memory lst) lm
                                        
                                    ) \<and>
                    (TypeSafe lev (accounts lst) (stack lst) (memory lst) (storage lst ) lcd) \<and> 
                    (TypeSafe lev0 (accounts lst) lk lm (storage lst ) lcd0) \<and>
                    fullyInitialised lev (accounts lst) (stack lst) \<and>  fullyInitialised lev0 (accounts lst) (lk) \<longrightarrow> 
                                                              (TypeSafe ev (accounts lst) k m (storage lst ) cd) \<and>
                       
 fullyInitialised ev (accounts lst) (k) \<and>
                       (\<not>lcp \<longrightarrow> (\<forall>locs tp. MCon tp (memory lst) locs \<longrightarrow> MCon tp m locs) 
                                        \<and> toploc (memory lst) \<le> toploc m
                                        \<and> ncpDenvalueLimit ev lev k (stack lst) (memory lst)  
                                        \<and> ncpOMemInDMem (memory lst) m
                                        \<and> ncpElementsNoSubPref (memory lst) m
                                        \<and> ncpNewSelfPoint (memory lst) m))"
      and ?P5.0="\<lambda>l3 ev3 cd3 st3 g3. (\<forall>v3' t3' g3'. rexp l3 ev3 cd3 st3 g3 = Normal (( v3',  t3'), g3') 
\<and> TypeSafe ev3 (accounts st3) (stack st3) (memory st3) (storage st3 ) cd3 \<and>
                  fullyInitialised ev3 (accounts st3) (stack st3)\<longrightarrow> 
                     (case t3' of Value typ \<Rightarrow> (typeCon typ (extractValueType(v3')) \<and> (\<exists>xx. v3' = KValue xx))
                                         | Calldata struct \<Rightarrow> (MCon struct cd3 (extractValueType(v3')) \<and> (\<exists>xx. v3' = KCDptr xx)
                                              \<and> (\<exists>stloc tp'' p. (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev3)\<and> accessStore stloc (stack st3) =Some (KCDptr p)
                                              \<and> ((tp'' = struct \<and>  v3' = KCDptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v3') \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd3 len arr struct p (extractValueType v3'))))
                                            )
                                         | Memory struct \<Rightarrow> (MCon struct (memory st3) (extractValueType(v3'))\<and> (\<exists>xx. v3' = KMemptr xx)
                                          \<and> (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev3)\<and> accessStore stloc (stack st3) =Some (KMemptr p)
                                              \<and> ((tp'' = struct \<and> v3' = KMemptr p) \<or> 
                                              (\<exists>len arr. (extractValueType v3') \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st3) len arr struct p (extractValueType v3')))))
                                         | Storage struct \<Rightarrow> (SCon struct (extractValueType(v3')) (storage st3 (address ev3))) \<and> (\<exists>xx. v3' = KStoptr xx)
                                                \<and> (\<exists>stloc tp''. (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev3)
                                                \<and>(
                                                                  (((tp'' = struct \<and>  v3' = KStoptr stloc) \<or> 
                                                                  ((extractValueType v3') \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3'))))
                                                              ))))"
      ])
  case (1 uu uv uw ux uy uz g)
  then show ?case using msel.simps(1) by simp 
next
  case (2 va vb vc vd ve vf vg g)
  then show ?case using msel.simps(2) by simp 
next
  case (3 mm al t loc x env cd st g)
  show ?case
  proof(intros)
    fix l1' t1' g1' arr 
    assume a1:
      "local.msel mm (MTArray al t) loc [x] env cd st g = Normal ((l1', t1'), g1') \<and>
      
       MCon (MTArray al t) (if mm then memory st else cd) loc \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd 
      \<and> fullyInitialised env (accounts st) (stack st)"

    then obtain kv b g4'  where a20: "local.expr x env cd st g = Normal ((KValue kv, Value (TUInt b)), g4')"
      and a30: "less (TUInt b) (TUInt b256) kv (ShowL\<^sub>i\<^sub>n\<^sub>t (int al)) = Some ((ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), TBool)"
      using a1 msel.simps(3) 
      by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm option.split_asm Memoryvalue.split_asm) 
    have a50: "checkUInt b kv" using 3(1) a1 a20 typeCon.simps(2)[of b "extractValueType (KValue kv)"] extractValueType.simps(1)[of kv] by auto
    then have a60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv) < int al " using a20 a30 less_def plift.simps(2)[of "(<)" b b256 kv "(ShowL\<^sub>i\<^sub>n\<^sub>t (int al))"] Read_ShowL_id[of "(int al)"] unfolding createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    then have a62:"0\<le>ReadL\<^sub>i\<^sub>n\<^sub>t(kv)" and a65:"(ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) = kv" using a50 checkUInt_def[of b kv] by simp+
    have a64:"(ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))) = kv" using ShowLnat_ReadLint_inverse a62 a50 unfolding checkUInt_def by simp
    then have a70:"(nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) \<in> {0..al-1}" using a60 a62 by simp
    have a90: "l1' = (hash loc kv)" using a20  msel.simps(3)[of mm al t loc x env cd st g] a30 a1 by simp
    then have a100: "t =  t1'" using a1 msel.simps by (simp split:if_split_asm result.split_asm prod.split_asm  Stackvalue.split_asm Type.split_asm)
    have **:"MCon (MTArray al t) (if mm then memory st else cd) loc" using a1 by blast
    then have defexp:"(if al = 0 then False else 
                        \<forall>i::nat <al. 
                                                (case (accessStore (hash loc  (ShowL\<^sub>n\<^sub>a\<^sub>t i))((if mm then memory st else cd))) of
                                                 (Some (MPointer loc2)) \<Rightarrow> 
                                                        (case t of MTArray len' arr' \<Rightarrow> (MCon t (if mm then memory st else cd) (loc2))
                                                            | _ \<Rightarrow> False)
                                                  | Some(MValue val) \<Rightarrow>  
                                                        (case t of MTValue typ \<Rightarrow> (MCon t (if mm then memory st else cd) (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                                                            | _ \<Rightarrow> False)
                                                  | _ \<Rightarrow> False
                                                 )
          \<and>  ((\<exists>p. accessStore loc (if mm then memory st else cd) = Some (MPointer p)) \<or> accessStore loc (if mm then memory st else cd) = None))" using MCon.simps(2)[of al t "(if mm then memory st else cd)" loc ] by simp
    have alNonZero:"al \<noteq> 0" using a60 a62 by simp
    then have b0:"(case (accessStore (hash loc  (ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))))((if mm then memory st else cd))) of
                                             (Some (MPointer loc2)) \<Rightarrow> 
                                                    (case t of MTArray len' arr' \<Rightarrow> (MCon t (if mm then memory st else cd) (loc2))
                                                        | _ \<Rightarrow> False)
                                              | Some(MValue val) \<Rightarrow>  
                                                    (case t of MTValue typ \<Rightarrow> (MCon t (if mm then memory st else cd) (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)))))
                                                        | _ \<Rightarrow> False)
                                              | _ \<Rightarrow> False
                                             )" using defexp a60 a65 alNonZero by simp
    then obtain v1' where b1:"(accessStore (hash loc  (ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))))((if mm then memory st else cd))) = Some v1'" using a64 
      by fastforce    
    then have a80:"(accessStore (hash loc kv) (if (\<not>mm) then cd else (memory st))) =  Some(v1')" using a1 a70 a64 by auto

    

    assume b99:" [x] \<noteq> []" 
    have "\<exists>len arr.
          MTArray al t = MTArray len arr \<and>
          (case t1' of
           MTArray l' ar' \<Rightarrow>
             \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and>
                 CompMemType (if mm then memory st else cd) len arr t1' loc p
           | MTValue val \<Rightarrow>
               CompMemType (if mm then memory st else cd) len arr t1' loc l1')" 
    proof(cases t)
      case (MTArray x11 x12)
      then obtain p where  "accessStore (hash loc kv) (if mm then memory st else cd) = Some (MPointer p)"  using  b0 b1   a1 a70 a65 a80 a64  defexp 
        by (metis (no_types, lifting) MTypes.simps(5) Memoryvalue.exhaust Memoryvalue.simps(5) Option.option.simps(5))
      moreover have "CompMemType (if mm then memory st else cd) al t t loc p" using calculation
        by (smt (z3) "**" MConPtrsMustBeSubLocs MTArray a60 a62 a80 b1 nat_less_iff CompMemType.simps(2))
      ultimately have "\<exists>p. accessStore (hash loc kv) (if mm then memory st else cd) = Some (MPointer p) \<and> (CompMemType (if mm then memory st else cd) al t t loc p)" by simp
      then show ?thesis using MTArray 
        using "**" CompTypeRemainsMCon MTypes.simps(5) a100 a90 by blast
    next
      case (MTValue x2)

      then show ?thesis 
        using MTValue CompMemType.simps(1) 
        using a100 a60 a62 a64 a90 nat_less_iff 
        by (metis (lifting) MTypes.simps(6))

    qed
    then show "\<exists>len arr.
          MTArray al t = MTArray len arr \<and>
          (case t1' of
           MTArray l' ar' \<Rightarrow>
             \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and>
                 CompMemType (if mm then memory st else cd) len arr t1' loc p
           | MTValue val \<Rightarrow>
               CompMemType (if mm then memory st else cd) len arr t1' loc l1')"
      using a90 a100 by blast
  qed
next
  case (4 mm al t loc x y ys env cd st g)
  show ?case 
  proof (intros)
    fix l1' t1' g1' arr
    assume a1: "local.msel mm (MTArray al t) loc (x # y # ys) env cd st g = Normal ((l1', t1'), g1') \<and>
       MCon (MTArray al t) (if mm then memory st else cd) loc \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd 
        \<and> fullyInitialised env (accounts st) (stack st)"

    then obtain kv b g4' l where a20: "local.expr x env cd st g = Normal ((KValue kv, Value (TUInt b)), g4')"
      and a30: "less (TUInt b) (TUInt b256) kv (ShowL\<^sub>i\<^sub>n\<^sub>t (int al)) = Some ((ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), TBool)"
      and a40: "accessStore (hash loc kv) (if mm then memory st else cd) = Some (MPointer l)"
      and a45:"local.msel mm (MTArray al t) loc (x # y # ys) env cd st g = local.msel mm t l (y # ys) env cd st g4'"
      using a1 msel.simps(4) by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm option.split_asm Memoryvalue.split_asm)  

    have a50: "checkUInt b kv" using 4(1) a1 a20 by simp
    then have a60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv) < int al " using a20 a30 less_def plift.simps(2)[of "(<)" b b256 kv "(ShowL\<^sub>i\<^sub>n\<^sub>t (int al))"] Read_ShowL_id[of "int al"] unfolding createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    then have a62:"0\<le>ReadL\<^sub>i\<^sub>n\<^sub>t(kv)" and a65:"(ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) = kv" using a50 checkUInt_def[of b kv] by simp+
    then have a64:"(ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))) = kv" using ShowLnat_ReadLint_inverse a50 unfolding checkUInt_def by simp
    then have a70:"(nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) \<in> {0..al-1}" using a60 by simp
    then have a80:"(accessStore (hash loc kv) (if (\<not>mm) then cd else (memory st))) =  Some(MPointer l)" using a1(1) a40 by presburger
    have a90:"al > 0" using a60 a62 by simp 
    have a91:" MCon (MTArray al t) (if mm then memory st else cd) loc" using a1 by blast
    then have defexp:"(case (accessStore (hash loc  (ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))))((if mm then memory st else cd))) of
                                           (Some (MPointer loc2)) \<Rightarrow> 
                                                  (case t of MTArray len' arr' \<Rightarrow> (MCon t (if mm then memory st else cd) (loc2))
                                                      | _ \<Rightarrow> False)
                                            | Some(MValue val) \<Rightarrow>  
                                                  (case t of MTValue typ \<Rightarrow> (MCon t (if mm then memory st else cd) (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)))))
                                                      | _ \<Rightarrow> False)
                                            | _ \<Rightarrow> False
                                           )" using MCon.simps(2)[of al t _ loc] a90 a60  by simp
    then have a95:"case t of MTArray len' arr' \<Rightarrow> MCon t (if mm then memory st else cd) l | MTValue Types \<Rightarrow> False" using a80 a64 by (auto split:if_splits )
    then obtain len' arr' where  tdef:"t = MTArray len' arr'" using a1 a70 a65 a64 a80 a90 a60 defexp by (cases t; simp)
    then have a100:"MCon t (if mm then memory st else cd) l" using a1 a70 a65 a64 a80 a90 a60 defexp a95 by simp


    assume b99:"x # y # ys \<noteq> []"
    have b10: "\<exists>len arr.
          MTArray al t = MTArray len arr \<and>
          (case t1' of
           MTArray l' ar' \<Rightarrow>
             \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and>
                 CompMemType (if mm then memory st else cd) len arr t1' loc p
           | MTValue val \<Rightarrow>
               CompMemType (if mm then memory st else cd) len arr t1' loc l1')"
    proof(cases ys)
      case Nil
      then have b15:"\<forall>l1' v1' t1' g1' arr.
       local.msel mm t l (y # ys) env cd st g4' = Normal ((l1', t1'), g1') \<and>
       MCon t (if mm then memory st else cd) l \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd \<longrightarrow>
        
        (y # ys \<noteq> [] \<longrightarrow>
         (\<exists>len arr.
            t = MTArray len arr \<and>
            (case t1' of MTArray l' ar' \<Rightarrow> \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) 
                                            \<and> CompMemType (if mm then memory st else cd) len arr t1' l p
                                            
             | MTValue val \<Rightarrow> CompMemType (if mm then memory st else cd) len arr t1' l l1')))" 
        using 4(2)[of "((KValue kv, Value (TUInt b)))" g4' "(kv, b)" g4' kv b ] a20 a30 a40  a45 a100 a1 by (auto split:if_splits option.splits )

      have b20: "local.msel mm t l [y] env cd st g4'  = Normal ((l1', t1'), g1')" using a45 Nil a1 by simp
      then obtain kv' b' where b30:"expr y env cd st g4' = Normal (((KValue kv', Value (TUInt b')), g1'))" 
        using msel.simps(3)[of mm len' arr' l y env cd st g4'] tdef  by (auto split:result.splits Stackvalue.splits Type.splits Types.splits if_splits)
      then have b40:"Valuetypes.less (TUInt b') (TUInt b256) kv' (ShowL\<^sub>i\<^sub>n\<^sub>t (int len')) = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True, TBool)"        
        using msel.simps(3)[of mm len' arr' l y env cd st g4'] tdef b20 by (auto split:result.splits Stackvalue.splits Type.splits Types.splits if_splits)

      then have b50:"l1' = hash l kv'"
        using msel.simps(3)[of mm len' arr' l y env cd st g4'] tdef b20 b30
        by (auto split:result.splits Stackvalue.splits Type.splits Types.splits if_splits)
      then have b60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv') < int len'"
        using tdef b20 b40 less_def plift.simps(2)[of "(<)" b' b256 kv' ] Read_ShowL_id[of "int len'"] createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def 
        by (auto split:result.splits Stackvalue.splits Type.splits Types.splits if_splits)
      then have "(y # ys \<noteq> [] \<longrightarrow>
        (\<exists>len arr.
           t = MTArray len arr \<and>
           (case t1' of
            MTArray l' ar' \<Rightarrow>
              \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and>
                  CompMemType (if mm then memory st else cd) len arr t1' l p
            | MTValue val \<Rightarrow>
                CompMemType (if mm then memory st else cd) len arr t1' l l1')))" 
        using b15 b20 a1 a100 Nil by simp
      then have b70:"(
            (case t1' of MTArray l' ar' \<Rightarrow> \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) 
                                                \<and> CompMemType (if mm then memory st else cd) len' arr' t1' l p
                                                
             | MTValue val \<Rightarrow> CompMemType (if mm then memory st else cd) len' arr' t1' l l1' 
                              ))" 
        using b99 tdef by simp
      then show ?thesis 
      proof(cases t1')
        case (MTArray x11 x12)
        then have "\<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) 
                    \<and> CompMemType (if mm then memory st else cd) len' arr' t1' l p
                    " 
          using b70 by simp
        then obtain p where pdef:" accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and> CompMemType (if mm then memory st else cd) len' arr' t1' l p"  by auto
        have "CompMemType (if mm then memory st else cd) al ( MTArray len' arr') t1' loc p"
          using CompMemType.simps(2)[of "(if mm then memory st else cd)" al len' arr' t1' loc p] 
          by (metis a40 a60 a62 a64 nat_less_iff pdef)
        then show ?thesis using MTArray b70 pdef tdef 
          using CompTypeRemainsMCon MTypes.simps(5) a91 by blast
      next
        case (MTValue x2)
        then have c10:"CompMemType (if mm then memory st else cd) len' arr' t1' l l1'" using b70 by simp
        then have noteq:"l \<noteq> l1'" 
          by (metis b50 hash_inequality)
        have "l \<noteq> loc" using b50 MConPtrsMustBeSubLocs2[of al t "(if mm then memory st else cd)" loc] a91  
          using MConSubTypes a100 CompMemJustType.simps(2) tdef by blast
        then show ?thesis using MTValue b70 tdef using a1 a70 a65 a64 a80 a90 a60 defexp a95 noteq a40 c10
          by (metis (no_types, lifting) MTypes.simps(6) a62 nat_less_iff
              CompMemType.simps(2))
      qed
    next
      case (Cons a list)
      then have b15:"\<forall>l1' v1' t1' g1' arr.
       local.msel mm t l (y # ys) env cd st g4' = Normal ((l1', t1'), g1') \<and>
       MCon t (if mm then memory st else cd) l \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd \<longrightarrow>
       (y # ys \<noteq> [] \<longrightarrow>(\<exists>len arr.
            t = MTArray len arr \<and>
            (case t1' of MTArray l' ar' \<Rightarrow> \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) 
                                            \<and> CompMemType (if mm then memory st else cd) len arr t1' l p
                                            
             | MTValue val \<Rightarrow> CompMemType (if mm then memory st else cd) len arr t1' l l1' )))" 
        using 4(2)[of "((KValue kv, Value (TUInt b)))" g4' "(kv, b)" g4' kv b ] a20 a30 a40  a45 a1 by (auto split:if_splits option.splits )
      have b20: "local.msel mm t l (y#ys) env cd st g4'  = Normal ((l1', t1'), g1')" using a45 Cons a1 by simp
      then have b30:"\<exists>len arr.
            t = MTArray len arr \<and>
            (case t1' of MTArray l' ar' \<Rightarrow> \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) 
                                            \<and> CompMemType (if mm then memory st else cd) len arr t1' l p
                                            
             | MTValue val \<Rightarrow> CompMemType (if mm then memory st else cd) len arr t1' l l1' )" 
        using b15 b20 a1 a100  by simp
      then show ?thesis
      proof(cases t1')
        case (MTArray x11 x12)
        then have " \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and> CompMemType (if mm then memory st else cd) al t t1' loc p" 
          using b30 a40 a62 a64 nat_less_iff 
          using a60 by fastforce
        then show ?thesis using MTArray 
          using CompTypeRemainsMCon MTypes.simps(5) a91 by blast
      next
        case (MTValue x2)
        then have "CompMemType (if mm then memory st else cd) al t t1' loc l1'" using b30 
          using a40 a60 a62 a64 nat_less_iff by fastforce
        then show ?thesis using MTValue b30 by force
      qed
    qed
    then show "\<exists>len arr.
          MTArray al t = MTArray len arr \<and>
          (case t1' of
           MTArray l' ar' \<Rightarrow>
             \<exists>p. accessStore l1' (if mm then memory st else cd) = Some (MPointer p) \<and>
                 CompMemType (if mm then memory st else cd) len arr t1' loc p 
           | MTValue val \<Rightarrow>
               CompMemType (if mm then memory st else cd) len arr t1' loc l1')" by simp
  qed
next
  case (5 tp loc vi vj vk g)
  then show ?case
  proof (intros)
    fix l2' v2' t2' g2' 
    assume a1: "local.ssel tp loc [] vi vj vk g = Normal ((l2', t2'), g2') \<and>
       SCon tp loc (storage vk (address vi)) \<and> TypeSafe vi (accounts vk) (stack vk) (memory vk) (storage vk) vj 
\<and> fullyInitialised vi (accounts vk) (stack vk)"
    assume *:"[] \<noteq> []"
    then have a10:"loc = l2'" and a20:"t2' = tp" using ssel.simps(1) by simp+
    show " CompStoType tp t2' loc l2' " using * by simp
  qed
next
  case (6 vl vm vn vo vp vq vr g)
  then show ?case using ssel.simps(2) by simp
next
  case (7 al t loc x xs env cd st g)
  show ?case
  proof(intros)
    fix l2' v2' t2' g2' 
    assume a1:"local.ssel (STArray al t) loc (x # xs) env cd st g = Normal ((l2', t2'), g2') \<and>
       SCon (STArray al t) loc (storage st (address env)) \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd  
      \<and>  fullyInitialised env (accounts st) (stack st)"
    assume b99:"x # xs \<noteq> []"   
    then obtain kv b g4' where a20: "local.expr x env cd st g = Normal ((KValue kv, Value (TUInt b)), g4')"
      and a30: "less (TUInt b) (TUInt b256) kv (ShowL\<^sub>i\<^sub>n\<^sub>t (int al)) = Some (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True, TBool)"
      and a40:"ssel (STArray al t) loc (x # xs) env cd st g = ssel t (hash loc kv) xs env cd st g4'"
      using a1 ssel.simps(3) by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm)  

    have a50: "checkUInt b kv" using 7(1) a1 a20 by simp
    then have a60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv) < int al " using a20 a30 less_def plift.simps(2)[of "(<)" b b256 kv "(ShowL\<^sub>i\<^sub>n\<^sub>t (int al))"] Read_ShowL_id[of "(int al)"] unfolding createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    then have a62:"0\<le>ReadL\<^sub>i\<^sub>n\<^sub>t(kv)" and a65:"(ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) = kv" using a50 checkUInt_def[of b kv] by simp+
    then have a67:"(ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))) = kv" using ShowLnat_ReadLint_inverse a50 unfolding checkUInt_def by simp
    then have a68:"nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv) < al" by (simp add: a60 a62 nat_less_iff)
    then have b10:"SCon t (hash loc kv) (storage st (address env)) \<and> (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) \<in> {0..al-1}"
      using a1  a65 a67 by force
             
    have b10:"CompStoType (STArray al t) t2' loc l2' \<and> loc \<noteq> l2'"
    proof(cases xs)
      case Nil
      then have "ssel t (hash loc kv) xs env cd st g4' = Normal(((hash loc kv), t),g2')" using ssel.simps(1) a1 a40 by simp
      then have b30:"l2' = (hash loc kv) \<and> t2' = t" using a40 a1 by simp
      then have "(\<exists>i<al. TypedStoSubpref l2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t)" using a67 a68 TypedStoSubpref_sameLoc by auto
      moreover have "(\<exists>i<al. CompStoType t t2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l2')" using a67 a68 b30 CompStoType_sameLocNdTyp by auto
      moreover have "l2' \<noteq> loc" using b30 by (simp add: hash_inequality)
      ultimately show ?thesis using TypedStoSubpref.simps(2)[of l2' loc al t ] b30 CompStoType.simps(2)[of al t t2' loc l2'] by simp

    next
      case (Cons a list) 
      have b20:"xs \<noteq> [] \<longrightarrow> CompStoType t t2'  (hash loc kv) l2'" 
        using 7(2) a1 a20 a30 a40 b10 by simp
      then have b30:"CompStoType t t2'  (hash loc kv) l2'" using Cons by simp
      have "al > 0" using a60  by (metis a62 bot_nat_0.not_eq_extremum less_nat_zero_code nat_less_iff) 
      then have "\<forall>i::nat. i\<in>{0..al - 1} \<longrightarrow> i<al" using a60 by auto
      then have b40:"(\<exists>i<al. TypedStoSubpref l2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t \<or> l2' = hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i))" 
        using a60 a65 a67 b20 b30 by (metis CompStoType_imps_TypedStoSubpref a68)

      then show ?thesis
      proof(cases t)
        case (STArray x11 x12)
        then have c1:"loc \<noteq> l2'" using b30 TypedStoSubpref.simps(2)[of l2' "(hash loc kv)" x11 x12] TypedStoSubpref_hashes 
          by (metis b40 hash_inequality)
        have "((\<exists>i<al. CompStoType t t2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l2'))" using b30 a67 a68 by auto
        moreover have "((\<exists>i<al. TypedStoSubpref l2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t))" 
          using b30 a67 a68 TypedStoSubpref_sameLoc b40 by blast
        ultimately show ?thesis using  CompStoType.simps(2)[of al t t2' loc l2'] b30 TypedStoSubpref.simps(2)[of l2' loc al t] c1 by simp 
      next
        case (STMap x21 x22)
        then have c1:"loc \<noteq> l2'" 
          using b30 TypedStoSubpref.simps(2) TypedStoSubpref_hashes by (metis b40)
        have "((\<exists>i<al. CompStoType t t2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l2'))" using b30 a67 a68 by auto
        moreover have "((\<exists>i<al. TypedStoSubpref l2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t))" 
          using b30 a67 a68 TypedStoSubpref_sameLoc b40 by blast
        ultimately show ?thesis using  CompStoType.simps(2)[of al t t2' loc l2'] b30 TypedStoSubpref.simps(2)[of l2' loc al t] c1 by simp 
      next
        case (STValue x3) 
        then have "l2' = (hash loc kv)" using b30 TypedStoSubpref.simps(1)[of l2' " (hash loc kv)" x3] by auto
        then have c1:"loc \<noteq> l2'" by (metis hash_inequality)
        have "(\<exists>i<al. CompStoType t t2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) l2')" using b30 a67 a68 by auto
        moreover have "(\<exists>i<al. TypedStoSubpref l2' (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) t)" using b30 a67 a68 
          using TypedStoSubpref_sameLoc b40 by blast
        ultimately show ?thesis using  CompStoType.simps(2)[of al t t2' loc l2'] b30 TypedStoSubpref.simps(2)[of l2' loc al t] c1 by simp 
      qed
    qed
    show "CompStoType (STArray al t) t2' loc l2'" using b10 by auto
  qed
next
  case (8 vs t loc x xs env cd st g)
  show ?case
  proof(intros)
    fix l2' v2' t2' g2' 
    assume a1:"local.ssel (STMap vs t) loc (x # xs) env cd st g = Normal ((l2', t2'), g2') \<and>
       SCon (STMap vs t) loc (storage st (address env)) \<and> TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd
      \<and>  fullyInitialised env (accounts st) (stack st) "

    then obtain kv g4' t'' where a20: "local.expr x env cd st g = Normal ((KValue kv, Value t''), g4')"
      and a30: "comp t'' vs"
      and a40:"ssel (STMap vs t) loc (x # xs) env cd st g = ssel t (hash loc kv) xs env cd st g4'"
      using a1 ssel.simps(4) by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm)  

    then have "typeCon t'' kv" using 8(1) a1 by simp
    then have b20:"typeCon vs kv" using SameCompTypeCon[of t'' vs kv] a30  by simp 
    then have b10:"SCon t (hash loc kv) (storage st (address env))" using SCon.simps(3)[of vs t loc "(storage st (address env))"] a1 by simp

    assume "x # xs \<noteq> []"
    then have b10:"CompStoType (STMap vs t) t2' loc l2'"
    proof(cases xs)
      case Nil
      then have "ssel t (hash loc kv) xs env cd st g4' = Normal(((hash loc kv), t),g2')" using ssel.simps(1) a1 a40 by simp
      then have b30:"l2' = (hash loc kv) \<and> t2' = t" using a40 a1 by simp

      then have " (\<exists>i. typeCon vs i \<and> (TypedStoSubpref l2' (hash loc i) t \<or> l2' = hash loc i))" using b20 by auto
      then show ?thesis using TypedStoSubpref.simps(3)[of l2' loc vs t ] b30 b20 
        using CompStoType_sameLocNdTyp TypedStoSubpref_sameLoc by auto
    next
      case (Cons a list) 
      have "(xs \<noteq> [] \<longrightarrow> CompStoType t t2' (hash loc kv) l2')"  using 8(2) a1 a20 a30 a40 b10 by simp
      then have b30:"CompStoType t t2' (hash loc kv) l2'" using Cons by blast
      then show ?thesis 
      proof(cases "t2' = t")
        case True
        then show ?thesis using b20 b30 a40 a1 Cons by auto
      next
        case False
        then have " (\<exists>i. typeCon vs i \<and>  CompStoType t t2' (hash loc i) l2')"  using b20 b30 by auto
        then show ?thesis using b30 b20 using CompStoType.simps(3)[of vs t t2' loc l2'] False by auto
      qed
    qed
    show "CompStoType (STMap vs t) t2' loc l2'" using b10 by simp
  qed
next
  case (9 b x ev cd st g')
  then show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (E.INT b x) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st ) cd
                \<and>  fullyInitialised ev (accounts st) (stack st) "
    show " case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp'' .
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))) "
    proof -
      have a10:"t = Value (TSInt b)" using expr.simps(1) a1 by (simp split:if_split_asm)
      then have a20:"v = KValue (createSInt b x)" using expr.simps(1) a1 by (simp split:if_split_asm)
      moreover have "typeCon (TSInt b) (createSInt b x) = checkSInt (b) (createSInt b x)" by simp
      moreover have "checkSInt (b) (createSInt b x)" using checkSIntCreate by simp
      ultimately have "typeCon (TSInt b) (extractValueType v)" by (simp split:if_split_asm)
      then show ?thesis using a10 a20 by (simp split:if_split_asm)
    qed
  qed
next
  case (10 b x ev cd st g')
  then show ?case
  proof (intros)
    fix v t g
    assume a1: "local.expr (UINT b x) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st ) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "v = KValue (createUInt b x)" using expr.simps(2) by (simp split:if_split_asm)
    moreover have "t = Value (TUInt b)" using a1 expr.simps(2) by (simp split:if_split_asm)
    moreover have "typeCon (TUInt b) (createUInt b x) = checkUInt (b) (createUInt b x)"  using a1 expr.simps(2) by (simp split:if_split_asm)
    moreover have "checkUInt b (createUInt b x)" using checkUIntCreate by simp
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))) " by simp
  qed
next
  case (11 ad ev cd st g')
  then show ?case
  proof (intros)
    fix v t g
    assume a1: "local.expr (ADDRESS ad) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st ) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    have a10:"v = KValue (createAddress ad)" using a1 expr.simps(3) by (simp split:if_split_asm)
    then have a20:"t = Value TAddr" using a1 expr.simps(3) by (simp split:if_split_asm)
    then have "typeCon TAddr ad = checkAddress ad" by simp
    then show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using a10 a20 unfolding checkAddress_def 
      using createAddressNoDots 
        typeCon.simps(4)[of "(createAddress ad)"] 
        extractValueType.simps(1)[of "createAddress ad"] by (simp add: checkAddress_def)
  qed
next
  case (12 ad ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (BALANCE ad) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st ) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then obtain adv where 3:"expr ad ev cd st (g' - costs\<^sub>e (BALANCE ad) ev cd st) = Normal ((KValue adv, Value TAddr), g)" using expr.simps(4) by (simp split:if_split_asm prod.split_asm result.split_asm Stackvalue.split_asm Type.split_asm Types.split_asm)
    moreover have a5:"expr (BALANCE ad) ev cd st g' = Normal ((KValue (bal ((accounts st) adv)), Value (TUInt b256)), g)" using a1 expr.simps(4) 3 by (simp split:if_split_asm prod.split_asm result.split_asm Stackvalue.split_asm Type.split_asm Types.split_asm)
    moreover have "v = KValue (bal ((accounts st) adv))" using a1 a5 by simp
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp'' .
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" 
      using a1 typeSafeAccounts[of "ev" "(accounts st)" "(stack st)" "(memory st)" "(storage st)" cd] balanceTypes_def by simp
  qed
next
  case (13 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr THIS ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st ) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "v = KValue (address ev)" using expr.simps(5) by (simp split:if_split_asm)
    moreover have "t = Value TAddr" using a1 expr.simps(5) by (simp split:if_split_asm)
    moreover have "typeCon TAddr (address ev) = checkAddress (address ev)" using expr.simps(5) by (simp split:if_split_asm)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      unfolding checkAddress_def using a1 unfolding TypeSafe_def addressFormat_def by simp
  qed
next
  case (14 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr SENDER ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "v = KValue (sender ev)" using expr.simps(6) by (simp split:if_split_asm)
    moreover have "t = Value TAddr" using a1 expr.simps(6) by (simp split:if_split_asm)
    moreover have "typeCon TAddr (sender ev) = checkAddress (sender ev)" using expr.simps(6) by (simp split:if_split_asm)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      unfolding checkAddress_def using a1 unfolding TypeSafe_def addressFormat_def by simp
  qed
next
  case (15 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr VALUE ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "t = Value (TUInt b256)" using expr.simps(7) by (simp split:if_split_asm)
    moreover have "v = KValue(svalue ev)" using a1 expr.simps(7) by (simp split:if_split_asm)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using a1 typeSafeSvalue[of "ev" "(accounts st)" "(stack st)" "(memory st)" "(storage st)" cd] svalueTypes_def by simp
  qed
next
  case (16 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr TRUE ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "t = Value TBool" using expr.simps(8) by (simp split:if_split_asm)
    moreover have "v = KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True)" using a1 expr.simps(8) by (simp split:if_split_asm)
    moreover have "typeCon TBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True) = checkBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True)" using expr.simps(8) by (simp split:if_split_asm)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      unfolding checkBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
  qed
next
  case (17 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr FALSE ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
                \<and> fullyInitialised ev (accounts st) (stack st)"
    then have "t = Value TBool" using expr.simps(9) by (simp split:if_split_asm)
    moreover have "v = KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False)" using a1 expr.simps(9) by (simp split:if_split_asm)
    moreover have "typeCon TBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) = checkBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False)" using expr.simps(9) by (simp split:if_split_asm)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      unfolding checkBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
  qed
next
  case (18 x ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (NOT x) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    moreover have 1: "assert Gas (\<lambda>g. g > costs\<^sub>e (NOT x) ev cd st) g' = Normal ((), g')" using expr.simps(10) a1 by (simp split:if_split_asm)
    moreover have 2: "modify (\<lambda>g. g - costs\<^sub>e (NOT x) ev cd st) g' = Normal ((), g' - costs\<^sub>e (NOT x) ev cd st)" using a1 by simp
    moreover obtain v'' g'' where 3:"expr x ev cd st (g' - costs\<^sub>e (NOT x) ev cd st) = Normal ((KValue v'', Value TBool), g'')" using a1 expr.simps(10) by (simp split:if_split_asm prod.split_asm result.split_asm Stackvalue.split_asm Type.split_asm Types.split_asm)
    ultimately have a5:"v'' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v'' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False" using a1 expr.simps(10) by (simp split:if_split_asm prod.split_asm result.split_asm Stackvalue.split_asm Type.split_asm Types.split_asm)
    then consider (T) "v'' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True" |(F)  "v'' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False" by auto
    then show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
    proof(cases)
      case T
      then have a10:"expr FALSE ev cd st g'' = Normal ((v, t), g)" using 1 2 3 expr.simps(10)[of x ev cd st g'] a1 by simp
      then have "t = Value TBool" using expr.simps(9) by (simp split:if_split_asm)
      moreover have "v = KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False)" using a1 expr.simps(9) a10 by (simp split:if_split_asm)
      moreover have "typeCon TBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) = checkBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False)" using expr.simps(9) by (simp split:if_split_asm)
      ultimately show ?thesis unfolding checkBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    next
      case F
      then have a20:"expr TRUE ev cd st g'' = Normal ((v, t), g)" using 1 2 3 expr.simps(10)[of x ev cd st g'] a1 ReadShow.true_neq_false by simp
      then have "t = Value TBool" using expr.simps(8) by (simp split:if_split_asm)
      moreover have "v = KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True)" using a1 expr.simps(8) a20 by (simp split:if_split_asm)
      moreover have "typeCon TBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True) = checkBool (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True)" using expr.simps(8) by (simp split:if_split_asm)
      ultimately show ?thesis unfolding checkBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    qed
  qed
next
  case (19 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (PLUS e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a2:"lift expr add e1 e2 ev cd st (g' - costs\<^sub>e (PLUS e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(11) a1 by (simp split:if_split_asm)
    moreover obtain t' where  "t = Value t'" using a2 by (auto split:result.splits)
    moreover obtain v' where "v = KValue v'" using a2 by (auto split:result.splits)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using oliftSuccess[of "(+)" e1 e2 ev cd st "(g' - costs\<^sub>e (PLUS e1 e2) ev cd st)" v' t' g] add_def a1 a2 by simp
  qed
next
  case (20 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (MINUS e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a2:"lift expr sub e1 e2 ev cd st (g' - costs\<^sub>e (MINUS e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(12) a1 by (simp split:if_split_asm)
    moreover obtain t' where  "t = Value t'" using a2 by (auto split:result.splits)
    moreover obtain v' where "v = KValue v'" using a2 by (auto split:result.splits)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using oliftSuccess[of "(-)" e1 e2 ev cd st "(g' - costs\<^sub>e (MINUS e1 e2) ev cd st)" v' t' g] sub_def a2 a1 by simp
  qed
next
  case (21 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (LESS e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a2:"lift expr less e1 e2 ev cd st (g' - costs\<^sub>e (LESS e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(13) a1 by (simp split:if_split_asm)
    moreover obtain t' where  "t = Value t'" using a2 by (auto split:result.splits)
    moreover obtain v' where "v = KValue v'" using a2 by (auto split:result.splits)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using pliftSuccess[of "(<)" e1 e2 ev cd st "(g' - costs\<^sub>e (LESS e1 e2) ev cd st)" v' t' g] less_def by simp
  qed
next
  case (22 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (EQUAL e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a2:"lift expr equal e1 e2 ev cd st (g' - costs\<^sub>e (EQUAL e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(14) a1 by (simp split:if_split_asm)
    moreover obtain t' where  "t = Value t'" using a2 by (auto split:result.splits)
    moreover obtain v' where "v = KValue v'" using a2 by (auto split:result.splits)
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using pliftSuccess[of "(=)" e1 e2 ev cd st "(g' - costs\<^sub>e (EQUAL e1 e2) ev cd st)" v' t' g] equal_def by simp
  qed
next
  case (23 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (AND e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a10:"lift expr vtand e1 e2 ev cd st (g' - costs\<^sub>e (AND e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(15) a1 by (simp split:if_split_asm)
    then obtain v1 t1 g'' where a20:"expr e1 ev cd st (g' - costs\<^sub>e (AND e1 e2) ev cd st) = Normal((KValue v1, Value t1), g'')" using lift_def by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
    then obtain v2 t2 g''' where a25:"expr e2 ev cd st g'' = Normal((KValue v2, Value t2), g''')" using lift_def a10 by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
    then obtain v' t' where  a30:"vtand t1 t2 v1 v2 = Some(v', t')" using a10 a20 a25 a1 lift_def by (auto split:option.split_asm)
    then have a90:"KValue v' = v" and a95:"Value t' = t" using a30 a1 a10 a20 a25  by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm option.split_asm)
    then have a100:"(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool" using lift_def[of expr vtand e1 e2 ev cd st] expr.simps(15)[of e1 e2 ev cd st g] vtandTypeOut  a30 a1 a10 a20 a25 by simp
    then show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using a30 vtandTypeCon[of t1 t2 v1 v2 v' t'] a90 a95 a30 a1 a10 a20 a25 a100 by auto
  qed
next
  case (24 e1 e2 ev cd st g')
  show ?case
  proof (intros)
    fix v t g
    assume a1: "expr (OR e1 e2) ev cd st g' = Normal ((v, t), g) \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
\<and> fullyInitialised ev (accounts st) (stack st)"
    then have a10:"lift expr vtor e1 e2 ev cd st (g' - costs\<^sub>e (OR e1 e2) ev cd st) = Normal ((v, t), g)"  using expr.simps(16) a1 by (simp split:if_split_asm)
    then obtain v1 t1 g'' where a20:"expr e1 ev cd st (g' - costs\<^sub>e (OR e1 e2) ev cd st) = Normal((KValue v1, Value t1), g'')" using lift_def by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
    then obtain v2 t2 g''' where a25:"expr e2 ev cd st g'' = Normal((KValue v2, Value t2), g''')" using lift_def a10 by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm)
    then obtain v' t' where  a30:"vtor t1 t2 v1 v2 = Some(v', t')" using a10 a20 a25 a1 lift_def by (auto split:option.split_asm)
    then have a90:"KValue v' = v" and a95:"Value t' = t" using a30 a1 a10 a20 a25 by (auto split:result.split_asm Stackvalue.split_asm Type.split_asm option.split_asm)
    then have a100:"(v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True \<or> v' = ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False) \<and> t' = TBool" using lift_def[of expr vtand e1 e2 ev cd st] expr.simps(16)[of e1 e2 ev cd st g] vtorTypeOut a30 a1 a10 a20 a25 by simp
    then show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow>  MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
      using a30 checkBool_def createBool_def  ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def a90 a95 a30 a1 a10 a20 a25 a100 by auto
  qed
next
  case (25 i ev cd st g')
  show ?case
  proof(intros)
    fix v t g4' assume a1:"local.expr (LVAL i) ev cd st g' = Normal ((v, t), g4') 
                           \<and> TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd
                           \<and> fullyInitialised ev (accounts st) (stack st)"
    obtain v' where "assert Gas ((<) (costs\<^sub>e (LVAL i) ev cd st)) g' = Normal (v', g')"  using a1 25 expr.simps(17) extractValueType.simps by (simp split:if_split_asm option.splits prod.splits)
    moreover obtain v''  g'' where " modify (\<lambda>g. g - costs\<^sub>e (LVAL i) ev cd st) g' = Normal (v'', g'')" using a1 25 expr.simps(17) extractValueType.simps calculation by (simp split:if_split_asm option.splits prod.splits)

    moreover have "rexp i ev cd st g'' = Normal ((v, t), g4')" using a1 25 expr.simps(17) extractValueType.simps calculation by (simp split:if_split_asm option.splits prod.splits)
    ultimately show "
       (case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx)
        | Calldata struct \<Rightarrow>
            MCon struct cd (extractValueType v) \<and>
            (\<exists>xx. v = KCDptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                accessStore stloc (stack st) = Some (KCDptr p) \<and>
                (tp'' = struct \<and> v = KCDptr p \<or>
                 (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow>
            MCon struct (memory st) (extractValueType v) \<and>
            (\<exists>xx. v = KMemptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                accessStore stloc (stack st) = Some (KMemptr p) \<and>
                (tp'' = struct \<and> v = KMemptr p \<or>
                 (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
            SCon struct (extractValueType v) (storage st (address ev)) \<and>
            (\<exists>xx. v = KStoptr xx) \<and>
            (\<exists>stloc tp''.
                (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
                (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))"
      using a1 25(1)[of v' g' v'' g'']  by auto
  qed
next
  case (26 i xe e cd st g)
  show ?case 
  proof (intros)
    fix v t g4' assume a1:"local.expr (CALL i xe) e cd st g = Normal (( v,  t), g4')  \<and> 
                            TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd
                           \<and> fullyInitialised e (accounts st) (stack st)" 
    then obtain v' where  a10:"assert Gas ((<) (costs\<^sub>e (CALL i xe) e cd st)) g = Normal (v', g)" using expr.simps(18) a1 by (simp split:if_split_asm option.splits prod.splits)
    then obtain v'' g'' where a20:"modify (\<lambda>g. g - costs\<^sub>e (CALL i xe) e cd st) g = Normal (v'', g'')" using expr.simps(18) by (simp split:if_split_asm option.splits prod.splits)
    then obtain vb where a30:"option Err (\<lambda>_. ep $$ contract e) g'' = Normal (vb, g'')" using a1 expr.simps(18) by (simp split:if_split_asm option.splits prod.splits)
    then obtain ct dud where a40:"vb = (ct, dud)"  using a1 expr.simps(18) by (simp split:if_split_asm option.splits prod.splits)
    then obtain vc where a50:"(case ct $$ i of None \<Rightarrow> throw Err | Some (Function (fp, True, xa)) \<Rightarrow> throw Err | Some (Function (fp, False, xa)) \<Rightarrow> return (fp, xa) | Some _ \<Rightarrow> throw Err) g'' 
                            = Normal (vc, g'')" using a1 expr.simps(18) a30 by (simp split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits)
    then obtain fp x where a60:"vc = (fp, x)"  using a1 expr.simps(18) a30 a40 by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits)

    then obtain e' where a70:"e' = ffold_init ct (emptyEnv (address e) (contract e) (sender e) (svalue e)) (fmdom ct)" using a1 expr.simps(18) by (simp split:if_split_asm option.splits prod.splits)
    then have "storage st (address e') = storage st (address e)" by simp
    have a72:"(\<exists>c. type (accounts st (address e')) = Some (Contract c) \<and> contract e' = c)" using a1 unfolding fullyInitialised_def a70 by simp
    have e'IsStoreloc:"\<forall>x y . (denvalue e' $$ x = Some y \<longrightarrow> snd y = Storeloc x)" using a70 unfolding ffold_init_def using ffoldInitAllLocsStorage[of ct e e e "svalue e" "fmdom ct"] by simp


(* Load denvalue from e to e' Not including the storage variables *)
    obtain ev cda k m g''' where a80:"load False fp xe e' emptyStore emptyStore (memory st) e cd st g'' = Normal ((ev, cda, k, m), g''')" 
      using expr.simps(18) a1 a10 a20 a30 a40 a50 a60 a70 by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits)
    then have a85:"(\<exists>c. type (accounts st (address ev)) = Some (Contract c) \<and> contract ev = c)" using a72 
      using expressions_with_gas.msel_ssel_expr_load_rexp_gas(4) statement_with_gas_axioms statement_with_gas_def by auto
    have a90:"ep $$ contract e = Some(ct,dud)" using a30 a40 by (simp split:option.splits)
    have a92:"ep $$ contract e' = Some(ct,dud)" using a30 a40 a70 by (simp split:option.splits)
    then have a95:" (\<forall>id v'. ct $$ id = Some (Var v') \<longrightarrow> ((denvalue e') $$ id = Some (Storage v', Storeloc id)))" using a70 ffold_init_fmap unfolding ffold_init_def 
      by (metis emptyEnv_denvalue fmdom_notD fmdom_notI fmempty_lookup not_Some_eq)
    have sameCont:"contract e = contract e' \<and> address e = address e'" using a30 a40 
      by (simp add: a70)
    have a97:"\<forall>id. id |\<in>| fmdom (denvalue e') \<longrightarrow> id |\<in>| fmdom ct" using ffold_init_emptyDen a70 by auto

    have methodVarsNoPref using a1 unfolding TypeSafe_def by simp
    obtain xa ya where  a100:"TypeSafe e' (accounts st) emptyStore (memory st) (storage st) emptyStore 
                                    \<and> (denvalue e' $$ xa = Some ya \<longrightarrow> snd ya = Storeloc xa) \<and> (denvalue e' $$ xa = Some ya \<longrightarrow> (\<exists>t1. ct $$ xa = Some (Var t1) \<and> fst ya = Storage t1))" 
      using  ffoldInitTypeSafe[of "(storage st) "  "accounts st" " (svalue e)" "memory st" e ct dud "address e" "sender e"]  a70 ffold_init_def a1 a90 unfolding TypeSafe_def by simp
    then have a103:"TypeSafe e' (accounts st) emptyStore (memory st) (storage st) emptyStore " by blast

    have a101:" \<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp (memory st) locs" by simp
    have a102: " memory st = memory st" by simp

    have a104:"ncpDenvalueLimit e' e emptyStore (stack st) (memory st)" unfolding ncpDenvalueLimit_def 
    proof intros
      fix tp' locs p i
      assume "(Memory tp', Stackloc locs) |\<in>| fmran (denvalue e') \<and> accessStore locs emptyStore = Some (KMemptr p) \<and> i < toploc (memory st) \<and> LSubPrefL2 p (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
      then show "\<exists>tp'' loc2 p'.
          (Memory tp'', Stackloc loc2) |\<in>| fmran (denvalue e) \<and>
          accessStore loc2 (stack st) = Some (KMemptr p') \<and> (p' = p \<and> tp'' = tp' \<or> (\<exists>len arr. p' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr tp' p' p))" 
        unfolding accessStore_def emptyStore_def by simp
    qed
    have a105:"ncpElementsNoSubPref (memory st) (memory st)" using ncpElementsNoSubPref_sameMem a1 by blast
    have a106:"  ncpOMemInDMem (memory st) (memory st)"
      unfolding ncpOMemInDMem_def by blast
    have ncp:"ncpNewSelfPoint (memory st) (memory st)" unfolding ncpNewSelfPoint_def by auto
    have "(\<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c) \<and>
    (\<forall>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id)))" 
      using a72 a92 a95 a97 AddressTypes_def a1 fmupd_lookup unfolding fullyInitialised_def TypeSafe_def
      by blast
    then have "(\<exists>c. type (accounts st (address e')) = Some (Contract c) \<and> contract e' = c)" using sameCont by simp
    moreover have "(\<forall>id v ct dud. (ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id)))" 
    proof intros
      fix id v ct' dud'
      have in1:"ep $$ contract e' = Some (ct, dud)" using a92 by simp
      show "(ep $$ contract e' = Some (ct', dud') \<and> ct' $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id))"
      proof
        assume "ep $$ contract e' = Some (ct', dud') \<and> ct' $$ id = Some (Var v)"
        then have "ct' = ct" using in1 by auto
        then show "denvalue e' $$ id = Some (Storage v, Storeloc id)" 
          using \<open>ep $$ contract e' = Some (ct', dud') \<and> ct' $$ id = Some (Var v)\<close> a95 by presburger
      next
        assume "denvalue e' $$ id = Some (Storage v, Storeloc id)"
        then show "ep $$ contract e' = Some (ct', dud') \<and> ct' $$ id = Some (Var v)" 
          by (metis
              \<open>(\<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c) \<and> (\<forall>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id)))\<close>
              a70 a90 ffold_init_def ffold_init_emptyDen_ran in1)
      qed
    qed
    moreover have "fullyInitialised e' (accounts st) (stack st)" unfolding fullyInitialised_def 
      using calculation e'IsStoreloc ncp by fastforce
    moreover have "fullyInitialised e' (accounts st) emptyStore" unfolding fullyInitialised_def 
      using calculation e'IsStoreloc by fastforce
    ultimately have a110:"TypeSafe ev (accounts st) k m (storage st) cda \<and>  fullyInitialised ev (accounts st) k"
      using "26.hyps"(1)[OF a10 _ a30 a40 a50 a60 a70 ] a20 a80 a90  a101 a102 a100 a103 a104 a105 a106 a1 ncp by auto


    have a120:"expr x ev cda (st\<lparr>stack := k, memory := m\<rparr>) g''' = Normal ((v, t), g4')" using a1 expr.simps(18) a10 a20 a30 a40 a50 a60 a70 a80 a90 by (auto split:option.split_asm Stackvalue.split_asm result.split_asm if_split_asm)
    then have a125:"(case v of KValue x \<Rightarrow> return (v,t)
      | KCDptr cdloc \<Rightarrow>  throw Err
      | KMemptr memloc \<Rightarrow> throw Err
      | KStoptr storloc \<Rightarrow> return (v, t)) g4' = Normal ((v, t), g4')" using a1 expr.simps(18) a10 a20 a30 a40 a50 a60 a70 a80 a90 by (auto split:if_splits option.splits Stackvalue.splits Member.splits prod.splits result.splits bool.splits)
    then have a127:"TypeSafe ev (accounts (st\<lparr>stack := k, memory := m\<rparr>))
                            (stack (st\<lparr>stack := k, memory := m\<rparr>)) 
                            (memory (st\<lparr>stack := k, memory := m\<rparr>)) 
                            (storage (st\<lparr>stack := k, memory := m\<rparr>)) cda" using a110 by simp
    then have a128:"TypeSafe ev (accounts st) k m (storage st) cda" by simp
    have "(\<forall>id ct dud v. ep $$ contract ev = Some (ct, dud) \<and> ct $$ id = Some (Var v) \<longrightarrow> (\<exists>t. denvalue ev $$ id = Some (Storage t, Storeloc id)))" using a80 a95 load_denval_existing_remain
      by (metis a92 fst_eqD msel_ssel_expr_load_rexp_gas(4) option.inject)
    then have "fullyInitialised ev (accounts st) k"using a110 by simp
    then have a130:"(case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and>  (\<exists>xx. v = KValue xx)
        | Calldata struct \<Rightarrow> MCon struct cda (extractValueType v) \<and>  (\<exists>xx. v = KCDptr xx)
              \<and> (\<exists>stloc tp'' p.
                (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                accessStore stloc (stack (st\<lparr>stack := k, memory := m\<rparr>)) = Some (KCDptr p) \<and>
                (tp'' = struct \<and> v = (KCDptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cda len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow> MCon struct (memory (st\<lparr>stack := k, memory := m\<rparr>)) (extractValueType v) \<and>  (\<exists>xx. v = KMemptr xx)
              \<and> (\<exists>stloc tp'' p.
                (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                accessStore stloc (stack (st\<lparr>stack := k, memory := m\<rparr>)) = Some (KMemptr p) \<and>
        (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>stack := k, memory := m\<rparr>)) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage (st\<lparr>stack := k, memory := m\<rparr>) (address ev)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp'' .
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> (extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))))"
      using "26.hyps"(2) a1 a10 a20 a30 a40 a50 a60 a70 a80 a85 a90 a120  a128 by simp

    then show " case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx)
       | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) \<and> (\<exists>xx. v = KCDptr xx) \<and> (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = (KCDptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow> MCon struct (memory st) (extractValueType v) \<and> (\<exists>xx. v = KMemptr xx)
            \<and> (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address e)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" 
    proof(cases t) 
      case (Value x1)
      then show ?thesis using a130 by simp
    next
      case (Calldata x2)

      then show ?thesis using Calldata a1 expr.simps(18)[of i xe e cd st g ] a130 a10 a20 a30 a40 a50 a60 a70 
        by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Stackvalue.splits)
    next
      case (Memory x3)
      then show ?thesis using Memory a1 expr.simps(18)[of i xe e cd st g ] a130 a10 a20 a30 a40 a50 a60 a70 
        by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Stackvalue.splits)
    next
      case (Storage x4)
      have sameAddress:"address ev = address e" using a80 a70 by (simp add:msel_ssel_expr_load_rexp_gas(4))

      have "(\<forall>c' adv'.  type (accounts st adv') = Some (Contract c') \<and> (address e) = adv' \<longrightarrow> c' = contract e)" 
        using a1 a30 unfolding TypeSafe_def  
        using fullyInitialised_def by simp

      have " ep $$ contract e' = Some (ct, dud)" using a90 a70 by simp
      then have "(\<forall>t l. (Storage t, Storeloc l) |\<in>| fmran (denvalue e') \<longrightarrow> ct $$ l = Some (Var t))" 
        by (metis Denvalue.inject(2)
            \<open>\<forall>id v ct dud. (ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id))\<close>
            e'IsStoreloc fmranE snd_conv)
      then have a700:"\<forall>t l.  (Storage t, Storeloc l) |\<in>| fmran (denvalue ev) \<longrightarrow> (Storage t, Storeloc l) |\<in>| fmran (denvalue e')" 
        using a80  load_denval_existing_remain(4)  load_denval_storage_remain(4) 
        by (meson fmlookup_ran_iff)
      then have a500:"SCon x4 (extractValueType v) (storage (st\<lparr>stack := k, memory := m\<rparr>) (address ev)) \<and>
        (\<exists>xx. v = KStoptr xx) \<and>
        (\<exists>stloc tp'' .
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
            (tp'' = x4 \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v)))"
        using a130 Storage by simp 
      then obtain stloc tp'' where def:"(Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
            (tp'' = x4 \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v))" using a110 by auto
      then have a550:"tp'' = x4 \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v)" using def by simp
      have "(Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev)" using  def by auto
      then have "(Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e')" using a110 def  a700 by simp
      then have "(Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e)" using a100 a1 
          Member.inject(3) a90 fmranI fullyInitialised_def 
        by (metis (mono_tags, lifting) \<open>\<forall>t l. (Storage t, Storeloc l) |\<in>| fmran (denvalue e') \<longrightarrow> ct $$ l = Some (Var t)\<close>)


      then show ?thesis using Storage a130  def a550 sameAddress by fastforce
    qed
  qed

next
  case (27 ad i xe e cd st g)
  show ?case
  proof (intros)
    fix v t g4' assume a1: "local.expr (ECALL ad i xe) e cd st g = Normal ((v, t), g4') \<and>
       TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd \<and> fullyInitialised e (accounts st) (stack st)"

    then obtain v' where  a10:"assert Gas ((<) (costs\<^sub>e (ECALL ad i xe) e cd st)) g = Normal (v', g)" using expr.simps(19) by (simp split:if_split_asm option.splits prod.splits)
    then obtain v'' g'' where a20:"modify (\<lambda>g. g - costs\<^sub>e (ECALL ad i xe) e cd st) g = Normal (v'', g'')" using expr.simps(19) by (simp split:if_split_asm option.splits prod.splits)
    then obtain g''' kad where a30:"expr ad e cd st g'' = Normal (kad, g''')"  using expr.simps(19) a1 by (simp split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits)
    then obtain adv g'''' where a40:"(case kad of (KValue adv, Value TAddr) \<Rightarrow> return adv | _ \<Rightarrow> throw Err) g''' = Normal (adv, g'''')" using expr.simps(19) a1 a20 
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then have a50:"adv \<noteq> address e" using expr.simps(19) a1 a20 a30
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then obtain c ga5 where a60:"(case type (accounts st adv) of Some (Contract c) \<Rightarrow> return c | _ \<Rightarrow> throw Err) g'''' = Normal (c, ga5)" using expr.simps(19) a1 a20 a30 a40 a50
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then obtain vb where a70:"option Err (\<lambda>_. ep $$ c) ga5 = Normal (vb, ga5)" 
      using a1 expr.simps(19) a20 a30 a40 a50 by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then obtain ct dud where a80:"vb = (ct, dud)"  using a1 expr.simps(19)  a20 a30 a40 a50 
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then obtain fp x where a90:"(case ct $$ i of Some (Function (fp, True, x)) \<Rightarrow> return (fp, x) | _ \<Rightarrow> throw Err) ga5
                            = Normal ((fp ,x), ga5)" using a1 expr.simps(19)  a20 a30 a40 a50 a60 a70
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits Type.splits)
    then obtain e' where a100:"e' = ffold_init ct (emptyEnv adv c (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t 0)) (fmdom ct)" using a1 expr.simps(19) by (simp split:if_split_asm option.splits prod.splits)
    then obtain ev cda k m ga6 where a110:"load True fp xe e' emptyStore emptyStore emptyStore e cd st ga5 = Normal ((ev, cda, k, m), ga6)" 
      using expr.simps(19) a1 a10 a20 a30 a40 a50 a60 a70 a80 a90 by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits)
    have a120:"ep $$  c = Some(ct,dud)" using a80 a70 by (simp split:option.splits)

    then obtain contracte::Environment where a125:"c = (contract contracte)"
      by (metis Environment.select_convs(2))
    have c1:" safeContract (storage st)" using a1 unfolding TypeSafe_def by simp
    have c2:"balanceTypes (accounts st)" using a1 unfolding TypeSafe_def by simp   
    then have "typeCon (TUInt b256) (ShowL\<^sub>n\<^sub>a\<^sub>t 0)" 
      using checkUInt_def[of b256 "STR ''0''"] by Solidity_Symbex.solidity_symbex

    then have c3:"svalueTypes (ShowL\<^sub>n\<^sub>a\<^sub>t 0)" by (simp add: svalueTypes_def)
    have c4:"methodVarsNoPref" using a1 unfolding TypeSafe_def by simp
    have c15:"AddressTypes (accounts st)" using a1 unfolding TypeSafe_def by simp 
    then have c5:"\<forall>c adv ct dud. type (accounts st adv) = Some (Contract c) \<longrightarrow> ep $$ c = Some (ct,dud) \<and> addressFormat adv" unfolding AddressTypes_def using a125 a70 a120 by blast

    have c6:"lessThanTopLocs emptyStore" using emptyTopLocs by simp

    obtain xa ya where a130:"TypeSafe e' (accounts st) emptyStore emptyStore (storage st) emptyStore
                                    \<and> (denvalue e' $$ xa = Some ya \<longrightarrow> snd ya = Storeloc xa)
                                    \<and> (denvalue e' $$ xa = Some ya \<longrightarrow> (\<exists>t1. ct $$ xa = Some (Var t1) \<and> fst ya = Storage t1))
\<and> (\<forall>t l p.
        (Storage t, Stackloc l) |\<in>| fmran (denvalue e') \<longrightarrow>
        accessStore l (stack st) = Some (KStoptr p) \<longrightarrow> (\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t l' p))" 
      using c3 a1 a120 a125 a100 unfolding fullyInitialised_def 
      by (metis accessStore_def accessStore_updateStore c5 fmempty_lookup option.distinct(1))


    have ttt:"(\<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c) \<and>
  (\<forall>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))) \<and>
  (\<forall>t l p.
      (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack st) = Some (KStoptr p) \<longrightarrow>
      (\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p))" 
      using a1 unfolding fullyInitialised_def 
      using c5 by force

    have "contract ev = contract e'" using a110 
      by (simp add: msel_ssel_expr_load_rexp_gas(4))
    then have "contract ev = c" using a100 by simp

    have h1:"(\<exists>c. type (accounts (st\<lparr>stack := k, memory := m\<rparr>) (address ev)) = Some (Contract c) \<and> contract ev = c)" 
      using a1 a70  unfolding fullyInitialised_def
      by (smt (z3) c5 fmempty_lookup fmupd_lookup not_None_eq option.inject prod.inject)
    then have a95:" (\<forall>id v'. ct $$ id = Some (Var v') \<longrightarrow> ((denvalue e') $$ id = Some (Storage v', Storeloc id)))" 
      using a100 ffold_init_fmap unfolding ffold_init_def 
      by (simp add: ffold_init_fmdom)
    then have h2:"(\<forall>id ct dud v. ep $$ contract ev = Some (ct, dud) \<and> ct $$ id = Some (Var v) \<longrightarrow> 
                    (\<exists>t. denvalue ev $$ id = Some (Storage t, Storeloc id)))" 
      using a100 a110 a90 load_denval_existing_remain(4)[of True fp xe e' emptyStore emptyStore emptyStore e cd st ga5 ev cda k m ga6] 
      by (metis \<open>contract ev = c\<close> a120 option.inject prod.inject)


    have adde':"address e' = adv" 
      by (simp add: a100)
    have e'IsC:"contract e' = c" using a100 by simp
    have "type (accounts st (address e')) = Some (Contract c)" using adde' a60 by (simp split:option.splits atype.splits)
    then have "(\<exists>c. type (accounts st (address e')) = Some (Contract c) \<and> contract e' = c)" using adde' e'IsC by blast
    moreover have "(\<forall>id ct dud v. ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v) \<longrightarrow> (denvalue e' $$ id = Some (Storage v, Storeloc id)))" 
      using \<open>contract ev = c\<close> \<open>contract ev = contract e'\<close> a120 a95 by simp
    moreover have "fullyInitialised e' (accounts st) emptyStore" unfolding fullyInitialised_def 
    proof intros
      show "\<exists>c. type (accounts st (address e')) = Some (Contract c) \<and> contract e' = c" using calculation(1) by simp
      show "\<And>id ct dud v. (ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id))"
        using \<open>contract ev = c\<close> \<open>contract ev = contract e'\<close> a120 a95 
        using a100 c5 ffold_init_emptyDen_ran ttt by force
      fix t l p 
      assume a1:"(Storage t, Stackloc l) |\<in>| fmran (denvalue e') \<and> accessStore l emptyStore = Some (KStoptr p)"
      then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t l' p"
        unfolding accessStore_def emptyStore_def by simp
    qed

    ultimately have a140:"TypeSafe ev (accounts st) k m (storage st) cda \<and> fullyInitialised ev (accounts st) k"
      using "27.hyps"(2)[OF a10 _ a30 a40 _ a60 a70 a80 a90 _ a100, of v'' _ fp ] a1 a20 a50 a110 a120 a130 by auto

    have a150:"expr x ev cda (st\<lparr>stack := k, memory := m\<rparr>) ga6 = Normal ((v, t), g4')"
      using a1 expr.simps(19)[of ad i xe e cd st g ] a10 a20 a30 a40 a50 a60 a70 a80 a90 a100 a110 a120 a130 
      by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits atype.splits Type.splits Stackvalue.splits)
    then have a160:"(case v of KValue x \<Rightarrow> return (v,t)
      | KCDptr cdloc \<Rightarrow> throw Err
      | KMemptr memloc \<Rightarrow> throw Err
      | KStoptr storloc \<Rightarrow> throw Err) g4' = Normal ((v, t), g4')" using a1 expr.simps(19) a10 a20 a30 a40 a50 a60 a70 a80 a90 
      by (auto split:if_splits option.splits Stackvalue.splits Member.splits prod.splits result.splits bool.splits)

    then have "TypeSafe ev (accounts (st\<lparr>stack := k, memory := m\<rparr>))
                            (stack (st\<lparr>stack := k, memory := m\<rparr>)) 
                            (memory (st\<lparr>stack := k, memory := m\<rparr>)) 
                            (storage (st\<lparr>stack := k, memory := m\<rparr>)) cda" using a160 a140 by simp

    then have a170:"(case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and>  (\<exists>xx. v = KValue xx)
        | Calldata struct \<Rightarrow> MCon struct cda (extractValueType v) \<and>  (\<exists>xx. v = KCDptr xx)
\<and> (\<exists>stloc tp'' p.
                  (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                  accessStore stloc (stack (st\<lparr>stack := k, memory := m\<rparr>)) = Some (KCDptr p) \<and>
  (tp'' = struct \<and> v = (KCDptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cda len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow> MCon struct (memory (st\<lparr>stack := k, memory := m\<rparr>)) (extractValueType v) \<and>  (\<exists>xx. v = KMemptr xx)
                \<and> (\<exists>stloc tp'' p.
                  (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue ev) \<and>
                  accessStore stloc (stack (st\<lparr>stack := k, memory := m\<rparr>)) = Some (KMemptr p) \<and>
  (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>stack := k, memory := m\<rparr>)) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
            SCon struct (extractValueType v) (storage (st\<lparr>stack := k, memory := m\<rparr>) (address ev)) \<and>
            (\<exists>xx. v = KStoptr xx) \<and>
            (\<exists>stloc tp'' .
                (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue ev) \<and>
                (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))"
      using "27.hyps"(3)[of v' g v'' g'' kad g''' adv g'''' _ _ c ga5 vb ga5 ct dud "(fp,x)" ga5 fp x e' "(ev, cda, k, m)" ga6 ev "(cda, k, m)" cda "(k,m)" k m ] 
        a1 a10 a20 a30 a40 a50 a60 a70 a80 a90 a100 a110 a120 a130 a140 a150 a160 h1 h2 by simp

    then show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = KMemptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address e)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> (extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))" 
    proof(cases t) 
      case (Value x1)
      then show ?thesis using a170 by simp
    next
      case (Calldata x2)
      then show ?thesis using Calldata a1 expr.simps(19)[of ad i xe e cd st g ] a10 a20 a30 a40 a50 a60 a70 a80 a90 a100 a110 a120 a130 a140 a150 a160 a170
        by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits atype.splits Type.splits Stackvalue.splits)
    next
      case (Memory x3)
      then show ?thesis using Memory a1 expr.simps(18)[of i xe e cd st g ]a10 a20 a30 a40 a50 a60 a70 a80 a90 a100 a110 a120 a130 a140 a150 a160 a170
        by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits atype.splits Type.splits Stackvalue.splits)
    next
      case (Storage x4)
      then show ?thesis using a1 expr.simps(18)[of i xe e cd st g ]a10 a20 a30 a40 a50 a60 a70 a80 a90 a100 a110 a120 a130 a140 a150 a160 a170
        by (auto split:if_split_asm option.splits prod.splits Member.splits result.split_asm bool.splits atype.splits Type.splits Stackvalue.splits)
    qed

  qed

next
  case (28 cp i\<^sub>p t\<^sub>p pl ex el e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g)
  show ?case
  proof(intros)
    fix ev cda k m g' loc t ls tp locs ct dud id' v''
    assume "load cp ((i\<^sub>p, t\<^sub>p) # pl) (ex # el) e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g = Normal ((ev, cda, k, m), g') \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) \<and>
        toploc (memory st) \<le> toploc mem' \<and>
        ncpDenvalueLimit e\<^sub>v' e\<^sub>v sck' (stack st) (memory st)  \<and>
        ncpOMemInDMem (memory st) mem' \<and> ncpElementsNoSubPref (memory st) mem' \<and> ncpNewSelfPoint (memory st) mem'
        ) \<and>
       TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and>
       TypeSafe e\<^sub>v' (accounts st) sck' mem' (storage st) cd' \<and>
       fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e\<^sub>v' (accounts st) sck'"
    then have as1: "local.load cp ((i\<^sub>p, t\<^sub>p) # pl) (ex # el) e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g = Normal ((ev, cda, k, m), g')" 
      and as2:"(\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) \<and> toploc (memory st) \<le> toploc mem' \<and>
        ncpDenvalueLimit e\<^sub>v' e\<^sub>v sck' (stack st) (memory st) \<and> ncpOMemInDMem (memory st) mem' 
        \<and> ncpElementsNoSubPref (memory st) mem' 
        \<and> ncpNewSelfPoint (memory st) mem' )" 
      and as6:"TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and> TypeSafe e\<^sub>v' (accounts st) sck' mem' (storage st) cd'" 
      and as7:"fullyInitialised e\<^sub>v (accounts st) (stack st)"
      and as8:"fullyInitialised e\<^sub>v' (accounts st) sck'"by blast+
    then have a2:"TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd"  by blast
    then obtain x g4' where a7:"expr ex e\<^sub>v cd st g = Normal (x, g4')" 
      using as1 load.simps(1)[of cp i\<^sub>p t\<^sub>p  pl ex  el e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g] 
      by (simp split: Type.splits result.splits prod.splits option.splits)
    then have  a8:"\<exists>v t. expr ex e\<^sub>v cd st g = Normal ((v, t), g4')" using as1 by simp
    then obtain v t where a10:"expr ex e\<^sub>v cd st g = Normal ((v, t), g4')"  
      using as1 load.simps(1)[of cp i\<^sub>p t\<^sub>p  pl ex  el e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g] 
      by (auto split: result.splits prod.splits option.splits)
    then obtain c m' k' e where a15:"decl i\<^sub>p t\<^sub>p (Some (v,t)) cp cd (memory st)  (storage st (address e\<^sub>v)) (cd', mem',  sck', e\<^sub>v') = Some (c, m', k', e)"
      using as1 load.simps(1) by (auto split: Type.splits result.splits prod.splits option.splits)
    have a18: "(if \<not>cp then (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) else True)" using as1 as2 by simp
    then have a20:"load cp pl el e c k' m' e\<^sub>v cd st g4' = Normal ((ev, cda, k, m), g')"  
      using as1 load.simps(1)[of cp i\<^sub>p t\<^sub>p  pl ex  el e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g] a10 a15 
      by (simp split:Type.splits if_splits option.splits)

    have "address e = address e\<^sub>v'" using a15 
      by (simp add: decl_env)
    moreover have "contract e = contract e\<^sub>v'" using a15 
      using decl_env by auto


    have none:"denvalue e\<^sub>v' $$ i\<^sub>p = None" using as1 unfolding load.simps by (auto split:option.splits Type.splits)
    have tpNSto:"\<forall>x. t\<^sub>p \<noteq> Storage x" using as1 load.simps by auto

    then have cc0:"TypeSafe ev (accounts st) k m (storage st) cda                   
                  \<and> (\<not> cp \<longrightarrow> (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and> 
                                toploc (memory st) \<le> toploc m \<and> ncpElementsNoSubPref (memory st) m 
\<and> ncpOMemInDMem (memory st) m
\<and> ncpNewSelfPoint (memory st) m \<and> ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st))
\<and> fullyInitialised ev (accounts st) k
"  
    proof(cases t\<^sub>p)
      case (Value x1)
      have fiE:"fullyInitialised e (accounts st) k'" unfolding fullyInitialised_def
      proof intros
        show " \<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c" 
          using \<open>contract e = contract e\<^sub>v'\<close> as8 calculation fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using  \<open>contract e = contract e\<^sub>v'\<close> a15 as8 decl_env_monotonic decl_env_not_i decl_env_storlocs_unchanged  unfolding fullyInitialised_def
          by (smt (z3))
        fix t l p 
        assume cc1:"(Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l k' = Some (KStoptr p)"
        then obtain ii where iidef:"(denvalue e) $$ ii = Some (Storage t, Stackloc l)" by blast
        then have "accessStore l sck' = accessStore l k'" using Value a15 decl_StorageStack_options[OF a15 _ iidef ] cc1 by simp
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p" 
          using as8 unfolding fullyInitialised_def  using cc1 
          by (smt (z3) a15  decl_env_monotonic decl_env_not_i decl_env_storage fmlookup_ran_iff iidef none tpNSto)

      qed

      then have a22:"(case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) \<and> (\<exists>xx. v = KCDptr xx) \<and> (\<exists>stloc tp'' p.
                (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KCDptr p) \<and>
                (tp'' = struct \<and> v = (KCDptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow>
            MCon struct (memory st) (extractValueType v) \<and>
            (\<exists>xx. v = KMemptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KMemptr p) \<and>
                (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr. (extractValueType v) \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
            SCon struct (extractValueType v) (storage st (address e\<^sub>v)) \<and>
            (\<exists>xx. v = KStoptr xx) \<and>
            (\<exists>stloc tp'' .
                (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))" 
        using as6 a10 "28.hyps"(1)[of x1] a18 Value none as7 as8 by simp
      then have a25:" case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) | Memory struct \<Rightarrow> MCon struct (memory st) (extractValueType v)
      | Storage struct \<Rightarrow> SCon struct (extractValueType v) (storage st (address e\<^sub>v))" by (simp split:Type.splits)
      have a26:"\<forall>struct.
       t = Memory struct \<longrightarrow>
       (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore stloc (stack st) = Some (KMemptr p) \<and> (tp'' = struct \<and> v = (KMemptr p)
      \<or> (\<exists>len arr. (extractValueType v) \<noteq> p  \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))" using a22 by auto
      have a27:"\<forall>struct. t = Calldata struct \<longrightarrow>
      
      (\<exists>stloc tp'' p.
          (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
          accessStore stloc (stack st) = Some (KCDptr p) \<and>
          (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))" using a22 by auto
      have a28:" \<forall>struct.
       t = Storage struct \<longrightarrow>
       (\<exists>stloc tp'' .
           (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
           (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" using a22 by auto
      have a30:"TypeSafe e (accounts st) k' m' (storage st) c \<and>
    (\<not> cp \<longrightarrow>
     (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
     toploc (memory st) \<le> toploc m' \<and>
     ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) \<and>
     ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
    toploc mem' \<le> toploc m'"
        using typeSafeDecl[of e\<^sub>v st cd v t  e\<^sub>v' sck' mem' cd' i\<^sub>p t\<^sub>p cp c m' k' e] a2 as1 as2  a15 a25 Value a18 a26 as6 a27 a28 fiE by blast

      have cc1:"\<forall>ev cda k m g'.
       local.load cp pl el e c k' m' e\<^sub>v cd st g4' = Normal ((ev, cda, k, m), g') \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
        toploc (memory st) \<le> toploc m' \<and>
        ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
       TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and>
       TypeSafe e (accounts st) k' m' (storage st) c \<and> fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e (accounts st) k' \<longrightarrow>
       TypeSafe ev (accounts st) k m (storage st) cda \<and>
      fullyInitialised ev (accounts st) k \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and> ncpElementsNoSubPref (memory st) m \<and> ncpNewSelfPoint (memory st) m)"   
        using "28.hyps"(2)[of x1 "(v,t)" g4' v t "(c, m', k', e)" g4' c "(m', k', e)" m' "(k', e)" k' e] a10 a15  a7 Value a2 as1 as2  as6 as7 as8 none by force
      then have cc2:"TypeSafe ev (accounts st) k m (storage st) cda \<and>       
       fullyInitialised ev (accounts st) k \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and> ncpElementsNoSubPref (memory st) m \<and> ncpNewSelfPoint (memory st) m)"
        using a20 a2 as1 a30 as7 as8 fiE  by simp

      moreover have "TypeSafe ev (accounts st) k m (storage st ) cda" using cc2 by simp
      
      ultimately show " TypeSafe ev (accounts st) k m (storage st) cda \<and>
          (\<not> cp \<longrightarrow>
           (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
           toploc (memory st) \<le> toploc m \<and>
           ncpElementsNoSubPref (memory st) m \<and>
           ncpOMemInDMem (memory st) m \<and> ncpNewSelfPoint (memory st) m \<and> ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st)) \<and>
          fullyInitialised ev (accounts st) k" 
        using fmsubset_alt_def cc2 fmsubset_pred by meson
    next
      case (Calldata x2)
      have fiE:"fullyInitialised e (accounts st) k'" unfolding fullyInitialised_def
      proof intros
        show " \<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c" 
          using \<open>contract e = contract e\<^sub>v'\<close> as8 calculation fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using  \<open>contract e = contract e\<^sub>v'\<close> a15 as8 decl_env_monotonic decl_env_not_i decl_env_storlocs_unchanged unfolding fullyInitialised_def
          by (smt (z3))
        fix t l p 
        assume cc1:"(Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l k' = Some (KStoptr p)"
        then obtain ii where iidef:"(denvalue e) $$ ii = Some (Storage t, Stackloc l)" by blast
        then have "accessStore l sck' = accessStore l k'" using Calldata a15 decl_StorageStack_options[OF a15 _ iidef ]cc1  by simp
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p" 
          using as8 unfolding fullyInitialised_def using cc1
          by (smt (z3)
              \<open>local.load cp ((i\<^sub>p, t\<^sub>p) # pl) (ex # el) e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g = Normal ((ev, cda, k, m), g') \<and> (\<not> cp \<longrightarrow> (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) \<and> toploc (memory st) \<le> toploc mem' \<and> ncpDenvalueLimit e\<^sub>v' e\<^sub>v sck' (stack st) (memory st) \<and> ncpOMemInDMem (memory st) mem' \<and> ncpElementsNoSubPref (memory st) mem' \<and> ncpNewSelfPoint (memory st) mem') \<and> TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and> TypeSafe e\<^sub>v' (accounts st) sck' mem' (storage st) cd' \<and> fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e\<^sub>v' (accounts st) sck'\<close>
              a20  fmlookup_ran_iff iidef load_denval_existing_remain(4) load_denval_storage_remain(4))

      qed
      then have a22:"(case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) \<and> (\<exists>xx. v = KCDptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KCDptr p) \<and>
                (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow>
            MCon struct (memory st) (extractValueType v) \<and>
            (\<exists>xx. v = KMemptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KMemptr p) \<and>
                (tp'' = struct \<and> v = KMemptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
            SCon struct (extractValueType v) (storage st (address e\<^sub>v)) \<and>
            (\<exists>xx. v = KStoptr xx) \<and>
            (\<exists>stloc tp''.
                (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))" 
        using as6 a10 "28.hyps"(3)[of x2] a18 Calldata as7 as8 none by simp
      then have a25:" case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) | Memory struct \<Rightarrow> MCon struct (memory st) (extractValueType v)
      | Storage struct \<Rightarrow> SCon struct (extractValueType v) (storage st (address e\<^sub>v))" by (simp split:Type.splits)
      have a26:"\<forall>struct.
       t = Memory struct \<longrightarrow>
       (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore stloc (stack st) = Some (KMemptr p) \<and> (tp'' = struct \<and> v = (KMemptr p)
      \<or> (\<exists>len arr.  extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))" using a22 by auto
      have a27:"\<forall>struct. t = Calldata struct \<longrightarrow>
      
      (\<exists>stloc tp'' p.
          (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
          accessStore stloc (stack st) = Some (KCDptr p) \<and>
          (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))" using a22 by auto

      have a28:" \<forall>struct.
       t = Storage struct \<longrightarrow>
       (\<exists>stloc tp''.
           (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
           (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" using a22 by auto
      have a30:"TypeSafe e (accounts st) k' m' (storage st) c \<and>
    (\<not> cp \<longrightarrow>
     (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
     toploc (memory st) \<le> toploc m' \<and>
     ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) \<and>
     ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
    toploc mem' \<le> toploc m'"
        using typeSafeDecl[of e\<^sub>v st cd v t  e\<^sub>v' sck' mem' cd' i\<^sub>p t\<^sub>p cp c m' k' e] a2 as1 as2  a15 a25 Calldata a18 a26 as6  a27 a28 by blast

      have cc1:"\<forall>ev cda k m g'.
       local.load cp pl el e c k' m' e\<^sub>v cd st g4' = Normal ((ev, cda, k, m), g') \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
        toploc (memory st) \<le> toploc m' \<and> ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) 
        \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
       TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and> TypeSafe e (accounts st) k' m' (storage st) c \<and>
        fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e (accounts st) k'
\<longrightarrow>
       TypeSafe ev (accounts st) k m (storage st) cda \<and> 
       fullyInitialised ev (accounts st) k
\<and> (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and>
        ncpElementsNoSubPref (memory st) m \<and>
        ncpNewSelfPoint (memory st) m)"  
        using "28.hyps"(4)[of x2 "(v,t)" g4' v t "(c, m', k', e)" g4' c "(m', k', e)" m' "(k', e)" k' e] a10 a15  a7 Calldata a2 as1 as2  as6 as7 as8 none by force
      then have cc2:"TypeSafe ev (accounts st) k m (storage st) cda \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and> ncpElementsNoSubPref (memory st) m \<and> ncpNewSelfPoint (memory st) m)
\<and>
       fullyInitialised ev (accounts st) k"
        using a20 a2 as1 a30 as7 as8  fiE by simp
      moreover have "TypeSafe ev (accounts st) k m (storage st ) cda" using a20  a2 as1 a30 cc1 
        using cc2 by blast
      ultimately show "TypeSafe ev (accounts st) k m (storage st ) cda 
\<and> (\<not> cp \<longrightarrow>
           (\<forall>locs tp.
               MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
           toploc (memory st) \<le> toploc m \<and>
           ncpElementsNoSubPref (memory st) m \<and>  ncpOMemInDMem (memory st) m \<and>
           ncpNewSelfPoint (memory st) m \<and>
           ncpDenvalueLimit ev e\<^sub>v k (stack st)(memory st))\<and> 
          fullyInitialised ev (accounts st) k"
        using fmsubset_alt_def cc2 fmsubset_pred 
        by meson

    next
      case (Memory x3)
      have fiE:"fullyInitialised e (accounts st) k'" unfolding fullyInitialised_def
      proof intros
        show " \<exists>c. type (accounts st (address e)) = Some (Contract c) \<and> contract e = c" 
          using \<open>contract e = contract e\<^sub>v'\<close> as8 calculation fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using \<open>contract e = contract e\<^sub>v'\<close> a15 as8 decl_env_monotonic decl_env_not_i decl_env_storlocs_unchanged
          unfolding fullyInitialised_def 
          by (smt (z3))
        fix t l p 
        assume cc1:"(Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l k' = Some (KStoptr p)"
        then obtain ii where iidef:"(denvalue e) $$ ii = Some (Storage t, Stackloc l)" by blast
        then have "accessStore l sck' = accessStore l k'" using Memory a15 decl_StorageStack_options[OF a15 _ iidef ] cc1 by simp
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p" 
          using as8 cc1 unfolding fullyInitialised_def 
          by (smt (z3) a15  decl_env_monotonic decl_env_not_i decl_env_storage fmlookup_ran_iff iidef none tpNSto)

      qed
      then have a22:"(case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx) 
        | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) \<and> (\<exists>xx. v = KCDptr xx)\<and>
            (\<exists>stloc tp'' p.
                (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KCDptr p) \<and>
                (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
        | Memory struct \<Rightarrow>
            MCon struct (memory st) (extractValueType v) \<and>
            (\<exists>xx. v = KMemptr xx) \<and>
            (\<exists>stloc tp'' p.
                (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                accessStore stloc (stack st) = Some (KMemptr p) \<and>
                (tp'' = struct \<and> v = (KMemptr p) \<or> (\<exists>len arr.  extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
        | Storage struct \<Rightarrow>
            SCon struct (extractValueType v) (storage st (address e\<^sub>v)) \<and>
            (\<exists>xx. v = KStoptr xx) \<and>
            (\<exists>stloc tp''.
                (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v))))" 
        using as6 a10 "28.hyps"(5)[of x3] a18 Memory as7 as8 none by blast
      then have a25:" case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v) | Memory struct \<Rightarrow> MCon struct (memory st) (extractValueType v)
      | Storage struct \<Rightarrow> SCon struct (extractValueType v) (storage st (address e\<^sub>v))" by (simp split:Type.splits)
      have a26:"\<forall>struct.
       t = Memory struct \<longrightarrow>
       (\<exists>stloc tp'' p. (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore stloc (stack st) = Some (KMemptr p) \<and> (tp'' = struct \<and> v = (KMemptr p)
      \<or> (\<exists>len arr.  extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))" using a22 by auto
      have a27:"\<forall>struct. t = Calldata struct \<longrightarrow>
      (\<exists>stloc tp'' p.
          (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
          accessStore stloc (stack st) = Some (KCDptr p) \<and>
          (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))" using a22 by auto
      have a28:" \<forall>struct.
       t = Storage struct \<longrightarrow>
       (\<exists>stloc tp''.
           (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
           (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" using a22 by auto
      have a30:" TypeSafe e (accounts st) k' m' (storage st) c \<and>
    (\<not> cp \<longrightarrow>
     (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
     toploc (memory st) \<le> toploc m' \<and>
     ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) \<and>
     ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
    toploc mem' \<le> toploc m'"
        using typeSafeDecl[of e\<^sub>v st cd v t  e\<^sub>v' sck' mem' cd' i\<^sub>p t\<^sub>p cp c m' k' e] a2 as1 as2  a15 a25 Memory a18 a26 as6 a27 a28 by blast

      have cc1:"\<forall>ev cda k m g'.
       local.load cp pl el e c k' m' e\<^sub>v cd st g4' = Normal ((ev, cda, k, m), g') \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m' locs) \<and>
        toploc (memory st) \<le> toploc m' \<and> ncpDenvalueLimit e e\<^sub>v k' (stack st) (memory st) \<and> ncpOMemInDMem (memory st) m' \<and> ncpElementsNoSubPref (memory st) m' \<and> ncpNewSelfPoint (memory st) m') \<and>
       TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and> TypeSafe e (accounts st) k' m' (storage st) c 
\<and> fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e (accounts st) k' \<longrightarrow>
       TypeSafe ev (accounts st) k m (storage st) cda  \<and>
       fullyInitialised ev (accounts st) k
\<and> (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and>
        ncpElementsNoSubPref (memory st) m \<and>
        ncpNewSelfPoint (memory st) m)"  
        using "28.hyps"(6)[of x3 "(v,t)" g4' v t "(c, m', k', e)" g4' c "(m', k', e)" m' "(k', e)" k' e] a10 a15  a7 Memory a2 as1 as2  as6 as7 as8 none by force
      then have cc2:"TypeSafe ev (accounts st) k m (storage st) cda \<and>
       (\<not> cp \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
        toploc (memory st) \<le> toploc m \<and>
        ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) m \<and> ncpElementsNoSubPref (memory st) m \<and> ncpNewSelfPoint (memory st) m)
\<and> fullyInitialised ev (accounts st) k "
        using a20 a2 as1 a30 as7 as8  fiE by simp
      moreover have "TypeSafe ev (accounts st) k m (storage st ) cda" using a20  a2 as1 a30 cc1 cc2 by blast
      
      ultimately show "TypeSafe ev (accounts st) k m (storage st ) cda 
\<and> (\<not> cp \<longrightarrow>
           (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp m locs) \<and>
           toploc (memory st) \<le> toploc m \<and>
           ncpElementsNoSubPref (memory st) m \<and>  ncpOMemInDMem (memory st) m \<and>
           ncpNewSelfPoint (memory st) m \<and>
           ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st))
\<and> fullyInitialised ev (accounts st) k" 
        using fmsubset_alt_def cc2 fmsubset_pred by meson
    next
      case (Storage x4)
      then show ?thesis using as1 load.simps by simp
    qed
    then show "TypeSafe ev (accounts st) k m (storage st) cda" by simp
    then show "\<not> cp \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m locs" using cc0 by simp
    show "\<not> cp \<Longrightarrow> toploc (memory st) \<le> toploc m" using cc0 by simp
    show "\<not> cp \<Longrightarrow> ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st)" using cc0 by simp
    show "\<not> cp \<Longrightarrow> ncpOMemInDMem (memory st) m" using cc0 by simp
    show "\<not> cp \<Longrightarrow> ncpElementsNoSubPref (memory st) m" using cc0 by simp
    show "\<not> cp \<Longrightarrow> ncpNewSelfPoint (memory st) m " using cc0 by simp
    show "fullyInitialised ev (accounts st) k" using cc0 by simp
  qed
next
  case (29 vt vu vv vw vx vy vz wa wb wc g)
  show ?case
  proof(intros)
    fix ev cd k m g' locs ls tp ct dud id' v
    assume a1: "local.load vt [] (vu # vv) vw vx vy vz wa wb wc g =
       Normal ((ev, cd, k, m), g') \<and>
       (\<not> vt \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory wc) locs \<longrightarrow> MCon tp vz locs) \<and>
        toploc (memory wc) \<le> toploc vz \<and>
        ncpDenvalueLimit vw wa vy (stack wc) (memory wc) \<and>
        ncpOMemInDMem (memory wc) vz \<and>
        ncpElementsNoSubPref (memory wc) vz \<and>
        ncpNewSelfPoint (memory wc) vz) \<and>
       TypeSafe wa (accounts wc) (stack wc) (memory wc) (storage wc) wb \<and>
       TypeSafe vw (accounts wc) vy vz (storage wc) vx \<and>
       fullyInitialised wa (accounts wc) (stack wc) \<and> fullyInitialised vw (accounts wc) vy"
    then show "TypeSafe ev (accounts wc) k m (storage wc) cd" using load.simps(2) by (auto split:if_split_asm result.splits)
    show "\<not> vt \<Longrightarrow> MCon tp (memory wc) locs \<Longrightarrow> MCon tp m locs"  using a1 using load.simps(2) by simp
    show "\<not> vt \<Longrightarrow> toploc (memory wc) \<le> toploc m"  using a1 using load.simps(2) by simp
    show "\<not> vt \<Longrightarrow> ncpDenvalueLimit ev wa k (stack wc) (memory wc)" using a1 using load.simps by simp
    show "\<not> vt \<Longrightarrow> ncpOMemInDMem (memory wc) m" using a1 using load.simps by simp
    show "\<not> vt \<Longrightarrow> ncpElementsNoSubPref (memory wc) m" using a1 using load.simps by simp
    show "\<not> vt \<Longrightarrow> ncpNewSelfPoint (memory wc) m " using a1 using load.simps by simp
    show "fullyInitialised ev (accounts wc) k" using a1 using load.simps(2) by simp
  qed
next
  case (30 wd we wf wg wh wi wj wk wl wm g)
  show ?case
  proof(intros)
    fix ev cd k m g' locs ls tp ct dud id' v
    assume a1: "local.load wd (we # wf) [] wg wh wi wj wk wl wm g =
       Normal ((ev, cd, k, m), g') \<and>
       (\<not> wd \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory wm) locs \<longrightarrow> MCon tp wj locs) \<and>
        toploc (memory wm) \<le> toploc wj \<and>
        ncpDenvalueLimit wg wk wi (stack wm) (memory wm) \<and>
        ncpOMemInDMem (memory wm) wj \<and>
        ncpElementsNoSubPref (memory wm) wj \<and>
        ncpNewSelfPoint (memory wm) wj) \<and>
       TypeSafe wk (accounts wm) (stack wm) (memory wm) (storage wm) wl \<and>
       TypeSafe wg (accounts wm) wi wj (storage wm) wh \<and>  fullyInitialised wk (accounts wm) (stack wm) \<and> fullyInitialised wg (accounts wm) wi"
    then show "TypeSafe ev (accounts wm) k m (storage wm) cd" using load.simps(3) by (auto split:if_split_asm result.splits)
    show "\<not> wd \<Longrightarrow> MCon tp (memory wm) locs \<Longrightarrow> MCon tp m locs"  using a1 using load.simps(3) by simp
    show "\<not> wd \<Longrightarrow> toploc (memory wm) \<le> toploc m"  using a1 using load.simps(3) by simp
    show "\<not> wd \<Longrightarrow> ncpDenvalueLimit ev wk k (stack wm) (memory wm)" using a1 using load.simps by simp
    show "\<not> wd \<Longrightarrow> ncpOMemInDMem (memory wm) m" using a1 using load.simps by simp
    show "\<not> wd \<Longrightarrow> ncpElementsNoSubPref (memory wm) m" using a1 using load.simps by simp
    show "\<not> wd \<Longrightarrow> ncpNewSelfPoint (memory wm) m " using a1 using load.simps by simp
    show "fullyInitialised ev (accounts wm) k" using a1 using load.simps(3) by simp
  qed
next
  case (31 wn e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g)
  show ?case
  proof(intros)
    fix ev cda k m g' locs ls tp ct dud id' v
      (* cd' = cda \<Longrightarrow> sck' = k \<Longrightarrow> mem' = m*)
    assume a1: "local.load wn [] [] e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g =
       Normal ((ev, cda, k, m), g') \<and>
       (\<not> wn \<longrightarrow>
        (\<forall>locs tp. MCon tp (memory st) locs \<longrightarrow> MCon tp mem' locs) \<and>
        toploc (memory st) \<le> toploc mem' \<and>
        ncpDenvalueLimit e\<^sub>v' e\<^sub>v sck' (stack st) (memory st) \<and>
        ncpOMemInDMem (memory st) mem' \<and>
        ncpElementsNoSubPref (memory st) mem' \<and>
        ncpNewSelfPoint (memory st) mem') \<and>
       TypeSafe e\<^sub>v (accounts st) (stack st) (memory st) (storage st) cd \<and>
       TypeSafe e\<^sub>v' (accounts st) sck' mem' (storage st) cd' \<and>
       fullyInitialised e\<^sub>v (accounts st) (stack st) \<and> fullyInitialised e\<^sub>v' (accounts st) sck'"
    then have fi1:"fullyInitialised e\<^sub>v (accounts st) (stack st)" and fi2:"fullyInitialised e\<^sub>v' (accounts st) sck'" by blast+
    then show "TypeSafe ev (accounts st) k m (storage st) cda" using load.simps(4)[of wn e\<^sub>v' cd' sck' mem' e\<^sub>v cd st g] a1 by (auto split:if_split_asm result.splits)
    show "\<not> wn \<Longrightarrow> MCon tp (memory st) locs \<Longrightarrow> MCon tp m locs"  using a1 using load.simps(4) by auto
    show "\<not> wn \<Longrightarrow> toploc (memory st) \<le> toploc m"  using a1 using load.simps(4) by auto
    show "\<not> wn \<Longrightarrow> ncpDenvalueLimit ev e\<^sub>v k (stack st) (memory st)" using a1 using load.simps(4) by auto
    show "\<not> wn \<Longrightarrow> ncpOMemInDMem (memory st) m" using a1 using load.simps(4) by auto
    show "\<not> wn \<Longrightarrow> ncpElementsNoSubPref (memory st) m" using a1 using load.simps(4) by auto
    show "\<not> wn \<Longrightarrow> ncpNewSelfPoint (memory st) m " using a1 using load.simps(4) by auto
    have eq:"(e\<^sub>v', cd', sck', mem') = (ev, cda, k, m)" using a1 load.simps(4) by simp
    then show "fullyInitialised ev (accounts st) k" using fi2 by simp 
  qed
next
  case (32 i e cd st g)
  show ?case 
  proof(intros)
    fix v3' t3' g3' assume a1:"rexp (L.Id i) e cd st g = Normal (( v3',  t3'), g3') \<and> TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd
                                \<and> fullyInitialised e (accounts st) (stack st)"
    then consider 
      (stack) tp l where "fmlookup (denvalue e) i = Some (tp, Stackloc l)"
    |(store) tp l where "fmlookup (denvalue e) i = Some (tp, Storeloc l)" using rexp.simps(1) a1 by (simp split:option.splits prod.splits  Type.splits Denvalue.splits STypes.splits)
    then show "case t3' of Value typ \<Rightarrow> typeCon typ (extractValueType v3') \<and> (\<exists>xx. v3' = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v3') \<and>
           (\<exists>xx. v3' = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v3' = KCDptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v3'))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v3') \<and>
           (\<exists>xx. v3' = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v3' = KMemptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v3'))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v3') (storage st (address e)) \<and>
           (\<exists>xx. v3' = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3')))"      
    proof (cases)
      case stack
      then have a7:"(tp, Stackloc l) |\<in>| fmran (denvalue e)" using Finite_Map.fmranI  by fast
      then consider 
        (kval) v where "accessStore l (stack st) = Some(KValue v)"
      | (cdptr) p where "accessStore l (stack st) = Some (KCDptr p)"
      | (memptr) p where "accessStore l (stack st) = Some (KMemptr p)"
      | (stoptr) p where "accessStore l (stack st) = Some (KStoptr p)"
        using rexp.simps(1) a1 stack by (simp split:option.splits prod.splits  Type.splits Denvalue.splits STypes.splits Stackvalue.splits )
      then show "case t3' of Value typ \<Rightarrow> typeCon typ (extractValueType v3') \<and> (\<exists>xx. v3' = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v3') \<and>
           (\<exists>xx. v3' = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v3' = KCDptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v3'))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v3') \<and>
           (\<exists>xx. v3' = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v3' = KMemptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v3'))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v3') (storage st (address e)) \<and>
           (\<exists>xx. v3' = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3')))"
      proof(cases)
        case kval
        then show ?thesis using a1 stack  a7 unfolding rexp.simps(1) TypeSafe_def typeCompat_def by (cases tp; force)
      next
        case cdptr
        then show ?thesis using a1 stack  a7 unfolding TypeSafe_def rexp.simps(1) typeCompat_def by (cases tp; force)
      next
        case memptr
        show ?thesis 
        proof(cases tp)
          case (Value x1)
          then show ?thesis using a1  stack a7 memptr unfolding TypeSafe_def typeCompat_def rexp.simps(1) by force
        next
          case (Calldata x2)
          then show ?thesis using a1  stack a7 memptr unfolding TypeSafe_def rexp.simps(1) typeCompat_def by force
        next
          case (Memory x3)
          then have a10:"(v3', t3') = (KMemptr p, Memory x3)" using a1 stack rexp.simps(1)[of i e cd st g ]  stack a7 memptr 
            by (auto split:option.splits Type.splits MTypes.splits STypes.splits)
          then have a20:"MCon x3 (memory st) (extractValueType v3')" using a1 stack a7 memptr Memory unfolding rexp.simps(1) TypeSafe_def typeCompat_def by force
          have a30:"(\<exists>xx. v3' = KMemptr xx)"  using a1 stack rexp.simps(1) a7 memptr Memory by auto
          have a35:"extractValueType v3' = p" using a10 by simp
          then show ?thesis using a20 a30 a1 stack a7 memptr Memory a35 unfolding rexp.simps(1) by force
        next
          case (Storage x4)
          then show ?thesis using a1 stack a7 memptr unfolding TypeSafe_def rexp.simps(1) typeCompat_def by force
        qed
      next 
        case stoptr
        then show ?thesis   
        proof (cases tp)
          case (Value x1)
          then show ?thesis using a1 stoptr stack a7 unfolding TypeSafe_def rexp.simps(1) typeCompat_def by force
        next
          case (Calldata x2)
          then show ?thesis using a1 stoptr stack a7 unfolding TypeSafe_def typeCompat_def by force
        next
          case (Memory x3)
          then show ?thesis using a1 stoptr stack a7 unfolding TypeSafe_def typeCompat_def by force
        next
          case (Storage x4)
          then have a30: "t3' = Storage x4"  and a40:"v3' = KStoptr p" using a1 stack stoptr unfolding rexp.simps(1) by (simp split:option.splits prod.splits  Type.splits Denvalue.splits STypes.splits Stackvalue.splits)+
          have "SCon x4 (extractValueType v3') (storage st (address e)) \<and>
        (\<exists>xx. v3' = KStoptr xx) \<and>
        (\<exists>stloc tp''.
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
            (tp'' = x4 \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v3')))" 
          proof intros
            show "SCon x4 (extractValueType v3') (storage st (address e))" using stoptr stack a7 Storage a30 a40 using a1 unfolding TypeSafe_def typeCompat_def by force
            show "\<exists>xx. v3' = KStoptr xx" using a40 by simp
            show "\<exists>stloc tp''.
       (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
       (tp'' = x4 \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v3'))"
              using a1 unfolding fullyInitialised_def 
              by (metis CompStoType_sameLoc_sameType Storage a40 a7 extractValueType.simps(4) stoptr)
          qed
          then show ?thesis using a1 stoptr stack a7 Storage a30 a40 unfolding TypeSafe_def typeCompat_def by simp
        qed
      qed
    next
      case store
      then have a7:"(tp, Storeloc l) |\<in>| fmran (denvalue e)" using Finite_Map.fmranI store by simp
      then consider 
        (stval) t where "tp = Storage (STValue t)"
      | (stary) t x where "tp = Storage (STArray x t)"        
        using rexp.simps(1) a1 store by (simp split:option.splits prod.splits  Type.splits Denvalue.splits STypes.splits Stackvalue.splits)

      then show "case t3' of Value typ \<Rightarrow> typeCon typ (extractValueType v3') \<and> (\<exists>xx. v3' = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v3') \<and>
           (\<exists>xx. v3' = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v3' = KCDptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v3'))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v3') \<and>
           (\<exists>xx. v3' = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v3' = KMemptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v3'))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v3') (storage st (address e)) \<and>
           (\<exists>xx. v3' = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3')))"
      proof(cases)
        case stval
        then have a20:"accessStorage t l (storage st (address e)) = (case (storage st (address e)) $$ l of
              Some v \<Rightarrow> v
            | None \<Rightarrow> ival t)" using accessStorage_def by auto
        then show ?thesis
        proof(cases "(storage st (address e)) $$ l")
          case None
          then have "accessStorage t l (storage st (address e)) = ival t" using a20 by simp
          then have "KValue (ival t) = v3'" using a20 stval store rexp.simps(1) None a1 by simp
          then show ?thesis using ivalTypeCon[of t "extractValueType v3'"] a20 stval store rexp.simps(1) None a1 by auto
        next
          case (Some a)
          then have a30:"SCon (STValue t) l ((storage st) (address e))" using a20 stval store a1 a7 unfolding TypeSafe_def typeCompat_def by force
          moreover have "SCon (STValue t) l ((storage st) (address e)) = (typeCon t a)" using Some SCon.simps(1) accessStorage_def by simp
          moreover have "extractValueType v3' = a"  using a20 stval store a1 a7  rexp.simps(1) Some by auto
          ultimately show ?thesis  using stval store a1 rexp.simps(1) by auto
        qed
      next
        case stary
        then have a30: "t3' = Storage (STArray x t)"  and "v3' = KStoptr l" using a1 store  unfolding rexp.simps(1) by (simp split:option.splits prod.splits  Type.splits Denvalue.splits STypes.splits Stackvalue.splits)+
        then have a35:"SCon (STArray x t) l ((storage st) (address e))" using store a1 a7 stary unfolding TypeSafe_def typeCompat_def by force
        then show ?thesis using stary store a1 a30 unfolding rexp.simps(1) 
          using a7 by force
      qed
    qed
  qed
next
  case (33 i r e cd st g)
  show ?case
  proof(intros)
    fix v3' t3' g3' assume a1:" local.rexp (Ref i r) e cd st g = Normal ((v3', t3'), g3') \<and>
       TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd 
       \<and> fullyInitialised e (accounts st) (stack st) " 
    then consider
      (stloc) tp l  where "fmlookup (denvalue e) i = Some (tp, Stackloc l)" 
    |(stoloc) tp l where "fmlookup (denvalue e) i = Some (tp, Storeloc l)" 
      using a1 by (simp add: rexp.simps  split:option.split_asm prod.split_asm Denvalue.split_asm)
    then show "case t3' of Value typ \<Rightarrow> typeCon typ (extractValueType v3') \<and> (\<exists>xx. v3' = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v3') \<and>
           (\<exists>xx. v3' = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v3' = KCDptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v3'))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v3') \<and>
           (\<exists>xx. v3' = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v3' = KMemptr p \<or>
                (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v3'))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v3') (storage st (address e)) \<and>
           (\<exists>xx. v3' = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v3')))" 
    proof (cases)
      case stloc
      then have a7:"(tp, Stackloc l) |\<in>| fmran (denvalue e)" using Finite_Map.fmranI[of "denvalue e"] by simp
      then consider 
        (cdptr) l' where "accessStore l (stack st) = Some (KCDptr l')"
      | (memptr) l' where "accessStore l (stack st) = Some (KMemptr l')"
      | (stoptr) l' where "accessStore l (stack st) = Some (KStoptr l')"      
        using a1 stloc by (simp add: rexp.simps  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm)
      then show ?thesis 
      proof(cases)
        case cdptr
        then obtain t where a10:"tp = Calldata t" using stloc a1 by (simp add: rexp.simps  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm)
        then obtain l'' t' g' where a20:"msel False t l' r e cd st g = Normal ((l'',t'), g')" 
          using stloc a1 cdptr by (simp add: rexp.simps split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm)
        then have a22:"r \<noteq> []" using msel.simps by auto

        have a25:"MCon t cd l'" using a1 a7 cdptr stloc a10 a1 unfolding TypeSafe_def typeCompat_def by (auto split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm Stackvalue.split_asm Type.split_asm )
        
        then show ?thesis
        proof(cases t')
          case (MTArray x11 t'')
          then obtain p where a30:"accessStore l'' cd = Some(MPointer p)" using MTArray stloc a1 cdptr a10 a20  rexp.simps(2)[of i r e cd st g ] by (auto  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm Memoryvalue.split_asm)
          
          then have a40:"v3' = KCDptr p" using stloc a1 cdptr a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have a45:"t3' = Calldata (MTArray x11 t'')" using stloc a1 cdptr a10 a20 MTArray by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          moreover have a60:"r \<noteq> [] \<longrightarrow>
       (\<exists>len arr.
           t = MTArray len arr \<and>
           (case t' of
            MTArray l'a ar' \<Rightarrow>
              \<exists>p. accessStore l'' (if False then memory st else cd) = Some (MPointer p) \<and>
                  CompMemType (if False then memory st else cd) len arr t' l' p
            | MTValue val \<Rightarrow>
                CompMemType (if False then memory st else cd) len arr t' l' l''))" 
            using "33.hyps"(1)[of "(tp, Stackloc l)" tp "Stackloc l" l "KCDptr l'" l' t g] 
                  stloc cdptr a10 a20 a30 a25 a1 by simp
          then obtain len arr where a35:"t = MTArray len arr" using a25 MTArray 
            using a22 by blast
          moreover have "CompMemType cd len arr t' l' p"
            using MTArray a40 extractValueType.simps(2) calculation a22 a30 a25 a35 a60 by simp
          moreover have "MCon (MTArray x11 t'') cd (extractValueType v3')"
            using MTArray a40 extractValueType.simps(2) calculation 
            using a22 a30 a25 a35 CompTypeRemainsMCon by presburger
          moreover have a70:"(\<exists>len arr.
            t = MTArray len arr \<and> (\<exists>p. accessStore l'' (if False then memory st else cd) = Some (MPointer p) \<and> CompMemType (if False then memory st else cd) len arr t' l' p))" 
            using a60 a20 a22 MTArray by auto
          moreover have a80:"(Calldata t, Stackloc l) |\<in>| fmran (denvalue e)" using a10 a7 by blast
          moreover have a90:"accessStore l (stack st) = Some (KCDptr l')" using cdptr by blast
          moreover have a100:"extractValueType v3' = p" using a40 by auto
          ultimately have " MCon (MTArray x11 t'') cd (extractValueType v3') \<and>
        (\<exists>xx. v3' = KCDptr xx) \<and>
        (\<exists>stloc tp'' p.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
            accessStore stloc (stack st) = Some (KCDptr p) \<and>
            (tp'' = (MTArray x11 t'') \<and> v3' = KCDptr p \<or> (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr (MTArray x11 t'') p (extractValueType v3'))))" 
            by (metis (no_types, lifting) BothMConImpsNotCompMemType MTArray Memoryvalue.inject(2) a25 a30 option.inject)
          then show ?thesis using a45 
            by (auto split:Type.splits if_splits)
        next
          case (MTValue x2)
          then obtain v where a30:"accessStore l'' cd = Some(MValue v)" using MTValue stloc a1 cdptr a10 a20  rexp.simps(2)[of i r e cd st g ] by (auto  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm Memoryvalue.split_asm)
          then have a40:"v3' = KValue v" using stloc a1 cdptr a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have "t3' = Value x2" using stloc a1 cdptr a10 a20 MTValue by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          moreover have a60:"MCon t' cd l''" 
            using "33.hyps"(1)[of "(tp, Stackloc l)" tp "Stackloc l" l "KCDptr l'" l' t g] 
                  stloc cdptr a10 a20 a30 a25 a1 a22 a30 MTValue 
            by (metis (no_types, lifting) CompTypeRemainsMCon MTypes.simps(6) Type.simps(18) return.simps)
          then have "typeCon x2 (extractValueType v3')" using extractValueType.simps(1)[of v] a40 a60 a30 MTValue by simp
          ultimately show ?thesis by simp
        qed
      next
        case memptr
        then obtain t where a10:"tp = Memory  t" using stloc a1 by (simp add: rexp.simps  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm)
        then obtain l'' t' g' where a20:"msel True t l' r e cd st g = Normal ((l'',t'), g')" 
          using stloc a1 memptr by (simp add: rexp.simps split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm)
        then have a22:"r \<noteq> []" using msel.simps by auto
        have a25:"MCon t (memory st) l'" using a1 a7 memptr stloc a10 a1 unfolding TypeSafe_def typeCompat_def by (auto split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm Stackvalue.split_asm Type.split_asm )
        then show ?thesis
        proof(cases t')
          case (MTArray x11 t'')
          then obtain p where a30:"accessStore l'' (memory st) = Some(MPointer p)" using MTArray stloc a1 memptr a10 a20  rexp.simps(2)[of i r e cd st g ] by (auto split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm Memoryvalue.split_asm)
          then have a40:"v3' = KMemptr p" using stloc a1 memptr a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have a45:"t3' = Memory (MTArray x11 t'')" using stloc a1 memptr a10 a20 MTArray by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          moreover have a60:"r \<noteq> [] \<longrightarrow>
       (\<exists>len arr.
           t = MTArray len arr \<and>
           (case t' of
            MTArray l'a ar' \<Rightarrow>
              \<exists>p. accessStore l'' (if True then memory st else cd) = Some (MPointer p) \<and>
                  CompMemType (if True then memory st else cd) len arr t' l' p 
            | MTValue val \<Rightarrow> CompMemType (if True then memory st else cd) len arr t' l' l''))" 
            using "33.hyps"(2)[of "(tp, Stackloc l)" tp "Stackloc l" l "KMemptr l'" l' t g] stloc memptr a10 a20 a30 a25 a1 by simp+
          then obtain len arr where a35:"t = MTArray len arr" using a25 MTArray 
            using a22 by blast
          then have a65:"CompMemType (memory st) len arr t' l' p "
            using MTArray a40 extractValueType.simps(2) calculation a22 a30 a60 a35 a25 by simp
          moreover have "MCon (MTArray x11 t'') (memory st) (extractValueType v3')" 
            using MTArray a40 extractValueType.simps(2) calculation a22 a30 a60 a35 a25 a65 
            using CompTypeRemainsMCon extractValueType.simps(3) by presburger
          moreover have a70:"(\<exists>len arr.
            t = MTArray len arr \<and> (\<exists>p. accessStore l'' (if True then memory st else cd) = Some (MPointer p) \<and> CompMemType (if True then memory st else cd) len arr t' l' p))" 
            using a60 a20 a22 MTArray by auto
          moreover have a80:"(Memory t, Stackloc l) |\<in>| fmran (denvalue e)" using a10 a7 by auto
          moreover have a90:"accessStore l (stack st) = Some (KMemptr l')" using memptr by blast
          moreover have a100:"extractValueType v3' = p" using a40 by auto

          ultimately have " MCon  (MTArray x11 t'') (memory st) (extractValueType v3') \<and>
        (\<exists>xx. v3' = KMemptr xx) \<and>
        (\<exists>stloc tp'' p.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
            accessStore stloc (stack st) = Some (KMemptr p) \<and>
            (tp'' =  (MTArray x11 t'') \<and> v3' = KMemptr p \<or> (\<exists>len arr. extractValueType v3' \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr  (MTArray x11 t'') p (extractValueType v3'))))" 
            by (metis (no_types, lifting) BothMConImpsNotCompMemType MTArray Memoryvalue.inject(2) a25 a30 option.inject)
          then show ?thesis using a45 by (auto split:Type.splits if_splits)
        next
          case (MTValue x2)
          then obtain v where a30:"accessStore l'' (memory st) = Some(MValue v)" 
            using MTValue stloc a1 memptr a10 a20 rexp.simps(2)[of i r e cd st g ] 
            by (auto  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm Memoryvalue.split_asm)
          then have a40:"v3' = KValue v" 
            using stloc a1 memptr a10 a20 
            by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have "t3' = Value x2" 
            using stloc a1 memptr a10 a20 MTValue 
            by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          moreover have a60:"MCon t' (memory st) l''" 
            using "33.hyps"(2)[of "(tp, Stackloc l)" tp "Stackloc l" l "KMemptr l'" l' t g] 
                  stloc memptr a10 a20 a30 a25 a1 MTValue a22 
            by (metis (lifting) MTypes.simps(6) Type.case(3) return.simps CompTypeRemainsMCon)
          then have "typeCon x2 (extractValueType v3')" using extractValueType.simps(1)[of v] a40 a60 a30 MTValue by simp
          ultimately show ?thesis by simp
        qed
      next
        case stoptr
        then obtain t where a10:"tp = Storage  t" using stloc a1 
          by (simp add: rexp.simps split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm)
        then obtain l'' t' g' where a20:"ssel t l' r e cd st g = Normal ((l'',t'), g')" 
          using stloc a1 stoptr 
          by (simp add: rexp.simps split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm 
                                        Type.split_asm MTypes.split_asm result.split_asm)
        have a25:"SCon t l' (storage st (address e))" 
          using a1 a7 stoptr stloc a10 a1 
          unfolding TypeSafe_def typeCompat_def 
          by (auto split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm Stackvalue.split_asm Type.split_asm )
        then show ?thesis
        proof(cases t')
          case (STArray x11 t'')
          have ret:"(KStoptr l'', Storage t') = (v3', t3')" using a1 rexp.simps(2)[of i r e cd st g ] stoptr stloc a10 a20 STArray  
            by (simp split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)

          have "(t = t' \<and> v3' = KStoptr l' \<or> extractValueType v3' \<noteq> l' \<and> CompStoType t t' l' (extractValueType v3'))" 
          proof(cases "r = []")
            case True
            then have "l'' = l'" using a20 ssel.simps by simp
            moreover have "t' = t" using a20 ssel.simps(1)[of t l' e cd st g] True by simp
            ultimately show ?thesis using ret by simp
          next
            case False
            then have "CompStoType t t' l' l''" 
              using "33.hyps"(3)[of "(tp, Stackloc l)" tp "Stackloc l" l "KStoptr l'" l' t g] stloc stoptr a10 a20  a25 a1 STArray by simp
            then show ?thesis using ret 
              using CompStoType_sameLoc_sameType by force
          qed
          then have "SCon t' (l'') (storage st (address e))" using a25 SCon_imps_sublocs ret by fastforce
          then have g1:"SCon (STArray x11 t'') (extractValueType v3') (storage st (address e))" using STArray ret by auto
          have "SCon (STArray x11 t'') (extractValueType v3') (storage st (address e)) \<and>
        (\<exists>xx. v3' = KStoptr xx) \<and>
        (\<exists>stloc tp''.
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
            (tp'' = (STArray x11 t'') \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' (STArray x11 t'') stloc (extractValueType v3')))"

          proof intros
            show " SCon (STArray x11 t'') (extractValueType v3') (storage st (address e))" using g1 by simp
            show "\<exists>xx. v3' = KStoptr xx" using ret by blast
            show "\<exists>stloc tp''.
       (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
       (tp'' = STArray x11 t'' \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' (STArray x11 t'') stloc (extractValueType v3')) " 
              by (smt (verit, ccfv_threshold) CompStoType_trns STArray \<open>\<exists>xx. v3' = KStoptr xx\<close>
                  \<open>t = t' \<and> v3' = KStoptr l' \<or> extractValueType v3' \<noteq> l' \<and> CompStoType t t' l' (extractValueType v3')\<close> a1 a10 a7 extractValueType.simps(4)
                  CompStoType_sameLoc_sameType fullyInitialised_def stoptr)
          qed
          then show ?thesis using a20 a10 stoptr a7 g1 ret STArray stloc  by fastforce
        next
          case (STMap x21 x22)
          then have a40:"v3' = KStoptr l''" 
            using stloc a1 stoptr a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have a50:"t3' = Storage (STMap x21 x22)" 
            using stloc a1 stoptr a10 a20 STMap 
            by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          have "(t = t' \<and> v3' = KStoptr l' \<or> extractValueType v3' \<noteq> l' \<and> CompStoType t t' l' (extractValueType v3'))" 
          proof(cases "r = []")
            case True
            then have "l'' = l'" using a20 ssel.simps by simp
            moreover have "t' = t" using a20 ssel.simps(1)[of t l' e cd st g] True by simp
            ultimately show ?thesis using a40 a50 by simp
          next
            case False
            then have "CompStoType t t' l' l''" 
              using "33.hyps"(3)[of "(tp, Stackloc l)" tp "Stackloc l" l "KStoptr l'" l' t g] stloc stoptr a10 a20  a25 a1 STMap by simp
            then show ?thesis using a40 a50 using CompStoType_sameLoc_sameType by force
          qed
          then have "SCon t' (l'') (storage st (address e))" using a25
            using SCon_imps_sublocs calculation by fastforce 
          then have g1:"SCon (STMap x21 x22) (extractValueType v3') (storage st (address e))" using STMap a40 by simp

          have "SCon (STMap x21 x22) (extractValueType v3') (storage st (address e)) \<and>
        (\<exists>xx. v3' = KStoptr xx) \<and>
        (\<exists>stloc tp''.
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
            (tp'' = (STMap x21 x22) \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' (STMap x21 x22) stloc (extractValueType v3')))"

          proof intros
            show " SCon (STMap x21 x22) (extractValueType v3') (storage st (address e))" using g1 by simp
            show "\<exists>xx. v3' = KStoptr xx" using a40 by auto
            show "\<exists>stloc tp''.
       (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
       (tp'' = STMap x21 x22 \<and> v3' = KStoptr stloc \<or> extractValueType v3' \<noteq> stloc \<and> CompStoType tp'' (STMap x21 x22) stloc (extractValueType v3')) " 
              by (smt (verit, ccfv_threshold) CompStoType_trns STMap \<open>\<exists>xx. v3' = KStoptr xx\<close>
                  \<open>t = t' \<and> v3' = KStoptr l' \<or> extractValueType v3' \<noteq> l' \<and> CompStoType t t' l' (extractValueType v3')\<close> a1 a10 a7 extractValueType.simps(4)
                  CompStoType_sameLoc_sameType fullyInitialised_def stoptr)
          qed

          then show ?thesis using a20 a10 stoptr a7 g1 a40 a50 STMap stloc by force
        next
          case (STValue t'')
          then have a40:"v3' = KValue (accessStorage t'' l'' (storage st (address e)))" using stloc a1 stoptr a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
          moreover have "t3' = Value t''" using stloc a1 stoptr a10 a20 STValue by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
          moreover have a60:"SCon t (l') (storage st (address e))" using "33.hyps"(3) stloc stoptr a10 a20 a25 a1 STValue by simp 
          then have cc0:"(t = t' \<and> l' = l'' \<or> CompStoType t t' l' l'')" 
          proof(cases "r = []")
            case True
            then have "l'' = l'" using a20 ssel.simps by auto 
            moreover have "t' = t" using a20 ssel.simps(1)[of t l' e cd st g] True by simp
            ultimately show ?thesis using a40 by simp
          next
            case False
            then have "CompStoType t t' l' l''" 
              using  a10 a20  a25 a1 STValue "33.hyps"(3) stoptr 
              by (simp add: stloc)
            then show ?thesis using a40 using CompStoType_sameLoc_sameType by simp
          qed
          then have "typeCon t'' (accessStorage t'' l'' (storage st (address e)))" 
            using a60 SCon_imps_sublocs STValue SCon.simps(1) by blast
          ultimately show ?thesis by simp
        qed
      qed
    next
      case stoloc
      then have a7:"(tp, Storeloc l) |\<in>| fmran (denvalue e)" using Finite_Map.fmranI[of "denvalue e"] by simp

      then obtain t where a10:"tp = Storage  t" using stoloc a1 by (simp add: rexp.simps  split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm)
      then obtain l'' t' g' where a20:"ssel t  l r e cd st g = Normal ((l'',t'), g')" 
        using  a1 stoloc  by (simp add: rexp.simps split:option.split_asm prod.split_asm Denvalue.split_asm Stackvalue.split_asm Type.split_asm MTypes.split_asm result.split_asm)
      have a25:"SCon t  l (storage st (address e))" using a1 a7  stoloc a10 a1 unfolding TypeSafe_def typeCompat_def by (auto split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm Stackvalue.split_asm Type.split_asm )
      then show ?thesis
      proof(cases t')
        case (STArray x11 t'')
        then have a40:"v3' = KStoptr l''" 
          using a1 stoloc a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
        moreover have a50:"t3' = Storage (STArray x11 t'')" 
          using stoloc a1  a10 a20 STArray 
          by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
        have cc0:"(t = t' \<and> v3' = KStoptr l \<or> extractValueType v3' \<noteq> l \<and> CompStoType t t' l (extractValueType v3'))" 
        proof(cases "r = []")
          case True
          then have "l'' = l" using a20 ssel.simps by simp
          moreover have "t' = t" using a20 ssel.simps(1)[of t l e cd st g] True by simp
          ultimately show ?thesis using a40 a50 by simp
        next
          case False
          then have "CompStoType t t' l l''" 
            using stoloc a10 a20  a25 a1 STArray "33.hyps"(4) by auto
          then show ?thesis using a40 a50 using CompStoType_sameLoc_sameType by force
        qed
        then have "SCon t' (l'') (storage st (address e))" using a25 
          by (metis SCon_imps_sublocs calculation extractValueType.simps(4)) 
        then have g1:"SCon (STArray x11 t'') (extractValueType v3') (storage st (address e))" using STArray a40 by simp
        then show ?thesis using a20 a10 stoloc a7 g1 a40 a50 STArray cc0 by force
      next
        case (STMap x21 x22)
        then have a40:"v3' = KStoptr l''" using stoloc a1  a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
        moreover have a50:"t3' = Storage (STMap x21 x22)" using stoloc a1  a10 a20 STMap by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
        have cc0:"(t = t' \<and> v3' = KStoptr l \<or> extractValueType v3' \<noteq> l \<and> CompStoType t t' l (extractValueType v3'))" 
        proof(cases "r = []")
          case True
          then have "l'' = l" using a20 ssel.simps by simp
          moreover have "t' = t" using a20 ssel.simps(1)[of t l e cd st g] True by simp
          ultimately show ?thesis using a40 a50 by simp
        next
          case False
          then have "CompStoType t t' l l''" 
            using stoloc a10 a20  a25 a1 STMap "33.hyps"(4) by auto
          then show ?thesis using a40 a50 using CompStoType_sameLoc_sameType by force
        qed
        then have "SCon t' (l'') (storage st (address e))" using a25 
          using SCon_imps_sublocs calculation by fastforce
        then have g1:"SCon (STMap x21 x22) (extractValueType v3') (storage st (address e))" using STMap a40 by simp
        then show ?thesis using a20 a10 stoloc a7 g1 a40 a50 STMap cc0 by auto
      next
        case (STValue t'')
        then have a40:"v3' = KValue (accessStorage t'' l'' (storage st (address e)))" using stoloc a1  a10 a20 by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm)
        moreover have "t3' = Value t''" using stoloc a1  a10 a20 STValue by (simp add:rexp.simps(2) split:option.split_asm prod.split_asm Denvalue.split_asm MTypes.split_asm Memoryvalue.split_asm)
        moreover have a60:"SCon t (l) (storage st (address e))" using "33.hyps"(4) stoloc  a10 a20 a25 a1 STValue by simp 
        then have "r \<noteq> [] \<longrightarrow> CompStoType t t' l l''"
          using "33.hyps"(4)[OF stoloc, of tp "Storeloc l" l t g] stoloc  a10 a20 a25 a1 STValue a40  by simp
        then have cc0:"(t = t' \<and> l =l'' 
                        \<or> CompStoType t t' l l'')" 
        proof(cases "r = []")
          case True
          then have "l'' = l" using a20 ssel.simps by simp
          moreover have "t' = t" using a20 ssel.simps(1)[of t l e cd st g] True by simp
          ultimately show ?thesis using a40 by simp
        next
          case False
          then have "CompStoType t t' l l''" 
            using stoloc a10 a20  a25 a1 STValue "33.hyps"(4) by auto
          then show ?thesis using a40 using CompStoType_sameLoc_sameType by simp
        qed
        then have "typeCon t'' (accessStorage t'' l'' (storage st (address e)))" using a60
          using SCon_imps_sublocs STValue SCon.simps(1) by blast
        ultimately show ?thesis by simp
      qed
    qed
  qed
next
  case (34 e cd st g)
  show ?case 
  proof (intros)
    fix v t g4' assume a1:"local.expr CONTRACTS e cd st g = Normal ((v, t), g4') \<and>
       TypeSafe e (accounts st) (stack st) (memory st) (storage st) cd \<and> fullyInitialised e (accounts st) (stack st)"
    then have "t = Value TAddr" using a1 expr.simps(20)[of e cd st g ] by (simp split:if_split_asm result.split_asm prod.split_asm )
    moreover obtain n where  a2:"(contracts (accounts st (address e))) = Suc n" using a1 expr.simps(20) by (simp split:if_splits result.splits prod.splits nat.splits)
    moreover have vdef:"v = KValue (hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t  n))" using expr.simps(20)[of e cd st g ] a1 a2 by (auto split:if_split_asm result.splits prod.split_asm nat.splits)
    moreover have "typeCon TAddr (extractValueType v)" unfolding typeCon.simps
    proof -
      have in1:"extractValueType v = (hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t  n))" 
        using vdef extractValueType.simps by auto
      then have in2:"extractValueType v = (ShowL\<^sub>n\<^sub>a\<^sub>t (n)) + (STR ''-'' + address e)" unfolding hash_version_def
        by blast
      have "CHR ''.'' \<notin> set (literal.explode (address e))" 
        using a1 unfolding TypeSafe_def addressFormat_def typeCon.simps checkAddress_def by blast
      then have "CHR ''.'' \<notin> set (literal.explode (STR ''-'' + address e))" 
        by (simp add: Literal.rep_eq add_Literal_assoc)
      moreover have "CHR ''.'' \<notin> set (literal.explode (ShowL\<^sub>n\<^sub>a\<^sub>t (n)))" using ShowLNatDot by blast

      ultimately have "CHR ''.'' \<notin> set (literal.explode ((ShowL\<^sub>n\<^sub>a\<^sub>t (n)) + (STR ''-'' + address e)))" 
        by (simp add: plus_literal.rep_eq)
      then show "checkAddress (extractValueType v) " using in2  unfolding checkAddress_def  by auto
      
    qed

      
    ultimately show "case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx)
       | Calldata struct \<Rightarrow>
           MCon struct cd (extractValueType v) \<and>
           (\<exists>xx. v = KCDptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KCDptr p) \<and>
               (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
       | Memory struct \<Rightarrow>
           MCon struct (memory st) (extractValueType v) \<and>
           (\<exists>xx. v = KMemptr xx) \<and>
           (\<exists>stloc tp'' p.
               (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e) \<and>
               accessStore stloc (stack st) = Some (KMemptr p) \<and>
               (tp'' = struct \<and> v = KMemptr p \<or>
                (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory st) len arr struct p (extractValueType v))))
       | Storage struct \<Rightarrow>
           SCon struct (extractValueType v) (storage st (address e)) \<and>
           (\<exists>xx. v = KStoptr xx) \<and>
           (\<exists>stloc tp''.
               (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e) \<and>
               (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" 
      unfolding checkAddress_def a1 extractValueType.simps by simp
  qed
qed

end
end