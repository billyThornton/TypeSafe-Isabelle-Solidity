theory TypeSafe
  imports TypeSafe_Expressions
begin

context statement_with_gas 
begin

lemma diffTypeDiffLoc:
  assumes "st' = st\<lparr>stack := updateStore l v (stack st), gas:=g\<rparr>"
    and "v' \<noteq> v"
    and "accessStore l1 (stack st') = Some v'"
  shows "l1 \<noteq> l" using assms notNoneUpdate by fastforce

lemma stackSingleUpdate:
  assumes "st' = st\<lparr>stack := updateStore l v (stack st), gas:=g\<rparr>"
  shows "\<forall>nl \<noteq>l. accessStore nl (stack st) = accessStore nl (stack st')"
proof (intros)
  fix nl
  assume a1:"nl \<noteq> l"
  then have "accessStore nl (updateStore l v (stack st)) = accessStore nl (stack st)"
    unfolding updateStore_def by (simp add: accessStore_def)
  then show "accessStore nl (stack st) = accessStore nl (stack st')"  using assms by simp     
qed

lemma updateOneType:
  assumes "st' = st\<lparr>stack := updateStore l v (stack st), gas:=g\<rparr>"
    and "v' \<noteq> v"
  shows "accessStore l1 (stack st') = Some v' \<Longrightarrow> accessStore l1 (stack st) = Some v'" 
proof - 
  assume a1:"accessStore l1 (stack st') = Some v'"
  then have "l1 \<noteq> l" using diffTypeDiffLoc[of st' g l v st v' l1] assms by simp
  then show "accessStore l1 (stack st) = Some v'" using stackSingleUpdate[of st' g l v st] assms a1 by simp
qed

lemma memSingleUpdate:
  assumes "st' = st\<lparr>memory := updateStore l v (memory st)\<rparr>"
  shows "\<forall>nl \<noteq>l. accessStore nl (memory st) = accessStore nl (memory st')"
proof (intros)
  fix nl
  assume a1:"nl \<noteq> l"
  then have "accessStore nl (updateStore l v (memory st)) = accessStore nl (memory st)"
    unfolding updateStore_def by (simp add: accessStore_def)
  then show "accessStore nl (memory st) = accessStore nl (memory st')"  using assms by simp     
qed

lemma storeSingleUpdate:
  assumes "st' = st\<lparr>storage := (storage st) (address env := fmupd l v' (storage st (address env)))\<rparr>"
  shows "\<forall>nl \<noteq>l.((storage st') (address ev)) $$ nl= ((storage st) (address ev)) $$ nl"
proof (intros)
  fix nl
  assume a1:"nl \<noteq> l"
  show "((storage st') (address ev)) $$ nl= ((storage st) (address ev)) $$ nl"  using assms a1 by simp     
qed

lemma typeSafeLocExists:
  assumes "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd"
    and "(t, l) |\<in>| fmran (denvalue ev)"
    and "l = Stackloc loc"
    and "unique_locations (denvalue ev)"
    and "balanceTypes (accounts st)"
  shows "\<exists>val. accessStore loc (stack st) = Some(val)"
proof -
  have a10:"TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd  = (unique_locations (denvalue ev) \<and>
     balanceTypes (accounts st) \<and>
     (\<forall>t l. (t, l) |\<in>| fmran (denvalue ev) \<longrightarrow>
            (case l of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st) of None \<Rightarrow> False
               | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
               | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
               | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st) stloc | _ \<Rightarrow> False)
               | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address ev)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address ev)) | _ \<Rightarrow> False))))" using assms TypeSafe_def typeCompat_def by simp
  then show ?thesis
  proof(cases "accessStore loc (stack st)")
    case None
    then have "False" using a10 assms by force
    then show ?thesis by simp
  next
    case (Some a)
    then show ?thesis using a10 assms by simp
  qed
qed

lemma typeConConvert:
  assumes "local.expr ex env cd (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (gas st - costs (ASSIGN lv ex) env cd st) = Normal ((KValue v, Value t2), g)"
    and "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"
    and "convert t2 t' v = Some (v)"
    and "fullyInitialised env (accounts st) (stack st)"
  shows "typeCon t' v"
proof -
  have "memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) = memory st" by simp
  moreover have "storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) = storage st" by simp
  moreover have "accounts (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) = accounts st" by simp
  moreover have "stack st = stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" by simp
  ultimately have "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"  using assms(2)  by metis
  then have a10:"typeCon t2 v" using exprTypeconInduct(3) assms(1,4) by force
  then show "typeCon t' v" using a10 assms(3) typeSafeConvert by simp
qed


text \<open>If you have an SCon memory and lexp returns something in that SCon memory the type must be the same\<close>

lemma lexpStorage:
  assumes "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"
    and "lexp lv env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage (STValue t')),g')"
    and "fullyInitialised env (accounts st) (stack st)"

obtains (1) 
  "((Storage (STValue t'), Storeloc locChanged) |\<in>| fmran (denvalue env))"
| (2) l t
where "((Storage t, Storeloc l) |\<in>| fmran (denvalue env))"
  and "(TypedStoSubpref locChanged l t \<and>  CompStoType t (STValue t') l locChanged)"

| (3) l' t l
where "((Storage t, Stackloc l) |\<in>| fmran (denvalue env))"
  and "accessStore l (stack st) = Some (KStoptr l')"
  and "(TypedStoSubpref locChanged l' t \<and>  CompStoType t (STValue t') l' locChanged)"
proof (cases lv)
  case (Id x1)
  then have "lexp (Id x1) env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage (STValue t')), g')" using assms(2) by simp
  then have "denvalue env $$ x1 = Some (Storage (STValue t'), Storeloc locChanged) " 
    using Id lexp.simps(1)[of x1 env cd "(st\<lparr>gas := g\<rparr>)" g] by (auto split:option.splits Denvalue.splits)
  then show ?thesis by (simp add: "1" fmranI)
next
  case (Ref x21 x22)
  then have *: "lexp (Ref x21 x22) env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage (STValue t')), g')" using assms(2) by simp
  then show ?thesis 
  proof(cases "denvalue env $$ x21")
    case None
    then show ?thesis using * lexp.simps(2) Ref by simp
  next
    case (Some a)
    then obtain tp loc where adef:"a = (Storage tp, loc)" using * lexp.simps(2) Ref by (cases a; (auto split: result.splits Type.splits Denvalue.splits option.splits Stackvalue.splits))
    then have b6:"(Storage tp, loc) |\<in>| fmran (denvalue env)" using Some by (simp add: fmranI)

    then show ?thesis
    proof(cases loc)
      case (Stackloc x1)
      then show ?thesis 
      proof(cases "accessStore x1 (stack st)")
        case None
        then show ?thesis using * Ref Stackloc lexp.simps(2)[of x21 x22 env cd "(st\<lparr>gas := g\<rparr>)" g] Some adef by simp
      next
        case some2:(Some a)
        then obtain x4 where x4def:"a = KStoptr x4" using * Ref Stackloc lexp.simps(2)[of x21 x22 env cd "(st\<lparr>gas := g\<rparr>)" g] Some adef some2 by (cases a; auto)
        then obtain l'' t'' where  b20:"ssel tp x4 x22 env cd (st\<lparr>gas := g\<rparr>) g = Normal ((l'', t''), g')" 
          using Stackloc Some Ref * lexp.simps(2) adef some2 by (auto split: result.splits Type.splits)
        have b10:"SCon tp x4 (storage st (address env))" using assms b6 some2 Stackloc x4def unfolding TypeSafe_def typeCompat_def by fastforce
        then have b30:"locChanged = l'' \<and> (STValue t') =  t''" using * lexp.simps(2) Ref adef Stackloc b20 some2 x4def Some Ref b6 by simp

        then show ?thesis 
        proof(cases x22)
          case Nil
          then have b25:"tp = t'' \<and> x4 = l''" using b20 ssel.simps(1) by simp
          then have b30:"locChanged = l'' \<and> (STValue t') =  t''" using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 by simp
          then show ?thesis using b6 3 b25  Stackloc some2 x4def by auto
        next
          case (Cons a list)
          then have b10:"(CompStoType tp t'' x4 l'')" 
            using exprTypeconInduct(2)[of tp x4 x22 env cd "(st\<lparr>gas := g\<rparr>)" g l'' t'' g'] assms 
            using b10 b20 some2 x4def unfolding fullyInitialised_def by simp
          have b30:"l'' = locChanged  \<and> (STValue t') =  t''" using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 by simp
          then have "CompStoType tp (STValue t') x4 l''" using b10 by simp
          then show ?thesis using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 b10 b30 3
            using CompStoType_imps_TypedStoSubpref by blast
        qed
      qed
    next
      case (Storeloc x2)
      then have b10:"SCon tp x2 (storage st (address env))" using assms b6 unfolding TypeSafe_def typeCompat_def by force
      then obtain l'' t'' where  b20:"ssel tp x2 x22 env cd (st\<lparr>gas := g\<rparr>) g = Normal ((l'', t''), g')" 
        using Storeloc Some Ref * lexp.simps(2) adef by (auto split: result.splits Type.splits)
      then show ?thesis 
      proof(cases x22)
        case Nil
        then have b25:"tp = t'' \<and> x2 = l''" using b20 ssel.simps(1) by simp
        then have b30:"locChanged = l'' \<and> (STValue t') =  t''" using * lexp.simps(2) Ref adef Storeloc b20  Some Ref b6 by simp
        then show ?thesis using b6 1 adef Some Ref * b25 b20 by (simp add: Storeloc)
      next
        case (Cons a list)
        then have b10:"CompStoType tp t'' x2 l''" 
          using exprTypeconInduct(2)[of tp x2 x22 env cd "(st\<lparr>gas := g\<rparr>)" g l'' t'' g'] assms 
          using b10 b20 Storeloc unfolding fullyInitialised_def by simp
        have b30:"l'' = locChanged  \<and> (STValue t') =  t''" using * lexp.simps(2) Ref adef Storeloc b20  Some Ref b6 by simp
        then have "CompStoType tp (STValue t') x2 l''" using b10 by simp
        then show ?thesis using b30 b6 2 adef Some Ref * b10 b20 Storeloc 
          using CompStoType_imps_TypedStoSubpref by blast
      qed
    qed
  qed
qed



lemma originalMConStillMCon:
  assumes "MCon struct (memory st) x3"
    and "(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"
    and "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs (memory st')"
    and "\<forall>locs.  \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) t' \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs (memory st')" 
  shows " MCon struct (memory st') x3" using assms(1)
proof(induction struct arbitrary: x3)
  case (MTArray x1 struct)
  have mcexp:"\<forall>i<x1.
(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st) (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st) loc2 | MTValue Types \<Rightarrow> False))" 
    using MTArray(2) unfolding MCon.simps by simp

  have "\<forall>i<x1.
(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
  proof(intros)
    fix i assume h1:"i<x1"
    show "case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st') loc2 | MTValue Types \<Rightarrow> False)"
    proof(cases "struct")
      case mta1:(MTArray x11 x12)
      then obtain v where vdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer v)" using h1 mcexp 
        using MTArray.prems(1) MConArrayPointers by blast
      then have vdef2:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer v)" using   assms(2) assms(3,4) 
        by (metis  nat_le_linear option.distinct(1))
      have "MCon struct (memory st) v" using vdef mcexp h1 mta1 by fastforce                     
      then have "MCon struct (memory st') v" using MTArray.IH[of v]  
        by simp
      then show ?thesis using mta1 h1 vdef vdef2 by simp
    next
      case (MTValue x2)
      then obtain v where vdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue v)" using h1 mcexp 
        using MCon_sub_MTVal_imps_val MTArray.prems(1) by presburger
      then have vdef2:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st')  = Some (MValue v)" using assms 
        by (metis  nat_le_linear  option.distinct(1))
      have "MCon struct (memory st) (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using vdef mcexp h1 MTValue by auto
      then show ?thesis using MTValue vdef vdef2 h1 by auto 
    qed
  qed

  moreover have "x3 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
    using MCon_imps_Some MTArray.prems LSubPrefL2_def assms(2) not_None_eq by blast
  moreover have " \<not> TypedMemSubPref x3 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) t'" using assms 
    by (metis (no_types, opaque_lifting) MCon_imps_Some MTArray.prems LSubPrefL2_def Not_Sub_More_Specific le_refl neg_MemLSubPrefL2_imps_TypedMemSubPref not_Some_eq)
  moreover have "((\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None)" 
    using  allocateSameAccess MTArray.prems    calculation assms
    by (metis  MCon.simps(2)) 

  ultimately show ?case unfolding MCon.simps 
    by (metis MTArray.prems(1) MCon.simps(2))
next
  case (MTValue x')
  then show ?case using   assms 
    by (metis Option.option.simps(4) le_eq_less_or_eq   MCon.simps(1))
qed

lemma originalSConStillMCon:
  assumes "MCon struct (memory st) x3"
    and "(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"
    and "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs (memory st')"
    and "\<forall>locs.  \<not> TypedStoSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) t' \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs (memory st')" 
  shows " MCon struct (memory st') x3" using assms(1)
proof(induction struct arbitrary: x3)
  case (MTArray x1 struct)
  have mcexp:"\<forall>i<x1.
(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st) (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st) loc2 | MTValue Types \<Rightarrow> False))" 
    using MTArray(2) unfolding MCon.simps by simp

  have "\<forall>i<x1.
(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
  proof(intros)
    fix i assume h1:"i<x1"
    show "case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case struct of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon struct (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
| Some (MPointer loc2) \<Rightarrow> (case struct of MTArray len' arr' \<Rightarrow> MCon struct (memory st') loc2 | MTValue Types \<Rightarrow> False)"
    proof(cases "struct")
      case mta1:(MTArray x11 x12)
      then obtain v where vdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer v)" using h1 mcexp 
        using MTArray.prems(1) MConArrayPointers by blast
      then have vdef2:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer v)" using   assms(2) assms(3,4) 
        by (metis  nat_le_linear option.distinct(1))

      have "MCon struct (memory st) v" using vdef mcexp h1 mta1 by fastforce                     
      then have "MCon struct (memory st') v" using MTArray.IH[of v]  
        by simp
      then show ?thesis using mta1 h1 vdef vdef2 by simp
    next
      case (MTValue x2)
      then obtain v where vdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue v)" using h1 mcexp 
        using MCon_sub_MTVal_imps_val MTArray.prems(1) by presburger
      then have vdef2:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st')  = Some (MValue v)" using assms  
        by (metis  nat_le_linear  option.distinct(1))
      have "MCon struct (memory st) (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using vdef mcexp h1 MTValue by auto
      then show ?thesis using MTValue vdef vdef2 h1 by auto 
    qed
  qed

  moreover have "x3 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
    using MCon_imps_Some MTArray.prems LSubPrefL2_def assms(2) not_None_eq by blast
  moreover have " \<not> TypedStoSubPref x3 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) t'" using assms 
    by (metis (no_types, opaque_lifting) MCon_imps_Some MTArray.prems LSubPrefL2_def Not_Sub_More_Specific le_refl not_Some_eq stoTypedPrefix_imp_SubPref)
  moreover have "((\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None)" 
    using  allocateSameAccess MTArray.prems    calculation assms
    by (metis MCon.simps(2)) 

  ultimately show ?case unfolding MCon.simps 
    by (metis MTArray.prems(1) MCon.simps(2))
next
  case (MTValue x')
  then show ?case using   assms 
    by (metis Option.option.simps(4) le_eq_less_or_eq   MCon.simps(1))
qed

lemma mselReturnAlwaysHash:
  assumes"msel True t l'' x22 env cd st g = Normal ((l, t'), g')" 
    and "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"
    and "MCon t (memory st) l''"
    and "fullyInitialised env (accounts st) (stack st)"
  shows "\<exists>prnt i len arr len' arr'. t= MTArray len arr \<and>  l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)  \<and> arr' = t' \<and> i < len' \<and> MCon (MTArray len' arr') (memory st) prnt
                        \<and> (prnt = l'' \<and> len = len' \<and> arr' = arr  \<or> CompMemType (memory st) len arr  (MTArray len' arr') l'' prnt) " using assms(1,3)
proof(induction "x22" arbitrary: t l'' g)
  case Nil
  then show ?case using msel.simps by simp
next
  case (Cons a x22)
  show ?case  using Cons(2)
  proof(cases rule: msel.elims )
    case (1 uv uw ux uy uz g)
    then show ?thesis by blast
  next
    case (2 vb vc vd ve vf vg g)
    then show ?thesis by auto
  next
    case (3 al t loc x env cd st g)
    then obtain kv b g4'  where a20: "local.expr x env cd st g = Normal ((KValue kv, Value (TUInt b)), g4')"
      and a30: "less (TUInt b) (TUInt b256) kv (ShowL\<^sub>i\<^sub>n\<^sub>t (int al)) = Some ((ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), TBool)"
      using  msel.simps(3) by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm option.split_asm Memoryvalue.split_asm)
    then have b2:"(hash loc kv, t) = (l, t')" using 3 by simp
    have a50: "checkUInt b kv" using exprTypeconInduct(3) 3(1) assms(2) a20 typeCon.simps(2)[of b "extractValueType (KValue kv)"] extractValueType.simps(1)[of kv] 
      using "3"(4,5,6) using assms(4)  by force
    then have a60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv) < int al " using a20 a30 less_def plift.simps(2)[of "(<)" b b256 kv "(ShowL\<^sub>i\<^sub>n\<^sub>t (int al))"] Read_ShowL_id[of "(int al)"] unfolding createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    then have a62:"0\<le>ReadL\<^sub>i\<^sub>n\<^sub>t(kv)" and a65:"(ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) = kv" using a50 checkUInt_def[of b kv] by simp+
    have a64:"(ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))) = kv" using ShowLnat_ReadLint_inverse a62 a50 unfolding checkUInt_def by simp
    then have a70:"(nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) \<in> {0..al-1}" using a60 a62 by simp
    have "loc = l''" using 3 by simp
    moreover have "(nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) < al" using a70 
      by (simp add: a60 a62 nat_less_iff)
    ultimately show ?thesis using b2 a64 a70 "3"(1) prod.inject 
      by (metis Cons.prems(2))

  next
    case (4 al t'' loc x y ys env cd st g'')
    then obtain kv b g4' ptr where a20: "local.expr x env cd st g'' = Normal ((KValue kv, Value (TUInt b)), g4')"
      and a30: "less (TUInt b) (TUInt b256) kv (ShowL\<^sub>i\<^sub>n\<^sub>t (int al)) = Some ((ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), TBool)"
      and a40:"accessStore (hash loc kv) (if True then memory st else cd) = Some (MPointer ptr)"
      using  msel.simps(3) by (simp split: result.split_asm prod.split_asm Types.split_asm Type.split_asm if_split_asm Stackvalue.split_asm option.split_asm Memoryvalue.split_asm)
    have a50: "checkUInt b kv" using exprTypeconInduct(3) 4(1) assms(2) a20 typeCon.simps(2)[of b "extractValueType (KValue kv)"] extractValueType.simps(1)[of kv] 
      using "4"(4,5,6) using assms(4) by force
    then have a60:"ReadL\<^sub>i\<^sub>n\<^sub>t(kv) < int al " using a20 a30 less_def plift.simps(2)[of "(<)" b b256 kv "(ShowL\<^sub>i\<^sub>n\<^sub>t (int al))"] Read_ShowL_id[of "(int al)"] unfolding createBool_def ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l_def by (simp split:if_split_asm)
    then have a62:"0\<le>ReadL\<^sub>i\<^sub>n\<^sub>t(kv)" and a65:"(ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) = kv" using a50 checkUInt_def[of b kv] by simp+
    have a64:"(ShowL\<^sub>n\<^sub>a\<^sub>t (nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv))) = kv" using ShowLnat_ReadLint_inverse a62 a50 unfolding checkUInt_def by simp
    then have a70:"(nat (ReadL\<^sub>i\<^sub>n\<^sub>t kv)) \<in> {0..al-1}" using a60 a62 by simp
    have tdef:"t = MTArray al t''" using 4 by simp
    then have mc:" MCon t'' (memory st) ptr" using Cons.prems a40 
      by (metis "4"(2,6) MCon_imps_sub_Mcon a60 a62 a64 nat_less_iff)

    then have mse:"msel True t'' ptr (y # ys) env cd st g4' = Normal ((l, t'), g')" using 4 a20 a30 a40  by simp
    then have "\<exists>prnt i len arr len' arr'.
       t'' = MTArray len arr \<and>
       l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = t' \<and> MCon (MTArray len' arr') (memory st) prnt \<and> (prnt = ptr \<and> len = len' \<and> arr' = arr \<or> CompMemType (memory st) len arr (MTArray len' arr') ptr prnt )" using Cons.IH[of t'' ptr g4'] 4(4,5,6,7,3) a64  mc by blast
    then obtain prnt i len arr len' arr' where defs:"t'' = MTArray len arr \<and>
       l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = t' \<and> MCon (MTArray len' arr') (memory st) prnt \<and> (prnt = ptr \<and> len = len' \<and> arr' = arr \<or> CompMemType (memory st) len arr (MTArray len' arr') ptr prnt )" by blast

    have a6:"(case t' of MTArray l' ar' \<Rightarrow> \<exists>p. accessStore l (if True then memory st else cd) = Some (MPointer p) 
                            \<and> CompMemType (if True then memory st else cd) len arr t' ptr p 
          | MTValue val \<Rightarrow> CompMemType (if True then memory st else cd) len arr t' ptr l )" 
      using exprTypeconInduct(1)[of True t'' ptr "(y # ys)" env cd st g4' l t' g'] mse mc assms(2) 4 defs 
      using assms(4) unfolding fullyInitialised_def by simp

    then show ?thesis 
    proof(cases "prnt = ptr")
      case True
      have notComp:"\<not>CompMemType (memory st) len arr (MTArray len' arr') ptr prnt" 
      proof
        assume in1:"CompMemType (memory st) len arr (MTArray len' arr') ptr prnt"
        show False
        proof(cases "arr")
          case (MTArray x11 x12)
          then have "(\<exists>i<len. \<exists>l. accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> 
                    (l = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType (memory st) x11 x12 (MTArray len' arr') l prnt))" 
            using in1 CompMemType.simps(2)[of "memory st" len x11 x12 "(MTArray len' arr')" ptr prnt] by auto
          moreover have " MCon (MTArray len (MTArray x11 x12)) (memory st) ptr" using mc defs MTArray by simp
          ultimately show ?thesis using True in1 mc defs 
            by (metis BothMConImpsNotCompMemType)
        next
          case (MTValue x2)
          then show ?thesis using in1 True by simp
        qed
      qed

      then have lenIslen':"len = len'" using defs mc a6 notComp by simp
      then have arrIsarr':"arr' = arr" using defs mc a6 notComp by blast

      then have notSame:"ptr \<noteq> l''" using defs mc 4 
        using Cons.prems(2) MConSubTypes CompMemJustType.simps(2) by blast
      have "CompMemType (memory st) al (MTArray len arr) (MTArray len' arr') loc prnt " 
        using CompMemType.simps(2)[of "memory st" al len arr "(MTArray len' arr')"  loc prnt] a40  True defs lenIslen' arrIsarr' 
        by (metis a60 a62 a64 nat_less_iff)
      moreover have "arr' = t'" using defs by simp
      ultimately show ?thesis using tdef True defs notSame 
        using "4"(6,2) by blast
    next
      case False
      then have "CompMemType (memory st) len arr (MTArray len' arr') ptr prnt" using defs by auto
      then show ?thesis 
        by (smt (verit, ccfv_SIG) "4"(2,6)
            \<open>\<exists>prnt i len arr len' arr'. t'' = MTArray len arr \<and> l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = t' \<and> MCon (MTArray len' arr') (memory st) prnt \<and> (prnt = ptr \<and> len = len' \<and> arr' = arr \<or> CompMemType (memory st) len arr (MTArray len' arr') ptr prnt)\<close>
            a40 a60 a62 a64 nat_less_iff CompMemType.simps(2) tdef)
    qed
  qed
qed

lemma lexpIndexMem:
  assumes "lexp lv env cd st g = Normal ((LMemloc l, Memory t'), g')"
    and "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"
    and "fullyInitialised env (accounts st) (stack st)"

obtains (1) x21 x22 tp tParent l' l'' prnt  len' arr' i
where  "lv = Ref x21 x22"
  and "(tp, Stackloc l') |\<in>| fmran (denvalue env)"
  and "accessStore l' (stack st) = Some (KMemptr l'')"
  and "tp = Memory tParent"
  and "MCon tParent (memory st) l''"
  and "(\<exists>len arr. tParent = MTArray len arr \<and> 
      (case t' of MTArray l' ar' \<Rightarrow>
          \<exists>p. accessStore l (memory st)  = Some (MPointer p) \<and> CompMemType (memory st) len arr t' l'' p 
      | MTValue val \<Rightarrow> CompMemType (memory st) len arr t' l'' l )
\<and>     l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = t' \<and> MCon (MTArray len' arr') (memory st) prnt \<and> (prnt = l'' \<and> len = len' \<and> arr' = arr \<or> CompMemType (memory st) len arr (MTArray len' arr') l'' prnt))"
proof(cases lv)
  case (Id x1)
  then show ?thesis using assms(1) lexp.simps(1)[of x1] by (auto split:option.splits Denvalue.splits)
next
  case (Ref x21 x22)
  then obtain tp l' where tpdef:"denvalue env $$ x21 = Some (tp, Stackloc l')" 
    using assms(1) lexp.simps(2)[of x21 x22 env cd "st"]  
    by (auto split:option.splits Denvalue.splits Type.splits result.splits)
  then have parentIn:"( tp, Stackloc l') |\<in>| fmran (denvalue env)" using fmranI by metis
  then obtain l'' where access:"accessStore l' (stack st) = Some (KMemptr l'')" 
    using Ref assms(1) lexp.simps(2)[of x21 x22 env cd "st"]  tpdef
    by (auto split:option.splits Denvalue.splits Type.splits result.splits Stackvalue.splits)
  then obtain t where tdef:"tp = Memory t" using access tpdef Ref assms(1) lexp.simps(2)[of x21 x22 env cd "st"]  
    by (auto split:option.splits Denvalue.splits Type.splits result.splits Stackvalue.splits)
  then have msel12:"msel True t l'' x22 env cd st g = Normal ((l, t'), g')" using access tpdef Ref assms(1) lexp.simps(2)[of x21 x22 env cd "st"]  
    by (auto split:option.splits Denvalue.splits Type.splits result.splits Stackvalue.splits prod.splits)
  have " MCon t (memory st) l''" 
    using access assms(2) parentIn sameMemTSafe tdef by blast
  then obtain prnt i len arr len' arr' where a1:"
     t = MTArray len arr \<and> l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> arr' = t' \<and> i < len' \<and> MCon (MTArray len' arr') (memory st) prnt \<and> (prnt = l'' \<and> len = len' \<and> arr' = arr \<or> CompMemType (memory st) len arr (MTArray len' arr') l'' prnt)" 
    using mselReturnAlwaysHash[OF msel12  assms(2)] assms(3)  unfolding fullyInitialised_def by blast

  have mconP:"MCon t (memory st) l''" using tpdef access tdef assms(2)
    by (meson assms(2) fmranI sameMemTSafe)
  have "x22 \<noteq> []" using msel12 msel.simps by auto
  then have a6:"(\<exists>len arr.
       t = MTArray len arr \<and>
       (case t' of
        MTArray l' ar' \<Rightarrow>
          \<exists>p. accessStore l (memory st) = Some (MPointer p) \<and>
              CompMemType (memory st) len arr t' l'' p 
        | MTValue val \<Rightarrow> CompMemType (memory st) len arr t' l'' l ))" 
    using exprTypeconInduct(1)[of True t l'' x22 env cd "st" g l t' g'] assms(2) mconP msel12 assms(3)  unfolding fullyInitialised_def 
    by presburger
  then show ?thesis using msel12 1[OF Ref parentIn access tdef mconP, of prnt i len' arr' ] a1 by blast
qed

lemma lexpStorageG:
  assumes "TypeSafe env (accounts st) (stack st) (memory st) (storage st) cd"

and "lexp lv env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage t'),g')"
and "fullyInitialised env (accounts st) (stack st)"

obtains (1) 
  "((Storage t', Storeloc locChanged) |\<in>| fmran (denvalue env))"
| (2) l t
where "((Storage t, Storeloc l) |\<in>| fmran (denvalue env))"
  and "(TypedStoSubpref locChanged l t \<and>  CompStoType t t' l locChanged)"

| (3) l' t l
where "((Storage t, Stackloc l) |\<in>| fmran (denvalue env))"
  and "accessStore l (stack st) = Some (KStoptr l')"
  and "(TypedStoSubpref locChanged l' t \<and>  CompStoType t t' l' locChanged)"
proof (cases lv)
  case (Id x1)
  then have "lexp (Id x1) env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage ( t')), g')" using assms(2) by simp
  then have "denvalue env $$ x1 = Some (Storage ( t'), Storeloc locChanged) " 
    using Id lexp.simps(1)[of x1 env cd "(st\<lparr>gas := g\<rparr>)" g] by (auto split:option.splits Denvalue.splits)
  then show ?thesis by (simp add: "1" fmranI)
next
  case (Ref x21 x22)
  then have *: "lexp (Ref x21 x22) env cd (st\<lparr>gas := g\<rparr>) g = Normal ((LStoreloc locChanged, Storage ( t')), g')" using assms(2) by simp
  then show ?thesis 
  proof(cases "denvalue env $$ x21")
    case None
    then show ?thesis using * lexp.simps(2) Ref by simp
  next
    case (Some a)
    then obtain tp loc where adef:"a = (Storage tp, loc)" using * lexp.simps(2) Ref by (cases a; (auto split: result.splits Type.splits Denvalue.splits option.splits Stackvalue.splits))
    then have b6:"(Storage tp, loc) |\<in>| fmran (denvalue env)" using Some by (simp add: fmranI)

    then show ?thesis
    proof(cases loc)
      case (Stackloc x1)
      then show ?thesis 
      proof(cases "accessStore x1 (stack st)")
        case None
        then show ?thesis using * Ref Stackloc lexp.simps(2)[of x21 x22 env cd "(st\<lparr>gas := g\<rparr>)" g] Some adef by simp
      next
        case some2:(Some a)
        then obtain x4 where x4def:"a = KStoptr x4" using * Ref Stackloc lexp.simps(2)[of x21 x22 env cd "(st\<lparr>gas := g\<rparr>)" g] Some adef some2 by (cases a; auto)
        then obtain l'' t'' where  b20:"ssel tp x4 x22 env cd (st\<lparr>gas := g\<rparr>) g = Normal ((l'', t''), g')" 
          using Stackloc Some Ref * lexp.simps(2) adef some2 by (auto split: result.splits Type.splits)
        have b10:"SCon tp x4 (storage st (address env))" using assms b6 some2 Stackloc x4def unfolding TypeSafe_def typeCompat_def by fastforce
        then have b30:"locChanged = l'' \<and> ( t') =  t''" using * lexp.simps(2) Ref adef Stackloc b20 some2 x4def Some Ref b6 by simp

        then show ?thesis
        proof(cases x22)
          case Nil
          then have b25:"tp = t'' \<and> x4 = l''" using b20 ssel.simps(1) by simp
          then have b30:"locChanged = l'' \<and> ( t') =  t''" using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 by simp
          then show ?thesis using b6 3 b25  Stackloc some2 x4def 
            using CompStoType_sameLocNdTyp TypedStoSubpref_sameLoc by auto
        next
          case (Cons a list)
          then have b10:"CompStoType tp t'' x4 l''" 
            using exprTypeconInduct(2)[of tp x4 x22 env cd "(st\<lparr>gas := g\<rparr>)" g l'' t'' g'] assms 
            unfolding fullyInitialised_def using b10 b20 some2 x4def by simp
          have b30:"l'' = locChanged  \<and> (t') =  t''" using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 by simp
          then have "CompStoType tp (t') x4 l''" using b10 by simp
          then show ?thesis using * lexp.simps(2) Ref adef Stackloc some2 x4def b20 Some Ref b6 b10 b30 3 
            using CompStoType_imps_TypedStoSubpref by blast
        qed
      qed
    next
      case (Storeloc x2)
      then have b10:"SCon tp x2 (storage st (address env))" using assms b6 unfolding TypeSafe_def typeCompat_def by force
      then obtain l'' t'' where  b20:"ssel tp x2 x22 env cd (st\<lparr>gas := g\<rparr>) g = Normal ((l'', t''), g')" 
        using Storeloc Some Ref * lexp.simps(2) adef by (auto split: result.splits Type.splits)
      then show ?thesis 
      proof(cases x22)
        case Nil
        then have b25:"tp = t'' \<and> x2 = l''" using b20 ssel.simps(1) by simp
        then have b30:"locChanged = l'' \<and> (t') =  t''" using * lexp.simps(2) Ref adef Storeloc b20  Some Ref b6 by simp
        then show ?thesis using b6 1 adef Some Ref * b25 b20 by (simp add: Storeloc)
      next
        case (Cons a list)
        then have b10:"CompStoType tp t'' x2 l''" 
          using exprTypeconInduct(2)[of tp x2 x22 env cd "(st\<lparr>gas := g\<rparr>)" g l'' t'' g'] b20 assms 
          unfolding fullyInitialised_def using b10 b20 Storeloc by simp
        have b30:"l'' = locChanged  \<and> (t') =  t''" using * lexp.simps(2) Ref adef Storeloc b20  Some Ref b6 by simp
        then have "CompStoType tp (t') x2 l''" using b10 by simp
        then show ?thesis using b30 b6 2 adef Some Ref * b10 b20 Storeloc 
          using CompStoType_imps_TypedStoSubpref by blast
      qed
    qed
  qed
qed

lemma limitsCarried:
  assumes "(\<forall>i loc loc2. i < toploc memN \<and> toploc memO \<le> i \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> accessStore loc memN = Some (MPointer loc2) \<longrightarrow> loc = loc2)"
    and "\<forall>loc y. accessStore loc memN = Some y \<longrightarrow> (\<exists>tloc. tloc<(toploc memN) \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc))"
    and "\<exists>x. LSubPrefL2 x3 (ShowL\<^sub>n\<^sub>a\<^sub>t x) \<and> x < toploc memO"
    and "TypedMemSubPrefPtrs memN x11 x12 mem_loc x3"
  shows "\<exists>i<toploc memO. LSubPrefL2 mem_loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)" using assms(4)
proof(induction x12 arbitrary:x11 mem_loc)
  case (MTArray x1 x12)
  then obtain i l where idef:"i<x11 \<and> accessStore (hash mem_loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) memN = Some (MPointer l) \<and> (l = x3 \<or> TypedMemSubPrefPtrs memN x1 x12 l x3)"
    unfolding TypedMemSubPrefPtrs.simps by blast
  then have lestTop:"\<exists>ii::nat<toploc memN. LSubPrefL2 (hash mem_loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ii)" using assms by simp
  then show ?case
  proof(cases "l = x3")
    case True
    then show ?thesis
    proof(cases "\<exists>ii. toploc memO \<le> ii \<and> LSubPrefL2 (hash mem_loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t ii)")
      case True
      then show ?thesis using MTArray.prems idef assms lestTop 
        by (metis MTArray.IH MemLSubPrefL2_specific_imps_general linorder_le_less_linear)
    next
      case False
      then show ?thesis using idef assms lestTop 
        by (metis MemLSubPrefL2_specific_imps_general linorder_not_less)
    qed
  next
    case False
    then show ?thesis using MTArray.IH[of x1 l] MTArray.prems idef assms 
      by (metis MemLSubPrefL2_specific_imps_general linorder_not_less)
  qed
next
  case (MTValue x)
  then show ?case  using assms
    by (metis MemLSubPrefL2_specific_imps_general TypedMemSubPrefPtrs.simps(1))
qed

definition allStoresSCon::"(Address \<Rightarrow> StorageT) \<Rightarrow> bool"
  where "allStoresSCon stoN =  (\<forall>e ct t' l'. ep $$ contract e = Some ct 
\<and> (Storage t', Storeloc l') |\<in>| fmran (denvalue (e::Environment))  \<longrightarrow> (SCon t' l' (stoN (address (e::Environment)))))"


definition StateInvariant :: "Environment \<Rightarrow> State \<Rightarrow> State \<Rightarrow> CalldataT \<Rightarrow> bool" where
  "StateInvariant ev st_orig st_curr cd \<equiv>
     TypeSafe ev (accounts st_curr) (stack st_curr) (memory st_curr) (storage st_curr) cd \<and>
     fullyInitialised ev (accounts st_curr) (stack st_curr)
    "

lemma TypeSafe_Statements:
  assumes "TypeSafe ev (accounts st) (stack st) (memory st) (storage st) cd" 
    and normal:"stmt smt ev cd st = Normal((),st')"
    and inits:"fullyInitialised ev (accounts st) (stack st)"
  shows  "StateInvariant ev st st' cd"
  using assms(1,2,3)
proof (induction arbitrary: st' rule:stmt.induct)
  case (1 e cd st)
  have *:"st' = st\<lparr>gas := gas st - costs SKIP e cd st\<rparr>" using 1 skip by simp
  moreover have "stack st = stack st'" using * by simp
  moreover have memSame:"memory st' = memory st" using * by simp
  moreover have "storage st' = storage st" using * by simp
  moreover have "accounts st' = accounts st" using * by simp
  moreover have "WrittenMem_between (memory st) (memory st') = {}" using calculation unfolding WrittenMem_between_def by simp
  moreover have "ReachableMem e (stack st') (memory st') = ReachableMem e (stack st) (memory st)" unfolding ReachableMem.simps using calculation by metis

  ultimately show ?case using assms 1 * unfolding StateInvariant_def fullyInitialised_def  by auto
next
  case (2 lv ex env cd st)
  then show ?case 
  proof (cases rule:assign[OF 2(2)])
    case (1 v t2 g l2 t' g' v')
    show "StateInvariant env st st' cd" unfolding StateInvariant_def TypeSafe_def 
    proof (intros)
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd" unfolding typeCompat_def
      proof intros
        fix t l assume a10:"(t, l) |\<in>| fmran (denvalue env)"
        show "case l of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)"
        proof (split Denvalue.split, intros)
          fix loc assume a20:"l = Stackloc loc"
          show "case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
          proof (cases "loc = l2") 
            case False
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then have "accessStore loc (stack st) = None" using 1(4) False by (simp add:stackSingleUpdate)
              then show False using a30 a20 a10 assms False "2.prems"(1) unfolding TypeSafe_def typeCompat_def  by force
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have a40:"accessStore loc (stack st) = Some x2" using 1(4) False by (simp add:stackSingleUpdate)
              then have a50:"(memory st) = (memory st')" using 1(4) by simp
              then have a60:"(storage st) = (storage st')" using 1(4) by simp
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                    | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                    | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                    | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)" 
                using a10 a20 a30 a40 a50 a60 "2.prems"(1) unfolding TypeSafe_def typeCompat_def by (cases x2; cases t; force)
            qed
          next 
            case sameLoc:True
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then show False using a20 a10 assms(1) sameLoc 1(4) notNoneUpdate[of st' g' loc "KValue v'" st] by simp
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
              proof(cases "x2")
                case (KValue x1)
                then have a40:"unique_locations (denvalue env)" using 2(1) typeSafeUnique by simp
                then have "(Value t', l2) = (t, loc)" using  a40 a20 1(2) lexpStackloc_imps_inDen a10 sameLoc uniqueLocs[of env "(t,l)" "(Value t', Stackloc l2)"] by simp
                then have True:"Value t' = t" by simp
                then have a40:"v' = v" using convertSame[of t2 t' v v'] 1(3) by simp
                moreover have "typeCon t' v" using typeConConvert[of ex env cd st lv v t2 g t'] a40 1 2(1) 2(3) by simp
                moreover have "x1 = v" using sameLoc a30 a40 KValue 1(4) notNoneUpdate[of st' g' l2 "(KValue x1)"  st] notNoneUpdate[of st' g' l2 "(KValue v')"  st] by simp
                ultimately have "typeCon t' x1" by simp
                then show ?thesis using True KValue by auto
              next
                case (KCDptr x2)
                then show ?thesis using a30 "1"(4) by (simp add:sameLoc)
              next
                case (KMemptr x3)
                then show ?thesis using a30 "1"(4) by (simp add:sameLoc)
              next
                case (KStoptr x4)
                then show ?thesis using a30 "1"(4) by (simp add:sameLoc)
              qed
            qed
          qed

        next
          fix x2 assume a20:"l = Storeloc x2"
          then have "(storage st' (address env)) = (storage st (address env))" using 1(4) by simp
          then show "case t of Storage typ \<Rightarrow> SCon typ x2 (storage st' (address env)) | _ \<Rightarrow> False"  
            using a10 a20  "2.prems"(1) unfolding TypeSafe_def typeCompat_def by (cases t; force)
        qed
      qed
    next
      show "unique_locations (denvalue env)" using 2(1) typeSafeUnique by auto
    next
      have "(accounts st) = accounts(st')" using 1(4) by simp
      then show "balanceTypes (accounts st')" using balanceTypes_def balanceTypes_def 2(1) typeSafeAccounts by simp
    next
      show " compPointers (stack st')  (denvalue env)" unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l22 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l22) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l22 = Storeloc stl2)"
        then have 10:"accessStore l1' (stack st) = Some (KStoptr stl1) \<or> l1 = Storeloc stl1" using 1(4) 2(1) updateOneType[of st' g' l2 "(KValue v')" st "(KStoptr stl1)" l1' ] by auto
        then have 20:"accessStore l2' (stack st) = Some (KStoptr stl2) \<or> l22 = Storeloc stl2" using a1 1(4) 2(1) updateOneType[of st' g' l2 "(KValue v')" st "(KStoptr stl2)" l2' ] by auto
        have "storage st' (address env) = (storage st (address env))" using a1 1(4) 2(1) updateOneType[of st' g' l2 "(KValue v')" st "(KStoptr stl2)" l2' ] by auto
        then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"  
          using 2(1) a1 10 20 unfolding TypeSafe_def compPointers_def by blast
      qed
    next
      show "svalueTypes (svalue env)" using svalueTypes_def typeSafeSvalue 2(1) by simp
    next
      have "(storage st') = (storage st)" using 1(4) by simp
      then show "safeContract (storage st')" using 2(1) unfolding safeContract_def TypeSafe_def  by auto
    next
      have a10:"toploc (stack st') = toploc (stack st)" using 1(4) unfolding updateStore_def by simp
      then have "(Value t', Stackloc l2) |\<in>| fmran (denvalue env)"  using 2(1) 1(2) lexpStackloc_imps_inDen by simp
      then have a20:"\<exists>val. accessStore l2 (stack st) = Some val" using typeSafeLocExists 2(1) TypeSafe_def by blast
      then have a30:"(\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                     \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using 2(1) unfolding TypeSafe_def  lessThanTopLocs_def by simp
      then have a40:"(\<forall>tloc loc. toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                      \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using a10 by simp
      show "lessThanTopLocs (stack st')" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then show "accessStore loc (stack st') = None"
        proof(cases "loc = l2")
          case True
          then show ?thesis using * a10 
            by (metis a20 a30 option.distinct(1)) 
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 1(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using 2(1) a40 * a10 False a30 by simp
        qed
      next 
        fix loc y 
        assume *:" accessStore loc (stack st') = Some y "
        show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        proof(cases "loc = l2")
          case True
          then show ?thesis using *a10 a20 a30 by simp
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 1(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using * 2(1) a40 by simp
        qed
      qed
    next
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def using 1 by auto
    next 
      show "lessThanTopLocs (memory st')" using 2(1) unfolding TypeSafe_def using 1 by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def  by auto
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      have sameMemory: "memory st = memory st'" using 1 by simp
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2' stl1 stl2 dloc1
        assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2' (stack st') = Some (KMemptr stl2) "
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using 2(1)  unfolding TypeSafe_def unique_locations_def by blast

        have a3:"\<forall>dloc1.
     (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2' (stack st) = Some (KMemptr stl2) \<longrightarrow>
     (if stl1 = stl2 then tp1 = tp2
      else case tp1 of
           MTArray len arr \<Rightarrow>
             (case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
               else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                    else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
           | MTValue val \<Rightarrow>
               (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
               | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

        then have "l1 \<noteq> l2 \<and> l2' \<noteq> l2" using 1 a1 unfolding updateStore_def accessStore_def by auto
        then have "accessStore l1 (stack st) = Some (KMemptr stl1) \<and>  accessStore l2' (stack st) = Some (KMemptr stl2)" using 1(4) a1 unfolding updateStore_def accessStore_def by auto

        then show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)" using a1 a3 sameMemory
          by (metis (lifting) ext)
      qed
    next 
      show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using 1 by simp
    next 
      have "accounts st'= accounts st" using 1 by auto
      then show "fullyInitialised env (accounts st') (stack st')" using 2(3) 1(4) unfolding fullyInitialised_def updateStore_def accessStore_def by simp    
    qed
  next
    case subcase2:(2 v t2 g locationChanged t' g' v')
    then have tpCon:"typeCon t2 (extractValueType (KValue v)) \<and> (\<exists>xx. KValue v = KValue xx)" 
      using exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KValue v" "Value t2" g] 
      using "2.prems"(1) 2(3) unfolding fullyInitialised_def by force
    then have tcon:"typeCon t' v'" using typeSafeConvert[of t2 "(extractValueType (KValue v))" t' ] subcase2(3) 
      by (metis convertSame extractValueType.simps(1))
    have stacksSame:"stack st = stack st'" using subcase2(4) by simp
    have accessStoreSt:"storage st' (address env) $$ locationChanged = Some v'" using subcase2 by simp
    then have scont':"SCon (STValue t') locationChanged (storage st' (address env))" 
      using SCon.simps(1)[of t' locationChanged "storage st' (address env)"] accessStorage_def tcon by simp
    have nonLocChanged:"\<forall>l. l \<noteq> locationChanged \<longrightarrow> storage st' (address env) $$ l = storage st (address env) $$ l"  using subcase2 by simp
    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros
      show "unique_locations (denvalue env)" using 2(1) typeSafeUnique by simp
    next
      have "compPointers (stack st)  (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      show "compPointers (stack st')  (denvalue env)" unfolding compPointers_def  using "2.prems"(1) compPointers_def stacksSame typeSafeCompPointers by force

    next
      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next
      have "accounts st' = accounts st" using subcase2(4) by simp
      then show "balanceTypes (accounts st')"  using 2(1)  unfolding TypeSafe_def balanceTypes_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next
      have "stack st = stack st'" using subcase2(4) by simp
      then show "lessThanTopLocs (stack st')" using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    next
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd" unfolding typeCompat_def
      proof intros
        fix t l 
        assume inDen:"(t, l) |\<in>| fmran (denvalue env)"
        then show "case l of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False
               | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
               | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
               | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
               | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)"
        proof (cases l)
          case (Stackloc loc)
          then have "l \<noteq> Storeloc locationChanged" by simp
          then have same:"accessStore loc (stack st) = accessStore loc (stack st')" using subcase2(4) by simp
          then show ?thesis 
          proof(cases "accessStore loc (stack st')")
            case None
            then show ?thesis using same 2(1) inDen Stackloc unfolding TypeSafe_def typeCompat_def by fastforce
          next
            case (Some a)
            have samemem:"(memory st) = memory st'" using subcase2(4) by simp
            then show ?thesis
            proof(cases a)
              case (KValue x1)
              then show ?thesis using Some same 2(1) inDen Stackloc unfolding TypeSafe_def typeCompat_def by fastforce
            next
              case (KCDptr x2)
              then show ?thesis using Some same 2(1) inDen Stackloc unfolding TypeSafe_def typeCompat_def samemem by fastforce
            next
              case (KMemptr x3)
              then show ?thesis using Some same 2(1) inDen Stackloc unfolding TypeSafe_def typeCompat_def samemem by fastforce
            next
              case (KStoptr x4)
              then have a20:"accessStore loc (stack st) = Some (KStoptr x4)" using same Some by simp
              have a25:"(case l of
              Stackloc loc \<Rightarrow>
                (case accessStore loc (stack st) of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st) stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address env)) | _ \<Rightarrow> False))
              | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address env)) | _ \<Rightarrow> False))" 
                using 2(1) unfolding TypeSafe_def typeCompat_def using inDen by simp
              then obtain struct where a30:"t = Storage struct" using a20 Stackloc by (simp split:Type.splits)
              then have a40:"SCon struct x4 (storage st (address env))" using a25 a20 Stackloc by (simp split:Type.splits)
              have tCont2v:"typeCon t2 v" using subcase2(1) extractValueType.simps 2(1) 
                using exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KValue v" "Value t2" g] 
                using 2(3) unfolding fullyInitialised_def 
                by (simp)
              have "v' = v" using  convertSame[of t2 t' v v'] subcase2(3) by simp
              then have tCont'v:"typeCon t' v" using typeSafeConvert[of t2 v t'] subcase2(3) tCont2v by simp
              have "SCon struct x4 (storage st' (address env))" using a40 a30 inDen
              proof(cases "TypedStoSubpref locationChanged x4 struct")
                case subloc:True
                have compPtr:"(\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
                        (Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
                        (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
                        (l1 = Stackloc l1' \<and> accessStore l1' (stack st) = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) 
                        \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
                        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
                  using 2(1)  unfolding TypeSafe_def compPointers_def  by auto
                then show ?thesis 
                proof(cases rule:lexpStorage[OF 2(1) subcase2(2) 2(3)])
                  case 11:1
                  then have b40:"CompStoType struct (STValue t') x4 locationChanged" 
                    using inDen Stackloc Some KStoptr a20  a30   compPtr subloc by metis
                  then show ?thesis
                  proof(cases "x4 = locationChanged")
                    case True
                    then have "struct = (STValue t')" using b40 by (simp add: CompStoType_sameLoc_sameType)
                    then show ?thesis using True scont' by auto
                  next
                    case x4Dif:False
                    then have c0:"CompStoType struct (STValue t') x4 locationChanged" using subloc b40 by simp
                    then obtain i'' where c1:"(hash x4 i'' = locationChanged)" using CompStoType_imps_subloc x4Dif by blast
                    then have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                      by (metis TypedStoSubpref_sameLoc nonLocChanged)
                    then show ?thesis using stvalueLocationsInduct a40  x4Dif c1 scont' c0 nonLocChanged by blast
                  qed
                next
                  case (2 l'' t'')
                  have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                    by (metis TypedStoSubpref_sameLoc nonLocChanged)
                  have b40:"if TypedStoSubpref x4 l'' t'' then CompStoType t'' struct l'' x4
                                  else if TypedStoSubpref l'' x4 struct then CompStoType struct t'' x4 l'' 
                                    else True"
                    using compPtr inDen Stackloc Some KStoptr a20  a30 2  by blast
                  then show ?thesis using subloc 2
                  proof(cases "x4 = l''")
                    case True
                    then have stt:"struct = t''" using b40 
                      using CompStoType_sameLoc_sameType TypedStoSubpref_sameLoc by auto
                    then show ?thesis 
                    proof(cases "l'' = locationChanged")
                      case t4:True
                      then show ?thesis using  stt True scont' 
                        using "2"(2) CompStoType_sameLoc_sameType by blast
                    next
                      case False
                      have c0:"CompStoType struct (STValue t') x4 locationChanged" using 2(2) True stt by simp
                      then have "\<exists>y. hash l'' y = locationChanged" using subloc "2"(2) TypedStoSubpref_b False by auto
                      then obtain i'' where c1:"(hash x4 i'' = locationChanged)" using CompStoType_imps_subloc False True by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 by blast 
                    qed
                  next
                    case x4Dif:False
                    then show ?thesis
                    proof(cases "TypedStoSubpref x4 l'' t''")
                      case d5:True
                      then have d7:"CompStoType t'' struct l'' x4" using b40 by simp
                      have d9:"CompStoType t'' (STValue t') l'' locationChanged" using 2(2) by simp
                      have d10:"CompStoType struct (STValue t') x4 locationChanged" using tap[of t'' t' l'' locationChanged struct x4] subloc d7 d9 by blast
                      then have d11:"\<exists>x. hash l'' x = x4" using TypedStoSubpref_b x4Dif d5 by auto
                      then show ?thesis 
                      proof(cases "l'' = locationChanged")
                        case True
                        then obtain i'' where d11:"hash locationChanged i'' = x4" using d11 by auto
                        then show ?thesis using subloc using TypedStoSubpref_hashes by auto
                      next
                        case False
                        then have "\<exists>x. hash l'' x = locationChanged" using 2(2) TypedStoSubpref_b by auto
                        then have "\<exists>x. hash l'' x = x4" using d11 using hash_suffixes_associative by auto
                        then show ?thesis
                        proof(cases "x4 = locationChanged")
                          case True
                          then have "struct = (STValue t')" using d10 by (simp add: CompStoType_sameLoc_sameType)
                          then show ?thesis using True scont' by auto
                        next
                          case False
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" 
                            using subloc False TypedStoSubpref_b[of locationChanged x4 struct] by blast
                          then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 d10 by blast
                        qed
                      qed
                    next
                      case f5:False
                      then show ?thesis
                      proof(cases "TypedStoSubpref l'' x4 struct")
                        case True
                        then have d5:"TypedStoSubpref l'' x4 struct"  by simp
                        then have d7:"CompStoType struct t'' x4 l''" using b40 f5 by simp
                        then have d10:"\<exists>x. hash x4 x = l''" using TypedStoSubpref_b x4Dif d5 by auto
                        then show ?thesis 
                        proof(cases "l'' = locationChanged")
                          case True
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" using d10 by auto
                          then have d15:"t'' = STValue t'" using 2(2) CompStoType_sameLoc_sameType True by auto
                          then have c0:"CompStoType struct (STValue t') x4 locationChanged" using 2(2) d15 d7 by fastforce
                          then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 d11 by blast 
                        next
                          case False
                          then have "\<exists>x. hash l'' x = locationChanged" using 2(2) TypedStoSubpref_b by auto
                          then have "\<exists>x. hash x4 x = locationChanged" using d10 using hash_suffixes_associative by auto
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" by auto
                          then have "CompStoType struct (STValue t') x4 locationChanged" using CompStoType_trns 2(2)  d7 by blast
                          then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 by blast
                        qed
                      next
                        case False
                        have "x4 \<noteq> locationChanged" using 2(2) f5 by blast
                        then show ?thesis using  a40 False f5 2(2) singleLocChanged_nonchanged_SCon 
                          using nonLocChanged by blast
                      qed
                    qed
                  qed
                next
                  case (3 l'' t'' l)
                  have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                    by (metis TypedStoSubpref_sameLoc nonLocChanged)
                  then have b40:"if TypedStoSubpref x4 l'' t'' then CompStoType t'' struct l'' x4
                                  else if TypedStoSubpref l'' x4 struct then CompStoType struct t'' x4 l'' 
                                    else True"
                    using compPtr inDen Stackloc Some KStoptr a20  a30 3  by blast
                  then show ?thesis using subloc 2
                  proof(cases "x4 = l''")
                    case True
                    then have stt:"struct = t''" using b40 
                      using CompStoType_sameLoc_sameType TypedStoSubpref_sameLoc by auto
                    then show ?thesis 
                    proof(cases "l'' = locationChanged")
                      case t4:True
                      then show ?thesis using  stt True scont' 
                        using "3"(3) CompStoType_sameLoc_sameType by blast
                    next
                      case False
                      have c0:"CompStoType struct (STValue t') x4 locationChanged" using 3(3) True stt by simp
                      then have "\<exists>y. hash l'' y = locationChanged" using subloc 3(3) TypedStoSubpref_b False by auto
                      then obtain i'' where c1:"(hash x4 i'' = locationChanged)" using CompStoType_imps_subloc False True by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 by blast 
                    qed
                  next
                    case x4Dif:False
                    then show ?thesis
                    proof(cases "TypedStoSubpref x4 l'' t''")
                      case d5:True
                      then have d7:"CompStoType t'' struct l'' x4" using b40 by simp
                      have d9:"CompStoType t'' (STValue t') l'' locationChanged" using 3(3) by simp
                      have d10:"CompStoType struct (STValue t') x4 locationChanged" using tap[of t'' t' l'' locationChanged struct x4] subloc d7 d9 by blast
                      then have d11:"\<exists>x. hash l'' x = x4" using TypedStoSubpref_b x4Dif d5 by auto
                      then show ?thesis 
                      proof(cases "l'' = locationChanged")
                        case True
                        then obtain i'' where d11:"hash locationChanged i'' = x4" using d11 by auto
                        then show ?thesis using subloc using TypedStoSubpref_hashes by auto
                      next
                        case False
                        then have "\<exists>x. hash l'' x = locationChanged" using 3(3) TypedStoSubpref_b by auto
                        then have "\<exists>x. hash l'' x = x4" using d11 using hash_suffixes_associative by auto
                        then show ?thesis
                        proof(cases "x4 = locationChanged")
                          case True
                          then have "struct = (STValue t')" using d10 by (simp add: CompStoType_sameLoc_sameType)
                          then show ?thesis using True scont' by auto
                        next
                          case False
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" 
                            using subloc False TypedStoSubpref_b[of locationChanged x4 struct] by blast
                          then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 d10 by blast
                        qed
                      qed
                    next
                      case f5:False
                      then  show ?thesis 
                      proof(cases "TypedStoSubpref l'' x4 struct")
                        case True
                        then have d5:"TypedStoSubpref l'' x4 struct"  by simp
                        then have d7:"CompStoType struct t'' x4 l''" using b40 f5 by simp
                        then have d10:"\<exists>x. hash x4 x = l''" using TypedStoSubpref_b x4Dif d5 by auto
                        then show ?thesis 
                        proof(cases "l'' = locationChanged")
                          case True
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" using d10 by auto
                          then have d15:"t'' = STValue t'" using 3(3) CompStoType_sameLoc_sameType True by auto
                          then have c0:"CompStoType struct (STValue t') x4 locationChanged" using 3(3) d15 d7 by fastforce
                          then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 d11 by blast 
                        next
                          case False
                          then have "\<exists>x. hash l'' x = locationChanged" using 3(3) TypedStoSubpref_b by auto
                          then have "\<exists>x. hash x4 x = locationChanged" using d10 using hash_suffixes_associative by auto
                          then obtain i'' where d11:"hash x4 i'' = locationChanged" by auto
                          then have "CompStoType struct (STValue t') x4 locationChanged" using CompStoType_trns 3(3)  d7 by blast
                          then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 by blast
                        qed
                      next
                        case False
                        have "x4 \<noteq> locationChanged" using  f5 
                          using "3"(3) by auto
                        then show ?thesis using  a40 False f5 3(3) singleLocChanged_nonchanged_SCon 
                          using nonLocChanged by blast
                      qed
                    qed
                  qed
                qed
              next
                case f1:False
                then show ?thesis using a40
                proof(induction struct arbitrary:x4)
                  case (STArray x1 struct)
                  have b10:"\<forall>i<x1. SCon struct (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st (address env))" 
                    using STArray(3) using SCon.simps(2)[of x1 struct x4 "(storage st (address env))"] by auto
                  have b20:"\<forall>i<x1. \<not> TypedStoSubpref locationChanged (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct 
                                    \<and> locationChanged \<noteq> hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)" 
                    using STArray(2) TypedStoSubpref.simps(2)[of locationChanged x4 x1 struct] 
                    using TypedStoSubpref_sameLoc by auto
                  then have b30:"\<forall>i<x1. \<not> TypedStoSubpref locationChanged (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct " by auto
                  have " (\<forall>i<x1. SCon struct (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st' (address env)))" 
                  proof(intros)
                    fix i assume b40: "i<x1"
                    then have "\<not>TypedStoSubpref locationChanged (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct" using b30 by auto
                    then show "SCon struct (hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st' (address env))" using STArray(1)[of "(hash x4 (ShowL\<^sub>n\<^sub>a\<^sub>t i))"] b30 b10 b40 by simp
                  qed
                  then show ?case using SCon.simps(2)[of x1 struct x4 "storage st' (address env)"] by simp
                next
                  case (STMap x1 struct)
                  then have " (\<forall>i. typeCon x1 i \<longrightarrow> SCon struct (hash x4 i) (storage st (address env)))" using SCon.simps(3)[of x1 struct x4 "(storage st (address env))"] by simp
                  moreover have "(\<forall>i. \<not>typeCon x1 i \<or> \<not>TypedStoSubpref locationChanged (hash x4 i) struct \<and> locationChanged \<noteq> hash x4 i)" 
                    using STMap(2) TypedStoSubpref.simps(3)[of locationChanged x4 x1 struct] 
                    using TypedStoSubpref_sameLoc by auto
                  ultimately show ?case  using STMap(1) by auto
                next
                  case (STValue x)
                  then have c5:"(x4 \<noteq> locationChanged \<or> STValue t' \<noteq> STValue x)" using Subpref.simps(1)[of  x x4 "STValue t'" locationChanged] by auto
                  then show ?case 
                  proof(cases "x4 \<noteq> locationChanged")
                    case True
                    then have c10:"storage st' (address env) $$ x4 = storage st (address env) $$ x4" using subcase2 nonLocChanged by auto
                    then have " SCon (STValue x) x4 (storage st (address env))" using STValue by blast
                    then show ?thesis using c10 
                      by (simp add: accessStorage_def)
                  next
                    case False
                    then have "x4 = locationChanged" by simp
                    then have "STValue t' = STValue x" using subcase2  Stackloc KStoptr inDen lexpStorage[of env st cd lv g locationChanged t' g'] Some f1 2(1) a20 a30 
                      by (metis STValue.prems(1) TypedStoSubpref.simps(1))
                    then show ?thesis using False c5 by auto
                  qed
                qed
              qed
              then show ?thesis using Stackloc inDen KStoptr Some a30 subcase2 by simp
            qed
          qed
        next
          case (Storeloc x2)
          then have a20:"case t of Storage typ \<Rightarrow> SCon typ x2 (storage st (address env)) | _ \<Rightarrow> False" 
            using 2(1) unfolding TypeSafe_def typeCompat_def using inDen by force
          then obtain struct where a30:"t = Storage struct" using a20 Storeloc by (simp split:Type.splits)
          then have a40:"SCon struct x2 (storage st (address env))" using a20 Storeloc by (simp split:Type.splits)
          have tCont2v:"typeCon t2 v" using subcase2(1) extractValueType.simps 2(1) 
            using exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KValue v" "Value t2" g] 
            using 2(3) unfolding fullyInitialised_def by (simp)
          have "v' = v" using  convertSame[of t2 t' v v'] subcase2(3) by simp
          then have tCont'v:"typeCon t' v" using typeSafeConvert[of t2 v t'] subcase2(3) tCont2v by simp
          have "SCon struct x2 (storage st' (address env))" using a40 a30 inDen
          proof(cases "TypedStoSubpref locationChanged x2 struct")
            case subloc:True
            have compPtr:"(\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
                        (Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
                        (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
                        (l1 = Stackloc l1' \<and> accessStore l1' (stack st) = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) 
                        \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
                        (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
              using 2(1)  unfolding TypeSafe_def compPointers_def by auto
            then show ?thesis 
            proof(cases rule:lexpStorage[OF 2(1) subcase2(2) 2(3)])
              case 1
              then have b40:"CompStoType struct (STValue t') x2 locationChanged" 
                using inDen Storeloc a20 a30 1 compPtr subloc by metis
              then show ?thesis
              proof(cases "x2 = locationChanged")
                case True
                then have "struct = (STValue t')" using b40 by (simp add: CompStoType_sameLoc_sameType)
                then show ?thesis using True scont' by auto
              next
                case x4Dif:False
                then have c0:"CompStoType struct (STValue t') x2 locationChanged" using subloc b40 by simp
                then obtain i'' where c1:"(hash x2 i'' = locationChanged)" using CompStoType_imps_subloc x4Dif by blast
                then have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                  by (metis TypedStoSubpref_sameLoc nonLocChanged)
                then show ?thesis using stvalueLocationsInduct a40  x4Dif c1 scont' c0 nonLocChanged by blast
              qed
            next
              case (2 l'' t'')
              have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                by (metis TypedStoSubpref_sameLoc nonLocChanged)
              then have b40:"if TypedStoSubpref x2 l'' t'' then CompStoType t'' struct l'' x2
                                  else if TypedStoSubpref l'' x2 struct then CompStoType struct t'' x2 l'' 
                                    else True"
                using compPtr inDen Storeloc a20 a30 2  by blast
              then show ?thesis using subloc 2
              proof(cases "x2 = l''")
                case True
                then have stt:"struct = t''" using b40 
                  using CompStoType_sameLoc_sameType TypedStoSubpref_sameLoc by auto
                then show ?thesis 
                proof(cases "l'' = locationChanged")
                  case t4:True
                  then show ?thesis using  stt True scont' 
                    using "2"(2) CompStoType_sameLoc_sameType by blast
                next
                  case False
                  have c0:"CompStoType struct (STValue t') x2 locationChanged" using 2(2) True stt by simp
                  then have "\<exists>y. hash l'' y = locationChanged" using subloc "2"(2) TypedStoSubpref_b False by auto
                  then obtain i'' where c1:"(hash x2 i'' = locationChanged)" using CompStoType_imps_subloc False True by blast
                  then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 by blast 
                qed
              next
                case x4Dif:False
                then show ?thesis
                proof(cases "TypedStoSubpref x2 l'' t''")
                  case d5:True
                  then have d7:"CompStoType t'' struct l'' x2" using b40 by simp
                  have d9:"CompStoType t'' (STValue t') l'' locationChanged" using 2(2) by simp
                  have d10:"CompStoType struct (STValue t') x2 locationChanged" using tap[of t'' t' l'' locationChanged struct x2] subloc d7 d9 by blast
                  then have d11:"\<exists>x. hash l'' x = x2" using TypedStoSubpref_b x4Dif d5 by auto
                  then show ?thesis 
                  proof(cases "l'' = locationChanged")
                    case True
                    then obtain i'' where d11:"hash locationChanged i'' = x2" using d11 by auto
                    then show ?thesis using subloc using TypedStoSubpref_hashes by auto
                  next
                    case False
                    then have "\<exists>x. hash l'' x = locationChanged" using 2(2) TypedStoSubpref_b by auto
                    then have "\<exists>x. hash l'' x = x2" using d11 using hash_suffixes_associative by auto
                    then show ?thesis
                    proof(cases "x2 = locationChanged")
                      case True
                      then have "struct = (STValue t')" using d10 by (simp add: CompStoType_sameLoc_sameType)
                      then show ?thesis using True scont' by auto
                    next
                      case False
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" 
                        using subloc False TypedStoSubpref_b[of locationChanged x2 struct] by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 d10 by blast
                    qed
                  qed
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref l'' x2 struct")
                    case True
                    then have d5:"TypedStoSubpref l'' x2 struct" by simp
                    then have d7:"CompStoType struct t'' x2 l''" using b40 f5 by simp
                    then have d10:"\<exists>x. hash x2 x = l''" using TypedStoSubpref_b x4Dif d5 by auto
                    then show ?thesis 
                    proof(cases "l'' = locationChanged")
                      case True
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" using d10 by auto
                      then have d15:"t'' = STValue t'" using 2(2) CompStoType_sameLoc_sameType True by auto
                      then have c0:"CompStoType struct (STValue t') x2 locationChanged" using 2(2) d15 d7 by fastforce
                      then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 d11 by blast 
                    next
                      case False
                      then have "\<exists>x. hash l'' x = locationChanged" using 2(2) TypedStoSubpref_b by auto
                      then have "\<exists>x. hash x2 x = locationChanged" using d10 using hash_suffixes_associative by auto
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" by auto
                      then have "CompStoType struct (STValue t') x2 locationChanged" using CompStoType_trns 2(2)  d7 by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 by blast
                    qed
                  next
                    case False
                    have "x2 \<noteq> locationChanged" using 2(2) f5 by blast
                    then show ?thesis using  a40 False f5 2(2) singleLocChanged_nonchanged_SCon 
                      using nonLocChanged by blast
                  qed

                qed
              qed
            next
              case (3 l'' t'' l)
              have c3:"\<forall>l struct. \<not>TypedStoSubpref locationChanged l struct \<longrightarrow>  storage st' (address env) $$ l = storage st (address env) $$ l" 
                by (metis TypedStoSubpref_sameLoc nonLocChanged)
              then have b40:"if TypedStoSubpref x2 l'' t'' then CompStoType t'' struct l'' x2
                                  else if TypedStoSubpref l'' x2 struct then CompStoType struct t'' x2 l'' 
                                    else True"
                using compPtr inDen Storeloc a20  a30 3  by blast
              then show ?thesis using subloc 2
              proof(cases "x2 = l''")
                case True
                then have stt:"struct = t''" using b40 
                  using CompStoType_sameLoc_sameType TypedStoSubpref_sameLoc by auto
                then show ?thesis 
                proof(cases "l'' = locationChanged")
                  case t4:True
                  then show ?thesis using  stt True scont' 
                    using "3"(3) CompStoType_sameLoc_sameType by blast
                next
                  case False
                  have c0:"CompStoType struct (STValue t') x2 locationChanged" using 3(3) True stt by simp
                  then have "\<exists>y. hash l'' y = locationChanged" using subloc 3(3) TypedStoSubpref_b False by auto
                  then obtain i'' where c1:"(hash x2 i'' = locationChanged)" using CompStoType_imps_subloc False True by blast
                  then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 by blast 
                qed
              next
                case x4Dif:False
                then show ?thesis
                proof(cases "TypedStoSubpref x2 l'' t''")
                  case d5:True
                  then have d7:"CompStoType t'' struct l'' x2" using b40 by simp
                  have d9:"CompStoType t'' (STValue t') l'' locationChanged" using 3(3) by simp
                  have d10:"CompStoType struct (STValue t') x2 locationChanged" using tap[of t'' t' l'' locationChanged struct x2] subloc d7 d9 by blast
                  then have d11:"\<exists>x. hash l'' x = x2" using TypedStoSubpref_b x4Dif d5 by auto
                  then show ?thesis 
                  proof(cases "l'' = locationChanged")
                    case True
                    then obtain i'' where d11:"hash locationChanged i'' = x2" using d11 by auto
                    then show ?thesis using subloc using TypedStoSubpref_hashes by auto
                  next
                    case False
                    then have "\<exists>x. hash l'' x = locationChanged" using 3(3) TypedStoSubpref_b by auto
                    then have "\<exists>x. hash l'' x = x2" using d11 using hash_suffixes_associative by auto
                    then show ?thesis
                    proof(cases "x2 = locationChanged")
                      case True
                      then have "struct = (STValue t')" using d10 by (simp add: CompStoType_sameLoc_sameType)
                      then show ?thesis using True scont' by auto
                    next
                      case False
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" 
                        using subloc False TypedStoSubpref_b[of locationChanged x2 struct] by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 d10 by blast
                    qed
                  qed
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases "TypedStoSubpref l'' x2 struct")
                    case True
                    then have d5:"TypedStoSubpref l'' x2 struct" by simp
                    then have d7:"CompStoType struct t'' x2 l''" using b40 f5 by simp
                    then have d10:"\<exists>x. hash x2 x = l''" using TypedStoSubpref_b x4Dif d5 by auto
                    then show ?thesis 
                    proof(cases "l'' = locationChanged")
                      case True
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" using d10 by auto
                      then have d15:"t'' = STValue t'" using 3(3) CompStoType_sameLoc_sameType True by auto
                      then have c0:"CompStoType struct (STValue t') x2 locationChanged" using 3(3) d15 d7 by fastforce
                      then show ?thesis using stvalueLocationsInduct a40 scont' c0 nonLocChanged c3 d11 by blast 
                    next
                      case False
                      then have "\<exists>x. hash l'' x = locationChanged" using 3(3) TypedStoSubpref_b by auto
                      then have "\<exists>x. hash x2 x = locationChanged" using d10 using hash_suffixes_associative by auto
                      then obtain i'' where d11:"hash x2 i'' = locationChanged" by auto
                      then have "CompStoType struct (STValue t') x2 locationChanged" using CompStoType_trns 3(3)  d7 by blast
                      then show ?thesis using stvalueLocationsInduct a40 scont' nonLocChanged c3 d11 by blast
                    qed                
                  next
                    case False
                    have "x2 \<noteq> locationChanged" using 3(3) f5 by blast
                    then show ?thesis using  a40 False f5 3(3) singleLocChanged_nonchanged_SCon 
                      using nonLocChanged by blast
                  qed   
                qed
              qed
            qed
          next
            case f1:False
            then show ?thesis using a40
            proof(induction struct arbitrary:x2)
              case (STArray x1 struct)
              have b10:"\<forall>i<x1. SCon struct (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st (address env))" 
                using STArray(3) using SCon.simps(2)[of x1 struct x2 "(storage st (address env))"] by auto
              have b20:"\<forall>i<x1. \<not> TypedStoSubpref locationChanged (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct 
                                    \<and> locationChanged \<noteq> hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)" 
                using STArray(2) TypedStoSubpref.simps(2)[of locationChanged x2 x1 struct] 
                using TypedStoSubpref_sameLoc by auto
              then have b30:"\<forall>i<x1. \<not> TypedStoSubpref locationChanged (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct " by auto
              have " (\<forall>i<x1. SCon struct (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st' (address env)))" 
              proof(intros)
                fix i assume b40: "i<x1"
                then have "\<not>TypedStoSubpref locationChanged (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) struct" using b30 by auto
                then show "SCon struct (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (storage st' (address env))" using STArray(1)[of "(hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t i))"] b30 b10 b40 by simp
              qed
              then show ?case using SCon.simps(2)[of x1 struct x2 "storage st' (address env)"] by simp
            next
              case (STMap x1 struct)
              then have " (\<forall>i. typeCon x1 i \<longrightarrow> SCon struct (hash x2 i) (storage st (address env)))" using SCon.simps(3)[of x1 struct x2 "(storage st (address env))"] by simp
              moreover have "(\<forall>i. \<not>typeCon x1 i \<or> \<not>TypedStoSubpref locationChanged (hash x2 i) struct \<and> locationChanged \<noteq> hash x2 i)" 
                using STMap(2) TypedStoSubpref.simps(3)[of locationChanged x2 x1 struct] 
                using TypedStoSubpref_sameLoc by auto
              ultimately show ?case  using STMap(1) by auto
            next
              case (STValue x)
              then have c5:"(x2 \<noteq> locationChanged \<or> STValue t' \<noteq> STValue x)" using Subpref.simps(1)[of  x x2 "STValue t'" locationChanged] by auto
              then show ?case 
              proof(cases "x2 \<noteq> locationChanged")
                case True
                then have c10:"storage st' (address env) $$ x2 = storage st (address env) $$ x2" using subcase2 nonLocChanged by auto
                then have " SCon (STValue x) x2 (storage st (address env))" using STValue by blast
                then show ?thesis using c10 
                  by (simp add: accessStorage_def)
              next
                case False
                then have "x2 = locationChanged" by simp
                then have "STValue t' = STValue x" using subcase2  Storeloc  inDen lexpStorage[of env st cd lv g locationChanged t' g'] f1 2(1) a20 a30 
                  by (metis STValue.prems(1) TypedStoSubpref.simps(1))
                then show ?thesis using False c5 by auto
              qed
            qed
          qed
          then show ?thesis 
            using Storeloc a30 by auto
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd" using subcase2 by auto
    next
      show "methodVarsNoPref" using 2 unfolding TypeSafe_def by simp
    next 
      show "lessThanTopLocs cd" using 2 unfolding TypeSafe_def by simp
    next 
      have "memory st = memory st'" using subcase2(4) by simp
      then show "lessThanTopLocs (memory st')" using 2 unfolding TypeSafe_def by simp
    next
      show "addressFormat (address env) " using 2 unfolding TypeSafe_def by simp
    next
      show "addressFormat (sender env)" using 2 unfolding TypeSafe_def by simp
    next      
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using 2(1)  unfolding TypeSafe_def unique_locations_def by blast

        have a3:"\<forall>dloc1.
     (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
     (if stl1 = stl2 then tp1 = tp2
      else case tp1 of
           MTArray len arr \<Rightarrow>
             (case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
               else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                    else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
           | MTValue val \<Rightarrow>
               (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
               | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto


        then have "accessStore l1 (stack st) = Some (KMemptr stl1) \<and>  accessStore l2 (stack st) = Some (KMemptr stl2)" using subcase2 a1 by simp
        moreover have "(memory st) = (memory st')" using subcase2 by auto
        ultimately show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)" using a3   a1  by presburger
      qed
    next 
      show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using subcase2 by simp
    next 
      have "accounts st'= accounts st" using subcase2 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) subcase2(4) unfolding fullyInitialised_def updateStore_def accessStore_def by simp
    qed

  next
    case (3 v t g l t' g' v')
    have sameStack:"stack st' = stack st" using 3(4) by auto
    have sameStorage:"storage st'  = storage st " using 3 by auto
    have temp:"TypeSafe env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd" 
      using 2(1) by simp
    have ttt:"fullyInitialised env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>))" using 2(3) unfolding fullyInitialised_def by simp
    show ?thesis 
    proof(cases rule:lexpIndexMem[OF 3(2) temp ttt])
      case lInfo:(1 x21 x22 tp tParent l' l'' prnt len' arr' i)

      have nonLocChanged:"\<forall>locs. locs \<noteq> l \<longrightarrow> accessStore locs  (memory st) = accessStore locs  (memory st')" 
        using 3 unfolding updateStore_def accessStore_def by simp

      have TCsrc:"typeCon t (extractValueType (KValue v)) \<and> (\<exists>xx. KValue v = KValue xx)"
        using 2(1) 3(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KValue v" "Value t" g] 
        using 2(3) unfolding fullyInitialised_def
        by (auto split:Type.splits if_splits )



      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp


      obtain len subT where tParentType:"tParent = MTArray len subT" using lInfo by blast
      then have compType:"CompMemType (memory (st\<lparr>gas := g\<rparr>)) len subT (MTValue t') l'' l" 
        and lsublocs:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = (MTValue t') \<and> MCon (MTArray len' arr') (memory (st)) prnt" 
        and lsublocs3:"(prnt = l'' \<and> len = len' \<and> arr' = subT \<or> CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt)"
        using lInfo 3(3) by fastforce+

      then have lsublocs2:" CompMemType (memory (st)) len' arr' (MTValue t') prnt l" 
        using 3(3) CompMemType.simps(2) by auto
      then have bb9:"\<forall>subT subloc. CompMemType (memory (st)) len' arr' subT prnt subloc \<and> subloc = l
                                  \<longrightarrow> subT = (MTValue t')" 
        using CompMemTypeSameLocsSameType lsublocs by blast

      have mconPrnt:"MCon (MTArray len' (MTValue t')) (memory st) prnt" using lsublocs by auto
      have ldef:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len'" using lsublocs by auto

      have t6:"(Memory tParent,  Stackloc l') |\<in>| fmran (denvalue env)" using lInfo by blast
      have t7:" MCon (MTArray len subT) (memory (st)) l''" using lInfo 
        using tParentType by auto
      then have mconlOld:"MCon (MTValue t') (memory st) l" using 3(3) lInfo 
        using CompTypeRemainsMCon lsublocs lsublocs2 by blast
      have "MCon (MTArray len' arr') (memory st) prnt" using lsublocs3 
        using lsublocs by blast
      then have mcPrntNew:"MCon (MTArray len' arr') (memory st') prnt" 
      proof -
        have lenNotZero:"len' \<noteq> 0" using lsublocs by auto
        have prntNotL:"prnt \<noteq> l" using ldef 
          by (metis hash_inequality)
        then have p2:"(\<exists>p. accessStore prnt (memory st') = Some (MPointer p)) \<or> accessStore prnt (memory st') = None" 
          using mconPrnt lenNotZero nonLocChanged by simp
        have "\<forall>i<len'.
            (case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
             | Some (MValue val) \<Rightarrow> (case arr' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon arr' (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
             | Some (MPointer loc2) \<Rightarrow> (case arr' of MTArray len' arr'a \<Rightarrow> MCon arr' (memory st') loc2 | MTValue Types \<Rightarrow> False)) 
           " 
        proof(intros)
          fix i1 assume in1:"i1<len'"
          show "case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') of None \<Rightarrow> False 
          | Some (MValue val) \<Rightarrow> (case arr' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon arr' (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)))
          | Some (MPointer loc2) \<Rightarrow> (case arr' of MTArray len' arr'a \<Rightarrow> MCon arr' (memory st') loc2 | MTValue Types \<Rightarrow> False)"
          proof(cases "i1 = i")
            case True
            then have "(hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) = l" using ldef by simp
            then have ac:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = Some((MValue v'))" using 3 by simp
            have "MCon  (MTValue t') (memory st) (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1))" 
              using \<open>hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1) = l\<close> lsublocs mconlOld by auto
            then have "typeCon t' v'" unfolding MCon.simps 
              by (metis "3"(3) TCsrc convertSame extractValueType.simps(1) typeSafeConvert)
            then show ?thesis 
              by (simp add: \<open>accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = Some (MValue v')\<close> lsublocs)
          next
            case False
            then have sameAC:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st)" using ldef nonLocChanged in1 
              by (metis Read_Show_nat'_id hash_never_equal_sufix)
            then obtain ptr where ptrDef:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st) = Some (MValue ptr)" using in1 
              using  lsublocs MCon_sub_MTVal_imps_val by blast
            then have ptrMC:"case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon t' xa | Some (MPointer t) \<Rightarrow> False" 
              using in1 mconPrnt unfolding MCon.simps
              using lsublocs mconlOld MCon.simps(1) by blast
            then show ?thesis using sameAC 
              using in1 lsublocs ptrDef by force
          qed
        qed
        then show ?thesis using lenNotZero p2 by simp
      qed

      have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l' (stack st) = Some (KMemptr l'')"
        using lInfo(2,3,4) tParentType by simp
      then have l'SubLocs:"(\<forall>tp2 l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if l'' = stl2 then (MTArray len subT) = tp2
         else case (MTArray len subT) of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 l'' then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 l''
                  else if TypedMemSubPrefPtrs (memory st) len arr l'' stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) l'' stl2
                       else if TypedMemSubPrefPtrs (memory st) len arr l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt l'' dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr l'' stl2 then CompMemType (memory st) len arr (MTValue val2) l'' stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 l'' then CompMemType (memory st) len2 arr2 (MTValue val) stl2 l'' else True
                  | MTValue val2 \<Rightarrow> True)))" using lInfo 2(1) unfolding TypeSafe_def compMemPtrs_def by blast
      then have l'SubLocs:"(\<forall>tp2 l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if l'' = stl2 then (MTArray len subT) = tp2
         else case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 l'' then CompMemType (memory st) len2 arr2 (MTArray len subT) stl2 l''
                  else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray len2 arr2) l'' stl2
                       else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTValue val2) l'' stl2 else True
              ))" by (metis (no_types, lifting) MTypes.simps(5))

      have prntRelations:"(\<forall>tp2  l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if prnt = stl2 then (MTArray len' arr') = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
                  else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                       else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True
              ))"
      proof intros
        fix tp2 l2 stl2 dloc1
        assume in0:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) "
        show "if prnt = stl2 then MTArray len' arr' = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
              else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                   else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True"
        proof(cases "prnt = stl2")
          case same:True
          then show ?thesis
          proof(cases "prnt = l''")
            case True
            then have "MTArray len subT = tp2" using l'SubLocs in0 same by simp
            then show ?thesis using in0 same True  lsublocs3 
              by (metis CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame t7)
          next
            case False
            then have l''NotStl2:"l'' \<noteq> stl2" using same by simp
            then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 False by simp
            then show ?thesis using l'SubLocs 
            proof(cases "tp2")
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                case True
                then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''"  using l'SubLocs False same in0 MTArray by fastforce
                then show ?thesis using cmp same 
                  by (metis (lifting) "2.prems"(1) CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MTArray TypedMemSubPrefOneWay in0 sameMemTSafe t7)
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                  case t2:True
                  then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using l'SubLocs False same in0 MTArray f1 by fastforce
                  then show ?thesis using cmp same in0 t7 MTArray f1 t2 
                    by (meson CompMemTypeSameLocsSameType)
                next
                  case False
                  then show ?thesis 
                    using CompMemType_imps_TypedMemSubPrefPtrs cmp same by auto
                qed

              qed
            next
              case (MTValue x2)
              then show ?thesis using same False cmp in0 l'SubLocs 
                by (metis (no_types, lifting) CompMemType_imps_TypedMemSubPrefPtrs MTypes.simps(6) t7 CompMem_SameLocs_SameSubT)
            qed
          qed
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have stl2Mcon:"MCon (MTArray x11 x12) (memory st) stl2" using in0 2(1) unfolding TypeSafe_def typeCompat_def by fastforce
            then show ?thesis 
            proof(cases "prnt = l''")
              case t3:True
              then have tps:"len = len' \<and> arr' = subT" using lsublocs3 
                using BothMConImpsNotCompMemType lsublocs t7 by blast
              then have in2:"if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l'' then CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''
               else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2
                    else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True" 
                using l'SubLocs MTArray t3 notSame in0 by fastforce
              then show ?thesis using in2 notSame MTArray tps 
                using t3 by force
            next
              case f2:False
              then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp

              then have in2:"\<forall>dloc1. if l'' = stl2 then MTArray len subT = tp2
          else  
               if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l'' then CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''
               else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2
                    else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True" 
                using l'SubLocs MTArray f2 notSame in0 by fastforce

              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt")
                case t3:True
                have "CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" 
                proof(cases "l'' = stl2")
                  case t4:True
                  then show ?thesis using t3 in2 MTArray 
                    using cmp by fastforce
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases " TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                    case t5:True
                    then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''" using in2 f5 by simp
                    then show ?thesis using  stl2Mcon  t5 t3 MTArray compMemTypes_trns cmp by blast
                  next
                    case f6:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                      case t6:True
                      then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using in2 f6 f5 by simp
                      then show ?thesis  using  stl2Mcon   t6 t3 MTArray f5 
                          CompMemType_asc_withSharedTarget[of "memory st" _ _ x11 x12 _ stl2 _ _] cmp f6 
                        by (meson lsublocs t7)
                    next
                      case False
                      have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt" 
                        using CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len subT _ l'' ] cmp f6 t3 by auto
                      moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt" using t3 by simp
                      ultimately have "\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 prnt \<and> CompMemType (memory st) len subT dt l'' prnt" 
                        using in2 False f5 f6 by simp
                      then show ?thesis using  stl2Mcon    t3 MTArray f5  in2 f6 f5 
                        using CompMemTypeSameLocsSameType cmp t7 by blast
                    qed
                  qed
                qed
                then show ?thesis using t3 notSame MTArray by auto
              next
                case f3:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 ")
                  case t3:True
                  have "CompMemType (memory st) len' arr' (MTArray x11 x12) prnt stl2" 
                  proof(cases "l'' = stl2")
                    case t4:True
                    then show ?thesis using t3 in2 MTArray notSame  f3  
                      using CompMemType_imps_TypedMemSubPrefPtrs 
                      using lsublocs3 by auto
                  next
                    case f5:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                      case t5:True
                      then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''" using in2 f5 by simp
                      then show ?thesis using cmp stl2Mcon   t5 t3 MTArray compMemTypes_trns 
                        by (metis CompMemType_imps_TypedMemSubPrefPtrs f3)
                    next
                      case f6:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                        case t6:True
                        then have " CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using in2 f6 f5 by simp
                        then show ?thesis  using cmp stl2Mcon   t6 t3 MTArray f5 
                            CompMemType_asc_withSharedTarget 
                          using lsublocs t7 by blast
                      next
                        case False
                        have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt" 
                          using cmp CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len subT "MTArray len' arr'" l'' prnt] by simp
                        moreover have "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2" using t3 by simp
                        ultimately show ?thesis using  stl2Mcon    t3 MTArray f5  in2 f6 f5 
                          using False TypedMemSubPrefPtrs_trns cmp lsublocs t7 by blast
                      qed
                    qed
                  qed
                  then show ?thesis using notSame MTArray t3 f3 by simp
                next
                  case f4:False
                  then show ?thesis 
                    by (smt (verit, ccfv_threshold) CompMemType_asc_withSharedTarget CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon MTArray MTypes.simps(5) TypedMemSubPrefPtrs_trns f3 in2
                        lsublocs3 notSame sharedParentSharedSubLocTypes stl2Mcon t7)
                qed
              qed
            qed
          next
            case (MTValue x2)
            then show ?thesis 
            proof(cases " TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2")
              case True
              then show ?thesis
              proof(cases "prnt = l''")
                case t2:True
                then have tps:"len = len' \<and> arr' = subT" using lsublocs3 
                  using BothMConImpsNotCompMemType lsublocs t7 by blast
                have noSameL'':"l'' \<noteq> stl2" using t2 notSame by simp
                then show ?thesis
                proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                  case t3:True
                  then have " CompMemType (memory st) len subT (MTValue x2) l'' stl2" using l'SubLocs noSameL'' MTValue in0 by fastforce
                  then show ?thesis using tps True notSame MTValue t2 by simp
                next
                  case f3:False
                  then show ?thesis using True t2 tps by auto
                qed
              next
                case f2:False
                then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
                then show ?thesis 
                proof(cases "l'' = stl2")
                  case t2:True
                  then show ?thesis using cmp True 
                    using CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefOneWay lsublocs t7 by blast
                next
                  case f3:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                    case t3:True
                    then have " CompMemType (memory st) len subT (MTValue x2) l'' stl2 "  using l'SubLocs f3 MTValue in0 by fastforce
                    then show ?thesis using True notSame MTValue f2 f3 t3 
                      by (metis (lifting) CompMemType_asc_withSharedTarget CompTypeRemainsMCon MTypes.simps(6) lsublocs3 t7)
                  next
                    case False
                    then show ?thesis using True 
                      using TypedMemSubPrefPtrs_trns cmp lsublocs t7 by blast
                  qed
                qed

              qed
            next
              case False
              then show ?thesis using notSame False MTValue by simp
            qed
          qed
        qed
      qed



      have mcAllNew:"\<forall>tp2 l2 stl2. (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)
                    \<longrightarrow> MCon tp2 (memory st') stl2"
      proof intros
        fix tp2 l2 stl2
        assume in1:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)"
        then have in2:"\<forall>dloc1. (if prnt = stl2 then MTArray len' arr' = tp2
        else case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
               else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                    else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True)" 
          using prntRelations by auto
        then have mcO:"MCon tp2 (memory st) stl2 " using 2(1) in1 unfolding TypeSafe_def typeCompat_def by force
        then show "MCon tp2 (memory st') stl2" 
        proof(cases "prnt = stl2")
          case True
          then show ?thesis using in2 mcPrntNew 
            by (simp add: lsublocs)
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have mcO:" MCon (MTArray x11 x12) (memory st) stl2" using MTArray mcO by blast

            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt")
              case True
              then have cpO:"CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" using in1 in2 notSame MTArray by simp

              have mcO:" MCon (MTArray x11 x12) (memory st) stl2" using MTArray mcO by blast
              moreover have "\<forall>newt newl. CompMemType (memory st) x11 x12 newt stl2 newl \<and> newl = prnt \<longrightarrow> newt = MTArray len' arr'" using CompMem_SameLocs_SameSubT[OF _ mcO] cpO  by auto
              ultimately have " MCon (MTArray x11 x12) (memory st') stl2" using notSame
              proof(induction x12 arbitrary: x11 stl2)
                case (MTArray x1 x12)
                then have "x11 \<noteq> 0" using MCon.simps by simp
                moreover have "\<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False 
              | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii assume iiDef:"ii<x11"
                  then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii))\<noteq> l" using MTArray.prems(3) ldef ShowLNatDot hash_injective by blast
                  then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by auto
                  then obtain v where vDef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer v) \<and> MCon (MTArray x1 x12) (memory st) v"
                    using MTArray.prems iiDef MCon_imps_sub_Mcon 
                    by (metis MConArrayPointers neq0_conv not_less_zero)
                  have "MCon (MTArray x1 x12) (memory st') v"
                  proof(cases "v = prnt")
                    case True
                    then have "MTArray len' arr' = MTArray x1 x12" using MTArray.prems(2) iiDef vDef same by auto
                    then show ?thesis using mcPrntNew True lsublocs by blast
                  next
                    case False
                    then show ?thesis using MTArray.IH[of x1 v] vDef MTArray.prems(2) iiDef same 
                      by (metis CompMemType.simps(2))
                  qed
                  then show "case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
         | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
         | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                    using vDef 
                    by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
                qed


                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None"
                proof -
                  have "(\<exists>p. accessStore stl2 (memory st) = Some (MPointer p)) \<or> accessStore stl2 (memory st) = None"
                    using MTArray.prems(1) calculation(1) by simp
                  then have notL:"stl2 \<noteq> l" 
                    by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) lsublocs option.distinct(1) option.inject)
                  have "accessStore stl2 (memory st') = accessStore stl2 (memory st)" using nonLocChanged notL by simp
                  then show ?thesis using MTArray.prems(1) calculation(1) by simp
                qed
                ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "memory st'" stl2] by auto
              next
                case (MTValue x)
                then have "x11 \<noteq> 0" using MCon.simps by simp
                moreover have "\<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii 
                  assume iiDef:"ii<x11"
                  have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using MTValue(3) ldef ShowLNatDot hash_injective by blast
                  then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by auto
                  then obtain v where vDef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MValue v) \<and> MCon (MTValue x) (memory st) (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii))"
                    using MTValue iiDef MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val by presburger
                  then show "(case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))" using same iiDef by auto
                qed
                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None"
                proof -
                  have "(\<exists>p. accessStore stl2 (memory st) = Some (MPointer p)) \<or> accessStore stl2 (memory st) = None"
                    using MTValue.prems(1) calculation(1) by simp
                  then have notL:"stl2 \<noteq> l" 
                    by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) lsublocs option.distinct(1) option.inject)
                  have "accessStore stl2 (memory st') = accessStore stl2 (memory st)" using nonLocChanged notL by simp
                  then show ?thesis using MTValue.prems(1) calculation(1) by simp
                qed
                ultimately show ?case using MCon.simps(2)[of x11 "MTValue x" "memory st'" stl2] by simp
              qed
              then show ?thesis using MTArray by simp
            next
              case f2:False

              have "MCon (MTArray x11 x12) (memory st') stl2" using mcO f2 notSame
              proof(induction x12 arbitrary:x11 stl2)
                case (MTArray x1 x12)
                then have "x11 \<noteq> 0" using MTArray unfolding MCon.simps by simp
                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None" 
                proof - 
                  have oo:"(\<exists>p. accessStore stl2 (memory st) = Some (MPointer p)) \<or> accessStore stl2 (memory st) = None"
                    using MTArray calculation by auto
                  then have "stl2 \<noteq> l" by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) lsublocs option.distinct(1) option.inject)
                  then show ?thesis using oo nonLocChanged by simp
                qed                
                moreover have " \<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii 
                  assume in1:"ii<x11"
                  have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray by blast
                  then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
                  then obtain ptr where ptrdef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ptr) \<and> MCon (MTArray x1 x12) (memory st) ptr"
                    using MTArray.prems(1) in1 
                    by (metis MConArrayPointers MCon_imps_sub_Mcon calculation(1) neq0_conv)
                  then have "MCon (MTArray x1 x12) (memory st') ptr" using MTArray.IH MTArray.prems 
                    by (metis in1 same TypedMemSubPrefPtrs.simps(2))
                  then show "(case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                    using in1 ptrdef by auto
                qed

                ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "memory st'" stl2] by simp
              next
                case (MTValue x)
                have "\<forall>i<x11. (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> l" using ldef hash_injective ShowLNatDot MTValue by blast
                then have same:"\<forall>i<x11. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st)" using nonLocChanged by simp
                have "x11 \<noteq> 0" using MTValue unfolding MCon.simps by simp
                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None" 
                proof - 
                  have oo:"(\<exists>p. accessStore stl2 (memory st) = Some (MPointer p)) \<or> accessStore stl2 (memory st) = None"
                    using MTValue calculation by auto
                  then have "stl2 \<noteq> l" by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) lsublocs option.distinct(1) option.inject)
                  then show ?thesis using oo nonLocChanged by simp
                qed
                moreover have "\<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii assume  *:"ii<x11"
                  then have "MCon (MTValue x) (memory st) (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii))" using MTValue(1) same 
                    using CompTypeRemainsMCon CompMemType.simps(1) by blast
                  then show "case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
         | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
         | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False )"
                    using same * 
                    by (metis MCon_sub_MTVal_imps_val MTValue.prems(1) MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) MCon.simps(1))
                qed
                ultimately show ?case using MCon.simps(2)[of x11 "MTValue x" "memory st'" stl2]  by simp
              qed
              then show ?thesis using MTArray by blast
            qed
          next
            case (MTValue x2)
            then have mcO2:"MCon (MTValue x2) (memory st) stl2 " using mcO by simp
            then have "case accessStore stl2 (memory st) of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon x2 xa | Some (MPointer t) \<Rightarrow> False" unfolding MCon.simps by simp
            then obtain xa where xaDef:"accessStore stl2 (memory st) = Some (MValue xa) \<and> typeCon x2 xa" 
              by (metis MConAccessSame.simps(1) Memoryvalue.simps(5) Option.option.simps(5) SameMCon_imps_MConAccessSame mcO2)
            then have "MCon (MTValue x2) (memory st') stl2 " 
            proof(cases "stl2 = l")
              case True
              then show ?thesis 
                by (smt (z3) CompMemType_imps_TypedMemSubPrefPtrs MCon_imps_sub_Mcon MTValue MTypes.simps(6) MconSameTypeSameAccess \<open>MCon (MTArray len' arr') (memory st) prnt\<close>
                    \<open>\<And>thesis. (\<And>xa. accessStore stl2 (memory st) = Some (MValue xa) \<and> typeCon x2 xa \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> bb9 hash_never_equal_sufix in2 lInfo(6) lsublocs2 mcPrntNew notSame
                    TypedMemSubPrefPtrs.simps(1))
            next
              case False
              then show ?thesis using xaDef nonLocChanged by simp
            qed
            then show ?thesis using MTValue by simp
          qed
        qed
      qed


      have cmpO_imps_new:"\<forall>x11 x12 stl2 dt prnt.  CompMemType (memory st) x11 x12 dt stl2 prnt
            \<longrightarrow> CompMemType (memory st') x11 x12 dt stl2 prnt"
      proof intros
        fix x11 x12 stl2 dt prnt
        assume "CompMemType (memory st) x11 x12 dt stl2 prnt"
        then show "CompMemType (memory st') x11 x12 dt stl2 prnt"
        proof(induction x12 arbitrary:x11 stl2)
          case (MTArray x1 x12)
          then obtain ii ll where iiDef: "ii<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = Some (MPointer ll) 
                    \<and> (ll = prnt \<and> MTArray x1 x12 = dt \<or> CompMemType (memory st) x1 x12 dt ll prnt)" 
            unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "ll = prnt")
            case True
            then show ?thesis using MTArray.prems iiDef 
              by (metis MCon_sub_MTVal_imps_val MTArray.IH Memoryvalue.distinct(1) lsublocs nonLocChanged option.inject CompMemType.simps(2))
          next
            case False
            then show ?thesis 
              by (metis MCon_sub_MTVal_imps_val MTArray.IH Memoryvalue.distinct(1) iiDef lsublocs nonLocChanged option.inject CompMemType.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case unfolding CompMemType.simps by simp
        qed

      qed

      have nToO_neg:"\<forall>x11 x12 stl2 prnt . \<not>TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt \<longrightarrow> \<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
      proof intros
        fix x11 x12 stl2 prnt
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt" 
        show "\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
        proof
          assume in2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
          then show False using in1
          proof(induction x12 arbitrary:x11 stl2)
            case (MTArray x1 x12)
            then obtain ii ll where iiDef:"ii<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = Some (MPointer ll) \<and> (ll = prnt \<or> TypedMemSubPrefPtrs (memory st) x1 x12 ll prnt)" 
              unfolding TypedMemSubPrefPtrs.simps by blast
            then show ?case 
            proof(cases "ll = prnt")
              case True
              then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using iiDef mconlOld by auto
              then show ?thesis using True iiDef nonLocChanged 
                using MTArray.prems(2) by auto
            next
              case False
              then show ?thesis using MTArray iiDef 
                by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) lsublocs nonLocChanged option.inject TypedMemSubPrefPtrs.simps(2))
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed
      qed


      have nToO:"\<forall>len2 arr2 stl2 stl1. TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 \<longrightarrow> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1"
      proof intros
        fix len2 arr2 stl2 stl1
        assume "TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1"
        then show "TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 "
        proof(induction arr2 arbitrary:len2 stl2)
          case (MTArray x1 arr2)
          then obtain ii ll where iidef:"ii<len2 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) \<and>
                                     (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 arr2 ll stl1)"
            unfolding TypedMemSubPrefPtrs.simps by auto
          then show ?case 
          proof(cases "ll = stl1")
            case True
            then show ?thesis 
              by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) iidef lsublocs mcPrntNew nonLocChanged option.inject TypedMemSubPrefPtrs.simps(2))
          next
            case False
            then show ?thesis 
              by (metis MCon_sub_MTVal_imps_val MTArray.IH Memoryvalue.distinct(1) iidef lsublocs mcPrntNew nonLocChanged option.inject TypedMemSubPrefPtrs.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      show ?thesis unfolding TypeSafe_def StateInvariant_def
      proof intros 
        show "AddressTypes (accounts st')" using 2(1) 3 unfolding TypeSafe_def by simp
      next 
        show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
        then show "compPointers (stack st') (denvalue env)"  using sameStack  sameStorage by simp
      next 
        show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
      next 
        show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "balanceTypes (accounts st')" using 3 using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
          using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have **:"toploc (stack st) = toploc (stack st')" using 3 unfolding updateStore_def by auto
        show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
        proof intros

          fix tloc loc 
          assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
          then show "accessStore loc (stack st') = None" using *  
            by (simp add: sameStack)
        next 
          fix loc y 
          assume h1:" accessStore loc (stack st') = Some y"
          then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
            by (metis sameStack)
        qed
      next 
        show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
      next
        have a12:"toploc (memory st) = toploc (memory st')" using 3 unfolding updateStore_def by auto
        have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
        proof intros
          fix tloc loc 
          assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have b20:"toploc (memory st) \<le> tloc" using a12 tloc a12 
            by force

          then show "accessStore loc (memory st') = None " 
            by (metis MCon_imps_Some a15 b10 lessThanSome_imps_Locs lessThanSome_imps_Locs2 lessThanTopLocs_def linorder_not_less mconlOld nonLocChanged)
        next 
          fix loc y 
          assume "accessStore loc (memory st') = Some y "
          then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
            by (metis MConAccessSame.simps(1) SameMCon_imps_MConAccessSame a12 a15 lessThanTopLocs_def mconlOld nonLocChanged)
        qed
      next 
        show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
          unfolding typeCompat_def 
        proof intros
          fix tLook lLook
          assume inDen:" (tLook, lLook) |\<in>| fmran (denvalue env)"
          show " case lLook of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tLook of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tLook of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case tLook of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tLook of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tLook of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
          proof(cases lLook)
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc by force
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some  by force
              next
                case (KCDptr x2)
                then show ?thesis  using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some by force
              next
                case (KMemptr x3)
                then obtain struct where stT: "tLook = Memory struct" using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some 
                  by (cases tLook; fastforce)
                then have "MCon struct (memory st) x3" 
                  by (metis "2.prems"(1) KMemptr Some Stackloc inDen sameMemTSafe sameStack)
                then have "MCon struct (memory st') x3" using mcAllNew 
                  using KMemptr Some Stackloc inDen sameStack stT by auto

                then show ?thesis using sameStorage inDen sameStack Stackloc Some KMemptr stT by simp
              next
                case (KStoptr x4)
                then show ?thesis  using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some by (cases tLook; force)
              qed
            qed
          next
            case (Storeloc x2)
            then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen 
              by (metis Denvalue.simps(6))
          qed
        qed
        then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd" using sameStack by auto

      next 
        have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
        show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
        proof intros
          fix tp1 tp2 l1 l2 stl1 stl2 dloc1
          assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
          have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
            using 2(1)  unfolding TypeSafe_def unique_locations_def by blast

          have a3:"\<forall>dloc1.
     (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
     (if stl1 = stl2 then tp1 = tp2
      else case tp1 of
           MTArray len arr \<Rightarrow>
             (case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
               else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                    else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
           | MTValue val \<Rightarrow>
               (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
               | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

          then show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)"
          proof(cases "stl1 = stl2")
            case same:True
            then show ?thesis using a1 a0 same unfolding compMemPtrs_def 
              by (simp add: sameStack)
          next
            case notSame:False

            then show ?thesis 
            proof(cases tp1)
              case mta1:(MTArray x11 x12)
              then have mcStl1:"MCon (MTArray x11 x12) (memory st') stl1" using a1 mcAllNew sameStack by metis
              have mcStl1O:" MCon (MTArray x11 x12) (memory st) stl1" using a1 sameStack 2(1) mta1 unfolding TypeSafe_def typeCompat_def by fastforce

              then show ?thesis 
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                then have mcStl2:"MCon (MTArray x11' x12') (memory st') stl2" using a1 mcAllNew sameStack by metis
                have mcStl2O:" MCon (MTArray x11' x12') (memory st) stl2" using a1 sameStack 2(1) mta2 unfolding TypeSafe_def typeCompat_def by fastforce
                then show ?thesis 
                proof(cases " TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" 
                    by (simp add: nToO)
                  then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using a1 a3 notSame mta1 mta2 sameStack by simp
                  then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" 
                    by (simp add: cmpO_imps_new)
                  then show ?thesis using notSame mta1 mta2 True by simp
                next
                  case f1:False
                  then have f1':"\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" 
                    by (simp add: nToO_neg)
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                    case True
                    then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using nToO by auto
                    then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using a1 a3 notSame mta1 mta2 sameStack f1' by simp
                    then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using cmpO_imps_new by simp
                    then show ?thesis  using notSame mta1 mta2 True f1 by simp
                  next
                    case f2:False
                    then have f2':"\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using nToO_neg by blast
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                      case True
                      then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" using nToO by auto
                      then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                        using a1 a3 notSame mta1 mta2 sameStack f1' f2' by auto
                      then obtain dt where dtDef:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by auto
                      then have "CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" using cmpO_imps_new by simp
                      then show ?thesis using notSame mta1 mta2 True f1 f2 by auto
                    next
                      case False
                      then show ?thesis using notSame mta1 mta2 f1 f2 by auto
                    qed
                  qed
                qed
              next
                case mtv1:(MTValue x2)
                then have mcStl2:"MCon (MTValue x2) (memory st') stl2" using a1 mcAllNew sameStack by metis
                have mcStl2O:" MCon (MTValue x2) (memory st) stl2" using a1 sameStack 2(1) mtv1 unfolding TypeSafe_def typeCompat_def by fastforce
                then have stl2NotPrnt:"stl2 \<noteq> prnt" 
                  by (metis MTypes.distinct(1) a1 mtv1 prntRelations sameStack)

                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                  case t2:True
                  then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                    by (simp add: nToO)
                  then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" using a1 a3 notSame mta1 mtv1 sameStack  by simp
                  then have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" 
                    by (simp add: cmpO_imps_new)
                  then show ?thesis using a1 mtv1 mta1 sameStack notSame by auto
                next
                  case False
                  then show ?thesis using a1 mtv1 mta1 sameStack notSame by simp
                qed
              qed
            next
              case mtv1:(MTValue x2)
              then have mcStl1:"MCon (MTValue x2) (memory st') stl1" using a1 mcAllNew sameStack by metis
              have mcStl1O:" MCon (MTValue x2) (memory st) stl1" using a1 sameStack 2(1) mtv1 unfolding TypeSafe_def typeCompat_def by fastforce
              then have stl1NotPrnt:"stl1 \<noteq> prnt" 
                by (metis MTypes.distinct(1) a1 mtv1 prntRelations sameStack)
              then show ?thesis 
              proof(cases tp2)
                case mta1:(MTArray x11 x12)
                then show ?thesis
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1")
                  case True
                  then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" 
                    by (simp add: nToO)
                  then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" using a1 a3 notSame mta1 mtv1 sameStack  by simp
                  then have "CompMemType (memory st') x11 x12 (MTValue x2) stl2 stl1" 
                    by (simp add: cmpO_imps_new)
                  then show ?thesis using a1 mtv1 mta1 sameStack notSame by auto
                next
                  case False
                  then show ?thesis  using a1 mtv1 mta1 sameStack notSame by simp
                qed
              next
                case (MTValue x2)
                then show ?thesis using mtv1 notSame a1 sameStack by simp
              qed
            qed

          qed
        qed


      next 
        have "accounts st'= accounts st" using 3 by auto
        then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 3 unfolding fullyInitialised_def  by auto
      next 

        have sameStack:"stack st = stack st'" using 3 by simp
        have oldL:"\<exists>v''. accessStore l (memory (st\<lparr>gas := g\<rparr>)) = Some (MValue v'')" using lInfo 
          using MCon_sub_MTVal_imps_val by blast

      qed
    qed

  next
    case (4 p x t g l g' p' m t' st'')
    have nonChangedStack:"\<forall>loc. loc \<noteq> l \<longrightarrow> accessStore loc (stack st) = accessStore loc (stack st')" using 4 unfolding accessStore_def updateStore_def by auto
    have accessLStack:"accessStore l (stack st') = Some (KMemptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 4 unfolding accessStore_def updateStore_def by auto
    have sameStorage:"storage st'  = storage st " using 4 by auto
    have lInDen:"(Memory t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[of lv env cd g st l ] 4(2) by simp
    have nonLocChanged:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
      using 4(6) unfolding cpm2m_def using  cpm2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ]   cpm2m_def[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" x t cd " (snd (allocate (memory st)))" ]  
      by fastforce
    have a30:"\<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
      using  4(6) unfolding cpm2m_def using cpm2mSingleChange2[of p  "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ]  by fastforce
    have selfPoint:"\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<and> accessStore l m = Some (MPointer l') \<longrightarrow> l' = l" 
      using  4(6) unfolding cpm2m_def using cpm2mSelfPointers[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ] by blast
    have mInStd:"m = memory st'" using 4 by simp

    have p'MCon:"MCon t' (memory st) p'" using 2 4(4) unfolding TypeSafe_def typeCompat_def using lInDen by (auto split:Denvalue.splits option.splits Stackvalue.splits Type.splits)

    have MConsrc:"MCon (MTArray x t) cd (extractValueType (KCDptr p)) \<and> (\<exists>xx. KCDptr p = KCDptr xx) \<and> 
            (\<exists>stloc tp'' pa.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KCDptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KCDptr p = KCDptr pa \<or>
             (\<exists>len arr. extractValueType (KCDptr p) \<noteq> pa \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr (MTArray x t) pa (extractValueType (KCDptr p)))))"
      using 2(1) 4(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KCDptr p" "Calldata (MTArray x t)" g] 
        2(3) unfolding fullyInitialised_def by (auto split:Type.splits if_splits )
    have "(\<exists>p. accessStore p' (memory st) = Some (MPointer p)) \<or> accessStore p' (memory st) = None" using p'MCon 4(3) 
      by (metis MCon.simps(2))
    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have MCondest:" MCon (MTArray x t) m (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using  4(6) unfolding cpm2m_def
      using MCon_cpm2m[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m] MConsrc extractValueType.simps(2) by metis
    have selfPoint2:"\<forall>l l'. LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> accessStore l (memory st') = Some (MPointer l') \<longrightarrow> l' = l" using selfPoint limitSt1 limitSt 
        "4"(6) a30 accessPrePost1 allocateSameAccess cpm2m_def eq_imp_le hash_inequality not_Some_eq 
      by (metis mInStd)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 4 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st') (denvalue env)"  unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
          using a0 nonChangedStack accessLStack sameStorage compPointers_def 
          by (smt (verit) Stackvalue.distinct(11) compPointers_def option.inject)
      qed
    next 
      show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 4 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 4 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
      proof intros

        fix tloc loc 
        assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
        then show "accessStore loc (stack st') = None" using *  
          by (metis "4"(4) nonChangedStack not_None_eq)
      next 
        fix loc y 
        assume h1:" accessStore loc (stack st') = Some y"
        then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
          by (metis "4"(4) nonChangedStack)        
      qed
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      have a10:"toploc (snd (allocate (memory st))) = toploc m" using cpm2mTopLocSame[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m] 4(6) mInStd unfolding cpm2m_def by fastforce
      have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp
      have a20:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using 4(6) unfolding cpm2m_def using  cpm2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m ]   
          cpm2m_def[of p  "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" x t cd "(snd (allocate (memory st)))" ] by fastforce
      then have a30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m" 
        by (metis allocateSameAccess)
      have st'IsM:"memory st' = m" using 4 by simp
      have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
      show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
      proof intros
        fix tloc loc 
        assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then have b20:"toploc (memory st) \<le> tloc" using a10 tloc st'IsM by simp
        have "\<not>LSubPrefL2 loc p'" 
        proof(rule ccontr)
          assume c10:"\<not> \<not> LSubPrefL2 loc p'"
          then have c20: "LSubPrefL2 loc p'" by simp
          then have c30:"LSubPrefL2 p' (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using b10  MemLSubPrefTransitive by auto
          then show False
          proof -
            have "MCon t' (memory st) p'" using 4(4) 2(1) unfolding TypeSafe_def typeCompat_def using lInDen by fastforce
            then obtain x i where c40: "accessStore p' (memory st) = Some x \<or> accessStore (hash p' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" using MCon_imps_Some by blast
            then show ?thesis
            proof(cases "accessStore p' (memory st) = Some x")
              case True
              then show ?thesis using lessThanSome_imps_Locs[of st p' x "tloc"] c30 a15 b20 by simp
            next
              case False
              then have "accessStore (hash p' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" using c40 by simp
              then show ?thesis using lessThanSome_imps_Locs2  c30 a15 b20 by fastforce
            qed
          qed
        qed
        then show "accessStore loc (memory st') = None " using b10 b20 a20 a10 st'IsM a15 a30 
          by (metis (no_types, lifting) LSubPrefL2_def MemLSubPrefTransitive antisym_conv2 hash_inequality hash_suffixes_associative hashesIntSame lessThanTopLocs_def order_less_le_trans tloc)

      next 
        fix loc y 
        assume "accessStore loc (memory st') = Some y "
        then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
          by (metis a10 a15 a30 lessThanTopLocs_def order_less_trans st'IsM tloc)
      qed
    next 
      show ns:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"
        then have memComp:" (\<forall>tp1 tp2 l1 l2 stl1 stl2 dloc1.
        (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                       else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
                  | MTValue val2 \<Rightarrow> True)))" 
          using 2(1) unfolding TypeSafe_def compMemPtrs_def by blast


        show " case l' of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
              | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using accessLStack nonChangedStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) accessLStack nonChangedStack unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(3) Stackvalue.simps(17) option.inject)
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) accessLStack nonChangedStack unfolding TypeSafe_def  typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(7) Stackvalue.simps(18) option.inject)
          next
            case (KMemptr x3)
            then have "\<exists>struct. t'' = Memory struct" 
            proof(cases "x1 = l")
              case True
              have "accessStore l (stack st) = Some (KMemptr p')" using 4(4) by simp
              then show ?thesis using Stackloc adef  inDen Stackloc 2(1) KMemptr True unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            next
              case False
              then have "accessStore x1 (stack st) = accessStore x1 (stack st')" using accessLStack nonChangedStack by simp
              then show ?thesis using Stackloc adef  inDen Stackloc 2(1) KMemptr unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            qed
            then obtain struct where structdef:"t'' = Memory struct" by blast


            have "MCon struct (memory st') x3" 
            proof(cases "x1 = l")
              case True
              then have "x3 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using 4 KMemptr adef unfolding accessStore_def updateStore_def by auto
              then show ?thesis using MCondest 4 
                by (metis (no_types, lifting) Stackloc True inDen lInDen mInStd memComp structdef)
            next
              case False
              then have "accessStore x1 (stack st) = accessStore x1 (stack st')" using accessLStack nonChangedStack by simp
              then have "accessStore x1 (stack st) = Some (KMemptr x3)" using adef KMemptr by simp
              then have mgh:"MCon struct (memory st) x3" using inDen KMemptr Stackloc adef structdef 2(1) unfolding TypeSafe_def typeCompat_def by force
              then show ?thesis using originalMConStillMCon[OF mgh limitSt ] mInStd allocateSameAccess a30  by (metis nonLocChanged)

            qed

            then show ?thesis  using structdef KMemptr Stackloc adef  inDen Stackloc 2(1) unfolding TypeSafe_def by simp

          next
            case (KStoptr x4)  
            then show ?thesis using Stackloc adef sameStorage  inDen Stackloc KStoptr 2(1) accessLStack nonChangedStack unfolding TypeSafe_def typeCompat_def apply(cases t'') 
              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(3) Type.simps(17) lInDen old.prod.inject snd_eqD uniqueLocs)
              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(7) Type.simps(18) lInDen old.prod.inject snd_eqD uniqueLocs)

              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(11) Stackvalue.simps(20) Type.simps(19) option.inject)

              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(11) Type.simps(20) lInDen prod.inject snd_conv uniqueLocs)
          qed

        next
          case (Storeloc x2)
          then show ?thesis using sameStorage inDen 2(1) unfolding TypeSafe_def typeCompat_def by (cases t''; force)
        qed
      qed
      have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"
        show "case l' of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st) of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)"
        proof(cases l')
          case (Stackloc x1)
          then show ?thesis
          proof(cases "x1 = l")
            case True
            then have accO:"accessStore x1 (stack st) = Some (KMemptr p')" 
              using 4 unfolding updateStore_def accessStore_def by auto
            then obtain struct where structdef: "t'' = Memory struct" 
              using Stackloc accO  inDen Stackloc 2(1) True unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            have "MCon struct (memory st') p'" 
              using  MCondest 4 accO
              by (smt (verit, best) "2.prems"(1)  PreExistMconNotChangeByToploc Stackloc  allocateSame cpm2mSingleChange cpm2m_def inDen limitSt limitSt1 mInStd statement_with_gas.sameMemTSafe statement_with_gas_axioms
                  structdef)
            then show ?thesis using True accO inDen structdef Stackloc by simp
          next
            case False
            then have "accessStore x1 (stack st) = accessStore x1 (stack st')" using 4 unfolding updateStore_def accessStore_def by auto
            then show ?thesis using Stackloc ns inDen unfolding typeCompat_def by force
          qed
        next
          case (Storeloc x2)
          then show ?thesis using ns inDen unfolding typeCompat_def by force
        qed
      qed
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def
      proof(intros)
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast

        then have c30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"   using nonLocChanged
          by simp
        moreover have st'IsM:"memory st' = m" using 4 by simp
        ultimately have c35:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st') = accessStore locs (memory st)" by simp
        assume h1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2)"

        show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)"
        proof(cases "stl1 = stl2")
          case True
          show ?thesis using 4 
          proof(cases "stl1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
            case t2:True
            then have "l1 = l" using 2(1) unfolding TypeSafe_def 
              by (metis "2.prems"(1) MCon_imps_Some LSubPrefL2_def h1 lessThanSome_imps_Locs nat_neq_iff nonChangedStack sameMemTSafe)
            moreover have "l2 = l" using 2(1) unfolding TypeSafe_def using t2 True 
              by (metis "2.prems"(1) MCon_imps_Some LSubPrefL2_def h1 lessThanSome_imps_Locs nat_neq_iff nonChangedStack sameMemTSafe)
            ultimately show ?thesis using 2(1) unfolding TypeSafe_def unique_locations_def using h1 by auto
          next
            case False
            moreover have "l1 \<noteq> l" using 4 h1 calculation unfolding accessStore_def updateStore_def by auto
            moreover have "accessStore l1 (stack st') = accessStore l1 (stack st)" using 4 calculation unfolding accessStore_def updateStore_def by auto
            ultimately show ?thesis using 2(1) unfolding TypeSafe_def unique_locations_def using h1 True 
              by (smt (verit) Stackvalue.inject(3) accessLStack compMemPtrs_def nonChangedStack option.inject)
          qed

        next
          case False
          then show ?thesis 
          proof(cases tp1)
            case mta1:(MTArray x11 x12)
            then show ?thesis 
            proof(cases tp2)
              case mta2:(MTArray x11' x12')
              then show ?thesis 
              proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                case stl2Toploc:True
                then have "stl1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                then have mcon1Old:" MCon tp1 (memory st) stl1" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                  by (metis Stackvalue.inject(3) accessLStack option.inject)
                have "l2 = l" using stl2Toploc h1 stackDenvalLimits nonChangedStack 
                  by (metis LSubPrefL2_def)
                have stl2NotParentStl1:" \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1" 
                  using MCondest LSubPrefL2_def TS_imps_InDenLessStack2 c35 limitSt limitSt1 mcon1Old selfPoint2 st'IsM stl2Toploc by blast
                have stl1NotParentStl2:"\<not>TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" 
                  using TS_imps_InDenLessStack3 MCondest LSubPrefL2_def c35 limitSt limitSt1 mcon1Old selfPoint2 st'IsM stl2Toploc 
                  using mta1 by blast
                have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<longrightarrow> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                  using SubPtrs_top selfPoint2 LSubPrefL2_def stl2Toploc by blast
                moreover have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<longrightarrow> \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                  using subPtrs_nonTop LSubPrefL2_def c35 limitSt limitSt1 mcon1Old mta1 by blast
                ultimately have "\<not>(TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1)" by auto
                then show ?thesis using stl2NotParentStl1 stl1NotParentStl2 mta1 mta2 False by auto
              next
                case f2:False
                then have stl2NotTop:"stl2 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                then have mcon2Old:" MCon tp2 (memory st) stl2" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                  by (metis Stackvalue.inject(3) accessLStack option.inject)
                then show ?thesis 
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                  case stl1Toploc: True

                  have "l1 = l" using stl1Toploc h1 stackDenvalLimits nonChangedStack 
                    by (metis LSubPrefL2_def)
                  have stl2NotParentStl1:" \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" 
                    using MCondest LSubPrefL2_def TS_imps_InDenLessStack2 c35 limitSt limitSt1 mcon2Old selfPoint2 st'IsM stl1Toploc by blast
                  have stl1NotParentStl2:"\<not>TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1" 
                    using TS_imps_InDenLessStack3 MCondest LSubPrefL2_def c35 limitSt limitSt1 mcon2Old selfPoint2 st'IsM stl1Toploc 
                    using mta1 mta2 by blast
                  have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<longrightarrow> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    using SubPtrs_top selfPoint2 LSubPrefL2_def stl1Toploc by blast
                  moreover have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<longrightarrow> \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    using subPtrs_nonTop LSubPrefL2_def c35 limitSt limitSt1 mcon2Old mta1 mta2 by blast
                  ultimately have "\<not>(TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1)" by auto
                  then show ?thesis using stl2NotParentStl1 stl1NotParentStl2 mta1 mta2 False by auto
                next
                  case f3:False
                  then have stl1NotTop:"stl1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                  then have mcon1Old:" MCon tp1 (memory st) stl1" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                    by (metis Stackvalue.inject(3) accessLStack option.inject)

                  then have l2StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack stl2NotTop  
                    by (metis Stackvalue.inject(3) accessLStack h1 option.inject)
                  then have l1StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack stl1NotTop  
                    by (metis Stackvalue.inject(3) accessLStack h1 option.inject)

                  then show ?thesis
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                    case True
                    then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using  h1  mta2  l2StackSame l1StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl2NotTop
                      by (metis (lifting) c35 le_refl limitSt mcon2Old stackDenvalLimits)
                    then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" 
                      using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False unfolding TypeSafe_def compMemPtrs_def 
                      by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using mcon1Old mcon2Old mta1 mta2 False 
                      by (smt (verit, ccfv_SIG) c35 cpm2mCompMemTypeOld_imps_CompMemType h1 l2StackSame limitSt nle_le stackDenvalLimits)
                    then show ?thesis  using mta1 mta2 False h1 True by simp
                  next
                    case f4:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2 ")
                      case True
                      then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                        using  h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl1NotTop mcon1Old 
                        by (metis c35 le_refl limitSt stackDenvalLimits)
                      then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" 
                        using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False unfolding TypeSafe_def compMemPtrs_def 
                        by (auto split: MTypes.splits)
                      then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using mcon1Old mcon2Old mta1 mta2 False 
                        by (smt (verit, ccfv_SIG) c35 cpm2mCompMemTypeOld_imps_CompMemType h1 l1StackSame limitSt nle_le stackDenvalLimits)
                      then show ?thesis  using mta1 mta2 False h1 True f4 by simp
                    next
                      case f5:False
                      then have n1:"\<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 stl1NotTop mcon1Old  
                        by (smt (verit, best) c35 cpm2mTPrefOld_imps_TPref le_refl limitSt stackDenvalLimits)
                      have n2:"\<not>TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using h1 mta2 l1StackSame l2StackSame 2(1) f2 f3 stl2NotTop mcon2Old f4
                        by (smt (verit, best) c35 cpm2mTPrefOld_imps_TPref le_refl limitSt stackDenvalLimits)
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                        case tp:True
                        then have tsu1:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1"
                          using  h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl1NotTop mcon1Old 
                          by (metis c35 le_refl limitSt stackDenvalLimits)
                        have tsu2:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1"
                          using  h1  mta2  l2StackSame l1StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl2NotTop tp
                          by (metis (lifting) c35 le_refl limitSt mcon2Old stackDenvalLimits)
                        have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                          using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False tsu1 tsu2 f4 f5 n1 n2 unfolding TypeSafe_def compMemPtrs_def 
                          by (auto split: MTypes.splits) 
                        then obtain dt where cp1:"CompMemType (memory st) x11' x12' dt stl2 dloc1" and cp2:"CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                        have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                          using cpm2mCompMemTypeOld_imps_CompMemType[OF cp1] c35  LSubPrefL2_def stl2NotTop mcon2Old limitSt 
                          by (metis dual_order.refl h1 l2StackSame mta2 stackDenvalLimits)
                        moreover have " CompMemType (memory st') x11 x12 dt stl1 dloc1"
                          using cpm2mCompMemTypeOld_imps_CompMemType[OF cp2] c35  LSubPrefL2_def stl1NotTop mcon1Old limitSt 
                          by (metis dual_order.refl h1 l1StackSame mta1 stackDenvalLimits)
                        ultimately show ?thesis using mta1 mta2 f2 f3 f4 f5 False by auto
                      next
                        case f6:False
                        then show ?thesis using mta1 mta2 False h1 f4 f5 f6 by auto
                      qed
                    qed
                  qed
                qed
              qed
            next
              case mtv2:(MTValue x2)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                case t2:True
                then show ?thesis 
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                  case t3:True
                  then have "l2 = l"using  h1 stackDenvalLimits nonChangedStack LSubPrefL2_def by metis
                  then have "tp2 =  MTArray x t" using 4(3) lInDen 2(1) h1 unfolding TypeSafe_def unique_locations_def by auto
                  then show ?thesis using mtv2 by simp
                next
                  case f3:False
                  then have "l2 \<noteq> l" using 4(5,7) h1 unfolding updateStore_def accessStore_def by auto
                  then have l1StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack by auto
                  then show ?thesis 
                  proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                    case True
                    then have "toploc (memory st) = toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                      by (simp add: LSubPrefL2_def)  
                    have mconstl1Old:"MCon tp2 (memory st) stl2" using sameMemTSafe h1 2(1) unfolding TypeSafe_def 
                      by (metis l1StackSame)

                    then have "\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" using TS_imps_InDenLessStack2[of tp2 st stl2 stl1 st' _ x11 x12] True LSubPrefL2_def limitSt limitSt1 selfPoint2 
                      using MCondest c35 st'IsM by blast

                    then show ?thesis using t2 by simp
                  next
                    case f4:False
                    then have "l1 \<noteq> l" using 4(5,7) h1 unfolding updateStore_def accessStore_def by auto
                    then have l2StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack by auto
                    then have mconstl2Old:"MCon tp1 (memory st) stl1" using h1 2(1) unfolding TypeSafe_def 
                      by (metis "2.prems"(1) sameMemTSafe)
                    then have "MCon (MTArray x11 x12) (memory st') stl1" using originalMConStillMCon[OF mconstl2Old limitSt ] mInStd allocateSameAccess a30  nonLocChanged mta1 by metis
                    moreover have "\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                    proof
                      assume "LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                      then have "\<exists>i. stl1 = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" unfolding LSubPrefL2_def using f4 by simp
                      then show False using mconstl2Old 
                        by (metis MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt option.distinct(1))
                    qed

                    ultimately have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using inv_cpm2mTPrefOld_imps_TPref t2 c35 limitSt mta1
                      by (smt (verit, ccfv_SIG) inv_cpm2mTPrefOld_imps_TPref mconstl2Old order_refl)
                    then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" 
                      using 2(1) unfolding TypeSafe_def compMemPtrs_def using h1 l2StackSame l1StackSame False  mtv2 mta1 by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" 
                      by (smt (verit, ccfv_SIG) \<open>\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> c35 cpm2mCompMemTypeOld_imps_CompMemType le_eq_less_or_eq limitSt mconstl2Old mta1)
                    then show ?thesis using h1 2(1) a30 f3 mta1 mtv2 False t2 l1StackSame l2StackSame by simp
                  qed
                qed
              next
                case f2:False
                then show ?thesis using mtv2 mta1 False by simp
              qed
            qed
          next
            case mtv1:(MTValue x2)
            then show ?thesis 
            proof(cases tp2)
              case mta2:(MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1")
                case t2:True
                then show ?thesis
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                  case t3:True
                  then have "l1 = l" using 2(1) h1 unfolding TypeSafe_def 
                    by (metis "2.prems"(1) Option.option.simps(4) \<open>accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None\<close> allocateSameAccess mtv1 nonChangedStack sameMemTSafe MCon.simps(1))
                  then have "tp1 =  MTArray x t" using 4(3) lInDen 2(1) h1 unfolding TypeSafe_def unique_locations_def by auto
                  then show ?thesis using mtv1 by simp
                next
                  case f3:False
                  then have "l1 \<noteq> l" using 4(5,7) h1 unfolding updateStore_def accessStore_def by auto
                  then have l1StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack by auto
                  then show ?thesis 
                  proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                    case True
                    then have "toploc (memory st) = toploc (memory st) \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                      by (simp add: LSubPrefL2_def)  
                    have mconstl1Old:"MCon tp1 (memory st) stl1" using sameMemTSafe h1 2(1) unfolding TypeSafe_def 
                      by (metis l1StackSame)

                    then have "\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1" using TS_imps_InDenLessStack2[of tp1 st stl1 stl2 st' _ x11 x12] True LSubPrefL2_def limitSt limitSt1 selfPoint2 
                      using MCondest c35 st'IsM by blast

                    then show ?thesis using t2 by simp
                  next
                    case f4:False
                    then have "l2 \<noteq> l" using 4(5,7) h1 unfolding updateStore_def accessStore_def by auto
                    then have l2StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack by auto
                    then have mconstl2Old:"MCon tp2 (memory st) stl2" using h1 2(1) unfolding TypeSafe_def 
                      by (metis "2.prems"(1) sameMemTSafe)
                    then have "MCon (MTArray x11 x12) (memory st') stl2" using originalMConStillMCon[OF mconstl2Old limitSt ] mInStd allocateSameAccess a30  nonLocChanged mta2 by metis
                    moreover have "\<not> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                    proof
                      assume "LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                      then have "\<exists>i. stl2 = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" unfolding LSubPrefL2_def using f4 by simp
                      then show False using mconstl2Old 
                        by (metis MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt option.distinct(1))
                    qed 

                    ultimately have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref t2 c35 limitSt mta2 

                      by (metis dual_order.refl mconstl2Old)
                    then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" 
                      using 2(1) unfolding TypeSafe_def compMemPtrs_def using h1 l2StackSame l1StackSame False  mtv1 mta2 by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11 x12 (MTValue x2) stl2 stl1" 
                      by (smt (verit, ccfv_SIG) \<open>\<not> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> c35 cpm2mCompMemTypeOld_imps_CompMemType le_eq_less_or_eq limitSt mconstl2Old mta2)
                    then show ?thesis using h1 2(1) a30 f3 mta2 mtv1 False t2 l1StackSame l2StackSame by simp
                  qed
                qed
              next
                case f2:False
                then show ?thesis using mta2 mtv1 False by (auto split:if_splits)
              qed
            next
              case mtv2:(MTValue x2')
              then show ?thesis using mtv1 False by simp
            qed
          qed
        qed
      qed
    next 
      have accSame:"accounts st'= accounts st" using 4 by auto
      show "fullyInitialised env  (accounts st') (stack st')" unfolding fullyInitialised_def
      proof intros
        show "\<exists>c. type (accounts st' (address env)) = Some (Contract c) \<and> contract env = c" using accSame 
          using "2.prems"(3) fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract env = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue env $$ id = Some (Storage v, Storeloc id))"
          using "2.prems"(3) fullyInitialised_def by blast
        fix t'' l'' p'' 
        assume in1:"(Storage t'', Stackloc l'') |\<in>| fmran (denvalue env)\<and>accessStore l'' (stack st') = Some (KStoptr p'')"
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue env) \<and> CompStoType t' t'' l' p''"
          using 4 "2.prems"(3) fullyInitialised_def unfolding accessStore_def updateStore_def 
          by (metis "2.prems"(1) Type.distinct(11) accessStore_def lInDen nonChangedStack prod.inject snd_eqD typeSafeUnique uniqueLocs)
      qed

    next 
      have a20':"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using 4(6) unfolding cpm2m_def using  cpm2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m ]   
          cpm2m_def[of p  "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" x t cd "(snd (allocate (memory st)))" ] by fastforce
      then have a30': "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m" 
        by (metis allocateSameAccess)
      have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
      have topLocEq:"toploc (snd (allocate (memory st))) = toploc (memory st')" 
        using cpm2mTopLocSame 4(6) cpm2m_def mInStd MCondest 
        by (metis (no_types, lifting) MCon.simps(2))

    qed 


  next
    case (5 p x t g l t' g' p' s)
    obtain t''' where t''Def:"t' = STArray x t''' " using 5(4) 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    have sameStack:"(stack st) = (stack st')" using 5 unfolding accessStore_def updateStore_def by auto
    have sameMemory:"memory st' = memory st " using 5 by auto
    have lInDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[of lv env cd g st l "Storage t'"] 5(2) by simp
    have nonLocChanged:"\<forall>t' locs. \<not> LSubPrefL2 locs p' \<or> locs = p' \<longrightarrow> accessStorage t' locs (storage st (address env)) = accessStorage t' locs s" 
      using 5(5) unfolding cpm2s_def using  cpm2sSingleChange[of p p' t cd "(storage st (address env))" x s]  
      by fastforce
    have a30:" \<forall>locs t' t''.
       cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> p' \<and> \<not> TypedStoSubpref locs p' (STArray x t') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs s" 
      using  5(5) unfolding cpm2s_def using cpm2sSingleChange2[of p  "p'" t cd "(storage st (address env))" x s ]  by simp
    then have a35:"\<forall>locs t''. locs \<noteq> p' \<and> \<not> TypedStoSubpref locs p' (STArray x t''') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs (storage st' (address env))" 
      using 5 t''Def by auto
    have mInStd:"s = storage st' (address env)" using 5 by simp

    have p'MCon:"SCon t' p' (storage st (address env))" using 2 5 unfolding TypeSafe_def typeCompat_def using lInDen 
      by (auto split:Denvalue.splits option.splits Stackvalue.splits Type.splits)

    have MConsrc:"MCon (MTArray x t) cd (extractValueType (KCDptr p)) \<and> (\<exists>xx. KCDptr p = KCDptr xx) \<and> 
            (\<exists>stloc tp'' pa.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KCDptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KCDptr p = KCDptr pa \<or>
             (\<exists>len arr. extractValueType (KCDptr p) \<noteq> pa \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr (MTArray x t) pa (extractValueType (KCDptr p)))))"
      using 2(1) 5(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KCDptr p" "Calldata (MTArray x t)" g] 
        2(3) unfolding fullyInitialised_def
      by (auto split:Type.splits if_splits )

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have SCondest:"SCon (STArray x t''') p' s" using  5 unfolding cpm2s_def
      using MCon_cpm2s[of p p' t cd "(storage st (address env))" x s t'''] t''Def MConsrc extractValueType.simps(2) by metis
    then have SCondest2:"SCon (STArray x t''') p' (storage st' (address env))" 
      by (simp add: mInStd)
    then have SCondest3:"SCon t' p' (storage st' (address env))" 
      by (simp add: mInStd t''Def)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 5 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st)  (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st') (denvalue env)"  unfolding compPointers_def 
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "TypedStoSubpref stl2 stl1 tp1")
          case True
          then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
        next
          case f1:False
          then show ?thesis 
          proof(cases "TypedStoSubpref stl1 stl2 tp2")
            case True
            then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
          next
            case False
            then show ?thesis using f1 by simp
          qed
        qed
      qed
    next 
      have "safeContract (storage st)" using 2(1) unfolding TypeSafe_def by simp 
      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 5 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 5 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  using sameStack * ** unfolding lessThanTopLocs_def by auto
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      show "lessThanTopLocs (memory st')" using sameMemory unfolding lessThanTopLocs_def 
        by (simp add: limitSt limitSt1)
    next 
      show tcN:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def 
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"

        show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack  unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def  typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
          next
            case (KMemptr x3)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack sameMemory unfolding TypeSafe_def typeCompat_def by (cases t''; fastforce)
          next
            case (KStoptr x4)  
            then obtain struct where structDef: "t'' = Storage struct" using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def typeCompat_def
              by (cases t''; fastforce)

            have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Stackloc l) |\<in>| fmran (denvalue env) \<and>
              (l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4) \<or> l' = Storeloc x4) \<and>
              (accessStore l (stack st) = Some (KStoptr p')) \<longrightarrow>
              (if TypedStoSubpref p' x4 struct then CompStoType struct  (STArray x t''') x4 p'
               else if TypedStoSubpref x4 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x4 else True))" 
              using 2(1) 5(3) lInDen inDen Stackloc structDef KStoptr unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref p' x4 struct then CompStoType struct  (STArray x t''') x4 p'
             else if TypedStoSubpref x4 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x4 else True)"
              using  5(3) lInDen inDen Stackloc structDef KStoptr  t''Def
              by (simp add: adef sameStack)

            have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Stackloc adef inDen Stackloc 2(1) sameStack structDef KStoptr 
              by fastforce

            have "SCon struct x4 (storage st' (address env))" 
            proof(cases "TypedStoSubpref p' x4 struct")
              case True
              then have "CompStoType struct (STArray x t''') x4 p'" using cmpStoPtr2 by simp
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast

            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x4 p'  (STArray x t''')")
                case True
                then have "CompStoType t' struct p' x4 " using cmpStoPtr2 f1 t''Def by simp
                then show ?thesis using SCondest3 SCon_imps_sublocs by blast

              next
                case False
                have notSame:"x4 \<noteq> p'" using False by auto
                have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> p' " using f1 by blast
                have k8:"\<forall>locs. TypedStoSubpref locs p' (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False by auto
                show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
              qed
            qed
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack KStoptr structDef by simp
          qed

        next
          case (Storeloc x2)
          then obtain struct where structDef: "t'' = Storage struct" using Storeloc  inDen  2(1) sameStack unfolding TypeSafe_def typeCompat_def
            by (cases t''; fastforce)

          have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Stackloc l) |\<in>| fmran (denvalue env) \<and>
               l' = Storeloc x2) \<and>
              (accessStore l (stack st) = Some (KStoptr p')) \<longrightarrow>
              (if TypedStoSubpref p' x2 struct then CompStoType struct  (STArray x t''') x2 p'
               else if TypedStoSubpref x2 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x2 else True)" 
            using 2(1) 5(3) lInDen inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

          then have cmpStoPtr2:"(if TypedStoSubpref p' x2 struct then CompStoType struct  (STArray x t''') x2 p'
               else if TypedStoSubpref x2 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x2 else True)"
            using  5(3) lInDen inDen Storeloc structDef t''Def by (simp add: sameStack)

          have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
            by fastforce

          have "SCon struct x2 (storage st' (address env))" 
          proof(cases "TypedStoSubpref p' x2 struct")
            case True
            then have "CompStoType struct (STArray x t''') x2 p'" using cmpStoPtr2 by simp
            then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
              by blast
          next
            case f1:False
            then show ?thesis 
            proof(cases "TypedStoSubpref x2 p'  (STArray x t''')")
              case True
              then have "CompStoType t' struct p' x2 " using cmpStoPtr2 f1 t''Def by simp
              then show ?thesis using SCondest3  SCon_imps_sublocs by blast
            next
              case False
              have notSame:"x2 \<noteq> p'" using False by auto
              have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> p' " using f1 by blast
              have k8:"\<forall>locs. TypedStoSubpref locs p' (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False by auto
              show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
            qed
          qed
          then show ?thesis using Storeloc  inDen  2(1) sameStack Storeloc structDef by simp
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        using sameStack by auto

    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      then show "compMemPtrs (stack st') (memory st') (denvalue env)" using sameStack sameMemory by auto
    next 
      have accSame:"accounts st'= accounts st" using 5 by auto
      show "fullyInitialised env  (accounts st') (stack st')" unfolding fullyInitialised_def
      proof intros
        show "\<exists>c. type (accounts st' (address env)) = Some (Contract c) \<and> contract env = c" using accSame 
          using "2.prems"(3) fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract env = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue env $$ id = Some (Storage v, Storeloc id))"
          using "2.prems"(3) fullyInitialised_def by blast
        fix t'' l'' p'' 
        assume in1:"(Storage t'', Stackloc l'') |\<in>| fmran (denvalue env)\<and>accessStore l'' (stack st') = Some (KStoptr p'')"
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue env) \<and> CompStoType t' t'' l' p''"
          using 5 "2.prems"(3) fullyInitialised_def unfolding accessStore_def updateStore_def by simp
      qed

    qed
  next
    case (6 p x t g l t' g' s)
    obtain t''' where t''Def:"t' = STArray x t''' " using 6(3) 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    have sameStack:"(stack st) = (stack st')" using 6 unfolding accessStore_def updateStore_def by auto
    have sameMemory:"memory st' = memory st " using 6 by auto
    have nonLocChanged:"\<forall>t' locs. \<not> LSubPrefL2 locs l \<or> locs = l \<longrightarrow> accessStorage t' locs (storage st (address env)) = accessStorage t' locs s" 
      using 6(4) unfolding cpm2s_def using  cpm2sSingleChange[of p l t cd "(storage st (address env))" x s]  
      by fastforce
    have a30:" \<forall>locs t' t''.
       cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> l \<and> \<not> TypedStoSubpref locs l (STArray x t') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs s" 
      using  6(4) unfolding cpm2s_def using cpm2sSingleChange2[of p  "l" t cd "(storage st (address env))" x s ]  by simp
    then have a35:"\<forall>locs t''. locs \<noteq> l \<and> \<not> TypedStoSubpref locs l (STArray x t''') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs (storage st' (address env))" 
      using 6 t''Def by auto
    have mInStd:"s = storage st' (address env)" using 6 by simp

    have MConsrc:"MCon (MTArray x t) cd (extractValueType (KCDptr p)) \<and> (\<exists>xx. KCDptr p = KCDptr xx) \<and> 
            (\<exists>stloc tp'' pa.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KCDptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KCDptr p = KCDptr pa \<or>
             (\<exists>len arr. extractValueType (KCDptr p) \<noteq> pa \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr (MTArray x t) pa (extractValueType (KCDptr p)))))"
      using 2(1) 6(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KCDptr p" "Calldata (MTArray x t)" g] 
        2(3) unfolding fullyInitialised_def
      by (auto split:Type.splits if_splits )

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have SCondest:"SCon (STArray x t''') l s" using  6 unfolding cpm2s_def
      using MCon_cpm2s[of p l t cd "(storage st (address env))" x s t'''] t''Def MConsrc extractValueType.simps(2) by metis
    then have SCondest2:"SCon (STArray x t''') l (storage st' (address env))" 
      by (simp add: mInStd)
    then have SCondest3:"SCon t' l (storage st' (address env))" 
      by (simp add: mInStd t''Def)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 6 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st)  (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st') (denvalue env)"  unfolding compPointers_def 
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "TypedStoSubpref stl2 stl1 tp1")
          case True
          then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
        next
          case f1:False
          then show ?thesis 
          proof(cases "TypedStoSubpref stl1 stl2 tp2")
            case True
            then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
          next
            case False
            then show ?thesis using f1 by simp
          qed
        qed
      qed
    next 
      have "safeContract (storage st)" using 2(1) unfolding TypeSafe_def by simp 
      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 6 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 6 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  using sameStack * ** unfolding lessThanTopLocs_def by auto
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      show "lessThanTopLocs (memory st')" using sameMemory unfolding lessThanTopLocs_def 
        by (simp add: limitSt limitSt1)
    next 
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"

        show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack  unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def  typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
          next
            case (KMemptr x3)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack sameMemory unfolding TypeSafe_def typeCompat_def by (cases t''; fastforce)
          next
            case (KStoptr x4)  
            then obtain struct where structDef: "t'' = Storage struct" using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def typeCompat_def
              by (cases t''; fastforce)

            have "SCon struct x4 (storage st' (address env))" 
            proof(cases rule:lexpStorageG[OF 2(1) 6(2) 2(3)])
              case lInDen:1
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage (STArray x t'''), Storeloc l) |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t''') x4 l
                 else if TypedStoSubpref x4 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x4 else True)" 
                using 2(1) 6(3) lInDen inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t''') x4 l
                 else if TypedStoSubpref x4 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x4 else True)"
                using  6(3) lInDen inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l x4 struct")
                case True
                then have "CompStoType struct (STArray x t''') x4 l" using cmpStoPtr2 by simp
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast

              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l  (STArray x t''')")
                  case True
                  then have "CompStoType t' struct l x4 " using cmpStoPtr2 f1 t''Def by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs by blast
                next
                  case False
                  have notSame:"x4 \<noteq> l" using False by auto
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False by auto
                  show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
                qed
              qed
              then show ?thesis by simp
            next
              case sub2:(2 l''' t)
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t, Storeloc l''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)" 
                using 2(1) 6(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)"
                using  6(3) sub2 inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t''') x4 l" using sub2 
                  using CompStoType_trns t''Def by blast
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis 
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def True by simp
                    moreover have "CompStoType t t' l''' x4" using t5 sub2 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def  True by simp                
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x4\<close> a35 scl''' sub2(2) t''Def)
                    qed
                  qed
                next
                  case False                                                             
                  then have asm10:"\<not> TypedStoSubpref l x4 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub2 by blast
                  then have asm20:"\<not> TypedStoSubpref x4 l t'" using sub2 NotReachablePrnt_imps_notReachableChild False f1 by blast
                  have notSame:"x4 \<noteq> l" using False sub2 by blast
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 sub2 asm10 asm20  by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False sub2 t''Def asm10 asm20 by blast
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
                qed
              qed

              then show ?thesis by simp
            next
              case sub3:(3 l''' t l'''')
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t, Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) \<and> accessStore l'''' (stack st) = Some (KStoptr l''')
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)" 
                using 2(1) 6(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)"
                using  6(3) sub3 inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def  using sub3 by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t''') x4 l" using sub3 
                  using CompStoType_trns t''Def by blast
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def True by simp
                    moreover have "CompStoType t t' l''' x4" using t5 sub3 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def  True by simp                
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x4\<close> a35 scl''' sub3(3) t''Def)
                    qed
                  qed
                next
                  case False                                                             
                  then have asm10:"\<not> TypedStoSubpref l x4 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                  then have asm20:"\<not> TypedStoSubpref x4 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                  have notSame:"x4 \<noteq> l" using False sub3 by blast
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False sub3 t''Def asm10 asm20 by blast
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
                qed
              qed
              then show ?thesis by simp
            qed
            then show ?thesis using Stackloc  inDen  2(1) sameStack KStoptr adef structDef by simp
          qed
        next
          case (Storeloc x2)
          then obtain struct where structDef: "t'' = Storage struct" using Storeloc  inDen  2(1) sameStack unfolding TypeSafe_def typeCompat_def
            by (cases t''; fastforce)

          have "SCon struct x2 (storage st' (address env))" 
          proof(cases rule:lexpStorageG[OF 2(1) 6(2) 2(3)])
            case lInDen:1
            have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Storeloc l) |\<in>| fmran (denvalue env) \<and>
               l' = Storeloc x2) 
               \<longrightarrow>
              (if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t''') x2 l
               else if TypedStoSubpref x2 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x2 else True)" 
              using 2(1) 6(3) lInDen inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t''') x2 l
               else if TypedStoSubpref x2 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x2 else True)"
              using  6(3) lInDen inDen Storeloc structDef t''Def sameStack by simp

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l x2 struct")
              case True
              then have "CompStoType struct (STArray x t''') x2 l" using cmpStoPtr2 by simp
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast

            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l  (STArray x t''')")
                case True
                then have "CompStoType t' struct l x2 " using cmpStoPtr2 f1 t''Def by simp
                then show ?thesis using SCondest3  SCon_imps_sublocs by blast
              next
                case False
                have notSame:"x2 \<noteq> l" using False by auto
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False by auto
                show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
              qed
            qed
            then show ?thesis by simp
          next
            case sub2:(2 l''' t)
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t, Storeloc l''') |\<in>| fmran (denvalue env) )
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)" 
              using 2(1) 6(3) inDen  Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)"
              using  6(3) sub2 inDen Storeloc  structDef t''Def sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t''') x2 l" using sub2 
                using CompStoType_trns t''Def by blast
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def True by simp
                  moreover have "CompStoType t t' l''' x2" using t5 sub2 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis 
                      using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x2\<close> a35 scl''' sub2(2) t''Def)
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub2 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub2 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub2 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub2 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False sub2 t''Def asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
              qed
            qed

            then show ?thesis by simp
          next
            case sub3:(3 l''' t l'''')
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t, Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 accessStore l'''' (stack st) = Some (KStoptr l'''))
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)" 
              using 2(1) 6(3) inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)"
              using  6(3) sub3 inDen Storeloc structDef t''Def sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub3 by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t''') x2 l" using sub3 
                using CompStoType_trns t''Def by blast
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def True by simp
                  moreover have "CompStoType t t' l''' x2" using t5 sub3 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis 
                      using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x2\<close> a35 scl''' sub3(3) t''Def)
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub3 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False sub3 t''Def asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
              qed
            qed
            then show ?thesis by simp
          qed


          then show ?thesis using Storeloc  inDen  2(1) sameStack Storeloc structDef by simp
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd" using sameStack by simp
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      then show "compMemPtrs (stack st') (memory st') (denvalue env)" using sameStack sameMemory by auto

    next 
      have "accounts st'= accounts st" using 6 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 6 unfolding fullyInitialised_def  by auto
    next 
      have ss:"stack st = stack st' \<and> memory st = memory st'" using 6 by simp

    qed
  next
    case (7 p x t g l t' g' m m')
    have temp:"TypeSafe env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd" 
      using 2(1) by simp
    have ttt:"fullyInitialised env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>))" using 2(3) unfolding fullyInitialised_def by simp
    then show ?thesis
    proof(cases rule:lexpIndexMem[OF 7(2) temp ttt])
      case lInfo:(1 x21 x22 tp tParent l' l'' prnt len' arr' i)
      have nonChangedStack:"\<forall>loc. loc \<noteq> l \<longrightarrow> accessStore loc (stack st) = accessStore loc (stack st')" using 7 unfolding accessStore_def updateStore_def by auto
      have sameStack:"(stack st') = stack st" using 7 unfolding accessStore_def updateStore_def by auto
      have sameStorage:"storage st'  = storage st " using 7 by auto
      have nonLocChanged:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using 7(4) unfolding cpm2m_def using  cpm2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ]   cpm2m_def[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" x t cd " (snd (allocate (memory st)))" ]  
        by fastforce
      have a30:"\<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using  7(4) unfolding cpm2m_def using cpm2mSingleChange2[of p  "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ]  by fastforce
      have a32:"\<forall>locs. \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"  
        by (metis a30 allocateSameAccess)
      have selfPoint:"\<forall>l l'. TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<and> accessStore l m = Some (MPointer l') \<longrightarrow> l' = l \<and> l \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using   7(4) unfolding cpm2m_def using cpm2mSelfPointers[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd " (snd (allocate (memory st)))" x m ] 
        by (metis LSubPrefL2_def hash_inequality hash_suffixes_associative TypedMemSubPref.simps(2) typedPrefix_imp_SubPref)

      have mInStd:"m' = memory st'" using 7 by simp
      have NonChangeM'm:"\<forall>locs. locs \<noteq> l \<longrightarrow> accessStore locs m = accessStore locs m'" using 7(5) unfolding accessStore_def updateStore_def by auto
      then have nonLocChanged3:"\<forall>locs. locs \<noteq>l \<and> \<not> TypedMemSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<longrightarrow> accessStore locs (memory st) = accessStore locs (memory st')"
        using a32 mInStd by auto

      have accessL:"accessStore l m' = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 7(5) unfolding accessStore_def updateStore_def by auto

      have MConsrc:"MCon (MTArray x t) cd (extractValueType (KCDptr p)) \<and> (\<exists>xx. KCDptr p = KCDptr xx) \<and> 
            (\<exists>stloc tp'' pa.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KCDptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KCDptr p = KCDptr pa \<or>
             (\<exists>len arr. extractValueType (KCDptr p) \<noteq> pa \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr (MTArray x t) pa (extractValueType (KCDptr p)))))"
        using 2(1) 7(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KCDptr p" "Calldata (MTArray x t)" g] 
        using 2(3) unfolding fullyInitialised_def
        by (auto split:Type.splits if_splits )

      have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" 
        using allocateSameAccess by blast
      ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
      then have MCondest:" MCon (MTArray x t) m (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using 7(4) unfolding cpm2m_def
        using MCon_cpm2m[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m] 
          MConsrc extractValueType.simps(2) by metis
      have lIs:"\<exists>x. accessStore l (memory st) = Some x" using lInfo by (auto split:option.splits)
      then have lOld:"\<exists>p. accessStore l (memory st) = Some (MPointer p)" using lInfo 7 by force
      then have l_not_toploc_orSub:"\<not>LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using limitSt by fastforce 

      have selfPoint2:"\<forall>l1 l2. LSubPrefL2 l1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) 
                        \<and> accessStore l1 (memory st') = Some (MPointer l2) \<longrightarrow> l2 = l1 \<and> l1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        by (metis NonChangeM'm a30 allocateSame l_not_toploc_orSub limitSt linorder_le_cases mInStd option.distinct(1)
            selfPoint)

      obtain len subT where tParentType:"tParent = MTArray len subT" using lInfo by blast
      then obtain p'' where lOrigin:"accessStore l (memory (st)) = Some (MPointer p'')" 
        and  compType:"CompMemType (memory (st\<lparr>gas := g\<rparr>)) len subT (MTArray x t) l'' p''" 
        and lsublocs:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = (MTArray x t) \<and> MCon (MTArray len' arr') (memory (st)) prnt" 
        and lsublocs3:"(prnt = l'' \<and> len = len' \<and> arr' = subT \<or> CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt)"
        using lInfo 7(3) by force
      then have lsublocs2:" CompMemType (memory (st)) len' arr' (MTArray x t) prnt p''" 
        using "7"(3) CompMemType.simps(2) by blast

      then have bb9:"\<forall>subT subloc. CompMemType (memory (st)) len' arr' subT prnt subloc \<and> subloc = p''
                                  \<longrightarrow> subT = (MTArray x t)" 
        using CompMemTypeSameLocsSameType lsublocs by blast

      have mconPrnt:"MCon (MTArray len' (MTArray x t)) (memory st) prnt" using lsublocs by auto
      have ldef:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len'" using lsublocs by auto

      have t6:"(Memory tParent,  Stackloc l') |\<in>| fmran (denvalue env)" using lInfo by blast
      have t7:" MCon (MTArray len subT) (memory (st)) l''" using lInfo 
        using tParentType by auto
      then have t8:"\<not> LSubPrefL2 l'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt limitSt1 typeSafe_noDenElementOverToploc_mem[OF 2(1) t6] lInfo(3) by simp
      have comptype2:"CompMemType m len subT (MTArray x t) l'' p''" using 
          cpm2mCompMemTypeOld_imps_CompMemType[of "(memory (st\<lparr>gas := g\<rparr>))" len subT "(MTArray x t)" l'' p'' "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" m ] 
          compType nonLocChanged limitSt t7 t8 allocateSame by auto
      have t10:"CompMemType (memory st) len subT (MTArray x t) l'' p''"
        using 
          cpm2mCompMemTypeOld_imps_CompMemType[of "(memory (st\<lparr>gas := g\<rparr>))" len subT "(MTArray x t)" l'' p'' "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" m ] 
          compType nonLocChanged limitSt t7 t8 allocateSame by auto
      then have mconlOld:"MCon (MTArray x t) (memory st) p''" using 7(3) lInfo lOrigin by force

      have nonLocChanged2:"\<forall>locs. locs \<noteq> l \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs (memory st')" 
        using 7 nonLocChanged LSubPrefL2_def NonChangeM'm mInStd allocateSame by metis
      have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                          \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto
      have MCondest2:" MCon (MTArray x t) (memory st') (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using 7 MCondest 
        by (smt (verit, best) LSubPrefL2_def MemLSubPrefTransitive NonChangeM'm MCon_nonSub_selfPointing l_not_toploc_orSub mInStd selfPoint)
      have bb:"\<forall>locs tp. CompMemType (memory st) len subT tp l'' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      proof intros
        fix locs tp 
        assume asm1:"CompMemType (memory st) len subT tp l'' locs"
        then have a2:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using t7
        proof(induction subT arbitrary:len l'')
          case (MTArray x1 subT)
          then show ?case 
            using CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def limitSt limitSt1 subPtrs_nonTop by blast
        next
          case (MTValue x)
          then show ?case 
            by (metis (no_types, lifting) CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def limitSt limitSt1 subPtrs_nonTop)
        qed
        then show " locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" by simp
        show "\<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using a2 by simp
      qed
      have b8:"\<forall>locs tp. CompMemType m len subT tp l'' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
      proof intros
        fix locs tp 
        assume asm1:"CompMemType m len subT tp l'' locs"
        then show "locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"  using t7 bb a32
        proof(induction subT arbitrary:len l'')
          case (MTArray x1 subT)
          obtain i' ptr' where i'Def:"i'<len \<and> accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m = Some (MPointer ptr') \<and> (ptr' = locs \<and> MTArray x1 subT = tp \<or> CompMemType m x1 subT tp ptr' locs)" 
            using MTArray.prems(1) unfolding CompMemType.simps by blast
          have "\<not> TypedMemSubPref (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t)" 

            by (metis MTArray.prems(2) bot_nat_0.extremum_unique i'Def leI limitSt mcon_accessStore nat_less_le neg_MemLSubPrefL2_imps_TypedMemSubPref not_Some_eq)
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m" using MTArray.prems by blast
          then show ?case 
          proof(cases "ptr' = locs")
            case True
            then show ?thesis 
              using MTArray.prems(3) \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m\<close> i'Def by auto
          next
            case False
            then have "CompMemType m x1 subT tp ptr' locs" 
              using i'Def by blast
            moreover have "MCon (MTArray x1 subT) (memory st) ptr'" 
              by (metis MCon_imps_sub_Mcon MTArray.prems(2) \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m\<close> i'Def)
            moreover have "\<forall>locs tp. CompMemType (memory st) x1 subT tp ptr' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
              using MTArray.prems(3) 
              by (metis (no_types, lifting) CompTypeRemainsMCon MCon_imps_Some LSubPrefL2_def \<open>MCon (MTArray x1 subT) (memory st) ptr'\<close> Not_Sub_More_Specific le_refl limitSt option.distinct(1))

            ultimately show ?thesis using MTArray.IH[of x1 ptr']  using MTArray.prems by blast
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed
      have nonLocChanged22:" \<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m" using nonLocChanged 
        by (simp add: allocateSame)
      then have l''mMcon:" MCon (MTArray len subT) m l''" using  t7 bb
      proof(induction subT arbitrary: len l'')
        case (MTArray x1 subT)
        have "\<forall>i<len.
             (case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False 
                                          | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<len"
          then obtain  ptr' where ptr'def:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer ptr')
                          \<and> MCon (MTArray x1 subT) (memory st) ptr'" using MTArray(3) 
            by (metis MConArrayPointers MCon_imps_sub_Mcon MCon.simps(2))
          have "CompMemType (memory st) len  (MTArray x1 subT)  (MTArray x1 subT) l'' (ptr')" 
            using ptr'def asm1 by auto
          then have "ptr' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 ptr' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTArray.prems(3) by blast
          have same:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" using nonLocChanged22 
            by (metis Read_Show_nat'_id antisym_conv1 limitSt option.distinct(1) ptr'def readLintNotEqual)

          have "\<forall>locs tp. CompMemType (memory st) x1 subT tp ptr' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTArray.prems(3) \<open>CompMemType (memory st) len (MTArray x1 subT) (MTArray x1 subT) l'' ptr'\<close> compMemTypes_trns by blast
          then have "MCon (MTArray x1 subT) m ptr'" using MTArray.IH[of x1 ptr'] ptr'def 
            using nonLocChanged22 by blast
          then show "(case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) m loc2 | MTValue Types \<Rightarrow> False))" 
            using same ptr'def 
            by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
        qed
        moreover have "len > 0" using MTArray.prems unfolding MCon.simps by blast
        moreover have "(\<exists>p. accessStore l'' m = Some (MPointer p)) \<or> accessStore l'' m = None"
        proof(cases "l'' = l")
          case True
          then show ?thesis 
            using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
        next
          case False
          then have "accessStore (l'' ) (memory st) = accessStore (l'') (m)" using nonLocChanged22 
            by (metis MConArrayPointers MTArray.prems(2) Read_Show_nat'_id calculation(2) lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 readLintNotEqual)
          then show ?thesis 
            using MTArray.prems(2) calculation(2) by force
        qed
        ultimately show ?case using MCon.simps(2)[of len "MTArray x1 subT" m l''] 
          by simp
      next
        case (MTValue x)
        have "\<forall>i<len.
             (case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<len"
          then obtain val where ptr':"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue val)
                          \<and> MCon (MTValue x) (memory st) (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTValue(2) 
            by (metis MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
          then have " CompMemType (memory st) len (MTValue x) (MTValue x) l'' (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using asm1 by auto
          then have "(hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTValue by blast
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" using nonLocChanged22 by auto
          then show "(case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) m loc2 | MTValue Types \<Rightarrow> False))" using ptr' asm1 
            by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) MCon.simps(1))
        qed
        moreover have "(\<exists>p. accessStore l'' m = Some (MPointer p)) \<or> accessStore l'' m = None"
        proof(cases "l'' =l")
          case True
          then show ?thesis 
            using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
        next
          case False
          then have "accessStore (l'' ) (memory st) = accessStore (l'') (m)" using nonLocChanged22  
            by (metis MCon_imps_Some MTValue.prems(2) Read_Show_nat'_id antisym_conv1 lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 option.discI readLintNotEqual)

          then show ?thesis 
            by (metis MTValue.prems(2) MCon.simps(2))
        qed
        moreover have "len > 0" using MTValue by fastforce
        ultimately show ?case using MCon.simps(2)[of len "MTValue x" m l''] by simp
      qed

      have p''mMcon:"MCon (MTArray x t) m p''" using mconlOld 
      proof(induction t arbitrary:x p'')
        case (MTArray x1 t)
        have samep'':"p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
          by (metis (no_types, lifting) MCon_imps_Some MTArray(2) LSubPrefL2_def Not_Sub_More_Specific le_refl limitSt option.distinct(1))
        have "x > 0" using MTArray 
          using zero_less_iff_neq_zero by force
        moreover have "(\<exists>p. accessStore p'' m = Some (MPointer p)) \<or> accessStore p'' m = None" using MTArray samep'' 
          using nonLocChanged22 calculation(1) by force
        moreover have "\<forall>i<x. (case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                  | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) m loc2 | MTValue Types \<Rightarrow> False))" 
        proof(intros)
          fix i assume asm1:"i<x"
          then obtain ptr where ptr':"accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer ptr) \<and> MCon (MTArray x1 t) (memory st) ptr" using MTArray 
            by (meson MConArrayPointers MCon_imps_sub_Mcon \<open>0 < x\<close>)
          moreover have "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m = accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st)"
            using MemLSubPrefL2_specific_imps_general \<open>p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> nonLocChanged22 by metis
          moreover have "accessStore ptr (memory st) = accessStore ptr (m)"
            using  nonLocChanged22 
            by (metis MCon_imps_Some Read_Show_nat'_id antisym_conv1 calculation(1) lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 option.discI readLintNotEqual)
          moreover have "MCon (MTArray x1 t) m ptr" using MTArray.IH ptr' by blast
          ultimately show "case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
          | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
          | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) m loc2 | MTValue Types \<Rightarrow> False)" by simp
        qed
        ultimately show ?case using MCon.simps(2)[of x "MTArray x1 t" m p''] by simp
      next
        case (MTValue x')
        have "p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
          by (metis (no_types, lifting) MCon_imps_Some MTValue LSubPrefL2_def Not_Sub_More_Specific le_refl limitSt option.distinct(1))
        then have samep':"accessStore p'' (memory st) = accessStore p'' m" 
          by (simp add: nonLocChanged22)
        have "\<forall>i<x. (case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                  | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<x" 
          then obtain val where "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue val) \<and> MCon (MTValue x') (memory st) (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTValue 
            by (meson MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
          moreover have "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" 
            using MemLSubPrefL2_specific_imps_general \<open>p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> nonLocChanged22 by blast
          ultimately show "(case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                  | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') m loc2 | MTValue Types \<Rightarrow> False))"
            by auto
        qed
        moreover have "x > 0" using MTValue 
          using zero_less_iff_neq_zero by force
        moreover have "(\<exists>p. accessStore p'' m = Some (MPointer p)) \<or> accessStore p'' m = None" using MTValue samep' 
          using calculation(2) by auto
        ultimately show ?case using MCon.simps(2)[of x "MTValue x'" m p''] by simp
      qed

      have prntMconNew:"MCon (MTArray len' (MTArray x t)) (memory st') prnt"
      proof - 
        have " \<forall>i<len'.
             (case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x t) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x t of MTArray len' arr' \<Rightarrow> MCon (MTArray x t) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
        proof intros
          fix i' assume asm1:"i'<len'"
          then obtain ptr where ptrDef': "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some(MPointer ptr)
                                  " and ptrDef'2:"MCon (MTArray x t) (memory st) ptr"
            using mconPrnt by (metis MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum not_less_zero)

          show "case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x t) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x t of MTArray len' arr' \<Rightarrow> MCon (MTArray x t) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
          proof(cases "i' = i")
            case True
            then show ?thesis 
              using MCondest2 accessL ldef mInStd by force
          next
            case False
            then have "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st')" using ldef 
              by (metis hashesIntSame limitSt nle_le nonLocChanged2 option.distinct(1) ptrDef')
            then have same:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st') =  Some(MPointer ptr)" using ptrDef' by simp
            have notPrnt:"ptr \<noteq> prnt" 
              using MConSubTypes mconPrnt ptrDef' CompMemJustType.simps(2) ptrDef'2 by blast

            have locRule:"\<forall>ct locs ints. CompMemType (memory st) len' (MTArray x t) ct prnt locs \<longrightarrow> locs \<noteq> prnt \<and> hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t ints) \<noteq> l"  
              using BothMConImpsNotCompMemType CompTypeRemainsMCon mconPrnt ldef  ShowLNatDot hash_injective by metis
            have "CompMemType (memory st) len' (MTArray x t) (MTArray x t)  prnt ptr" using ptrDef' asm1 by auto
            then have "MCon (MTArray x t) (memory st') ptr" using ptrDef'2 locRule 
            proof(induction t arbitrary: x ptr len' prnt)
              case (MTArray x11 x12)
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case MTArray x11 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x11 x12) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
               | Some (MPointer loc2) \<Rightarrow> (case MTArray x11 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x11 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume "i''<x"
                then obtain ptr' where ptr'Def:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = Some(MPointer ptr')
                                                \<and> MCon (MTArray x11 x12) (memory st) ptr'" using  MTArray.prems(2)
                  by (metis MConArrayPointers MCon_imps_sub_Mcon  neq0_conv not_less_zero)
                have "ptr \<noteq> prnt" using MTArray.prems by blast
                then have "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems ShowLNatDot hash_injective by blast
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st')" 
                  by (metis less_or_eq_imp_le limitSt nonLocChanged2 option.discI ptr'Def)
                then have same2:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some(MPointer ptr')" using ptr'Def by simp

                have "MCon (MTArray x11 x12) (memory st) ptr'" using ptr'Def by blast
                moreover have "CompMemType (memory st) x (MTArray x11 x12) (MTArray x11 x12) ptr ptr'" using ptr'Def 
                  using \<open>i'' < x\<close> by auto
                moreover have "\<forall>ct locs ints. CompMemType (memory st) x (MTArray x11 x12) ct ptr locs \<longrightarrow> locs \<noteq> ptr \<and> hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t ints) \<noteq> l" 
                  by (metis BothMConImpsNotCompMemType CompTypeRemainsMCon MTArray.prems(1,2,3) compMemTypes_trns)
                ultimately have "MCon (MTArray x11 x12) (memory st') ptr'" using MTArray.IH[of x x11 ptr ptr'] by blast
                then show "(case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case MTArray x11 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x11 x12) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
               | Some (MPointer loc2) \<Rightarrow> (case MTArray x11 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x11 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                  using ptrDef' same2 by auto
              qed

              moreover have xNotZero:"x>0" using MTArray.prems(2) 
                using bot_nat_0.not_eq_extremum by fastforce
              moreover have "(\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None"
              proof(cases "ptr = l")
                case True
                then have " accessStore ptr (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 7 by auto
                then show ?thesis by blast
              next
                case False
                then have pdef:"(\<exists>p. accessStore ptr (memory st) = Some (MPointer p)) \<or> accessStore ptr (memory st) = None" 
                  using MTArray.prems(2) MCon.simps(2)[of x _ "memory st" ptr] xNotZero by simp
                then have "\<not> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt1 limitSt 
                  by (metis (no_types, lifting) MCon_imps_Some MTArray.prems(2) LSubPrefL2_def Not_Sub_More_Specific le_refl option.distinct(1))
                then have "accessStore ptr (memory st) =accessStore ptr (memory st') " using False nonLocChanged2 by simp
                then show ?thesis using pdef by simp
              qed
              ultimately show ?case using MCon.simps(2)[of x "MTArray x11 x12" "memory st'" ptr]  by simp
            next
              case (MTValue x2)
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                 | Some (MValue val) \<Rightarrow> (case MTValue x2 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x2) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTValue x2 of MTArray len' arr' \<Rightarrow> MCon (MTValue x2) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume "i''<x"
                then obtain val where oldDef:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = Some(MValue val)
                                                \<and> MCon (MTValue x2) (memory st) (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using MTValue ptrDef' 
                  by (meson MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
                have "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l " using MTValue ldef ShowLNatDot hash_injective by blast
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st')" 
                  by (metis less_or_eq_imp_le limitSt nonLocChanged2 option.discI oldDef)
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some(MValue val)" using oldDef by simp
                then show "case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                       | Some (MValue val) \<Rightarrow> (case MTValue x2 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x2) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                       | Some (MPointer loc2) \<Rightarrow> (case MTValue x2 of MTArray len' arr' \<Rightarrow> MCon (MTValue x2) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                  using oldDef by auto
              qed
              moreover have xNotZero:"x>0" using MTValue(2) 
                using bot_nat_0.not_eq_extremum by fastforce
              moreover have "(\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None"
              proof(cases "ptr = l")
                case True
                then have " accessStore ptr (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 7 by auto
                then show ?thesis by blast
              next
                case False
                then have pdef:"(\<exists>p. accessStore ptr (memory st) = Some (MPointer p)) \<or> accessStore ptr (memory st) = None" 
                  using MTValue(2) MCon.simps(2)[of x _ "memory st" ptr] xNotZero by simp
                then have "\<not> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt1 limitSt 
                  by (metis (no_types, lifting) MCon_imps_Some MTValue(2) LSubPrefL2_def Not_Sub_More_Specific le_refl option.distinct(1))
                then have "accessStore ptr (memory st) =accessStore ptr (memory st') " using False nonLocChanged2 by simp
                then show ?thesis using pdef by simp
              qed

              ultimately show ?case using MCon.simps(2)[of x "MTValue x2" "memory st'" ptr] by simp
            qed
            then show ?thesis using same asm1 by simp
          qed
        qed

        moreover have "len' > 0" using mconPrnt 
          using ldef by auto
        moreover have "prnt \<noteq> l" using ldef 
          by (metis hash_inequality)
        moreover have "(\<exists>p. accessStore prnt (memory st') = Some (MPointer p)) \<or> accessStore prnt (memory st') = None"
        proof(cases "LSubPrefL2 prnt (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
          case True
          then show ?thesis 
            by (metis LSubPrefL2_def Not_Sub_More_Specific l_not_toploc_orSub ldef)
        next
          case False
          then show ?thesis using nonLocChanged2 calculation mconPrnt by simp
        qed
        ultimately show ?thesis using MCon.simps(2)[of len' "MTArray x t" "memory st'" prnt] mconPrnt  nonLocChanged2 ldef by simp
      qed

      have compmemst':"\<forall>locs lens subTs. CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt 
                            \<and> MCon (MTArray lens subTs) (memory st) locs 
                          \<longrightarrow> CompMemType (memory (st')) lens subTs (MTArray len' arr') locs prnt \<and> CompMemType (m) lens subTs (MTArray len' arr') locs prnt"
      proof intros
        fix locs lens subTs
        assume asm1:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt  \<and> MCon (MTArray lens subTs) (memory st) locs"
        then have asm5:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" by blast
        have asm6:"MCon (MTArray lens subTs) (memory st) locs" using asm1 by blast
        have asm2:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory (st)) = accessStore locs m"
          using nonLocChanged allocateSame by auto
        have mconl'':"MCon (MTArray len subT) (memory st) l''" using  lInfo(5) tParentType  by simp

        have a5:"CompMemType m lens subTs (MTArray len' arr') locs prnt" using cpm2mCompMemTypeOld_imps_CompMemType[OF asm5 asm2 ] asm6 limitSt 
          by (metis (no_types, opaque_lifting) MCon_imps_Some LSubPrefL2_def eq_imp_le Not_Sub_More_Specific not_None_eq)
        then have a10:"CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt \<and> CompMemType m lens subTs (MTArray len' arr') locs prnt" using asm6 
        proof(induction subTs arbitrary: lens locs)
          case (MTArray x11 x12)
          then have "CompMemType m lens (MTArray x11 x12) (MTArray len' arr') locs prnt" using a5 by simp
          then obtain iIn lIn where iInDef:"iIn<lens \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m = Some (MPointer lIn) 
                    \<and> (lIn = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType m x11 x12 (MTArray len' arr') lIn prnt)"
            unfolding CompMemType.simps by blast
          have same2:" accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m =  accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st)" 
            using MConArrayPointers MTArray.prems(2) allocateSame bot_nat_0.not_eq_extremum iInDef le_eq_less_or_eq limitSt nonLocChanged not_less_zero option.discI by metis
          then have mcIn:"MCon (MTArray x11 x12) (memory st) lIn" using same2 iInDef MTArray.prems
            by (metis MCon_imps_sub_Mcon)
          then show ?case
          proof(cases "lIn = prnt")
            case True
            have "prnt \<noteq> l" using ldef 
              by (metis hash_inequality)
            moreover have "MTArray x11 x12 = MTArray len' arr'" using iInDef True 
              by (metis CompMemType_imps_CompMemJustType MConSubTypes \<open>MCon (MTArray x11 x12) (memory st) lIn\<close> lsublocs mconPrnt CompMemJustType.simps(2))
            ultimately show ?thesis using True 
              by (metis MConPtrsMustBeSubLocs NonChangeM'm iInDef lsublocs mInStd same2 CompMemType.simps(2))
          next
            case False
            then have "CompMemType m x11 x12 (MTArray len' arr') lIn prnt" using iInDef by blast
            then have cp:"CompMemType (memory st') x11 x12 (MTArray len' arr') lIn prnt" using MTArray.IH[of x11 lIn] mcIn by blast
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) \<noteq> l" 
              by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc MConSubTypes Memoryvalue.inject(2) iInDef lOrigin lsublocs mcIn mconlOld option.inject same2
                  CompMemJustType.simps(2))
            then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st')" 
              by (simp add: NonChangeM'm mInStd)
            then have "\<exists>i<lens. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer l)
                \<and> (l = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType (memory st') x11 x12 (MTArray len' arr') l prnt)"
              using False cp iInDef by metis
            then show ?thesis unfolding CompMemType.simps(2) 
              using iInDef by blast
          qed
        next
          case (MTValue x2)
          then show ?case 
            using compType by auto
        qed
        then show "CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt" by blast
        show "CompMemType m lens subTs (MTArray len' arr') locs prnt " using a10 by simp
      qed

      then have l''Top'':"CompMemType (memory (st)) len subT (MTArray x t) l'' p''" using  lsublocs3 lsublocs 
        using compMemTypes_trns lsublocs2 by blast

      have l''MConst':"\<forall>locs lens subTs. CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt 
                            \<and> MCon (MTArray lens subTs) (memory st) locs \<and> MCon (MTArray lens subTs) m locs \<longrightarrow> MCon (MTArray lens subTs) (memory st') locs"
      proof intros

        fix locs lens subTs
        assume asm6:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt \<and> MCon (MTArray lens subTs) (memory st) locs \<and> MCon (MTArray lens subTs) m locs "
        then have asm7:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" by simp
        have asm8:"MCon (MTArray lens subTs) (memory st) locs" using asm6 by blast
        have asm9:"MCon (MTArray lens subTs) m locs " using asm6 by blast
        show "MCon (MTArray lens subTs) (memory st') locs "
        proof(cases "locs = prnt")
          case True
          then show ?thesis 
            using MConPtrsMustBeSubLocs2 lsublocs lsublocs3 prntMconNew asm8 asm7 by blast
        next
          case False
          then have cpMemo:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" 
            using asm6 by blast  
          then have asm10:"CompMemType m lens subTs (MTArray len' arr') locs prnt" using compmemst' asm8 by blast
          then have "CompMemType (memory (st')) lens subTs (MTArray len' arr') locs prnt" using compmemst' 
            using asm8 cpMemo by blast
          have "CompMemType m lens subTs (MTArray x t) locs p''" using asm10 compType 
            by (metis allocateSame compMemTypes_trns lOrigin l_not_toploc_orSub lsublocs nonLocChanged CompMemType.simps(2))
          then have "\<forall>locs' loct. CompMemType  m lens subTs loct locs locs' \<and> locs' = p'' \<longrightarrow> loct = (MTArray x t)" using  CompMem_SameLocs_SameSubT  
            using p''mMcon  asm9 asm7  by simp
          then show ?thesis using asm9 p''mMcon ldef lOrigin
          proof(induction subTs arbitrary: lens locs)
            case (MTArray x1 subT)
            have "\<forall>i<lens.
             (case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
            proof intros
              fix i'' assume asm1:"i''<lens"
              then obtain ptr where ptrDef:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 subT) m ptr" using MTArray.prems(2) 
                by (metis MConArrayPointers MconSameTypeSameAccessWithTyping bot_nat_0.not_eq_extremum less_nat_zero_code)

              show "(case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
              proof(cases "ptr = p''")
                case True
                then have sameTp:" (MTArray x1 subT) =  (MTArray x t)" using MTArray.prems ptrDef asm1 by auto 
                then show ?thesis 
                proof(cases "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
                  case True
                  then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" 
                    using accessL mInStd by auto
                  then show ?thesis using sameTp  MCondest2 by fastforce
                next
                  case False
                  then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                    by (simp add: NonChangeM'm mInStd)
                  have "\<forall>locs loct.  CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x t" 
                    using CompMemTypeSameLocsSameType ptrDef 
                    using MTArray.prems(1) asm1 CompMemType.simps(2) by blast
                  moreover have "MCon (MTArray x1 subT) (memory st') ptr" using MTArray.IH[of x1 ptr] MTArray.prems  ptrDef calculation by blast
                  ultimately show ?thesis 
                    by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)
                qed
              next
                case False
                then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems Memoryvalue.inject(2) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 subT) m ptr\<close>  option.inject

                  by (metis l_not_toploc_orSub nonLocChanged22)
                then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                  by (simp add: NonChangeM'm mInStd)
                have "\<forall>locs loct.  CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x t" 
                  using CompMemTypeSameLocsSameType ptrDef 
                  using MTArray.prems(1) asm1 CompMemType.simps(2) by blast
                moreover have "MCon (MTArray x1 subT) (memory st') ptr" using MTArray.IH[of x1 ptr] MTArray.prems  ptrDef calculation by blast
                ultimately show ?thesis 
                  by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)
              qed
            qed
            moreover have "lens > 0" using MTArray by force
            moreover have "(\<exists>p. accessStore locs (memory st') = Some (MPointer p)) \<or> accessStore locs (memory st') = None"
            proof(cases "locs = l")
              case True
              then show ?thesis 
                using accessL mInStd by auto
            next
              case False
              then have "accessStore locs (memory st') = accessStore locs m" 
                by (simp add: NonChangeM'm mInStd)
              then show ?thesis using MTArray(3) calculation(2) by simp
            qed

            ultimately show ?case using MCon.simps(2)[of lens "MTArray x1 subT" "memory st'" locs] by simp
          next
            case (MTValue x')
            have "\<forall>i<lens.
             (case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False))"
            proof(intros)
              fix i'' assume asm1:"i''<lens"
              then obtain ptr where ptrDef:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some(MValue ptr) \<and> MCon (MTValue x') m (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                using MCon_sub_MTVal_imps_val MTValue.prems(2) MconSameTypeSameAccessWithTyping by presburger
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" 
                using allocateSame lOrigin l_not_toploc_orSub nonLocChanged by fastforce
              then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                by (simp add: NonChangeM'm mInStd)
              then show "case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                using ptrDef 
                by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) MCon.simps(1))
            qed
            moreover have "lens > 0" using MTValue by fastforce
            moreover have "(\<exists>p. accessStore locs (memory st') = Some (MPointer p)) \<or> accessStore locs (memory st') = None"
            proof(cases "locs = l")
              case True
              then show ?thesis 
                using accessL mInStd by auto
            next
              case False
              then have "accessStore locs (memory st') = accessStore locs m" 
                by (simp add: NonChangeM'm mInStd)
              then show ?thesis using MTValue(2) calculation(2) by simp
            qed
            ultimately show ?case using MCon.simps(2)[of lens "MTValue x'" "memory st'" locs] by simp
          qed
        qed
      qed

      have aaa:"\<forall>sT sL. CompMemType (memory (st)) len subT sT l'' sL \<and> sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray len subT) (memory (st)) l''
                            \<longrightarrow>  CompMemType m len subT sT l'' sL"
      proof(intros)
        fix sT sL
        assume asm1: " CompMemType (memory st) len subT sT l'' sL \<and> sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray len subT) (memory (st)) l''"
        then show " CompMemType m len subT sT l'' sL"
        proof(induction subT arbitrary: len l'')
          case (MTArray x1 subT)
          obtain i'' ptr where i''Def:"(i''<len \<and> accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) \<and> (ptr = sL \<and> MTArray x1 subT = sT \<or> CompMemType (memory st) x1 subT sT ptr sL))"
            using MTArray.prems unfolding CompMemType.simps by auto
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m" using MTArray.prems 
            by (metis Read_Show_nat'_id antisym_conv1 limitSt nonLocChanged22 option.distinct(1) readLintNotEqual)

          then show ?case 
          proof(cases "ptr = sL")
            case True
            then have "MTArray x1 subT = sT" using i''Def MTArray.prems 
              by (meson BothMConImpsNotCompMemType CompTypeRemainsMCon MCon_imps_sub_Mcon)
            then show ?thesis using True i''Def 
              using \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> by force
          next
            case False
            then have "CompMemType m x1 subT sT ptr sL" using MTArray.IH[of x1 ptr] using i''Def MTArray.prems by force
            then show ?thesis 
              by (metis \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> i''Def CompMemType.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case 
            by auto
        qed
      qed

      have l''Sublocs:"\<forall>sT sL. CompMemType (memory (st)) len subT sT l'' sL \<longrightarrow> MCon sT (memory st') sL"
      proof intros
        fix sT sL
        assume asm1: "CompMemType (memory (st)) len subT sT l'' sL"
        show "MCon sT (memory st') sL"
        proof(cases "CompMemType (memory st') len subT sT l'' sL")
          case True
          then show ?thesis using asm1 l''MConst' CompTypeRemainsMCon 
            using l''mMcon lsublocs lsublocs3 prntMconNew t7 by blast
        next
          case False
          have asm5:"\<forall>locs loct. CompMemType  m len subT loct l'' locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x t)" using comptype2 CompMem_SameLocs_SameSubT  
            using p''mMcon l''mMcon by blast
          then have notTop:"sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using bb asm1 by auto
          then have cpm:"CompMemType m len subT sT l'' sL" using aaa 
            using asm1 t7 by blast        
          then have comps:"CompMemType m x t sT p'' sL \<or> sL = p'' \<and> (MTArray x t) = sT" using False p''mMcon asm5
          proof(induction subT arbitrary:len l'')
            case (MTArray x1 subT)
            have "\<exists>i<len. \<exists>l. accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m = Some (MPointer l) \<and> (l = sL \<and> MTArray x1 subT = sT \<or> CompMemType m x1 subT sT l sL)" 
              using MTArray.prems(1) unfolding CompMemType.simps(2) by blast
            then obtain i'' ptr where ptrDef:"i''<len \<and>  accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> (ptr = sL \<and> MTArray x1 subT = sT \<or> CompMemType m x1 subT sT ptr sL)"
              by auto
            have asm4:"(\<forall>i<len. \<exists>l. accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') \<noteq> Some (MPointer l) \<or> (l \<noteq> sL \<or> MTArray x1 subT \<noteq> sT \<and> \<not>CompMemType (memory st') x1 subT sT l sL))" 
              using MTArray.prems(2) unfolding CompMemType.simps(2) by blast
            then show ?case 
            proof(cases "(hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
              case t1:True
              then have ptrP'':"ptr = p''" using ptrDef 
                using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
              then have sameType: "MTArray x1 subT = MTArray x t" using MTArray.prems(4) ptrDef
                by (metis MTArray.prems(4) CompMemType.simps(2))
              then show ?thesis 
              proof(cases "ptr = sL")
                case True
                then show ?thesis using ptrP'' 
                  using comptype2 cpm l''mMcon CompMem_SameLocs_SameSubT by blast
              next
                case False
                then have "CompMemType m x1 subT sT ptr sL" using ptrDef by simp
                then show ?thesis using False ptrP'' sameType by simp
              qed
            next
              case False
              then have saemAccess:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                using NonChangeM'm mInStd by auto
              then have neg1:"(ptr \<noteq> sL \<or> MTArray x1 subT \<noteq> sT \<and> \<not>CompMemType (memory st') x1 subT sT ptr sL)" using ptrDef  MTArray.prems(2) by force
              then have "\<not>CompMemType (memory st') x1 subT sT ptr sL" 
                using MTArray.prems(2) ptrDef saemAccess by fastforce
              moreover have "CompMemType m x1 subT sT ptr sL" using ptrDef neg1 by blast
              moreover have "\<forall>locs loct. CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x t" 
                using MTArray.prems(4) ptrDef by auto
              ultimately show ?thesis using MTArray.IH[of x1 ptr] 
                using p''mMcon by fastforce
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed

          have notTop2:"sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using notTop by simp
          then have "MCon sT m sL" 
            using CompTypeRemainsMCon l''mMcon cpm by blast
          then show ?thesis 
            using notTop2 comps 
          proof(induction sT arbitrary:sL)
            case (MTArray x1 sT)
            then show ?case 
            proof(cases sT)
              case mta:(MTArray x11 x12)
              have "\<forall>i<x1.
                  (case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
                    | Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                    | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof(intros)
                fix i'' assume asm3: "i''<x1"
                then obtain ptr where ptrDef:" accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x11 x12) m ptr" 
                  using MTArray.prems(1)  MCon.simps(2)[of x1 sT m sL] MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum 
                  by (metis mta)

                show "case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False 
                      | Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                      | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False)"
                proof(cases "ptr =  p''")
                  case True
                  then show ?thesis 
                    by (metis CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MConPtrsMustBeSubLocs MTArray.prems(1,3) TypedMemSubPrefOneWay asm3 mta p''mMcon ptrDef
                        TypedMemSubPrefPtrs.simps(2))
                next
                  case False
                  then have "(hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef lsublocs ptrDef lOrigin 
                    using l_not_toploc_orSub nonLocChanged22 by fastforce

                  then have sameAccess:"accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                    by (simp add: NonChangeM'm mInStd)
                  then have "ptr \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc MConSubTypes MCondest MTArray.prems(3) mta ptrDef CompMemJustType.simps(2))
                  then have "MCon sT (memory st') ptr" using ptrDef MTArray.IH[of ptr] mta MTArray.prems(3) asm3 
                    by (metis MTypes.inject(1) compMemTypes_trns CompMemType.simps(2))
                  then show ?thesis using MCon.simps(2)[of x1 "MTArray x11 x12" "memory st'" sL] mta ptrDef sameAccess by simp
                qed
              qed
              moreover have "x1>0" using MTArray.prems(1) unfolding MCon.simps by presburger
              moreover have "(\<exists>p. accessStore sL (memory st') = Some (MPointer p)) \<or> accessStore sL (memory st') = None" 
                using MTArray.prems(1) calculation(2)  
                by (metis NonChangeM'm accessL mInStd MCon.simps(2))
              ultimately show ?thesis using MCon.simps(2)[of x1 sT "memory st'" sL] by simp
            next
              case (MTValue x2)
              have "\<forall>i<x1.
             (case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume asm6:"i''<x1"
                then obtain ptr where ptrDef:" accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MValue ptr) \<and> MCon (MTValue x2) m (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                  using MTArray.prems(1)  MCon.simps(2)[of x1 sT m sL]  MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum 
                  by (metis MCon_sub_MTVal_imps_val MTValue)
                then have "(hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" 
                  using allocateSame lOrigin l_not_toploc_orSub nonLocChanged by fastforce
                then have "accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
                  by (simp add: NonChangeM'm mInStd)

                have "MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using asm6 MTValue 
                  using \<open>accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef by fastforce
                then show "case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False 
                          | Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                          | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False)" using asm6 MTValue 
                  by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) \<open>accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)

              qed
              moreover have "x1>0" using MTArray(2) MCon.simps(2) 
                using zero_less_iff_neq_zero by fastforce
              moreover have "(\<exists>p. accessStore sL (memory st') = Some (MPointer p)) \<or> accessStore sL (memory st') = None" using MTArray.prems(1) calculation(2)  
                by (metis NonChangeM'm accessL mInStd MCon.simps(2))
              ultimately show ?thesis using MCon.simps(2)[of x1 sT "memory st'" sL] by simp
            qed      
          next
            case (MTValue x)
            then have "accessStore sL m = accessStore sL (memory st')" 
              by (metis MConAccessSame.simps(1) Memoryvalue.distinct(1) NonChangeM'm SameMCon_imps_MConAccessSame lOrigin l_not_toploc_orSub mInStd nonLocChanged22 option.inject)
            then show ?case using MTValue by simp
          qed
        qed
      qed

      have mcf:"\<forall>x11 x12 x3. CompMemType (memory st) x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) (memory st) x3
            \<longrightarrow> CompMemType m x11 x12 (MTArray len subT) x3 l''"
      proof(intros)
        fix x11 x12 x3
        assume asm3:"CompMemType (memory st) x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) (memory st) x3"
        then show "CompMemType m x11 x12 (MTArray len subT) x3 l''"
        proof(induction x12 arbitrary: x11 x3)
          case (MTArray x1 x12)
          then obtain i'' ptr where ptrDef:"(i''<x11 \<and> accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) \<and> (ptr = l'' \<and> MTArray x1 x12 = MTArray len subT \<or> CompMemType (memory st) x1 x12 (MTArray len subT) ptr l''))" 
            unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "ptr = l''")
            case True
            then show ?thesis 
              by (metis MTArray.prems allocateSame limitSt nle_le nonLocChanged option.discI ptrDef CompMemType.simps(2) CompMem_SameLocs_SameSubT)
          next
            case False
            then have " CompMemType (memory st) x1 x12 (MTArray len subT) ptr l''" using ptrDef by simp
            moreover have "MCon (MTArray x1 x12) (memory st) ptr" 
              using MCon_imps_sub_Mcon MTArray.prems ptrDef by blast
            ultimately show ?thesis using MTArray.IH[of x1 ptr] 
              by (metis limitSt nat_le_linear nonLocChanged22 not_Some_eq ptrDef CompMemType.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have mcg:"\<forall>x11 x12 x3. CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3 
            \<longrightarrow> CompMemType (memory st') x11 x12 (MTArray len subT) x3 l''"
      proof(intros)
        fix x11 x12 x3
        assume asm3:" CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3 "
        then have asm6:"\<forall>locs loct. CompMemType  m x11 x12 loct x3 locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x t)" 
          using CompMemTypeSameLocsSameType asm3  by (meson compMemTypes_trns comptype2)
        show "CompMemType (memory st') x11 x12 (MTArray len subT) x3 l''" using asm3 asm6
        proof(induction x12 arbitrary: x11 x3)
          case (MTArray x1 x12)
          then obtain i'' ptr where ptrDef:"(i''<x11 \<and> accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> (ptr = l'' \<and> MTArray x1 x12 = MTArray len subT \<or> CompMemType m x1 x12 (MTArray len subT) ptr l''))" 
            unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "ptr = p''")
            case True
            then have sameType:"(MTArray x1 x12) = MTArray x t" using MTArray.prems ptrDef 
              using asm3 CompMemType.simps(2) by blast 
            then show ?thesis using True 
              using BothMConImpsNotCompMemType compMemTypes_trns comptype2 p''mMcon ptrDef by blast
          next
            case False
            then have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems 
              using lOrigin l_not_toploc_orSub nonLocChanged22 ptrDef by force
            then have sameAc:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
              by (simp add: NonChangeM'm mInStd)
            have g1:"\<forall>locs loct. CompMemType m x1 x12 loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x t " using MTArray.prems ptrDef 
              using asm3 CompMemType.simps(2) by blast
            then show ?thesis 
            proof(cases "ptr = l''")
              case True
              then show ?thesis using sameAc False ptrDef 
                by (metis BothMConImpsNotCompMemType MCon_imps_sub_Mcon MTArray.prems(1) l''mMcon CompMemType.simps(2))
            next
              case False
              then have "CompMemType (memory st') x1 x12 (MTArray len subT) ptr l''" using MTArray.IH[of x1 ptr] ptrDef sameAc g1 ptrDef 
                using MCon_imps_sub_Mcon MTArray.prems(1) by blast
              then show ?thesis 
                using ptrDef sameAc by auto
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have mconParents:"\<forall>x11 x12 x3. CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3
            \<longrightarrow> MCon (MTArray x11 x12) (memory st') x3"
      proof intros
        fix x11 x12 x3
        assume asm3:"CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3"
        then have asm4: "CompMemType m x11 x12 (MTArray len subT) x3 l''" by blast
        then have asm6:"\<forall>locs loct. CompMemType  m x11 x12 loct x3 locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x t)" 

          using CompMemTypeSameLocsSameType asm3  
          by (meson compMemTypes_trns comptype2)
        have asm5:"MCon (MTArray x11 x12) m x3" using asm3 by blast
        then show "MCon (MTArray x11 x12) (memory st') x3" using asm6 
        proof(induction x12 arbitrary:x11 x3)
          case (MTArray x1 x12)
          have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
          proof intros
            fix i'' assume asm3:"i''<x11"
            then obtain ptr where ptrDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 x12) m ptr" using MTArray.prems(1) 
              by (metis MConArrayPointers MCon_imps_sub_Mcon less_nat_zero_code neq0_conv)
            show "(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
            proof(cases "ptr = p''")
              case True
              then have sameType:"(MTArray x1 x12) = MTArray x t" using MTArray.prems ptrDef 
                using asm3 CompMemType.simps(2) by blast 

              show ?thesis 
              proof(cases "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
                case True
                then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" 
                  using accessL mInStd by auto
                then show ?thesis using sameType 
                  using MCondest2 by auto
              next
                case False
                then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m" 
                  using NonChangeM'm mInStd by auto
                then show ?thesis using False 
                  by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) True l''Sublocs ptrDef sameType t10)
              qed

            next
              case False
              then have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems 
                using lOrigin l_not_toploc_orSub nonLocChanged22 ptrDef by force
              then have sameAc:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                by (simp add: NonChangeM'm mInStd)
              have "\<forall>locs loct. CompMemType m x1 x12 loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x t " using MTArray.prems ptrDef 
                using asm3 CompMemType.simps(2) by blast
              then have "MCon (MTArray x1 x12) (memory st') ptr" using MTArray.IH[of x1 ptr] ptrDef by blast
              then show ?thesis using sameAc ptrDef asm3 
                by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
            qed
          qed
          moreover have "x11 > 0" using MTArray.prems unfolding MCon.simps by force
          moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" 
            using MTArray.prems unfolding MCon.simps 
            by (metis NonChangeM'm accessL mInStd)
          ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "memory st'" x3] by auto
        next
          case (MTValue x')
          have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False))"
          proof intros
            fix i'' assume asm3:"i''<x11"
            then obtain val where valdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some(MValue val) \<and> MCon (MTValue x') m (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using MTValue(1) 
              using MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val by presburger
            moreover have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
              by (metis Memoryvalue.distinct(1) NonChangeM'm lOrigin l_not_toploc_orSub mInStd nonLocChanged22 option.inject valdef)
            ultimately show "case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)" by auto
          qed
          moreover have "x11 > 0" using MTValue unfolding MCon.simps by presburger
          moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" using MTValue unfolding MCon.simps 
            by (metis NonChangeM'm accessL mInStd)
          ultimately show ?case using MCon.simps(2)[of x11 "MTValue x'" "memory st'" x3] by simp
        qed
      qed

      have nonChangesSublocs:"\<forall>locs tlen tTp locs' tlen' tTp'. \<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt
                                              \<and> CompMemType (memory (st)) tlen tTp tTp' locs locs'
                                              \<and> MCon (MTArray tlen tTp) (memory st) locs  \<and> locs \<noteq> prnt
              \<longrightarrow>  CompMemType (memory st') tlen tTp tTp' locs locs'"
      proof(intros)
        fix locs tlen tTp locs' tlen' tTp'
        assume *:"\<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt \<and> CompMemType (memory st) tlen tTp tTp' locs locs' \<and> MCon (MTArray tlen tTp) (memory st) locs \<and> locs \<noteq> prnt"
        then have asm3:"\<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt" by blast
        have asm4:"CompMemType (memory st) tlen tTp tTp' locs locs'" using * by blast
        have asm5:"MCon (MTArray tlen tTp) (memory st) locs" using * by blast
        have asm6:"locs \<noteq> prnt" using * by blast 
        show "CompMemType (memory st') tlen tTp tTp' locs locs' " using asm3 asm4 asm5 asm6
        proof(induction tTp arbitrary:tlen locs)
          case (MTArray x1 tTp)
          have neg:"(\<forall>i<tlen. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> (l \<noteq> prnt \<and> \<not>TypedMemSubPrefPtrs (memory st) x1 tTp l prnt))"
            using MTArray.prems(1,3)  MConArrayPointers less_nat_zero_code neq0_conv unfolding TypedMemSubPrefPtrs.simps by metis
          have "\<exists>i<tlen. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> (l = locs' \<and> MTArray x1 tTp = tTp' \<or> CompMemType (memory st) x1 tTp tTp' l locs')" 
            using MTArray.prems(2) unfolding CompMemType.simps by auto
          then obtain i'' ptr where ptrDef:"i''<tlen \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) 
                                    \<and> (ptr = locs' \<and> MTArray x1 tTp = tTp' \<or> CompMemType (memory st) x1 tTp tTp' ptr locs')" by blast
          then show ?case 
          proof(cases "ptr = locs'")
            case True
            then have sameT:"MTArray x1 tTp = tTp'" using ptrDef 
              using BothMConImpsNotCompMemType CompTypeRemainsMCon MCon_imps_sub_Mcon MTArray.prems(3) by blast
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTArray.prems(4) ptrDef ShowLNatDot hash_injective by blast
            then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
              by (metis limitSt nat_le_linear nonLocChanged2 option.distinct(1))
            then show ?thesis using ptrDef True sameT using CompMemType.simps(2)[of "memory st'" tlen x1 tTp tTp' locs locs'] by metis
          next
            case False
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTArray.prems(4) ptrDef ShowLNatDot hash_injective by blast
            then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
              by (metis limitSt nat_le_linear nonLocChanged2 option.distinct(1))
            then have "CompMemType (memory st) x1 tTp tTp' ptr locs'" using ptrDef False by simp
            have "ptr \<noteq> prnt" using neg ptrDef by auto
            then have "CompMemType (memory st') x1 tTp tTp' ptr locs'" using MTArray.IH[of x1 ptr] 
              by (metis MCon_imps_sub_Mcon MTArray.prems(1,3) \<open>CompMemType (memory st) x1 tTp tTp' ptr locs'\<close> ptrDef TypedMemSubPrefPtrs.simps(2))
            then show ?thesis using CompMemType.simps(2)[of "memory st'" tlen x1 tTp' tTp' locs locs'] ptrDef False sameAccess by auto
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed
      have BT3:"\<forall>locs tp x t. \<not>LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> \<not>CompMemType (memory (st')) x t tp (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) locs 
                                                                    \<and> \<not>TypedMemSubPrefPtrs (memory (st')) x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) locs" 
        using CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def SubPtrs_top selfPoint2 by blast

      have mconL''New:"MCon (MTArray len subT) (memory st') l''" using lsublocs3
      proof(cases "prnt = l''")
        case True
        then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
          using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
          using BothMConImpsNotCompMemType t7 by blast
        then have sameTypes:"len = len' \<and> arr' = subT " using lsublocs3 by simp
        then show ?thesis using prntMconNew True 
          using lsublocs by blast
      next
        case False
        then have "CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
        then have a:"CompMemType (memory (st')) len subT (MTArray len' (MTArray x t)) l'' prnt" using compmemst'  lsublocs  
          using t7 by blast
        then show ?thesis using False l''MConst' t7  
          using \<open>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt\<close> l''mMcon by blast
      qed

      show ?thesis unfolding TypeSafe_def StateInvariant_def
      proof intros 
        show "AddressTypes (accounts st')" using 2(1) 7 unfolding TypeSafe_def by simp
      next 
        show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
        then show "compPointers (stack st')  (denvalue env)"  using sameStack  sameStorage by simp
      next 
        show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
      next 
        show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "balanceTypes (accounts st')" using 7 using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
          using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have **:"toploc (stack st) = toploc (stack st')" using 7 unfolding updateStore_def by auto
        show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
        proof intros

          fix tloc loc 
          assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
          then show "accessStore loc (stack st') = None" using *  
            by (simp add: sameStack)
        next 
          fix loc y 
          assume h1:" accessStore loc (stack st') = Some y"
          then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
            by (metis sameStack)
        qed
      next 
        show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
      next
        have a10:"toploc (snd (allocate (memory st))) = toploc m" 
          using cpm2mTopLocSame[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m] 7(4) mInStd unfolding cpm2m_def by fastforce
        then have a12:"toploc m = toploc m'" using 7(5) unfolding updateStore_def by auto
        have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
        proof intros
          fix tloc loc 
          assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have b20:"toploc (memory st) \<le> tloc" using a10 tloc a12 
            using mInStd by force

          then show "accessStore loc (memory st') = None " 
            by (metis (no_types, lifting)  LSubPrefL2_def MemLSubPrefTransitive NonChangeM'm \<open>\<exists>x. accessStore l (memory st) = Some x\<close> a10 a12 allocateSame antisym_conv2 b10 hash_inequality
                hash_suffixes_associative hashesIntSame limitSt mInStd nonLocChanged option.discI order_less_le_trans tloc)
        next 
          fix loc y 
          assume "accessStore loc (memory st') = Some y "
          then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
            by (metis NonChangeM'm \<open>\<exists>x. accessStore l (memory st) = Some x\<close> a10 a12 allocateSameAccess limitSt1 mInStd nonLocChanged order_less_trans tloc)
        qed
      next 
        show " typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
          unfolding typeCompat_def
        proof intros
          fix tLook lLook
          assume inDen:" (tLook, lLook) |\<in>| fmran (denvalue env)"
          show " case lLook of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tLook of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tLook of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case tLook of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tLook of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tLook of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
          proof(cases lLook)
            case (Stackloc x1)
            then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack nonChangedStack by fastforce
            then show ?thesis 
            proof(cases "a")
              case (KValue x1)
              then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack nonChangedStack unfolding TypeSafe_def typeCompat_def
                by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
            next
              case (KCDptr x2)
              then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack nonChangedStack unfolding TypeSafe_def  typeCompat_def
                by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
            next
              case (KMemptr x3)
              then have "\<exists>struct. tLook = Memory struct" using Stackloc adef  inDen Stackloc 2(1) KMemptr sameStack unfolding TypeSafe_def typeCompat_def  by (cases tLook;force+) 
              then obtain struct where structdef:"tLook = Memory struct" by blast

              then have mcOld:"MCon struct (memory st) x3" using 2(1) unfolding TypeSafe_def typeCompat_def
                using Stackloc adef inDen KMemptr sameStack by (auto split:Type.splits Denvalue.splits Stackvalue.splits option.splits)
              then have mcM:"MCon struct m x3" using PreExistMconNotChangeByToploc  limitSt limitSt1 nonLocChanged22 
                by auto

              then have ptrs:"(\<forall>dloc1. (if x3 = l'' then struct = tParent
                           else case struct of
                                MTArray len arr \<Rightarrow>
                                  (case tParent of
                                  MTArray len2 arr2 \<Rightarrow>
                                    if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' x3 then CompMemType (memory st) len2 arr2 (MTArray len arr) l'' x3
                                    else if TypedMemSubPrefPtrs (memory st) len arr x3 l'' then CompMemType (memory st) len arr (MTArray len2 arr2) x3 l''
                                         else if TypedMemSubPrefPtrs (memory st) len arr x3 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                                              then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len arr dt x3 dloc1 else True
                                  | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr x3 l'' then CompMemType (memory st) len arr (MTValue val2) x3 l'' else True)
                                | MTValue val \<Rightarrow>
                                    (case tParent of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' x3 then CompMemType (memory st) len2 arr2 (MTValue val) l'' x3 else True
                                    | MTValue val2 \<Rightarrow> True)))"  
                using 2(1) unfolding TypeSafe_def compMemPtrs_def 
                using inDen lInfo Stackloc KMemptr structdef adef sameStack by auto

              have "MCon struct (memory st') x3"
              proof(cases "x3 = l''")
                case True
                then have "struct = tParent" using ptrs by simp
                then have i1:"MCon (MTArray len subT) (memory st) l''" using True tParentType mcOld by simp
                then have "MCon (MTArray len subT) (memory st') l''" using lsublocs3
                proof(cases "prnt = l''")
                  case True
                  then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
                    using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
                    using BothMConImpsNotCompMemType t7 by blast
                  then have sameTypes:"len = len' \<and> arr' = subT " using lsublocs3 by simp
                  then show ?thesis using prntMconNew True 
                    using lsublocs by blast
                next
                  case False
                  then have "CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" using lsublocs3 True by simp
                  then have a:"CompMemType (memory (st')) len subT (MTArray len' (MTArray x t)) l'' prnt" using compmemst'  lsublocs  
                    using t7 by blast
                  then show ?thesis using i1 False l''MConst' t7  
                    using \<open>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt\<close> l''mMcon by blast
                qed
                then show ?thesis using lOrigin mconlOld lInfo True
                  using \<open>struct = tParent\<close> tParentType by auto
              next
                case notSame:False
                then show ?thesis 
                proof(cases "struct")
                  case mta4:(MTArray x11 x12)
                  then show ?thesis 
                  proof(cases tParent)
                    case mta5:(MTArray x11' x12')
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' x3")
                      case True
                      then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' x3" using ptrs notSame mta4 mta5 tParentType by simp
                      then have "MCon (MTArray x11 x12) (memory st') x3" using l''Sublocs by blast
                      then show ?thesis using mta4 by auto
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 x3 l''")
                        case True
                        then have " CompMemType (memory st) x11 x12 (MTArray len subT) x3 l''" using ptrs notSame tParentType mta4 mta5 f2 by simp
                        then show ?thesis using mconParents mcf 
                          using mcM mcOld mta4 by blast
                      next
                        case f3:False
                        then have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt" using lsublocs3 
                          using CompMemType_imps_TypedMemSubPrefPtrs by auto

                        then show ?thesis
                        proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 x3 prnt")
                          case True
                          then have "\<exists>dt. CompMemType (memory st) len subT dt l'' prnt \<and> CompMemType (memory st) x11 x12 dt x3 prnt" 
                            using ptrs notSame tParentType mta4 mta5 f2 f3 
                            using \<open>TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt\<close> by auto
                          then obtain dt where dtDef:"CompMemType (memory st) len subT dt l'' prnt \<and> CompMemType (memory st) x11 x12 dt x3 prnt" by blast
                          then have "CompMemType (memory st') len subT dt l'' prnt" 
                            using CompMemTypeSameLocsSameType True compmemst' f3 lInfo(6) t7 tParentType 
                             lsublocs3 by blast 
                          have "CompMemType (memory st') x11 x12 dt x3 prnt" using dtDef compmemst' 
                            using CompMemTypeSameLocsSameType True f3 lsublocs3 mcOld mta4 t7 by blast
                          then show ?thesis using l''MConst' 
                            using CompMemTypeSameLocsSameType True dtDef f3 lsublocs3 mcM mcOld mta4 t7 by blast
                        next
                          case f4:False
                          then have sameAccess:"accessStore x3 (memory st) = accessStore x3 m "  
                            using MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt nonLocChanged22
                            by (metis KMemptr Stackloc \<open>\<And>thesis. (\<And>struct. tLook = Memory struct \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> adef inDen sameStack stackDenvalLimits)
                          have notx3:"x3 \<noteq> prnt" 
                            using \<open>TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt\<close> f2 notSame by auto

                          have g1:"MCon (MTArray x11 x12) (memory st) x3" using mta4 
                            using mcOld by auto
                          have g2:"MCon (MTArray x11 x12) m x3" using mta4 mcM by simp
                          have "MCon (MTArray x11 x12) (memory st') x3" using notx3 g1 g2 f4
                          proof(induction x12 arbitrary: x11 x3)
                            case (MTArray x1 x12)
                            have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                            proof (intros)
                              fix i'' assume asm3:"i''<x11"
                              then obtain ptr where valDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some (MPointer ptr) \<and> MCon (MTArray x1 x12) m ptr" 
                                by (metis MConArrayPointers MCon_imps_sub_Mcon MTArray.prems(3) bot_nat_0.not_eq_extremum not_less_zero)

                              have g6:"(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef 
                              proof -
                                obtain nn :: "MTypes \<Rightarrow> nat \<Rightarrow> String.literal \<Rightarrow> String.literal \<Rightarrow> nat" where
                                  f1: "\<forall>x0 x1b x2 x3b. (\<exists>v4<x1b. TypedMemSubPref x3b (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t v4)) x0 \<or> x3b = hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t v4)) = (nn x0 x1b x2 x3b < x1b \<and> (TypedMemSubPref x3b (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t (nn x0 x1b x2 x3b))) x0 \<or> x3b = hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t (nn x0 x1b x2 x3b))))"
                                  by moura
                                obtain ll :: "String.literal \<Rightarrow> String.literal \<Rightarrow> String.literal" where
                                  "\<forall>x0 x1b. (\<exists>v2. x1b = hash x0 v2) = (x1b = hash x0 (ll x0 x1b))"
                                  by moura
                                then have f2: "\<forall>l la. (\<not> LSubPrefL2 l la \<or> l = hash la (ll la l) \<or> l = la) \<and> (LSubPrefL2 l la \<or> (\<forall>lb. l \<noteq> hash la lb) \<and> l \<noteq> la)"
                                  using LSubPrefL2_def by blast
                                then have "LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
                                  by blast
                                then show ?thesis
                                  using f2 f1 by (smt (z3) MTArray.prems(1) MemLSubPrefL2_specific_imps_general TypedStoSubPref.simps(1) Mutual_NonSub_SpecificNonSub hash_inequality hash_never_equal_sufix hash_suffixes_associative ldef TypedMemSubPref.simps(2) stoTypedPrefix_imp_SubPref typedPrefix_imp_SubPref)
                              qed
                              then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m)" 
                                by (simp add: NonChangeM'm mInStd)
                              moreover have "ptr \<noteq> prnt" using MTArray.prems(4) valDef 
                                by (metis asm3 bb calculation lsublocs3 nonLocChanged22 selfPoint2 TypedMemSubPrefPtrs.simps(2) t8)
                              moreover have "\<not> TypedMemSubPrefPtrs (memory st) x1 x12 ptr prnt" using MTArray.prems(4) valDef 
                                using MTArray.prems(2) asm3 calculation(1) g6 limitSt nonLocChanged2 by fastforce
                              moreover have " MCon (MTArray x1 x12) (memory st) ptr" using MTArray.prems(2) valDef 
                                by (metis (mono_tags, lifting) MConArrayPointers MconSameTypeSameAccessWithTyping asm3 limitSt nat_le_linear neq0_conv nonLocChanged22 not_less_zero option.discI)
                              ultimately have "MCon (MTArray x1 x12) (memory st') ptr" 
                                using MTArray.IH[of ptr x1] g6 valDef by blast

                              then show " (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                                            | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                                            | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                                by (simp add: \<open>accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> valDef)
                            qed
                            moreover have "x11>0" using MTArray.prems(3) unfolding MCon.simps by presburger
                            moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None"
                              using MTArray.prems(3) unfolding MCon.simps 
                              using NonChangeM'm accessL calculation(2) mInStd by auto
                            ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "(memory st')" x3] by auto
                          next
                            case (MTValue x)
                            have "\<forall>i<x11.
                                   (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                                    | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                                    | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                            proof(intros)
                              fix i'' assume asm3:"i''<x11"
                              then obtain val where valDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some (MValue val) \<and> MCon (MTValue x) m (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                                using MTValue.prems(3) MCon_sub_MTVal_imps_val 
                                by (meson MCon_imps_sub_Mcon)

                              have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTValue.prems(1) 
                                  Memoryvalue.distinct(1)  lOrigin l_not_toploc_orSub nonLocChanged22 option.inject
                                using valDef by fastforce
                              then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m)" 
                                by (simp add: NonChangeM'm mInStd)
                              then show "(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                                    | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                                    | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                                using valDef by auto
                            qed
                            moreover have "x11 > 0" using MTValue(3) unfolding MCon.simps by presburger
                            moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" 
                              using MTValue(3) unfolding MCon.simps using calculation(2) 
                              by (metis NonChangeM'm accessL mInStd)
                            ultimately show ?case  using MCon.simps(2)[of x11 "MTValue x" "memory st'" x3] by simp
                          qed
                          then show ?thesis using mta4 by simp
                        qed
                      qed
                    qed
                  next
                    case (MTValue x2)
                    then show ?thesis using tParentType by simp
                  qed
                next
                  case (MTValue x2)
                  then show ?thesis using ptrs 
                    by (metis (lifting) Memoryvalue.simps(6) NonChangeM'm Option.option.simps(5) lOrigin mInStd mcM mcOld MCon.simps(1))
                qed
              qed

              then show ?thesis  using structdef KMemptr Stackloc adef  inDen Stackloc 2(1) unfolding TypeSafe_def  typeCompat_def by simp

            next
              case (KStoptr x4)  
              then show ?thesis using Stackloc adef sameStorage  inDen Stackloc KStoptr 2(1) nonChangedStack sameStack unfolding TypeSafe_def  typeCompat_def
                apply(cases tLook) by fastforce+
            qed

          next
            case (Storeloc x2)
            then show ?thesis using sameStorage inDen 2(1) unfolding TypeSafe_def typeCompat_def by (cases tLook; force)
          qed
        qed
        then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd" using sameStack by simp
      next
        have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast

        have isPrntTypeSame:"\<forall>tp1 l1 stl1. (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1)
                  \<and> stl1 = prnt \<longrightarrow> tp1 = (MTArray len' arr')"
        proof intros
          fix tp1 l1 stl1 
          assume asm3:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> stl1 = prnt"
          have "\<forall>dloc1. (if stl1 = l'' then tp1 = MTArray len subT
        else case tp1 of
             MTArray len' arr' \<Rightarrow>
               (case MTArray len subT of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case MTArray len subT of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" 
            using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def  by fastforce
          then have asm5:"\<forall>dloc1. (if stl1 = l'' then tp1 = MTArray len subT
                      else case tp1 of
                           MTArray len' arr' \<Rightarrow>
                               if TypedMemSubPrefPtrs (memory st) len subT l'' stl1 then CompMemType (memory st) len subT (MTArray len' arr') l'' stl1
                               else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len subT) stl1 l''
                                    else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len subT l'' dloc1
                                         then \<exists>dt. CompMemType (memory st) len subT dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
                           | MTValue val \<Rightarrow>
                               if TypedMemSubPrefPtrs (memory st) len subT l'' stl1 then CompMemType (memory st) len subT (MTValue val) l'' stl1 else True )" 
            by (auto split:MTypes.splits)
          show "tp1 = MTArray len' arr'"
          proof(cases "stl1 = l''")
            case True
            then have "l'' = prnt" using asm3 by simp
            then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
              using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
              using BothMConImpsNotCompMemType t7 by blast
            then have " len = len' \<and> arr' = subT" using lsublocs3 by simp
            then show ?thesis using True asm5 by simp
          next
            case notSame:False
            then have lNotp:"l'' \<noteq> prnt" using notSame asm3 by simp
            then have g1:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by auto
            then have g5:"TypedMemSubPrefPtrs (memory st) len subT l'' stl1" using g1 asm3 CompMemType_imps_TypedMemSubPrefPtrs by simp
            then show ?thesis 
            proof(cases "tp1")
              case (MTArray x11 x12)
              then have stl1Mc:"MCon (MTArray x11 x12) (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl1")
                case True
                then have "CompMemType (memory st) len subT (MTArray  x11 x12) l'' stl1"
                  using notSame MTArray g1 lNotp asm5 stl1Mc lsublocs by simp
                then show ?thesis using MTArray g1 asm3 CompMemTypeSameLocsSameType 
                  using t7 by blast
              next
                case False
                then show ?thesis  using notSame MTArray g1 lNotp asm5 stl1Mc lsublocs 
                  by (simp add: g5)
              qed
            next
              case (MTValue x2)
              then have g2:"CompMemType (memory st) len subT (MTValue x2) l'' prnt" using g5 asm3 asm5 MTValue notSame by auto
              have "MCon (MTValue x2) (memory st) stl1" using asm3 2(1) MTValue sameStack unfolding TypeSafe_def typeCompat_def by force
              then show ?thesis using g1 g2 lsublocs asm3 by fastforce
            qed
          qed
        qed

        have isPrntTypeSub:"\<forall>l1 stl1 len'' arr''. (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1) 
                  \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' \<noteq> prnt\<longrightarrow> (CompMemType (memory st) len'' arr'' (MTArray len' arr') stl1 prnt)"
        proof intros
          fix l1 stl1  len'' arr''
          assume asm3:"(Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1)
                           \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' \<noteq> prnt"
          then have stl1Mc:"MCon (MTArray len'' arr'') (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
          then have stl1NotPrnt:"stl1 \<noteq> prnt" using asm3 TypedMemSubPrefPtrs_imps_notsame 
            by blast
          have "\<forall>dloc1.
       (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l' (stack st) = Some (KMemptr l'') \<longrightarrow>
       (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
        else case (MTArray len'' arr'') of
             MTArray len' arr' \<Rightarrow>
               (case (MTArray len subT) of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case (MTArray len subT) of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" 
            using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def by blast
          moreover have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env)" using lInfo(2,3,4) tParentType by blast
          moreover have "accessStore l' (stack st) = Some (KMemptr l'')" using lInfo by auto
          ultimately have asm6:"\<forall>dloc1. (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
              else if TypedMemSubPrefPtrs (memory st)  len subT l'' stl1 then CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l'' then CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st)  len subT l'' dloc1
                           then \<exists>dt. CompMemType (memory st)  len subT dt l'' dloc1 \<and> CompMemType (memory st) len'' arr'' dt stl1 dloc1 else True)" 
            using asm3 using sameStack by auto
          show "CompMemType (memory st) len'' arr'' (MTArray len' arr') stl1 prnt"
          proof(cases "stl1 = l''")
            case True
            then have "l'' \<noteq> prnt" using stl1NotPrnt by simp
            then have "CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
            then show ?thesis using True asm3 lsublocs3 asm6 by auto
          next
            case notSame:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st)  len subT l'' stl1")
              case True
              then have "CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1" using asm6 
                by (simp add: notSame)
              then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3  
                by (metis CompMemType_asc_withSharedTarget stl1Mc t7)
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l''")
                case True
                then have g6:"CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''"
                  using asm6  notSame f1 by simp
                then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3 
                  using compMemTypes_trns by blast
              next
                case f2:False
                then show ?thesis  using lsublocs lsublocs2 lsublocs3 asm3 asm6 notSame f1 f2 CompMemType_imps_TypedMemSubPrefPtrs
                  by (metis CompMemTypeSameLocsSameType t7)
              qed
            qed
          qed
        qed


        have isl''TypeSub:"\<forall>l1 stl1 len'' arr''. (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1) 
                  \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' = prnt\<longrightarrow> (CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 prnt)"
        proof intros
          fix l1 stl1  len'' arr''
          assume asm3:"(Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1)
                           \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' = prnt"
          then have stl1Mc:"MCon (MTArray len'' arr'') (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
          then have stl1NotPrnt:"stl1 \<noteq> prnt" using asm3 TypedMemSubPrefPtrs_imps_notsame 
            by blast

          have notl''prnt:"\<not>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using asm3 
            using CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame t7 by blast
          have "\<forall>dloc1.
       (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l' (stack st) = Some (KMemptr l'') \<longrightarrow>
       (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
        else case (MTArray len'' arr'') of
             MTArray len' arr' \<Rightarrow>
               (case (MTArray len subT) of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case (MTArray len subT) of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def by blast
          moreover have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env)" using lInfo(2,3,4) tParentType by blast
          moreover have "accessStore l' (stack st) = Some (KMemptr l'')" using lInfo by auto
          ultimately have asm6:"\<forall>dloc1. (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
              else if TypedMemSubPrefPtrs (memory st)  len subT l'' stl1 then CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l'' then CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st)  len subT l'' dloc1
                           then \<exists>dt. CompMemType (memory st)  len subT dt l'' dloc1 \<and> CompMemType (memory st) len'' arr'' dt stl1 dloc1 else True)" 
            using asm3 using sameStack by auto
          show "CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 prnt"
          proof(cases "stl1 = l''")
            case True
            then have "l'' \<noteq> prnt" using stl1NotPrnt by simp
            then have "CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
            then show ?thesis using lsublocs3 True asm3 lsublocs3 asm6 notl''prnt by auto
          next
            case notSame:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st)  len subT l'' stl1")
              case True
              then have "CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1" using asm6 
                by (simp add: notSame)
              then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3  
                by (metis  CompMemType_imps_CompMemJustType True TypedMemSubPrefOneWay stl1Mc t7)
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l''")
                case True
                then have g6:"CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''"
                  using asm6  notSame f1 by simp
                then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3 
                  using compMemTypes_trns by blast
              next
                case f2:False
                then show ?thesis  using lsublocs lsublocs2 lsublocs3 asm3 asm6 notSame f1 f2 CompMemType_imps_TypedMemSubPrefPtrs
                  by (metis)
              qed
            qed
          qed
        qed

        have notTopSublocs_inv:"\<forall>dloc1 x11 x12 stl1 i. \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 
                            \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1"
        proof intros
          fix dloc1 x11 x12 stl1
          assume "\<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1"
          then have asm3:"\<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            and asm4:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" by simp+
          show "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 " using asm3 asm4
          proof(induction x12 arbitrary:x11 stl1)
            case (MTArray x1 x12)
            obtain i'' ptr where ptrDef:"i''<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                    \<and> (ptr = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptr dloc1)"
              using MTArray.prems(2) unfolding TypedMemSubPrefPtrs.simps by auto
            then have notl:"(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using  MTArray.prems(1) 
              by (metis BT3 LSubPrefL2_def Memoryvalue.inject(2) accessL mInStd option.inject)
            have notSub:"\<not>LSubPrefL2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
              using SubPtrs_top asm3 ptrDef selfPoint2 by blast
            have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
              using notl notSub nonLocChanged2 by auto
            then show ?case 
            proof(cases "ptr = dloc1")
              case True
              then show ?thesis using sameAccess ptrDef by force
            next
              case False
              then show ?thesis using MTArray.IH sameAccess ptrDef 
                by (metis asm3 TypedMemSubPrefPtrs.simps(2))
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed

        show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def
        proof(intros)
          fix tp1 tp2 l1 l2 stl1 stl2 dloc1
          have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
          have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
          have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast

          then have c30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"   using nonLocChanged
            by simp
          assume h1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2)"
          then have tp1MconSt:"MCon tp1 (memory st) stl1" using 2(1) unfolding TypeSafe_def 
            by (metis "2.prems"(1) sameMemTSafe sameStack)
          then have tp2MconSt:"MCon tp2 (memory st) stl2" using 2(1) h1 unfolding TypeSafe_def 
            by (metis "2.prems"(1) sameMemTSafe sameStack)
          have tp1MconM:"MCon tp1 m stl1" using tp1MconSt PreExistMconNotChangeByToploc limitSt limitSt1 nonLocChanged22  
            by auto
          have tp2MconM:"MCon tp2 m stl2" using tp2MconSt PreExistMconNotChangeByToploc limitSt limitSt1 nonLocChanged22  
            by auto
          have stl1Lim:"\<not>LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using typeSafe_noDenElementOverToploc_mem[OF 2(1)] h1 sameStack by auto
          have stl2Lim:"\<not>LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using typeSafe_noDenElementOverToploc_mem[OF 2(1)] h1 sameStack by auto
          have "l \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using lInfo 
            using LSubPrefL2_def l_not_toploc_orSub by blast
          have accessLGen:"\<exists>ptr. accessStore l m' = Some (MPointer ptr) \<and> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray x t) (memory st') ptr " using MCondest2 accessL 
            by (simp add: LSubPrefL2_def )
          

         

          have subLocs1:"\<forall>len' arr' locs. TypedMemSubPrefPtrs (memory st') len' arr' locs stl1
                  \<longrightarrow> TypedMemSubPrefPtrs (memory st) len' arr' locs stl1"
          proof intros
            fix len' arr' locs
            assume asm3:"TypedMemSubPrefPtrs (memory st') len' arr' locs stl1"
            then show "TypedMemSubPrefPtrs (memory st) len' arr' locs stl1"
            proof(induction arr' arbitrary: len' locs)
              case (MTArray x1 arr')
              obtain i'' ptr where ptrDef:"i''<len' \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 arr' ptr stl1)"  
                using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using stl1Lim 
                using BT3 accessL accessLGen mInStd by force
              then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
                by (metis MTArray.prems MemLSubPrefL2_specific_imps_general SubPtrs_top nonLocChanged2 selfPoint2 stl1Lim)
              then show ?case 
              proof(cases "ptr = stl1")
                case True
                then show ?thesis using sameAccess 
                  using ptrDef by force
              next
                case False
                then show ?thesis using ptrDef sameAccess 
                  using MTArray.IH by auto
              qed
            next
              case (MTValue x)
              then show ?case by simp
            qed 
          qed     
            (*Can be replaced by a generalisation of the above*)
          have subLocs2:"\<forall>len' arr' locs. TypedMemSubPrefPtrs (memory st') len' arr' locs stl2
                  \<longrightarrow> TypedMemSubPrefPtrs (memory st) len' arr' locs stl2"
          proof intros
            fix len' arr' locs
            assume asm3:"TypedMemSubPrefPtrs (memory st') len' arr' locs stl2"
            then show "TypedMemSubPrefPtrs (memory st) len' arr' locs stl2"
            proof(induction arr' arbitrary: len' locs)
              case (MTArray x1 arr')
              obtain i'' ptr where ptrDef:"i''<len' \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 arr' ptr stl2)"  
                using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using stl2Lim 
                using BT3 accessL accessLGen mInStd by force
              then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
                by (metis MTArray.prems MemLSubPrefL2_specific_imps_general SubPtrs_top nonLocChanged2 selfPoint2 stl2Lim)
              then show ?case 
              proof(cases "ptr = stl2")
                case True
                then show ?thesis using sameAccess 
                  using ptrDef by force
              next
                case False
                then show ?thesis using ptrDef sameAccess 
                  using MTArray.IH by auto
              qed
            next
              case (MTValue x)
              then show ?case by simp
            qed 
          qed



          have subLocs3:"\<forall>x11 x12 locs stl1. \<not>LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) 
                                                  \<and> MCon (MTArray x11 x12) (memory st) stl1 
                                                  \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs
                                                  \<and> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))
                                                  \<and> (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt)
                                                  \<and> (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt)
                                                  \<and> (stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr')
                  \<longrightarrow> (CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" 
          proof intros
            fix x11 x12 locs stl1
            assume asm3:"\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and>
       MCon (MTArray x11 x12) (memory st) stl1 \<and>
       TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs \<and>
       LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and>
       (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt) \<and>
       (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt) \<and> (stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr')"
            have asm8:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt "
              using asm3 by simp
            have  asm9:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt"
              using asm3 by simp
            have  asm10:"stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr'"
              using asm3 by simp
            then have asm4:"\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using asm3 by simp

            have asm5:"MCon (MTArray x11 x12) (memory st) stl1" using asm3 by blast
            have asm6:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs" using asm3 by blast
            have asm7:"LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using asm3 by blast
            have conc:"(CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" 
              using asm4 asm5 asm6 asm7 asm8 asm9 asm10
            proof(induction x12 arbitrary: x11 stl1)
              case (MTArray x1 arr'')
              obtain i'' ptr where ptrDef:"i''<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = locs \<or> TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs)"  
                using MTArray.prems(3) unfolding TypedMemSubPrefPtrs.simps by blast
              then obtain ptr' where old:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr') " using MTArray.prems(2) 
                by (metis MConArrayPointers bot_nat_0.not_eq_extremum less_nat_zero_code)
              then have mc:"MCon (MTArray x1 arr'') (memory st) ptr'" using MTArray.prems(2) 
                by (meson MCon_imps_sub_Mcon ptrDef)
              then have oldLim:"\<not>LSubPrefL2 ptr' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using limitSt limitSt1 old 
                by (metis MCon_imps_Some le_refl lessThanSome_imps_Locs2 lessThanTopLocs_def nat_less_le option.distinct(1))
              then show ?case 
              proof(cases "ptr = locs")
                case True
                then have *:"LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using MTArray.prems(4) by simp
                then show ?thesis 
                proof(cases "ptr = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                  case True
                  then have "ptr \<noteq> ptr'" using oldLim 
                    using LSubPrefL2_def by auto
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l \<or> LSubPrefL2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using nonLocChanged2 old ptrDef 
                    by auto
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l" using MTArray.prems(1) LSubPrefL2_def 
                    using MemLSubPrefL2_specific_imps_general by blast
                  then have "stl1 = prnt" using ldef hash_injective ShowLNatDot by blast
                  moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" 
                    using MTArray.prems(7) MTArray.prems(3) calculation by blast
                  ultimately show ?thesis 
                    using CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame lsublocs3 t7 by blast
                next
                  case False
                  then have "\<exists>i. ptr = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" using * unfolding LSubPrefL2_def by simp
                  then show ?thesis 
                    by (metis False LSubPrefL2_def Memoryvalue.inject(2) NonChangeM'm accessL c30 le_refl limitSt mInStd old oldLim option.discI option.inject ptrDef)
                qed
              next
                case False
                then have "TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs" using ptrDef by simp
                then show ?thesis 
                proof(cases "LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                  case True
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l" 
                    by (metis MTArray.prems(1) MemLSubPrefL2_specific_imps_general Memoryvalue.inject(2) nonLocChanged2 old oldLim option.inject ptrDef)
                  then have "stl1 = prnt" using ldef hash_injective ShowLNatDot by blast
                  moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" 
                    using  MTArray.prems(7) 
                    using MTArray.prems(3) calculation by auto
                  ultimately show ?thesis 
                    using BothMConImpsNotCompMemType CompTypeRemainsMCon lsublocs3 t7 by blast
                next
                  case f2:False
                  then have "accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using False 
                    by (metis MTArray.prems(1) LSubPrefL2_def MemLSubPrefL2_specific_imps_general Memoryvalue.inject(2) accessL mInStd nonLocChanged2 option.inject ptrDef)
                  then have "MCon (MTArray x1 arr'') (memory st) ptr" using ptrDef MTArray.prems(2) 
                    by (metis MCon_imps_sub_Mcon)
                  moreover have "TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs" using ptrDef False by simp
                  moreover have "LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using MTArray(5) by simp
                  moreover have "TypedMemSubPrefPtrs (memory st) x1 arr'' ptr prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 arr'' (MTArray len' arr') ptr prnt" 
                    by (metis (full_types) CompMemType_asc_withSharedTarget MTArray.prems(2,5) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close>
                        existingLocation_imps_allLocs existingLocation_imps_allLocs_same lsublocs ptrDef TypedMemSubPrefPtrs.simps(2))
                  moreover have "TypedMemSubPrefPtrs (memory st) x1 arr'' ptr prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 arr'' (MTArray len subT) ptr prnt"
                    by (metis CompMemType_asc_withSharedTarget MTArray.prems(2,6) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> calculation(1)
                        existingLocation_imps_allLocs existingLocation_imps_allLocs_same ptrDef TypedMemSubPrefPtrs.simps(2))
                  moreover have "ptr = prnt \<longrightarrow> MTArray x1 arr'' = MTArray len' arr'" 
                    by (metis MTArray.prems(2,5,6) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> compMemTypes_trns
                        existingLocation_imps_allLocs_same lsublocs3 ptrDef TypedMemSubPrefPtrs.simps(2))
                  ultimately have "(CompMemType (memory st') x1 arr'' (MTArray len' arr') ptr prnt \<or> ptr = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs"
                    using MTArray.IH[of ptr x1] f2 MTArray.prems(4) by blast
                  then show ?thesis 
                    using ptrDef 
                    using MTArray.prems(5) 
                    using \<open>ptr = prnt \<longrightarrow> MTArray x1 arr'' = MTArray len' arr'\<close> CompMemType.simps(2) 
                    by (metis MConPtrsMustBeSubLocs2 lsublocs lsublocs3 t7)
                qed
              qed

            next
              case (MTValue x)
              then show ?case 
                by (metis MemLSubPrefL2_specific_imps_general TypedMemSubPrefPtrs.simps(1))
            qed
            then show "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt" by simp
            show "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" using conc by blast
            show "prnt = l'' \<Longrightarrow> MTArray len' arr' = MTArray len subT" using conc by simp
          qed     

          show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)" using sameStack 
          proof(cases "stl1 = stl2")
            case True
            then show ?thesis  
              using compMemPtrs_def compOld h1 sameStack by auto                                                                                     
          next
            case notSame:False
            then show ?thesis 
            proof(cases "tp1")
              case mta1:(MTArray x11 x12)
              have g1:"MCon (MTArray x11 x12) (memory st) stl1" using tp1MconSt mta1 by blast
              have prntT1:"stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr'" using h1 isPrntTypeSame mta1 by auto
              have subTs1: "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt)" using isPrntTypeSub h1  mta1 by auto
              then have gk1:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt" 
                using isl''TypeSub h1 mta1  by blast
              then show ?thesis
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                have g2:"MCon (MTArray x11' x12') (memory st) stl2" using tp2MconSt mta2 by blast
                have prntT:"stl2 = prnt \<longrightarrow> MTArray x11' x12' = MTArray len' arr'" using h1 isPrntTypeSame mta2 by auto
                have subTs: "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt)" using isPrntTypeSub h1  mta2 by auto
                then have gk:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11' x12' (MTArray len subT) stl2 prnt" 
                  using isl''TypeSub h1 mta2  by blast
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case o:True
                  then have oldType:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using subLocs1 o by simp
                  then have old:"CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
                    using compOld unfolding compMemPtrs_def using mta1 mta2 notSame h1 sameStack by force

                  have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using o g2 old prntT gk subTs
                  proof(induction x12' arbitrary:x11' stl2)
                    case (MTArray x1 x12')
                    obtain inew ptrNew where ptrNewDef: "inew<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl2 = prnt")
                      case True
                      then have "inew \<noteq> i"   
                        using BT3 accessL accessLGen ldef mInStd stl1Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12') (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 
                          using MConPtrsMustBeSubLocs[OF mc ] 
                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12' (MTArray x11 x12) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTArray x11 x12) ptrNew stl1" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12') (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12' (MTArray x11 x12) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12' = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11' (MTArray x1 x12') (MTArray len subT) stl2 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTArray x11 x12) ptrNew stl1" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed

                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed
                  then show ?thesis using mta1 mta2 notSame o by simp

                next
                  case f1:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                    case o:True
                    then have oldType:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using subLocs2 o by simp
                    then have old:"CompMemType (memory st)  x11 x12 (MTArray x11' x12') stl1 stl2"
                      using compOld unfolding compMemPtrs_def using mta1 mta2 notSame h1 sameStack by force
                    have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using o g1 old prntT1 gk1 subTs1
                    proof(induction x12 arbitrary:x11 stl1)
                      case (MTArray x1 x12)
                      obtain inew ptrNew where ptrNewDef: "inew<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2)" 
                        using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                      then show ?case 
                      proof(cases "stl1 = prnt")
                        case True
                        then have "inew \<noteq> i"  
                          using BT3 accessL accessLGen ldef mInStd stl2Lim  ptrNewDef by force
                        then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                          by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                        then have mc:"MCon (MTArray x1 x12) (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                          by (metis MCon_imps_sub_Mcon)
                        then show ?thesis 
                        proof(cases "ptrNew = stl2")
                          case True
                          then show ?thesis using MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2)
                            by (metis )
                        next
                          case False
                          have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 

                            using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                          have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using False ptrNewDef by simp
                          moreover have "CompMemType (memory st) x1 x12 (MTArray x11' x12') ptrNew stl2" 
                            by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                            by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt" 
                            by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                          ultimately have "CompMemType (memory st') x1 x12 (MTArray x11' x12') ptrNew stl2" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                          then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                        qed
                      next
                        case notPrnt:False
                        then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                        then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                          by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                        then show ?thesis 
                        proof(cases "ptrNew = stl2")
                          case True
                          then show ?thesis 
                            by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                        next
                          case False
                          then have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using ptrNewDef by simp
                          moreover have "MCon (MTArray x1 x12) (memory st) ptrNew" 
                            by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                          moreover have "CompMemType (memory st) x1 x12 (MTArray x11' x12') ptrNew stl2" 
                            by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                          moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12 = MTArray len' arr'" 
                            by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                          proof
                            assume *:"TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt"
                            then have "TypedMemSubPrefPtrs (memory st) x11 (MTArray x1 x12) stl1 prnt" using notPrnt 
                              using ptrNewDef sameAccess by auto
                            then have "CompMemType (memory st) x11 (MTArray x1 x12) (MTArray len subT) stl1 prnt" using MTArray.prems(5) * by blast
                            then show "CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                              by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                          qed
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt"
                            using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                            by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                          ultimately have "CompMemType (memory st') x1 x12 (MTArray x11' x12') ptrNew stl2" using MTArray.IH[of x1 ptrNew] by blast
                          then show ?thesis 
                            using ptrNewDef by auto
                        qed
                      qed

                    next
                      case (MTValue x)
                      then show ?case by simp
                    qed
                    then show ?thesis using mta1 mta2 notSame o f1 by simp
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                      case tc:True
                      then have p1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" by simp
                      then show ?thesis  using subLocs3
                      proof(cases "LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                        case dlocLessTop:True
                        then have j6:"(CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt \<or> stl2 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" using subLocs3 
                          using g2 stl2Lim tc gk subTs 
                          using prntT by blast                                                                                                                                      
                        have j7:"(CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1" using subLocs3  
                          using dlocLessTop g1 stl1Lim tc gk1 subTs1 
                          using j6 by blast
                        show ?thesis 
                        proof(cases "stl2 = prnt")
                          case t8:True
                          then have stl1ToPrnt:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 prnt" using notSame j7 
                            using CompMemType_imps_TypedMemSubPrefPtrs by blast
                          have "MTArray x11' x12' = MTArray len' arr'" using t8 by (simp add: prntT)
                          then show ?thesis using f2 t8 by (simp add: stl1ToPrnt)
                        next
                          case f8:False
                          then show ?thesis 
                          proof(cases "stl1 = prnt")
                            case True
                            then have stl2ToPrnt:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt" using notSame j6 using CompMemType_imps_TypedMemSubPrefPtrs by blast
                            then show ?thesis using f1 True by auto
                          next
                            case f9:False
                            then show ?thesis 
                            proof(cases "prnt = l''")
                              case True
                              have "CompMemType (memory st') x11' x12' (MTArray len subT) stl2 l''" using j6 f8 True by blast
                              moreover have "CompMemType (memory st') x11 x12 (MTArray len subT) stl1 l''" using j7 f9 j6 True by simp
                              have "TypedMemSubPrefPtrs (memory st') len subT l'' dloc1" using j7 j6 True by simp
                              then have "\<exists>dt. CompMemType (memory st') len subT dt l'' dloc1" 
                              proof(induction subT arbitrary:len l'')
                                case (MTArray x1 subT)
                                obtain i'' ptr where ptrDef: "i''<len \<and>  accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                                                                \<and> (ptr = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 subT ptr dloc1)" 
                                  using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                                then show ?case 
                                proof(cases "ptr = dloc1")
                                  case True
                                  then show ?thesis unfolding CompMemType.simps using ptrDef by blast
                                next
                                  case False
                                  then have "TypedMemSubPrefPtrs (memory st') x1 subT ptr dloc1" using ptrDef by simp
                                  then show ?thesis using MTArray.IH[of x1 ptr] 
                                    using ptrDef CompMemType.simps(2) by blast
                                qed
                              next
                                case (MTValue x)
                                then show ?case by simp
                              qed

                              then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                                using \<open>CompMemType (memory st') x11 x12 (MTArray len subT) stl1 l''\<close> \<open>CompMemType (memory st') x11' x12' (MTArray len subT) stl2 l''\<close> compMemTypes_trns by blast
                              then show ?thesis  using mta1 mta2 f1 f2 notSame by auto
                            next
                              case False
                              have "CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt" using j6 f8 by simp
                              moreover have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt" using j7 f9 by simp
                              moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1" using j7 by simp
                              ultimately have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                                by (metis False compMemTypes_trns compmemst' l''MConst' l''mMcon lsublocs3 sharedParentSharedSubLocTypes t7)
                              then show ?thesis  using mta1 mta2 f1 f2 notSame by auto
                            qed
                          qed
                        qed
                      next
                        case False
                        then have o2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" 
                          using notTopSublocs_inv tc by simp
                        then have "dloc1 \<noteq> stl2" using tc f2 ldef by auto
                        have "dloc1 \<noteq> stl1" using o2 
                          using f1 tc by auto
                        have k1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" using tc by simp
                        have k2:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" using tc by simp
                        have k3:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" using o2 by simp
                        have k4:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1" using o2 by simp

                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2")
                          case True
                          then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" 
                            using compOld notSame mta1 mta2 h1 sameStack unfolding compMemPtrs_def by force
                          then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                            using o2 by (meson compMemTypes_trns g1 notSame sharedParentSharedSubLocTypes)
                          then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                          then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                          then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                            using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                          moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                            using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                          ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                            by auto
                          then show ?thesis using mta1 mta2 h1 notSame f1 f2 True tc by simp
                        next
                          case f11:False
                          then show ?thesis 
                          proof(cases "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1")
                            case True
                            then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" 
                              using f11 compOld notSame mta1 mta2 h1 sameStack unfolding compMemPtrs_def by force
                            then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                              using o2 by (metis compMemTypes_trns g2 notSame sharedParentSharedSubLocTypes)
                            then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                            then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                            then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                              using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              by auto
                            then show ?thesis using mta1 mta2 h1 notSame f1 f2 True tc by simp
                          next
                            case f12:False
                            then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                              using f11 compOld notSame mta1 mta2 h1 sameStack o2 unfolding compMemPtrs_def 
                              by force
                            then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                            then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                            then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                              using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              by auto
                            then show ?thesis using mta1 mta2 h1 notSame f1 f2 tc by simp
                          qed
                        qed

                      qed
                    next
                      case False
                      then show ?thesis using mta1 mta2 f1 f2 notSame by auto
                    qed
                  qed
                qed
              next
                case mtv1:(MTValue x2)
                have g2:"MCon (MTValue x2) (memory st) stl2" using tp2MconSt mtv1 by blast

                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                  case o:True
                  then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                    by (simp add: subLocs2)
                  then have old:"CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2"
                    using compOld unfolding compMemPtrs_def using mta1 mtv1 notSame h1 sameStack by force           
                  have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" using o g1 old prntT1 gk1 subTs1
                  proof(induction x12 arbitrary:x11 stl1)
                    case (MTArray x1 x12)
                    obtain inew ptrNew where ptrNewDef: "inew<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl1 = prnt")
                      case True
                      then have "inew \<noteq> i"
                        using BT3 accessL accessLGen ldef mInStd stl2Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12) (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl2")
                        case True
                        then show ?thesis using MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2)
                          by (metis )
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 

                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12 (MTValue x2) ptrNew stl2" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12 (MTValue x2) ptrNew stl2" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl2")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12) (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12 (MTValue x2) ptrNew stl2" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12 = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11 (MTArray x1 x12) stl1 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11 (MTArray x1 x12) (MTArray len subT) stl1 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12 (MTValue x2) ptrNew stl2" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed

                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed

                  then show ?thesis  using mtv1 mta1 notSame by simp
                next
                  case False
                  then show ?thesis using mtv1 mta1 notSame by simp
                qed
              qed
            next
              case mtv1:(MTValue x2)
              then show ?thesis 
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                have g2:"MCon (MTArray x11' x12') (memory st) stl2" using tp2MconSt mta2 by blast
                have prntT:"stl2 = prnt \<longrightarrow> MTArray x11' x12' = MTArray len' arr'" using h1 isPrntTypeSame mta2 by auto
                have subTs: "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt)" using isPrntTypeSub h1  mta2 by auto
                then have gk:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11' x12' (MTArray len subT) stl2 prnt" 
                  using isl''TypeSub h1 mta2  by blast
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case o:True
                  then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" 
                    by (simp add: subLocs1)
                  then have old:"CompMemType (memory st) x11' x12' (MTValue x2) stl2 stl1"
                    using compOld unfolding compMemPtrs_def using mtv1 mta2 notSame h1 sameStack by force    
                  have "CompMemType (memory st') x11' x12' (MTValue x2) stl2 stl1" using o g2 old prntT gk subTs
                  proof(induction x12' arbitrary:x11' stl2)
                    case (MTArray x1 x12')
                    obtain inew ptrNew where ptrNewDef: "inew<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl2 = prnt")
                      case True
                      then have "inew \<noteq> i"
                        using BT3 accessL accessLGen ldef mInStd stl1Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12') (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 
                          using MConPtrsMustBeSubLocs[OF mc ] 
                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12' (MTValue x2) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTValue x2) ptrNew stl1" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12') (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12' (MTValue x2) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12' = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11' (MTArray x1 x12') (MTArray len subT) stl2 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTValue x2) ptrNew stl1" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed

                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed

                  then show ?thesis using mtv1 mta2 notSame by simp
                next
                  case False
                  then show ?thesis using mtv1 mta2 notSame by simp
                qed      
              next
                case (MTValue x2)
                then show ?thesis using mtv1 notSame by simp
              qed
            qed
          qed
        qed
      next 
        have "accounts st'= accounts st" using 7 by auto
        then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 7 unfolding fullyInitialised_def  by auto
      next 
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        have topLocEq:"toploc (snd (allocate (memory st))) = toploc m" 
          using cpm2mTopLocSame[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t cd "(snd (allocate (memory st)))" x m] 7(4) mInStd unfolding cpm2m_def by fastforce
        then have topmm':"toploc m = toploc m'" using 7(5) unfolding updateStore_def by auto
        then have topm'st':"toploc m' = toploc (memory st')" using mInStd by blast

        then have "{l. toploc (memory st) \<le> l \<and> l < Suc (toploc (memory st))} = {(toploc (memory st))}" by auto
        then have "{l. toploc (memory st) \<le> l \<and> l < (toploc m)} = {(toploc (memory st))}" using topLocEq mInStd unfolding allocate_def by auto
        then have topLocSet:"{(ShowL\<^sub>n\<^sub>a\<^sub>t l) |l. toploc (memory st) \<le> l \<and> l < toploc m} = {ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))}" 
          by (smt (verit, best) Collect_cong mem_Collect_eq singleton_conv2)
        have "\<forall>l. l \<in> WrittenMem_between (memory st) (m) \<longrightarrow> TypedMemSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) " 
          using WrittenMem_between_def mInStd a30 selfPoint a32 by blast
        then have "\<forall>l''. l'' \<in> WrittenMem_between (memory st) (m') \<longrightarrow> TypedMemSubPref l'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> l'' = l" 
          using NonChangeM'm  WrittenMem_between_def by fastforce
        then have cc0:"\<forall>l''. l'' \<in> WrittenMem_between (memory st) (memory st') \<longrightarrow> TypedMemSubPref l'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> l'' = l" using mInStd by simp
        moreover have aloccated:"\<forall>x'. x'\<in> (AllocatedMem_between (memory st) m) \<longleftrightarrow> TypedMemSubPref x' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> x' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        proof intros 
          fix x'
          show "(x' \<in> AllocatedMem_between (memory st) m) = (TypedMemSubPref x' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> x' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))"
          proof
            assume " x' \<in> AllocatedMem_between (memory st) m"
            then have "x' \<in> {(ShowL\<^sub>n\<^sub>a\<^sub>t l) |l. toploc (memory st) \<le> l \<and> l < toploc m} \<union> fset (fmdom (mapping m) |-| fmdom (mapping (memory st)))"
              unfolding AllocatedMem_between_def by simp
            then have "x' \<in> ({(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))} \<union> fset (fmdom (mapping m) |-| fmdom (mapping (memory st))))" 
              using topLocSet by simp
            then  show "TypedMemSubPref x' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> x' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
              using a30  accessStore_def allocateSame fminus_iff fmlookup_dom_iff 
              by (metis Un_iff empty_iff insert_iff)
          next 
            assume *:"TypedMemSubPref x' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x t) \<or> x' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"

            then show "x' \<in> AllocatedMem_between (memory st) m"  
            proof(cases "x' = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
              case True
              then show ?thesis unfolding AllocatedMem_between_def using topLocSet by simp
            next
              case False
              then have "accessStore x' (memory st) = None" using limitSt typedPrefix_imp_SubPref * by blast

              moreover have "\<exists>v. accessStore x' m = Some v" using * MCondest selfPoint MCon_imps_TypedMemSubPref_Some False by blast

              ultimately have "x' \<in> fset (fmdom (mapping m) |-| fmdom (mapping (memory st)))" using a30 
                by (simp add: accessStore_def fmlookup_dom_iff)
              then show ?thesis using AllocatedMem_between_def by auto
            qed
          qed
        qed
        moreover have "accessStore l m = accessStore l (memory st)" 
          using l_not_toploc_orSub nonLocChanged22 by fastforce
        moreover obtain vv where vvdef:"accessStore l m = Some vv" using calculation lIs by auto
        moreover have lIn22:"l |\<in>| fmdom (mapping m)" using fmdomI calculation(4)  accessStore_def by metis
        moreover have "accessStore l m' = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using fmdomI 7(5) by auto
        moreover have "l |\<in>| fmdom (mapping m')" using calculation(6) fmdomI 
          by (metis accessStore_def)

      qed
    qed
  next
    case (8 p x t g l t' g')
    then have stackChanged:"\<forall>l'. l' \<noteq> l \<longrightarrow> accessStore l' (stack st) = accessStore l' (stack st')" unfolding updateStore_def accessStore_def by simp
    have t'InDen:"(Memory t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[OF 8(2)] by blast
    then have lDen:"\<forall>t'. (t', Stackloc l) |\<in>| fmran (denvalue env) \<longrightarrow> t'= (Memory (MTArray x t))" using 8 2(1) unfolding TypeSafe_def unique_locations_def by auto

    have pOrigin:"MCon (MTArray x t) (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) (extractValueType (KMemptr p)) \<and>
        (\<exists>xx. KMemptr p = KMemptr xx) \<and>
        (\<exists>stloc tp'' pa.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KMemptr p = KMemptr pa \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pa \<and>
                 tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pa (extractValueType (KMemptr p)))))" 
      using 2(1) 8(1) 2(3) using
        exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KMemptr p" "Memory (MTArray x t)" g] 
      by (auto split:Type.splits if_splits )
    then obtain pParent pParentT pParentPtr where 
      pOrigin:"MCon (MTArray x t) (memory (st)) (extractValueType (KMemptr p)) \<and>(Memory pParentT, Stackloc pParent) |\<in>| fmran (denvalue env) \<and>
            accessStore pParent (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pParentPtr) \<and>
            (pParentT = (MTArray x t) \<and> KMemptr p = KMemptr pParentPtr \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
                 pParentT = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p))))"
      using pOrigin      by force
    have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    then have pParentRelations:"(\<forall>tp2 l1 l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if pParentPtr = stl2 then pParentT = tp2
         else case pParentT of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                  else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                       else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                  | MTValue val2 \<Rightarrow> True)))" using compMemPtrs_def pOrigin  by force
    have pMCon:"MCon (MTArray x t) (memory st) p" using pOrigin by force

(*All locations that can get to p must have a parent type of MTArray x t and all locations lower than p similarly*)
    have pRelations:"(\<forall>tp2  l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if p = stl2 then (MTArray x t) = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 p then CompMemType (memory st) len2 arr2 (MTArray x t) stl2 p
                  else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTArray len2 arr2) p stl2
                       else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTValue val2) p stl2 else True
              ))"
    proof intros 
      fix tp2 l2 stl2 dloc1
      assume in1:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)"

      have stl2Mcon:"MCon tp2 (memory st) stl2" using 2(1) unfolding TypeSafe_def typeCompat_def using in1 by fastforce
      have pParentMcon:"MCon pParentT (memory st) pParentPtr" using 2(1) unfolding TypeSafe_def typeCompat_def using pOrigin by force

      show "if p = stl2 then MTArray x t = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 p then CompMemType (memory st) len2 arr2 (MTArray x t) stl2 p
              else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTArray len2 arr2) p stl2
                   else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTValue val2) p stl2 else True"
      proof(cases "p = stl2")
        case t1:True
        then show ?thesis 
        proof(cases "p = pParentPtr")
          case True
          then have "pParentT = MTArray x t" using t1 pOrigin by simp
          then show ?thesis using pParentRelations in1 t1 True by auto
        next
          case False
          then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
            using pOrigin by auto
          have noeq:"pParentPtr \<noteq> stl2" using t1 False by simp

          then have "(if pParentPtr = stl2 then pParentT = tp2
        else case pParentT of
             MTArray len arr \<Rightarrow>
               (case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
             | MTValue val \<Rightarrow>
                 (case tp2 of
                 MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                 | MTValue val2 \<Rightarrow> True))"
            using pParentRelations pOrigin in1 lenDef by fast
          then have in2:" case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True"
            using    lenDef noeq by simp

          then show ?thesis using pParentRelations
          proof(cases tp2)
            case (MTArray x11 x12)
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
              case True
              then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 MTArray by simp
              then show ?thesis using t1 lenDef stl2Mcon  pParentMcon 
                by (metis (lifting) CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MTArray TypedMemSubPrefOneWay extractValueType.simps(3))
            next
              case f2:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                case True
                then have "CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using f2 in2 noeq MTArray by simp
                then show ?thesis  using t1 lenDef stl2Mcon  pParentMcon  
                  by (metis CompMemTypeSameLocsSameType MTArray extractValueType.simps(3))
              next
                case False
                then show ?thesis using t1 lenDef stl2Mcon  pParentMcon  f2 in2 noeq MTArray 
                  using CompMemType_imps_TypedMemSubPrefPtrs by force
              qed
            qed
          next
            case (MTValue x2)
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
              case True
              then have "CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2" using in2 
                using MTValue by auto
              then show ?thesis using t1 lenDef stl2Mcon  pParentMcon 
                using CompMemTypeSameLocsSameType 
                by (metis MTValue extractValueType.simps(3))
            next
              case False
              then show ?thesis 
                using CompMemType_imps_TypedMemSubPrefPtrs lenDef t1 by auto
            qed
          qed
        qed
      next
        case False

        have in3:"\<forall>dloc1. (if pParentPtr = stl2 then pParentT = tp2
        else case pParentT of
             MTArray len arr \<Rightarrow>
               (case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
             | MTValue val \<Rightarrow>
                 (case tp2 of
                 MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                 | MTValue val2 \<Rightarrow> True))" using pParentRelations in1 by auto
        then show ?thesis 
        proof(cases "tp2")
          case (MTArray x11 x12)
          then have stl2Mcon:"MCon (MTArray x11 x12) (memory st) stl2" using stl2Mcon by blast
          then show ?thesis 
          proof(cases "p = pParentPtr")
            case t3:True
            then have typesame:"pParentT = MTArray x t" using pOrigin by simp
            then have in2:"if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p then CompMemType (memory st) x11 x12 (MTArray  x t) stl2 p
                 else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st)  x t (MTArray x11 x12) p stl2
                      else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True" using in3 MTArray t3 False by fastforce
            then show ?thesis using in2 False MTArray by simp
          next
            case f2:False
            then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
              using pOrigin by auto
            then have in2:"\<forall>dloc1. if pParentPtr = stl2 then pParentT = tp2 
                else if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr then CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True" 
              using in3 MTArray False f2 by fastforce

            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p")
              case t3:True
              have "CompMemType (memory st) x11 x12 (MTArray x t) stl2 p" 
              proof(cases "pParentPtr = stl2")
                case t4:True
                then show ?thesis using t3 in2 MTArray False pOrigin by simp
              next
                case f5:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
                  case t5:True
                  then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 f5 by simp
                  then show ?thesis using lenDef stl2Mcon  pParentMcon t5 t3 MTArray compMemTypes_trns[of "memory st" _ _ "MTArray x t" _ p x11 x12 stl2] by auto
                next
                  case f6:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                    case t6:True
                    then have " CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using in2 f6 f5 by simp
                    then show ?thesis  using lenDef stl2Mcon  pParentMcon t6 t3 MTArray f5 pMCon
                        CompMemType_asc_withSharedTarget[of "memory st" len arr x11 x12 pParentPtr stl2 "MTArray x t" p] by simp
                  next
                    case False
                    have "TypedMemSubPrefPtrs (memory st) len arr pParentPtr p" 
                      using lenDef CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len arr "MTArray x t" pParentPtr p] by simp
                    moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p" using t3 by simp
                    ultimately have "\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 p \<and> CompMemType (memory st) len arr dt pParentPtr p" 
                      using in2 False f5 f6 by simp
                    then show ?thesis using lenDef stl2Mcon  pParentMcon  t3 MTArray f5 pMCon in2 f6 f5 
                      by (metis CompMemTypeSameLocsSameType extractValueType.simps(3))
                  qed
                qed
              qed
              then show ?thesis by (simp add: False MTArray t3)
            next
              case f3:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x t p stl2")
                case t3:True
                have "CompMemType (memory st) x t (MTArray x11 x12) p stl2" 
                proof(cases "pParentPtr = stl2")
                  case t4:True
                  then show ?thesis using t3 in2 MTArray False pOrigin f3  
                    using CompMemType_imps_TypedMemSubPrefPtrs by auto
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
                    case t5:True
                    then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 f5 by simp
                    then show ?thesis using lenDef stl2Mcon  pParentMcon t5 t3 MTArray compMemTypes_trns 
                      by (metis CompMemType_imps_TypedMemSubPrefPtrs f3 extractValueType.simps(3))
                  next
                    case f6:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                      case t6:True
                      then have " CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using in2 f6 f5 by simp
                      then show ?thesis  using lenDef stl2Mcon  pParentMcon t6 t3 MTArray f5 pMCon
                          CompMemType_asc_withSharedTarget 
                        by (metis extractValueType.simps(3))
                    next
                      case False
                      have "TypedMemSubPrefPtrs (memory st) len arr pParentPtr p" 
                        using lenDef CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len arr "MTArray x t" pParentPtr p] by simp
                      moreover have "TypedMemSubPrefPtrs (memory st) x t p stl2" using t3 by simp
                      ultimately show ?thesis using lenDef stl2Mcon  pParentMcon  t3 MTArray f5 pMCon in2 f6 f5 
                        by (metis False TypedMemSubPrefPtrs_trns extractValueType.simps(3))
                    qed
                  qed
                qed
                then show ?thesis using False MTArray t3 f3 by simp
              next
                case f4:False
                then show ?thesis 
                  by (smt (verit, ccfv_threshold) CompMemType_asc_withSharedTarget CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon False MTArray MTypes.simps(5) TypedMemSubPrefPtrs_trns f3
                      in2 lenDef pParentMcon sharedParentSharedSubLocTypes extractValueType.simps(3) stl2Mcon)
              qed
            qed
          qed
        next
          case (MTValue x2)
          then show ?thesis 
          proof(cases "TypedMemSubPrefPtrs (memory st) x t p stl2")
            case t1:True
            have "CompMemType (memory st) x t (MTValue x2) p stl2" 
            proof(cases "p = pParentPtr")
              case t3:True
              then have "pParentT = MTArray x t" using pOrigin by simp
              then have "if TypedMemSubPrefPtrs (memory st) x t pParentPtr stl2 then CompMemType (memory st) x t (MTValue x2) pParentPtr stl2 else True"
                using in3  t3 MTValue False  by simp
              then have "CompMemType (memory st) x t (MTValue x2) pParentPtr stl2" using t1 t3 by simp
              then show ?thesis using in3  t1 MTValue False 
                using t3 by auto
            next
              case False
              then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
                using pOrigin by auto

              then have in2:"if pParentPtr = stl2 then pParentT = tp2 else 
                          if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2 else True"
                using  in3  lenDef MTValue by (auto split:if_splits MTypes.split)

              then show ?thesis
              proof(cases "pParentPtr = stl2")
                case t5:True
                then have "pParentT = tp2" using in2 by simp
                then show ?thesis using MTValue lenDef by auto
              next
                case f5:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                  case t6:True
                  then have "CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2" using in2 f5 by simp
                  then show ?thesis 
                    by (metis CompMemType_asc_withSharedTarget CompTypeRemainsMCon lenDef pParentMcon extractValueType.simps(3) t1)
                next
                  case f6:False
                  then show ?thesis 
                    by (metis CompTypeRemainsMCon TypedMemSubPrefPtrs_trns lenDef pParentMcon extractValueType.simps(3) t1)
                qed
              qed
            qed

            then show ?thesis 
              by (simp add: False MTValue)
          next
            case f2:False
            then show ?thesis using MTValue  False by simp
          qed
        qed
      qed
    qed

    have storageSame:"(storage st' (address env)) = (storage st (address env))" using 8 by simp
    have memorySame:"memory st = memory st'" using 8 by simp
    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof (intros)
      show tcN:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof(intros)
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof (split Denvalue.split, intros)
          fix loc assume a20:"l' = Stackloc loc"
          show "(case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))"
          proof (cases "loc = l")
            case False
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then have "accessStore loc (stack st) = None" using 8(4) False by (simp add:stackSingleUpdate)
              then show False using a30 a20 a10 assms TypeSafe_def False "2.prems"(1) 
                by (metis option.distinct(1) typeSafeLocExists)
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have a40:"accessStore loc (stack st) = Some x2" using 8(4) False by (simp add:stackSingleUpdate)
              then have a50:"(memory st) = (memory st')" using 8(4) by simp
              then have a60:"(storage st) = (storage st')" using 8(4) by simp
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                    | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                    | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                    | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)" 
                using a10 a20 a30 a40 a50 a60 "2.prems"(1) unfolding TypeSafe_def typeCompat_def by (cases x2; cases t; force)
            qed
          next 
            case sameLoc:True
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then show False using a20 a10 assms(1) sameLoc 8(4) notNoneUpdate[of st' g' loc "(KMemptr p)" st] by simp
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have x2IsP:"x2 = KMemptr p" using 8 sameLoc by auto
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                    | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                    | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                    | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
              proof(cases "x2")
                case (KValue x1)

                then show ?thesis using x2IsP by auto
              next
                case (KCDptr x2)
                then show ?thesis using x2IsP by (simp add:sameLoc)
              next
                case (KMemptr x3)
                then show ?thesis  
                  using a10 a20 lDen memorySame pMCon sameLoc x2IsP by fastforce
              next
                case (KStoptr x4)
                then show ?thesis using x2IsP by (simp add:sameLoc)
              qed
            qed
          qed
        next
          fix x2 assume a20:"l' = Storeloc x2"
          then have "(storage st' (address env)) = (storage st (address env))" using 8(4) by simp
          then show "case t of Storage typ \<Rightarrow> SCon typ x2 (storage st' (address env)) | _ \<Rightarrow> False"  
            using a10 a20 "2.prems"(1) unfolding TypeSafe_def  typeCompat_def by (cases t; force)
        qed
      qed
      have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof(intros)
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st) of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then show ?thesis 
          proof(cases "x1= l")
            case True
            then obtain t''' where tdef:"t = Memory t'''" using lDen a10 Stackloc 2(1) by blast
            then have x2IsP:"\<exists>p. accessStore x1 (stack st) = Some (KMemptr p)" 
            proof(cases "accessStore x1 (stack st)")
              case None
              then show ?thesis using 8 True  2(1) a10 Stackloc unfolding TypeSafe_def typeCompat_def by force
            next
              case (Some a)
              then show ?thesis using tdef 8 True  2(1) a10 Stackloc  unfolding TypeSafe_def typeCompat_def
                by (cases a, force+ )
            qed
            then show ?thesis using a10 Stackloc lDen memorySame pMCon True tdef x2IsP 2(1) unfolding TypeSafe_def typeCompat_def by force
          next
            case False
            then have "accessStore x1 (stack st) = accessStore x1 (stack st')" 
              using stackChanged by auto
            then show ?thesis using tcN a10 Stackloc unfolding typeCompat_def by force
          qed
        next
          case (Storeloc x2)
          then show ?thesis using tcN a10 unfolding typeCompat_def by force
        qed
      qed
    next
      show "unique_locations (denvalue env)" using 2(1) typeSafeUnique by auto
    next
      have "(accounts st) = accounts(st')" using 8 by simp
      then show "balanceTypes (accounts st')" using balanceTypes_def balanceTypes_def 2(1) typeSafeAccounts by simp
    next
      have a0:"compPointers (stack st)  (denvalue env)" using 2(1) storageSame unfolding TypeSafe_def by simp
      show " compPointers (stack st')  (denvalue env)" unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l22 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l22) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l22 = Storeloc stl2)"
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using  2(1) unfolding TypeSafe_def unique_locations_def by simp

        have a3:"l1 \<noteq> Stackloc l \<and> l22 \<noteq> Stackloc l" using a2 t'InDen a1 by auto

        then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True"
        proof(cases "l1 = Storeloc stl1")
          case t1:True
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case True
            then show ?thesis using t1 a0 a1 unfolding compPointers_def by blast
          next
            case False
            then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a3 a1 by simp
            then show ?thesis using a0 a1 t1 unfolding compPointers_def by metis
          qed
        next
          case f1:False
          then have l1Same:"accessStore l1' (stack st') =  accessStore l1' (stack st)" 
            using stackChanged a3 a1 by simp
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case True
            then show ?thesis using f1 a0 a1 l1Same unfolding compPointers_def by metis
          next
            case False
            then have "accessStore l2' (stack st') =  accessStore l2' (stack st)" 
              using stackChanged a3 a1 by simp
            then show ?thesis using a0 a1 l1Same unfolding compPointers_def by metis
          qed
        qed

      qed
    next
      show "svalueTypes (svalue env)" using svalueTypes_def typeSafeSvalue 2(1) by simp
    next
      have "(storage st') = (storage st)" using 8(4) by simp
      then show "safeContract (storage st')" using 2(1) unfolding safeContract_def TypeSafe_def  by auto
    next
      have a10:"toploc (stack st') = toploc (stack st)" using 8(4) unfolding updateStore_def by simp
      then have a20:"\<exists>val. accessStore l (stack st) = Some val" using t'InDen typeSafeLocExists 2(1) TypeSafe_def by blast
      then have a30:"(\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                     \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using 2(1) unfolding TypeSafe_def  lessThanTopLocs_def by simp
      then have a40:"(\<forall>tloc loc. toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                      \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using a10 by simp
      show "lessThanTopLocs (stack st')" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then show "accessStore loc (stack st') = None"
        proof(cases "loc = l")
          case True
          then show ?thesis using * a10 
            by (metis a20 a30 option.distinct(1)) 
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 8(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using 2(1) a40 * a10 False a30 by simp
        qed
      next 
        fix loc y 
        assume *:" accessStore loc (stack st') = Some y "
        show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        proof(cases "loc = l")
          case True
          then show ?thesis using *a10 a20 a30 by simp
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 8(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using * 2(1) a40 by simp
        qed
      qed
    next
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def using 8 by auto
    next 
      show "lessThanTopLocs (memory st')" using 2(1) unfolding TypeSafe_def using 8 by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def  by auto
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using 2(1) t'InDen unfolding TypeSafe_def unique_locations_def by blast

        have a3:"\<forall>dloc1.
     (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
     (if stl1 = stl2 then tp1 = tp2
      else case tp1 of
           MTArray len arr \<Rightarrow>
             (case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
               else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                    else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
           | MTValue val \<Rightarrow>
               (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
               | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

        then show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)"
        proof(cases "stl1 = stl2")
          case same:True
          have "tp1 = tp2"
          proof(cases "stl1 = p")
            case True
            then show ?thesis using pRelations a1 same 
              by (metis (no_types, opaque_lifting) Type.inject(3) lDen stackChanged)
          next
            case False
            then have "l1 \<noteq> l \<and> l2 \<noteq> l" using a1 8 same by auto
            then have "accessStore l1 (stack st') = accessStore l1 (stack st)
                      \<and> accessStore l2 (stack st') = accessStore l2 (stack st)" using stackChanged by simp
            then show ?thesis using a1 a0 same unfolding compMemPtrs_def by presburger
          qed 
          then show ?thesis using same by simp
        next
          case notSame:False

          then show ?thesis 
          proof(cases tp1)
            case mta1:(MTArray x11 x12)
            then show ?thesis 
            proof(cases "tp2")
              case mta2:(MTArray x11' x12')
              then show ?thesis 
              proof(cases "stl1 = p")
                case stl1Isp:True
                then have stl2NotP:"stl2 \<noteq> p" using notSame by simp
                then have "l \<noteq> l2" using stackChanged 8 a1 by auto
                then have sameAccess:"accessStore l2 (stack st) = accessStore l2 (stack st')" 
                  using stackChanged 8 a1 by simp

                have mta1XT:"MTArray x11 x12 = MTArray x t"
                proof(cases "l1 = l")
                  case True
                  then show ?thesis using 8 lDen a1 mta1 by auto
                next
                  case False
                  then have sameAccess:"accessStore l1 (memory st) = accessStore l1 (memory st')" 
                    using stackChanged 8 unfolding accessStore_def updateStore_def by simp
                  then show ?thesis using pRelations mta1 a1 
                    by (metis False stackChanged stl1Isp) 
                qed
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case t1:True
                  then have "CompMemType (memory st') x11' x12' (MTArray x t) stl2 p"
                    using notSame mta1 mta1XT mta2 stl2NotP pRelations a1 notSame sameAccess memorySame stl1Isp by fastforce
                  then show ?thesis using t1 notSame mta1 mta2 mta1XT stl1Isp by simp
                next
                  case f1:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                    case t2:True
                    then have "CompMemType (memory st') x t  (MTArray x11' x12') p stl2"
                      using notSame mta1 mta1XT mta2 stl2NotP pRelations a1 notSame sameAccess memorySame stl1Isp f1 by fastforce
                    then show ?thesis using f1 t2 notSame mta1 mta2 mta1XT stl1Isp by simp
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                      case True
                      then have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1 "
                        using notSame mta1 mta1XT mta2 stl2NotP pRelations a1 notSame sameAccess memorySame stl1Isp f1 f2 
                        by (smt (verit, del_insts) MTypes.inject(1) MTypes.simps(5))
                      then show ?thesis using f1 f2 True notSame mta1 mta2 mta1XT stl1Isp by simp
                    next
                      case False
                      then show ?thesis  using f1 f2  notSame mta1 mta2 mta1XT stl1Isp by auto
                    qed
                  qed
                qed
              next
                case stl1NotP:False
                then have "l \<noteq> l1" using stackChanged 8 a1 by auto
                then have sameAccessL1:"accessStore l1 (stack st) = accessStore l1 (stack st')" 
                  using stackChanged 8 a1 by simp
                then have mconStl1:"MCon tp1 (memory st) stl1" using a1 2(1) unfolding TypeSafe_def typeCompat_def by fastforce

                then show ?thesis 
                proof(cases "stl2 = p")
                  case stl2Isp:True

                  have mta2XT:"MTArray x11' x12' = MTArray x t"
                  proof(cases "l2 = l")
                    case True
                    then show ?thesis using 8 lDen a1 mta2 by auto
                  next
                    case False
                    then have sameAccess:"accessStore l2 (memory st) = accessStore l2 (memory st')" 
                      using stackChanged 8 unfolding accessStore_def updateStore_def by simp
                    then show ?thesis using pRelations mta2 a1 False stackChanged stl2Isp
                      by metis
                  qed
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                    case t1:True
                    then have t11:"TypedMemSubPrefPtrs (memory st')  x t p stl1" 
                      using notSame mta1 mta2XT mta2 stl1NotP pRelations a1 notSame sameAccessL1 memorySame stl2Isp by blast                     
                    then have "CompMemType (memory st') x t (MTArray x11 x12) p stl1"                    
                    proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 p")
                      case True
                      then have "CompMemType (memory st) x11 x12 (MTArray x t) stl1 p"
                        using notSame mta1 mta2XT mta2 stl1NotP pRelations a1 notSame sameAccessL1 memorySame stl2Isp t1 
                        by fastforce
                      then show ?thesis using  mta1 memorySame t11 mconStl1 pMCon
                        by (metis (no_types, opaque_lifting) CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefOneWay)
                    next
                      case False
                      then show ?thesis using notSame mta1 mta2XT mta2 stl1NotP pRelations a1 notSame sameAccessL1 memorySame stl2Isp t1 
                        by fastforce
                    qed
                    then show ?thesis using t1 notSame mta1 mta2 mta2XT stl2Isp by simp
                  next
                    case f1:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                      case t2:True
                      then have "CompMemType (memory st') x11 x12 (MTArray x t) stl1 p"
                        using notSame mta1 mta2XT mta2 stl1NotP pRelations a1 notSame sameAccessL1 memorySame stl2Isp f1 by fastforce
                      then show ?thesis using f1 t2 notSame mta1 mta2 mta2XT stl2Isp by simp
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                        case True
                        then have "\<exists>dt. CompMemType (memory st') x t dt p dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1 "
                          using notSame mta1 mta2XT mta2 stl1NotP pRelations a1 notSame sameAccessL1 memorySame stl2Isp f1 f2 
                          by (smt (verit, del_insts) MTypes.inject(1) MTypes.simps(5))
                        then show ?thesis using f1 f2 True notSame mta1 mta2 mta2XT stl2Isp by simp
                      next
                        case False
                        then show ?thesis  using f1 f2  notSame mta1 mta2 mta2XT stl2Isp by auto
                      qed
                    qed
                  qed
                next
                  case f4:False
                  then have "l \<noteq> l2" using stackChanged 8 a1 by auto
                  then have sameAccessL2:"accessStore l2 (stack st) = accessStore l2 (stack st')" 
                    using stackChanged 8 a1 by simp
                  then show ?thesis using a1 a3 notSame sameAccessL2 sameAccessL1 
                    by (metis (lifting) ext memorySame)
                qed
              qed

            next
              case mtv1:(MTValue x2)
              then have stl2NotP:"stl2 \<noteq> p" using pRelations a1 notSame 
                by (metis MTypes.distinct(1) Type.inject(3) lDen stackChanged) 
              then show ?thesis 
              proof(cases " TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                case t2:True
                have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2"
                proof(cases "stl1 = p")
                  case True
                  then show ?thesis using notSame mtv1 mta1 stl2NotP pRelations a1 notSame t2 
                    by (metis (mono_tags, lifting) MTypes.distinct(1) MTypes.inject(1) MTypes.simps(6) Type.inject(3) lDen memorySame stackChanged)
                next
                  case False
                  then have "l1 \<noteq> l \<and> l2 \<noteq> l" using a1 8 stl2NotP by auto
                  then have "accessStore l1 (stack st') = accessStore l1 (stack st)
                      \<and> accessStore l2 (stack st') = accessStore l2 (stack st)" using stackChanged by simp
                  then have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" using a1  mta1 mtv1 t2 notSame a3 memorySame unfolding compMemPtrs_def by simp
                  then show ?thesis using a1  mta1 mtv1 t2 notSame a0 memorySame unfolding compMemPtrs_def by simp
                qed
                then show ?thesis using notSame mtv1 mta1 stl2NotP pRelations a1 notSame 
                  by simp
              next
                case False
                then show ?thesis using notSame mta1 mtv1 by simp
              qed
            qed
          next
            case mtv1:(MTValue x2)
            then have stl1NotP:"stl1 \<noteq> p" using pRelations a1 notSame 
              by (metis MTypes.distinct(1) Type.inject(3) lDen stackChanged) 
            then show ?thesis 
            proof (cases tp2)
              case mta1:(MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st')  x11 x12 stl2 stl1")
                case t2:True
                then have "CompMemType (memory st') x11 x12 (MTValue x2) stl2 stl1"  
                proof(cases "stl2 = p")
                  case True
                  then show ?thesis using notSame mtv1 mta1 stl1NotP pRelations a1 notSame t2 
                    by (metis (mono_tags, lifting) MTypes.distinct(1) MTypes.inject(1) MTypes.simps(6) Type.inject(3) lDen memorySame stackChanged)
                next
                  case False
                  then have "l1 \<noteq> l \<and> l2 \<noteq> l" using a1 8 stl1NotP by auto
                  then have "accessStore l1 (stack st') = accessStore l1 (stack st)
                      \<and> accessStore l2 (stack st') = accessStore l2 (stack st)" using stackChanged by simp
                  then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" using a1  mta1 mtv1 t2 notSame a3 memorySame unfolding compMemPtrs_def by simp
                  then show ?thesis using a1  mta1 mtv1 t2 notSame a0 memorySame unfolding compMemPtrs_def by simp
                qed
                then show ?thesis using notSame mtv1 mta1 stl1NotP pRelations a1 notSame 
                  by simp
              next
                case False
                then show ?thesis using notSame mtv1 mta1 by simp
              qed
            next
              case mtv2:(MTValue x2)
              then show ?thesis using notSame mtv1 by simp
            qed
          qed
        qed
      qed
    next 
      show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using 8 by simp
    next 
      have "accounts st'= accounts st" using 8 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 8 unfolding fullyInitialised_def accessStore_def updateStore_def  by auto

    qed
  next
    case (9 p x t g l t' g' p' s)

    obtain t''' where t''Def:"t' = STArray x t''' " using 9(3) 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    have sameStack:"(stack st) = (stack st')" using 9 unfolding accessStore_def updateStore_def by auto
    have sameMemory:"memory st' = memory st " using 9 by auto
    have lInDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[of lv env cd g st l "Storage t'"] 9(2) by simp
    have nonLocChanged:"\<forall>t' locs. \<not> LSubPrefL2 locs p' \<or> locs = p' \<longrightarrow> accessStorage t' locs (storage st (address env)) = accessStorage t' locs s" 
      using 9 unfolding cpm2s_def using  cpm2sSingleChange[of p p' t "memory st" "(storage st (address env))" x s]  
      by fastforce
    have a30:" \<forall>locs t' t''.
       cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> p' \<and> \<not> TypedStoSubpref locs p' (STArray x t') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs s" 
      using  9(5) unfolding cpm2s_def using cpm2sSingleChange2[of p  "p'" t  "memory st" "(storage st (address env))" x s ]  by simp
    then have a35:"\<forall>locs t''. locs \<noteq> p' \<and> \<not> TypedStoSubpref locs p' (STArray x t''') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs (storage st' (address env))" 
      using 9 t''Def by auto
    have mInStd:"s = storage st' (address env)" using 9 by simp

    have p'MCon:"SCon t' p' (storage st (address env))" using 2 9 unfolding TypeSafe_def typeCompat_def using lInDen 
      by (auto split:Denvalue.splits option.splits Stackvalue.splits Type.splits)

    have MConsrc:"MCon (MTArray x t) (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) (extractValueType (KMemptr p)) \<and>
        (\<exists>xx. KMemptr p = KMemptr xx) \<and>
        (\<exists>stloc tp'' pa.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KMemptr p = KMemptr pa \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pa \<and>
                 tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pa (extractValueType (KMemptr p)))))"
      using 2(1) 9(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KMemptr p" "Memory (MTArray x t)" g] 
        2(3) unfolding fullyInitialised_def
      by (auto split:Type.splits if_splits )

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have SCondest:"SCon (STArray x t''') p' s" using  9 unfolding cpm2s_def
      using MCon_cpm2s[of p p' t  "memory st" "(storage st (address env))" x s t'''] t''Def MConsrc extractValueType.simps(2) by simp
    then have SCondest2:"SCon (STArray x t''') p' (storage st' (address env))" 
      by (simp add: mInStd)
    then have SCondest3:"SCon t' p' (storage st' (address env))" 
      by (simp add: mInStd t''Def)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 9 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st')  (denvalue env)"  unfolding compPointers_def 
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "TypedStoSubpref stl2 stl1 tp1")
          case True
          then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
        next
          case f1:False
          then show ?thesis 
          proof(cases "TypedStoSubpref stl1 stl2 tp2")
            case True
            then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
          next
            case False
            then show ?thesis using f1 by simp
          qed
        qed
      qed
    next 
      have "safeContract (storage st)" using 2(1) unfolding TypeSafe_def by simp 

      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 9 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 9 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  using sameStack * ** unfolding lessThanTopLocs_def by auto
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      show "lessThanTopLocs (memory st')" using sameMemory unfolding lessThanTopLocs_def 
        by (simp add: limitSt limitSt1)
    next 
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"

        show " case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack  unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def   typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
          next
            case (KMemptr x3)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack sameMemory unfolding TypeSafe_def typeCompat_def by (cases t''; fastforce)
          next
            case (KStoptr x4)  
            then obtain struct where structDef: "t'' = Storage struct" 
              using Stackloc adef inDen Stackloc 2(1) sameStack 
              unfolding TypeSafe_def typeCompat_def
              by (cases t''; fastforce)

            have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Stackloc l) |\<in>| fmran (denvalue env) \<and>
              (l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4) \<or> l' = Storeloc x4) \<and>
              (accessStore l (stack st) = Some (KStoptr p')) \<longrightarrow>
              (if TypedStoSubpref p' x4 struct then CompStoType struct  (STArray x t''') x4 p'
               else if TypedStoSubpref x4 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x4 else True))" 
              using 2(1) 9(3) lInDen inDen Stackloc structDef KStoptr unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref p' x4 struct then CompStoType struct  (STArray x t''') x4 p'
             else if TypedStoSubpref x4 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x4 else True)"
              using  9(4) lInDen inDen Stackloc structDef KStoptr  t''Def
              by (simp add: adef sameStack)

            have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Stackloc adef inDen Stackloc 2(1) sameStack structDef KStoptr 
              by fastforce

            have "SCon struct x4 (storage st' (address env))" 
            proof(cases "TypedStoSubpref p' x4 struct")
              case True
              then have "CompStoType struct (STArray x t''') x4 p'" using cmpStoPtr2 by simp
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast

            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x4 p'  (STArray x t''')")
                case True
                then have "CompStoType t' struct p' x4 " using cmpStoPtr2 f1 t''Def by simp
                then show ?thesis using SCondest3 SCon_imps_sublocs by blast

              next
                case False
                have notSame:"x4 \<noteq> p'" using False by auto
                have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> p' " using f1 by blast
                have k8:"\<forall>locs. TypedStoSubpref locs p' (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False by auto
                show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
              qed
            qed
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack KStoptr structDef by simp
          qed

        next
          case (Storeloc x2)
          then obtain struct where structDef: "t'' = Storage struct" using Storeloc  inDen  2(1) sameStack unfolding TypeSafe_def typeCompat_def
            by (cases t''; fastforce)

          have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Stackloc l) |\<in>| fmran (denvalue env) \<and>
               l' = Storeloc x2) \<and>
              (accessStore l (stack st) = Some (KStoptr p')) \<longrightarrow>
              (if TypedStoSubpref p' x2 struct then CompStoType struct  (STArray x t''') x2 p'
               else if TypedStoSubpref x2 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x2 else True)" 
            using 2(1) 9(3) lInDen inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

          then have cmpStoPtr2:"(if TypedStoSubpref p' x2 struct then CompStoType struct  (STArray x t''') x2 p'
               else if TypedStoSubpref x2 p'  (STArray x t''') then CompStoType  (STArray x t''') struct p' x2 else True)"
            using  9(4) lInDen inDen Storeloc structDef t''Def by (simp add: sameStack)

          have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
            by fastforce

          have "SCon struct x2 (storage st' (address env))" 
          proof(cases "TypedStoSubpref p' x2 struct")
            case True
            then have "CompStoType struct (STArray x t''') x2 p'" using cmpStoPtr2 by simp
            then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
              by blast
          next
            case f1:False
            then show ?thesis 
            proof(cases "TypedStoSubpref x2 p'  (STArray x t''')")
              case True
              then have "CompStoType t' struct p' x2 " using cmpStoPtr2 f1 t''Def by simp
              then show ?thesis using SCondest3  SCon_imps_sublocs by blast
            next
              case False
              have notSame:"x2 \<noteq> p'" using False by auto
              have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> p' " using f1 by blast
              have k8:"\<forall>locs. TypedStoSubpref locs p' (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False by auto
              show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
            qed
          qed
          then show ?thesis using Storeloc  inDen  2(1) sameStack Storeloc structDef by simp
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd" using sameStack by simp
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      then show "compMemPtrs (stack st') (memory st') (denvalue env)" using sameStack sameMemory by auto

    next 
      have "accounts st'= accounts st" using 9 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 9 unfolding fullyInitialised_def  by auto

    qed                       
  next
    case (10 p x t g l t' g' s)

    obtain t''' where t''Def:"t' = STArray x t''' " using 10(3) 
      by (metis STypes.exhaust cps2mTypeCompatible.simps(2,4,6))
    have sameStack:"(stack st) = (stack st')" using 10 unfolding accessStore_def updateStore_def by auto
    have sameMemory:"memory st' = memory st " using 10 by auto
    have nonLocChanged:"\<forall>t' locs. \<not> LSubPrefL2 locs l \<or> locs = l \<longrightarrow> accessStorage t' locs (storage st (address env)) = accessStorage t' locs s" 
      using 10(4) unfolding cpm2s_def using  cpm2sSingleChange[of p l t "memory st" "(storage st (address env))" x s]  
      by fastforce
    have a30:" \<forall>locs t' t''.
       cps2mTypeCompatible (STArray x t') (MTArray x t) \<and> locs \<noteq> l \<and> \<not> TypedStoSubpref locs l (STArray x t') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs s" 
      using  10(4) unfolding cpm2s_def using cpm2sSingleChange2[of p  "l" t "memory st" "(storage st (address env))" x s ]  
      by simp
    then have a35:"\<forall>locs t''. locs \<noteq> l \<and> \<not> TypedStoSubpref locs l (STArray x t''') \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs (storage st' (address env))" 
      using 10 t''Def by auto
    have mInStd:"s = storage st' (address env)" using 10 by simp

    have MConsrc:"MCon (MTArray x t) (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) (extractValueType (KMemptr p)) \<and>
        (\<exists>xx. KMemptr p = KMemptr xx) \<and>
        (\<exists>stloc tp'' pa.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KMemptr p = KMemptr pa \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pa \<and>
                 tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pa (extractValueType (KMemptr p)))))"
      using 2(1) 10(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KMemptr p" "Memory (MTArray x t)" g] 
      using 2(3) unfolding fullyInitialised_def
      by (auto split:Type.splits if_splits )

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have SCondest:"SCon (STArray x t''') l s" using  10 unfolding cpm2s_def
      using MCon_cpm2s[of p l t "memory st" "(storage st (address env))" x s t'''] t''Def MConsrc extractValueType.simps(2) by auto
    then have SCondest2:"SCon (STArray x t''') l (storage st' (address env))" 
      by (simp add: mInStd)
    then have SCondest3:"SCon t' l (storage st' (address env))" 
      by (simp add: mInStd t''Def)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 10 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st')  (denvalue env)"  unfolding compPointers_def 
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "TypedStoSubpref stl2 stl1 tp1")
          case True
          then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
        next
          case f1:False
          then show ?thesis 
          proof(cases "TypedStoSubpref stl1 stl2 tp2")
            case True
            then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
          next
            case False
            then show ?thesis using f1 by simp
          qed
        qed
      qed
    next 
      have "safeContract (storage st)" using 2(1) unfolding TypeSafe_def by simp 

      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 10 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 10 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  using sameStack * ** unfolding lessThanTopLocs_def by auto
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      show "lessThanTopLocs (memory st')" using sameMemory unfolding lessThanTopLocs_def 
        by (simp add: limitSt limitSt1)
    next 
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"

        show " case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack  unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def   typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
          next
            case (KMemptr x3)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack sameMemory unfolding TypeSafe_def typeCompat_def by (cases t''; fastforce)
          next
            case (KStoptr x4)  
            then obtain struct where structDef: "t'' = Storage struct" using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def typeCompat_def
              by (cases t''; fastforce)

            have "SCon struct x4 (storage st' (address env))" 
            proof(cases rule:lexpStorageG[OF 2(1) 10(2) 2(3)])
              case lInDen:1
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage (STArray x t'''), Storeloc l) |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t''') x4 l
                 else if TypedStoSubpref x4 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x4 else True)" 
                using 2(1) 10(3) lInDen inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t''') x4 l
                 else if TypedStoSubpref x4 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x4 else True)"
                using  10(3) lInDen inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l x4 struct")
                case True
                then have "CompStoType struct (STArray x t''') x4 l" using cmpStoPtr2 by simp
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast

              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l  (STArray x t''')")
                  case True
                  then have "CompStoType t' struct l x4 " using cmpStoPtr2 f1 t''Def by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs by blast
                next
                  case False
                  have notSame:"x4 \<noteq> l" using False by auto
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False by auto
                  show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
                qed
              qed
              then show ?thesis by simp
            next
              case sub2:(2 l''' t)
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t, Storeloc l''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)" 
                using 2(1) 10(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)"
                using  10(3) sub2 inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t''') x4 l" using sub2 
                  using CompStoType_trns t''Def by blast
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis 
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def True by simp
                    moreover have "CompStoType t t' l''' x4" using t5 sub2 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def  True by simp                
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x4\<close> a35 scl''' sub2(2) t''Def)
                    qed
                  qed
                next
                  case False                                                             
                  then have asm10:"\<not> TypedStoSubpref l x4 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub2 by blast
                  then have asm20:"\<not> TypedStoSubpref x4 l t'" using sub2 NotReachablePrnt_imps_notReachableChild False f1 by blast
                  have notSame:"x4 \<noteq> l" using False sub2 by blast
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 sub2 asm10 asm20  by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False sub2 t''Def asm10 asm20 by blast
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
                qed
              qed

              then show ?thesis by simp
            next
              case sub3:(3 l''' t l'''')
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t, Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) \<and> accessStore l'''' (stack st) = Some (KStoptr l''')
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)" 
                using 2(1) 10(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t x4 l'''
                 else if TypedStoSubpref x4 l''' t then CompStoType t struct l''' x4 else True)"
                using  10(3) sub3 inDen adef Stackloc KStoptr structDef t''Def sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub3 by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t''') x4 l" using sub3 
                  using CompStoType_trns t''Def by blast
                then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis 
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def True by simp
                    moreover have "CompStoType t t' l''' x4" using t5 sub3 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then have " CompStoType t struct l''' x4" using cmpStoPtr2 f1 t''Def  True by simp                
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x4\<close> a35 scl''' sub3(3) t''Def)
                    qed
                  qed
                next
                  case False                                                             
                  then have asm10:"\<not> TypedStoSubpref l x4 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                  then have asm20:"\<not> TypedStoSubpref x4 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                  have notSame:"x4 \<noteq> l" using False sub3 by blast
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x4" using False sub3 t''Def asm10 asm20 by blast
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
                qed
              qed
              then show ?thesis by simp
            qed
            then show ?thesis using Stackloc  inDen  2(1) sameStack KStoptr adef structDef by simp
          qed
        next
          case (Storeloc x2)
          then obtain struct where structDef: "t'' = Storage struct" using Storeloc  inDen  2(1) sameStack unfolding TypeSafe_def typeCompat_def
            by (cases t''; fastforce)

          have "SCon struct x2 (storage st' (address env))" 
          proof(cases rule:lexpStorageG[OF 2(1) 10(2) 2(3)])
            case lInDen:1
            have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t'''), Storeloc l) |\<in>| fmran (denvalue env) \<and>
               l' = Storeloc x2) 
               \<longrightarrow>
              (if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t''') x2 l
               else if TypedStoSubpref x2 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x2 else True)" 
              using 2(1) 10(3) lInDen inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t''') x2 l
               else if TypedStoSubpref x2 l  (STArray x t''') then CompStoType  (STArray x t''') struct l x2 else True)"
              using  10(3) lInDen inDen Storeloc structDef t''Def sameStack by simp

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l x2 struct")
              case True
              then have "CompStoType struct (STArray x t''') x2 l" using cmpStoPtr2 by simp
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast

            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l  (STArray x t''')")
                case True
                then have "CompStoType t' struct l x2 " using cmpStoPtr2 f1 t''Def by simp
                then show ?thesis using SCondest3  SCon_imps_sublocs by blast
              next
                case False
                have notSame:"x2 \<noteq> l" using False by auto
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False by auto
                show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
              qed
            qed
            then show ?thesis by simp
          next
            case sub2:(2 l''' t)
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t, Storeloc l''') |\<in>| fmran (denvalue env) )
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)" 
              using 2(1) 10(3) inDen  Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)"
              using  10(3) sub2 inDen Storeloc  structDef t''Def sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t''') x2 l" using sub2 
                using CompStoType_trns t''Def by blast
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def True by simp
                  moreover have "CompStoType t t' l''' x2" using t5 sub2 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis 
                      using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x2\<close> a35 scl''' sub2(2) t''Def)
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub2 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub2 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub2 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub2 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False sub2 t''Def asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
              qed
            qed

            then show ?thesis by simp
          next
            case sub3:(3 l''' t l'''')
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t, Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 accessStore l'''' (stack st) = Some (KStoptr l'''))
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)" 
              using 2(1) 10(3) inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t x2 l'''
                 else if TypedStoSubpref x2 l''' t then CompStoType t struct l''' x2 else True)"
              using  10(3) sub3 inDen Storeloc structDef t''Def sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub3 by fastforce

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t''') x2 l" using sub3 
                using CompStoType_trns t''Def by blast
              then show ?thesis using SCondest2  SConx4Old a35 t''Def php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def True by simp
                  moreover have "CompStoType t t' l''' x2" using t5 sub3 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t struct l''' x2" using cmpStoPtr2 f1 t''Def  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis 
                      using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t struct l''' x2\<close> a35 scl''' sub3(3) t''Def)
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub3 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t''') \<longrightarrow> locs \<noteq> x2" using False sub3 t''Def asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 t''Def by blast
              qed
            qed
            then show ?thesis by simp
          qed
          then show ?thesis using Storeloc  inDen  2(1) sameStack Storeloc structDef by simp
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd " using sameStack by simp
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      then show "compMemPtrs (stack st') (memory st') (denvalue env)" using sameStack sameMemory by auto
    next 
      have "accounts st'= accounts st" using 10 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 10 unfolding fullyInitialised_def  by auto
   
    qed             
  next
    case (11 p x t g l t' g')
    have temp:"TypeSafe env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd" 
      using 2(1) by simp
    have ttt:"fullyInitialised env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>))" using 2(3) unfolding fullyInitialised_def by simp
    then show ?thesis
    proof(cases rule:lexpIndexMem[OF 11(2) temp ttt])
      case lInfo:(1 x21 x22 tp tParent l' l'' prnt len' arr' i)
      have sameStack:"(stack st') = stack st" using 11 unfolding accessStore_def updateStore_def by auto
      have sameStorage:"storage st'  = storage st " using 11 by auto

      have nonLocChanged:"\<forall>locs. locs \<noteq> l \<longrightarrow> accessStore locs  (memory st) = accessStore locs  (memory st')" 
        using 11 unfolding updateStore_def accessStore_def by simp

      have MConsrc:"MCon (MTArray x t) (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) (extractValueType (KMemptr p)) \<and>
        (\<exists>xx. KMemptr p = KMemptr xx) \<and>
        (\<exists>stloc tp'' pa.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue env) \<and>
            accessStore stloc (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pa) \<and>
            (tp'' = (MTArray x t) \<and> KMemptr p = KMemptr pa \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pa \<and>
                 tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pa (extractValueType (KMemptr p)))))"
        using 2(1) 11(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KMemptr p" "Memory (MTArray x t)" g] 
        using 2(3) unfolding fullyInitialised_def
        by (auto split:Type.splits if_splits )


      then obtain pParent pParentT pParentPtr where 
        pOrigin:"MCon (MTArray x t) (memory (st)) (extractValueType (KMemptr p)) \<and>(Memory pParentT, Stackloc pParent) |\<in>| fmran (denvalue env) \<and>
            accessStore pParent (stack (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) = Some (KMemptr pParentPtr) \<and>
            (pParentT = (MTArray x t) \<and> KMemptr p = KMemptr pParentPtr \<or>
             (\<exists>len arr.
                 extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
                 pParentT = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p))))"
        by force
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      then have pParentRelations:"(\<forall>tp2 l1 l2 stl2 dloc1.
        
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if pParentPtr = stl2 then pParentT = tp2
         else case pParentT of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                  else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                       else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                  | MTValue val2 \<Rightarrow> True)))" 
        using compMemPtrs_def pOrigin  by force
      have pMCon:"MCon (MTArray x t) (memory st) p" using pOrigin by force

(*All locations that can get to p must have a parent type of MTArray x t and all locations lower than p similarly*)
      have pRelations:"(\<forall>tp2  l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if p = stl2 then (MTArray x t) = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 p then CompMemType (memory st) len2 arr2 (MTArray x t) stl2 p
                  else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTArray len2 arr2) p stl2
                       else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTValue val2) p stl2 else True
              ))"
      proof intros 
        fix tp2 l2 stl2 dloc1
        assume in1:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)"

        have stl2Mcon:"MCon tp2 (memory st) stl2" using 2(1) unfolding TypeSafe_def typeCompat_def using in1 by fastforce
        have pParentMcon:"MCon pParentT (memory st) pParentPtr" using 2(1) unfolding TypeSafe_def typeCompat_def using pOrigin by force

        show "if p = stl2 then MTArray x t = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 p then CompMemType (memory st) len2 arr2 (MTArray x t) stl2 p
              else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTArray len2 arr2) p stl2
                   else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st) x t (MTValue val2) p stl2 else True"
        proof(cases "p = stl2")
          case t1:True
          then show ?thesis 
          proof(cases "p = pParentPtr")
            case True
            then have "pParentT = MTArray x t" using t1 pOrigin by simp
            then show ?thesis using pParentRelations in1 t1 True by auto
          next
            case False
            then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
              using pOrigin by auto
            have noeq:"pParentPtr \<noteq> stl2" using t1 False by simp

            then have "(if pParentPtr = stl2 then pParentT = tp2
        else case pParentT of
             MTArray len arr \<Rightarrow>
               (case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
             | MTValue val \<Rightarrow>
                 (case tp2 of
                 MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                 | MTValue val2 \<Rightarrow> True))"
              using pParentRelations pOrigin in1 lenDef by fast
            then have in2:" case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True"
              using    lenDef noeq by simp

            then show ?thesis using pParentRelations
            proof(cases tp2)
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
                case True
                then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 MTArray by simp
                then show ?thesis using t1 lenDef stl2Mcon  pParentMcon 
                  by (metis (lifting) CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MTArray TypedMemSubPrefOneWay extractValueType.simps(3))
              next
                case f2:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                  case True
                  then have "CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using f2 in2 noeq MTArray by simp
                  then show ?thesis  using t1 lenDef stl2Mcon  pParentMcon  
                    by (metis CompMemTypeSameLocsSameType MTArray extractValueType.simps(3))
                next
                  case False
                  then show ?thesis using t1 lenDef stl2Mcon  pParentMcon  f2 in2 noeq MTArray 
                    using CompMemType_imps_TypedMemSubPrefPtrs by force
                qed
              qed
            next
              case (MTValue x2)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                case True
                then have "CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2" using in2 
                  using MTValue by auto
                then show ?thesis using t1 lenDef stl2Mcon  pParentMcon 
                  using CompMemTypeSameLocsSameType 
                  by (metis MTValue extractValueType.simps(3))
              next
                case False
                then show ?thesis 
                  using CompMemType_imps_TypedMemSubPrefPtrs lenDef t1 by auto
              qed
            qed
          qed
        next
          case False

          have in3:"\<forall>dloc1. (if pParentPtr = stl2 then pParentT = tp2
        else case pParentT of
             MTArray len arr \<Rightarrow>
               (case tp2 of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue val2) pParentPtr stl2 else True)
             | MTValue val \<Rightarrow>
                 (case tp2 of
                 MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 pParentPtr then CompMemType (memory st) len2 arr2 (MTValue val) stl2 pParentPtr else True
                 | MTValue val2 \<Rightarrow> True))" using pParentRelations in1 by auto
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have stl2Mcon:"MCon (MTArray x11 x12) (memory st) stl2" using stl2Mcon by blast
            then show ?thesis 
            proof(cases "p = pParentPtr")
              case t3:True
              then have typesame:"pParentT = MTArray x t" using pOrigin by simp
              then have in2:"if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p then CompMemType (memory st) x11 x12 (MTArray  x t) stl2 p
                 else if TypedMemSubPrefPtrs (memory st) x t p stl2 then CompMemType (memory st)  x t (MTArray x11 x12) p stl2
                      else if TypedMemSubPrefPtrs (memory st) x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1 else True" using in3 MTArray t3 False by fastforce
              then show ?thesis using in2 False MTArray by simp
            next
              case f2:False
              then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
                using pOrigin by auto
              then have in2:"\<forall>dloc1. if pParentPtr = stl2 then pParentT = tp2 
                else if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr then CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr
                 else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2
                      else if TypedMemSubPrefPtrs (memory st) len arr pParentPtr dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                           then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt pParentPtr dloc1 else True" 
                using in3 MTArray False f2 by fastforce

              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p")
                case t3:True
                have "CompMemType (memory st) x11 x12 (MTArray x t) stl2 p" 
                proof(cases "pParentPtr = stl2")
                  case t4:True
                  then show ?thesis using t3 in2 MTArray False pOrigin by simp
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
                    case t5:True
                    then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 f5 by simp
                    then show ?thesis using lenDef stl2Mcon  pParentMcon t5 t3 MTArray compMemTypes_trns[of "memory st" _ _ "MTArray x t" _ p x11 x12 stl2] by auto
                  next
                    case f6:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                      case t6:True
                      then have " CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using in2 f6 f5 by simp
                      then show ?thesis  using lenDef stl2Mcon  pParentMcon t6 t3 MTArray f5 pMCon
                          CompMemType_asc_withSharedTarget[of "memory st" len arr x11 x12 pParentPtr stl2 "MTArray x t" p] by simp
                    next
                      case False
                      have "TypedMemSubPrefPtrs (memory st) len arr pParentPtr p" 
                        using lenDef CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len arr "MTArray x t" pParentPtr p] by simp
                      moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p" using t3 by simp
                      ultimately have "\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 p \<and> CompMemType (memory st) len arr dt pParentPtr p" 
                        using in2 False f5 f6 by simp
                      then show ?thesis using lenDef stl2Mcon  pParentMcon  t3 MTArray f5 pMCon in2 f6 f5 
                        by (metis CompMemTypeSameLocsSameType extractValueType.simps(3))
                    qed
                  qed
                qed
                then show ?thesis by (simp add: False MTArray t3)
              next
                case f3:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) x t p stl2")
                  case t3:True
                  have "CompMemType (memory st) x t (MTArray x11 x12) p stl2" 
                  proof(cases "pParentPtr = stl2")
                    case t4:True
                    then show ?thesis using t3 in2 MTArray False pOrigin f3  
                      using CompMemType_imps_TypedMemSubPrefPtrs by auto
                  next
                    case f5:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 pParentPtr")
                      case t5:True
                      then have "CompMemType (memory st) x11 x12 (MTArray len arr) stl2 pParentPtr" using in2 f5 by simp
                      then show ?thesis using lenDef stl2Mcon  pParentMcon t5 t3 MTArray compMemTypes_trns 
                        by (metis CompMemType_imps_TypedMemSubPrefPtrs f3 extractValueType.simps(3))
                    next
                      case f6:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                        case t6:True
                        then have " CompMemType (memory st) len arr (MTArray x11 x12) pParentPtr stl2" using in2 f6 f5 by simp
                        then show ?thesis  using lenDef stl2Mcon  pParentMcon t6 t3 MTArray f5 pMCon
                            CompMemType_asc_withSharedTarget 
                          by (metis extractValueType.simps(3))
                      next
                        case False
                        have "TypedMemSubPrefPtrs (memory st) len arr pParentPtr p" 
                          using lenDef CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len arr "MTArray x t" pParentPtr p] by simp
                        moreover have "TypedMemSubPrefPtrs (memory st) x t p stl2" using t3 by simp
                        ultimately show ?thesis using lenDef stl2Mcon  pParentMcon  t3 MTArray f5 pMCon in2 f6 f5 
                          by (metis False TypedMemSubPrefPtrs_trns extractValueType.simps(3))
                      qed
                    qed
                  qed
                  then show ?thesis using False MTArray t3 f3 by simp
                next
                  case f4:False
                  then show ?thesis 
                    by (smt (verit, ccfv_threshold) CompMemType_asc_withSharedTarget CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon False MTArray MTypes.simps(5) TypedMemSubPrefPtrs_trns f3
                        in2 lenDef pParentMcon sharedParentSharedSubLocTypes extractValueType.simps(3) stl2Mcon)
                qed
              qed
            qed
          next
            case (MTValue x2)
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x t p stl2")
              case t1:True
              have "CompMemType (memory st) x t (MTValue x2) p stl2" 
              proof(cases "p = pParentPtr")
                case t3:True
                then have "pParentT = MTArray x t" using pOrigin by simp
                then have "if TypedMemSubPrefPtrs (memory st) x t pParentPtr stl2 then CompMemType (memory st) x t (MTValue x2) pParentPtr stl2 else True"
                  using in3  t3 MTValue False  by simp
                then have "CompMemType (memory st) x t (MTValue x2) pParentPtr stl2" using t1 t3 by simp
                then show ?thesis using in3  t1 MTValue False 
                  using t3 by auto
              next
                case False
                then obtain len arr where lenDef:" (extractValueType (KMemptr p) \<noteq> pParentPtr \<and>
         pParentT = MTArray len arr \<and> CompMemType (memory (st)) len arr (MTArray x t) pParentPtr (extractValueType (KMemptr p)))"
                  using pOrigin by auto

                then have in2:"if pParentPtr = stl2 then pParentT = tp2 else 
                          if TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2 then CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2 else True"
                  using  in3  lenDef MTValue by (auto split:if_splits MTypes.split)

                then show ?thesis
                proof(cases "pParentPtr = stl2")
                  case t5:True
                  then have "pParentT = tp2" using in2 by simp
                  then show ?thesis using MTValue lenDef by auto
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) len arr pParentPtr stl2")
                    case t6:True
                    then have "CompMemType (memory st) len arr (MTValue x2) pParentPtr stl2" using in2 f5 by simp
                    then show ?thesis 
                      by (metis CompMemType_asc_withSharedTarget CompTypeRemainsMCon lenDef pParentMcon extractValueType.simps(3) t1)
                  next
                    case f6:False
                    then show ?thesis 
                      by (metis CompTypeRemainsMCon TypedMemSubPrefPtrs_trns lenDef pParentMcon extractValueType.simps(3) t1)
                  qed
                qed
              qed

              then show ?thesis 
                by (simp add: False MTValue)
            next
              case f2:False
              then show ?thesis using MTValue  False by simp
            qed
          qed
        qed
      qed

      obtain len subT where tParentType:"tParent = MTArray len subT" using lInfo by blast
      then obtain p'' where lOrigin:"accessStore l (memory (st)) = Some (MPointer p'')" 
        and  compType:"CompMemType (memory (st\<lparr>gas := g\<rparr>)) len subT (MTArray x t) l'' p''" 
        and lsublocs:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = (MTArray x t) \<and> MCon (MTArray len' arr') (memory (st)) prnt" 
        and lsublocs3:"(prnt = l'' \<and> len = len' \<and> arr' = subT \<or> CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt)"
        using lInfo 11(3) by force
      then have lsublocs2:" CompMemType (memory (st)) len' arr' (MTArray x t) prnt p''" 
        using 11(3) CompMemType.simps(2) by blast
      then have bb9:"\<forall>subT subloc. CompMemType (memory (st)) len' arr' subT prnt subloc \<and> subloc = p''
                                  \<longrightarrow> subT = (MTArray x t)" 
        using CompMemTypeSameLocsSameType lsublocs by blast

      have mconPrnt:"MCon (MTArray len' (MTArray x t)) (memory st) prnt" using lsublocs by auto
      have ldef:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len'" using lsublocs by auto

      have t6:"(Memory tParent,  Stackloc l') |\<in>| fmran (denvalue env)" using lInfo by blast
      have t7:" MCon (MTArray len subT) (memory (st)) l''" using lInfo 
        using tParentType by auto
      then have mconlOld:"MCon (MTArray x t) (memory st) p''" using 11(3) lInfo lOrigin by auto

      have mcP:"MCon (MTArray x t) (memory st) p" using MConsrc by force
      have compP:"\<not>CompMemType (memory (st)) x t (MTArray len' (MTArray x t)) p prnt" 
        using MCon_subTypes_imps_noPrnt mcP mconPrnt 
        by simp
      have pNotPrnt:"p \<noteq> prnt" using mcP mconPrnt nonLocChanged
        using MConSubTypes CompMemJustType.simps(2) by blast
      have pSubs:"TypedMemSubPrefPtrs (memory st) len' (MTArray x t) prnt p \<longrightarrow> (\<exists>i'. accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some (MPointer p) \<and> i'<len')" 
      proof intros
        assume in1:"TypedMemSubPrefPtrs (memory st) len' (MTArray x t) prnt p"
        then obtain i2 l2 where i2Def: "i2<len' \<and> accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st) = Some (MPointer l2) \<and> (l2 = p \<or> TypedMemSubPrefPtrs (memory st) x t l2 p)" 
          unfolding TypedMemSubPrefPtrs.simps by blast
        show "\<exists>i'. accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some (MPointer p) \<and> i' < len'"
        proof(cases "l2 = p")
          case True
          then show ?thesis using i2Def by auto
        next
          case False
          then have in2:"TypedMemSubPrefPtrs (memory st) x t l2 p" using i2Def by simp
          have in3:"\<forall>ta. CompMemJustType t ta \<longrightarrow> \<not> MCon ta (memory st) p" using MConSubTypes[OF mcP] by blast
          have "MCon (MTArray x t) (memory st) l2" using i2Def mconPrnt
            using MCon_imps_sub_Mcon by blast

          then show ?thesis using in3 in2
          proof(induction t arbitrary:l2 x)
            case (MTArray x1 t)
            obtain i3 l3 where i3Def:"i3<x \<and> accessStore (hash l2 (ShowL\<^sub>n\<^sub>a\<^sub>t i3)) (memory st) = Some (MPointer l3) 
                                      \<and> (l3 = p \<or> TypedMemSubPrefPtrs (memory st) x1 t l3 p)"
              using MTArray.prems(3) unfolding TypedMemSubPrefPtrs.simps by auto
            then have mcL3:"MCon (MTArray x1 t) (memory st) l3" using MTArray.prems(1) 
              using MconSameTypeSameAccessWithTyping by blast
            then have notP:"l3 \<noteq> p" using MTArray.prems(3) 
              using MConSubTypes MTArray.prems(2) CompMemJustType.simps(2) by blast
            have "\<forall>taa. CompMemJustType t taa \<longrightarrow> \<not> MCon taa (memory st) p" using MTArray.prems by simp
            moreover have "TypedMemSubPrefPtrs (memory st) x1 t l3 p" using notP i3Def by simp
            ultimately show ?case using MTArray.IH mcL3 by blast
          next
            case (MTValue x')
            then show ?case 
              by (metis CompTypeRemainsMCon TypedMemSubPrefPtrs.simps(1) CompMemJustType.simps(1) CompMemType.simps(1))
          qed
        qed
      qed

      have p''ToPrnt:"\<not>TypedMemSubPrefPtrs (memory st) x t p'' prnt" 
        by (meson CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon TypedMemSubPrefOneWay lsublocs lsublocs2)
      moreover have p''notprnt:"p'' \<noteq>prnt" using lsublocs2 
        using CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame lsublocs by blast
      ultimately have mcP''New:"MCon (MTArray x t) (memory st') p''" using mconlOld limitedMemoryChange[of "memory st" x t p'' prnt i ] nonLocChanged 11 ldef by fastforce

      have mcPrnt:"\<exists>t''. MCon t'' (memory st) prnt \<and> CompMemJustType t'' (MTArray x t) \<and> t'' \<noteq> (MTArray x t)" using mconPrnt by fastforce
      have asf:"\<not>TypedMemSubPrefPtrs (memory st) x t p prnt"  
      proof
        assume in1:"TypedMemSubPrefPtrs (memory st) x t p prnt"
        then show False using mcP mcPrnt  
        proof(induction t arbitrary:x p)
          case (MTArray x1 t)
          then obtain i2 l2 where i2Def: "i2<x \<and> accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st) = Some (MPointer l2)
                                             \<and> (l2 = prnt \<or> TypedMemSubPrefPtrs (memory st) x1 t l2 prnt)"
            unfolding TypedMemSubPrefPtrs.simps  by blast
          then have mcl2:"MCon (MTArray x1 t) (memory st) l2" using MTArray.prems(2) 
            using MCon_imps_sub_Mcon by blast
          then show ?case 
          proof(cases "l2 = prnt")
            case True
            then have "MCon (MTArray x1 t) (memory st)  prnt" using mcl2 by simp
            then show ?thesis 
              by (smt (verit) CompMemTypes_asc MConSubTypes MTArray.prems(3) MTypes.exhaust CompMemJustType.simps(1,2))
          next
            case False
            then have "TypedMemSubPrefPtrs (memory st) x1 t l2 prnt" using i2Def by simp
            then show ?thesis using MTArray.IH[OF _ mcl2] MTArray.prems(3) 
              by (metis CompMemTypes_asc reversable_CompMemJustType_imps_same CompMemJustType.simps(2))
          qed
        next
          case (MTValue x')
          then have "\<exists>i<x. hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i) = prnt" unfolding TypedMemSubPrefPtrs.simps by blast
          then show ?case using MTValue unfolding MCon.simps 
            using lsublocs by fastforce
        qed
      qed

      have mcPNew:"MCon (MTArray x t) (memory st') p" using mcP asf pNotPrnt
      proof(induction t arbitrary: x p)
        case (MTArray x1 t)
        then have  xnotzero:"x \<noteq> 0" unfolding MCon.simps by simp
        have "\<forall>i<x. (case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False 
                                  | MTValue typ \<Rightarrow> MCon (MTArray x1 t) (memory st') (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
               | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) (memory st') loc2 | MTValue Types \<Rightarrow> False)) \<and>
              ((\<exists>p'. accessStore p (memory st') = Some (MPointer p')) \<or> accessStore p (memory st') = None)"
        proof(intros)
          fix i2 assume i2Def:"i2<x"
          have "(hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) \<noteq> l" 
          proof
            assume in1':"hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2) = l"
            then have "p = prnt" using ldef ShowLNatDot 
              using hash_injective by blast
            then show False using MTArray.prems(3) by simp
          qed
          then have sameAccess:"accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by simp
          then obtain p2 where p2Def: "accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = Some (MPointer p2) \<and> MCon (MTArray x1 t) (memory st) p2" using i2Def
            using MTArray.prems by (metis MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum xnotzero)
          then have "\<not> TypedMemSubPrefPtrs (memory st) x1 t p2 prnt" using MTArray.prems 
            using i2Def sameAccess by fastforce
          moreover have "p2 \<noteq> prnt" using MTArray.prems p2Def i2Def 
            by (simp add: sameAccess)
          ultimately have "MCon (MTArray x1 t) (memory st') p2" using MTArray.IH[of x1 p2] p2Def MTArray.prems by blast
          then show "case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') of None \<Rightarrow> False
       | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) (memory st') (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)))
       | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
            using p2Def by simp
          show "(\<exists>p'. accessStore p (memory st') = Some (MPointer p')) \<or> accessStore p (memory st') = None" 
          proof(cases "p = l")
            case True
            then show ?thesis using 11 by simp
          next
            case False
            then show ?thesis using nonLocChanged using MTArray.prems(1) unfolding MCon.simps 
              using i2Def  sameAccess by simp
          qed
        qed
        then show ?case using MCon.simps(2)[of x "(MTArray x1 t)" "memory st'" p ]  xnotzero
          by simp
      next
        case (MTValue x')
        then have xnotzero:"x \<noteq> 0" unfolding MCon.simps by simp
        have "\<forall>i<x. (case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow>
                  (case MTValue x' of MTArray l a \<Rightarrow> False
                  | MTValue typ \<Rightarrow> (case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon x' xa | Some (MPointer t) \<Rightarrow> False))
              | Some (MPointer loc2) \<Rightarrow>
                  (case MTValue x' of MTArray len' arr' \<Rightarrow> (case accessStore loc2 (memory st') of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon x' xa | Some (MPointer t) \<Rightarrow> False)
                  | MTValue Types \<Rightarrow> False))\<and>
             ((\<exists>p'. accessStore p (memory st') = Some (MPointer p')) \<or> accessStore p (memory st') = None)" 
        proof(intros)
          fix i2 assume i2Def:"i2<x"
          then have "(hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) \<noteq> l" using  ldef 
            by (metis MCon_sub_MTVal_imps_val MTValue.prems(1) Memoryvalue.distinct(1) lOrigin option.inject)
          then have sameAccess:" accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') =  accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by simp
          then show "case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') of None \<Rightarrow> False
       | Some (MValue val) \<Rightarrow>
           (case MTValue x' of MTArray l a \<Rightarrow> False
           | MTValue typ \<Rightarrow> (case accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon x' xa | Some (MPointer t) \<Rightarrow> False))
       | Some (MPointer loc2) \<Rightarrow>
           (case MTValue x' of MTArray len' arr' \<Rightarrow> (case accessStore loc2 (memory st') of None \<Rightarrow> False | Some (MValue xa) \<Rightarrow> typeCon x' xa | Some (MPointer t) \<Rightarrow> False)
           | MTValue Types \<Rightarrow> False)" using MTValue(1) i2Def mcon_accessStore xnotzero by (auto split:option.splits Memoryvalue.splits MTypes.splits)
          show "(\<exists>p'. accessStore p (memory st') = Some (MPointer p')) \<or> accessStore p (memory st') = None" 
          proof(cases "p = l")
            case True
            then show ?thesis using 11 by simp
          next
            case False
            then show ?thesis using nonLocChanged using MTValue(1) unfolding MCon.simps 
              using i2Def  sameAccess by simp
          qed
        qed
        then show ?case unfolding MCon.simps using xnotzero
          by simp
      qed

      have mcPrntNew:"MCon (MTArray len' (MTArray x t)) (memory st') prnt" 
      proof -
        have lenNotZero:"len' \<noteq> 0" using lsublocs by auto
        have prntNotL:"prnt \<noteq> l" using ldef 
          by (metis hash_inequality)
        then have p2:"(\<exists>p. accessStore prnt (memory st') = Some (MPointer p)) \<or> accessStore prnt (memory st') = None" 
          using mconPrnt lenNotZero nonLocChanged by simp
        have "\<forall>i<len'.
           (case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
            | Some (MValue val) \<Rightarrow> (case MTArray x t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x t) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
            | Some (MPointer loc2) \<Rightarrow> (case MTArray x t of MTArray len' arr' \<Rightarrow> MCon (MTArray x t) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
        proof(intros)
          fix i1 assume in1:"i1<len'"
          show "case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') of None \<Rightarrow> False
         | Some (MValue val) \<Rightarrow> (case MTArray x t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x t) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)))
         | Some (MPointer loc2) \<Rightarrow> (case MTArray x t of MTArray len' arr' \<Rightarrow> MCon (MTArray x t) (memory st') loc2 | MTValue Types \<Rightarrow> False)"
          proof(cases "i1 = i")
            case True
            then have "(hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) = l" using ldef by simp
            then have "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = Some(MPointer p)" using 11 by simp
            then show ?thesis using mcPNew by simp
          next
            case False
            then have "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st)" using ldef nonLocChanged in1 
              by (metis Read_Show_nat'_id hash_never_equal_sufix)
            then obtain ptr where ptrDef:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st) = Some (MPointer ptr)" using in1 
              using MConArrayPointers lsublocs by blast
            then have ptrMC:"MCon (MTArray x t) (memory st) ptr" using in1 mconPrnt 
              using MCon_imps_sub_Mcon by blast
            moreover have sub2:"\<forall>p ta. MCon ta (memory st) p \<and> CompMemType (memory st) len' (MTArray x t) ta prnt p \<longrightarrow> p \<noteq> prnt" 
              using MConPtrsMustBeSubLocs2[OF mconPrnt] by auto
            moreover have ptrPrnt:"CompMemType (memory st) len' (MTArray x t) (MTArray x t)  prnt ptr" using ptrDef in1 by auto
            ultimately have prtNotPrnt:"ptr \<noteq> prnt" by blast
            have sub3:"\<forall>p ta. CompMemType (memory st) x t ta ptr p \<longrightarrow> p \<noteq> prnt" using ptrPrnt sub2 ptrMC 
              by (metis CompMemType_imps_CompMemJustType CompTypeRemainsMCon MConSubTypes mconPrnt)
            have "MCon (MTArray x t) (memory st') ptr" using ptrMC sub3 prtNotPrnt
            proof (induction t arbitrary:x ptr)
              case (MTArray x1 t)
              then have xnotZero:"x \<noteq> 0" by fastforce
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                 | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) (memory st') loc2 | MTValue Types \<Rightarrow> False)) \<and>
                ((\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None)"
              proof intros
                fix i2 assume i2Def:"i2<x"
                have "ptr  \<noteq> prnt" using MTArray.prems by simp
                then have notL:"(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) \<noteq> l" using ldef ShowLNatDot 
                  using hash_injective by blast
                then have sameAccess:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by auto
                then obtain ptr2 where ptr2Def: "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = Some (MPointer ptr2) \<and> MCon (MTArray x1 t) (memory st) ptr2"
                  using MTArray.prems(1) i2Def 
                  by (metis MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum xnotZero)
                moreover have "\<forall>p taa. CompMemType (memory st) x1 t taa ptr2 p \<longrightarrow> p \<noteq> prnt " using MTArray.prems ptr2Def i2Def 
                  by (metis sameAccess CompMemType.simps(2))
                moreover have "ptr2 \<noteq> prnt" using MTArray.prems ptr2Def i2Def 
                  by (metis sameAccess CompMemType.simps(2))
                ultimately show "case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') of None \<Rightarrow> False
                      | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)))
                      | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) (memory st') loc2 | MTValue Types \<Rightarrow> False)"
                  using MTArray.IH[of x1 ptr2] using ptr2Def by fastforce
                show " (\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None "
                proof(cases "ptr = l")
                  case True
                  then show ?thesis using 11 by simp
                next
                  case False
                  then show ?thesis using nonLocChanged MTArray.prems(1) 
                    using i2Def by fastforce
                qed
              qed
              then show ?case using MCon.simps(2)[of x "MTArray x1 t" "memory st'" ptr] using xnotZero by simp
            next
              case (MTValue x')
              then have xnotZero:"x \<noteq> 0" by fastforce
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                 | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)) \<and>
                ((\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None)"
              proof(intros)
                fix i2 assume i2Def:"i2<x"
                have "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) \<noteq> l" using MTValue 
                  by (metis MCon_sub_MTVal_imps_val Memoryvalue.distinct(1) i2Def lOrigin option.inject) 
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by simp
                then show "case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') of None \<Rightarrow> False
         | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i2)))
         | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)"
                  using i2Def MTValue 
                  by (metis (lifting) CompTypeRemainsMCon MTypes.distinct(1) MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) linorder_less_linear mcon_accessStore not_less_zero
                      CompMemType.simps(1) MCon.simps(1))
                show "(\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None" 
                proof(cases "ptr = l")
                  case True
                  then show ?thesis using 11 by simp
                next
                  case False
                  then show ?thesis using nonLocChanged MTValue i2Def by auto
                qed
              qed
              then show ?case using MCon.simps(2)[of x "MTValue x'" "memory st'" ptr] xnotZero by simp
            qed
            then show ?thesis 
              by (simp add: \<open>accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st') = accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i1)) (memory st)\<close> ptrDef)
          qed
        qed

        then show ?thesis using lenNotZero p2 by simp
      qed

      have compmemst':"\<forall>locs lens subTs. CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt 
                            \<and> MCon (MTArray lens subTs) (memory st) locs 
                          \<longrightarrow> CompMemType (memory (st')) lens subTs (MTArray len' arr') locs prnt"
      proof intros
        fix locs lens subTs
        assume asm1:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt  \<and> MCon (MTArray lens subTs) (memory st) locs"
        then have asm5:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" by blast
        have asm6:"MCon (MTArray lens subTs) (memory st) locs" using asm1 by blast

        have mconl'':"MCon (MTArray len subT) (memory st) l''" using  lInfo(5) tParentType  by simp


        then have a10:"CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt" using asm6 asm5
        proof(induction subTs arbitrary: lens locs)
          case (MTArray x11 x12)

          then obtain iIn lIn where iInDef:"iIn<lens \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st) = Some (MPointer lIn) 
                    \<and> (lIn = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType (memory st) x11 x12 (MTArray len' arr') lIn prnt)"
            unfolding CompMemType.simps by blast
          have same2:" accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st) =  accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st)" 
            using MConArrayPointers MTArray.prems(2)  bot_nat_0.not_eq_extremum iInDef le_eq_less_or_eq  nonLocChanged not_less_zero option.discI by metis
          then have mcIn:"MCon (MTArray x11 x12) (memory st) lIn" using same2 iInDef MTArray.prems
            by (metis MCon_imps_sub_Mcon)
          then show ?case
          proof(cases "lIn = prnt")
            case True
            have "prnt \<noteq> l" using ldef 
              by (metis hash_inequality)
            moreover have "MTArray x11 x12 = MTArray len' arr'" using iInDef True 
              by (metis CompMemType_imps_CompMemJustType MConSubTypes \<open>MCon (MTArray x11 x12) (memory st) lIn\<close> lsublocs mconPrnt CompMemJustType.simps(2))
            ultimately show ?thesis using True 
              by (metis MConPtrsMustBeSubLocs iInDef lsublocs nonLocChanged CompMemType.simps(2))
          next
            case False
            then have "CompMemType (memory st) x11 x12 (MTArray len' arr') lIn prnt" using iInDef by blast
            then have cp:"CompMemType (memory st') x11 x12 (MTArray len' arr') lIn prnt" using MTArray.IH[of x11 lIn] mcIn t7 by simp
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) \<noteq> l" 
              by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc MConSubTypes Memoryvalue.inject(2) iInDef lOrigin lsublocs mcIn mconlOld option.inject
                  CompMemJustType.simps(2))
            then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st')" 
              by (simp add:  nonLocChanged)
            then have "\<exists>i<lens. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer l)
                \<and> (l = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType (memory st') x11 x12 (MTArray len' arr') l prnt)"
              using False cp iInDef by metis
            then show ?thesis unfolding CompMemType.simps(2) 
              using iInDef by blast
          qed
        next
          case (MTValue x2)
          then show ?case 
            using compType by auto
        qed
        then show "CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt" by blast
      qed

      have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l' (stack st) = Some (KMemptr l'')"
        using lInfo(2,3,4) tParentType by simp
      then have l'SubLocs:"\<forall>tp2 l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if l'' = stl2 then (MTArray len subT) = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 l'' then CompMemType (memory st) len2 arr2 (MTArray len subT) stl2 l''
                  else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray len2 arr2) l'' stl2
                       else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTValue val2) l'' stl2 else True
              )" using lInfo 2(1) unfolding TypeSafe_def compMemPtrs_def
        by (metis (no_types, lifting) MTypes.simps(5))

      have prntRelations:"(\<forall>tp2  l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if prnt = stl2 then (MTArray len' arr') = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
                  else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                       else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True
              ))"
      proof intros
        fix tp2 l2 stl2 dloc1
        assume in0:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) "
        show "if prnt = stl2 then MTArray len' arr' = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
              else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                   else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True"
        proof(cases "prnt = stl2")
          case same:True
          then show ?thesis
          proof(cases "prnt = l''")
            case True
            then have "MTArray len subT = tp2" using l'SubLocs in0 same by auto
            then show ?thesis using in0 same True  lsublocs3 
              by (metis CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame t7)
          next
            case False
            then have l''NotStl2:"l'' \<noteq> stl2" using same by simp
            then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 False by simp
            then show ?thesis using l'SubLocs 
            proof(cases "tp2")
              case (MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                case True
                then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''"  using l'SubLocs False same in0 MTArray by fastforce
                then show ?thesis using cmp same 
                  by (metis (lifting) "2.prems"(1) CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MTArray TypedMemSubPrefOneWay in0 sameMemTSafe t7)
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                  case t2:True
                  then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using l'SubLocs False same in0 MTArray f1 by fastforce
                  then show ?thesis using cmp same in0 t7 MTArray f1 t2 
                    by (meson CompMemTypeSameLocsSameType)
                next
                  case False
                  then show ?thesis 
                    using CompMemType_imps_TypedMemSubPrefPtrs cmp same by auto
                qed

              qed
            next
              case (MTValue x2)
              then show ?thesis using same False cmp in0 l'SubLocs 
                by (metis (no_types, lifting) CompMemType_imps_TypedMemSubPrefPtrs MTypes.simps(6) t7 CompMem_SameLocs_SameSubT)
            qed
          qed
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have stl2Mcon:"MCon (MTArray x11 x12) (memory st) stl2" using in0 2(1) unfolding TypeSafe_def typeCompat_def by fastforce
            then show ?thesis 
            proof(cases "prnt = l''")
              case t3:True
              then have tps:"len = len' \<and> arr' = subT" using lsublocs3 
                using BothMConImpsNotCompMemType lsublocs t7 by blast
              then have in2:"if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l'' then CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''
               else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2
                    else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True" 
                using l'SubLocs MTArray t3 notSame in0 by fastforce
              then show ?thesis using in2 notSame MTArray tps 
                using t3 by force
            next
              case f2:False
              then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp

              then have in2:"\<forall>dloc1. if l'' = stl2 then MTArray len subT = tp2
          else  
               if TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l'' then CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''
               else if TypedMemSubPrefPtrs (memory st) len subT l'' stl2 then CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2
                    else if TypedMemSubPrefPtrs (memory st) len subT l'' dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len subT dt l'' dloc1 else True" 
                using l'SubLocs MTArray f2 notSame in0 by fastforce

              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt")
                case t3:True
                have "CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" 
                proof(cases "l'' = stl2")
                  case t4:True
                  then show ?thesis using t3 in2 MTArray 
                    using cmp by fastforce
                next
                  case f5:False
                  then show ?thesis 
                  proof(cases " TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                    case t5:True
                    then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''" using in2 f5 by simp
                    then show ?thesis using  stl2Mcon  t5 t3 MTArray compMemTypes_trns cmp by blast
                  next
                    case f6:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                      case t6:True
                      then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using in2 f6 f5 by simp
                      then show ?thesis  using  stl2Mcon   t6 t3 MTArray f5 pMCon
                          CompMemType_asc_withSharedTarget[of "memory st" _ _ x11 x12 _ stl2 _ _] cmp f6 
                        by (meson lsublocs t7)
                    next
                      case False
                      have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt" 
                        using CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len subT _ l'' ] cmp f6 t3 by auto
                      moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt" using t3 by simp
                      ultimately have "\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 prnt \<and> CompMemType (memory st) len subT dt l'' prnt" 
                        using in2 False f5 f6 by simp
                      then show ?thesis using  stl2Mcon    t3 MTArray f5 pMCon in2 f6 f5 
                        using CompMemTypeSameLocsSameType cmp t7 by blast
                    qed
                  qed
                qed
                then show ?thesis using t3 notSame MTArray by auto
              next
                case f3:False
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 ")
                  case t3:True
                  have "CompMemType (memory st) len' arr' (MTArray x11 x12) prnt stl2" 
                  proof(cases "l'' = stl2")
                    case t4:True
                    then show ?thesis using t3 in2 MTArray notSame pOrigin f3  
                      using CompMemType_imps_TypedMemSubPrefPtrs 
                      using lsublocs3 by auto
                  next
                    case f5:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 l''")
                      case t5:True
                      then have "CompMemType (memory st) x11 x12 (MTArray len subT) stl2 l''" using in2 f5 by simp
                      then show ?thesis using cmp stl2Mcon   t5 t3 MTArray compMemTypes_trns 
                        by (metis CompMemType_imps_TypedMemSubPrefPtrs f3 )
                    next
                      case f6:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                        case t6:True
                        then have " CompMemType (memory st) len subT (MTArray x11 x12) l'' stl2" using in2 f6 f5 by simp
                        then show ?thesis  using cmp stl2Mcon   t6 t3 MTArray f5 pMCon
                            CompMemType_asc_withSharedTarget 
                          using lsublocs t7 by blast
                      next
                        case False
                        have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt" 
                          using cmp CompMemType_imps_TypedMemSubPrefPtrs[of "memory st" len subT "MTArray len' arr'" l'' prnt] by simp
                        moreover have "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2" using t3 by simp
                        ultimately show ?thesis using  stl2Mcon    t3 MTArray f5 pMCon in2 f6 f5 
                          using False TypedMemSubPrefPtrs_trns cmp lsublocs t7 by blast
                      qed
                    qed
                  qed
                  then show ?thesis using notSame MTArray t3 f3 by simp
                next
                  case f4:False
                  then show ?thesis 
                    by (smt (verit, ccfv_threshold) CompMemType_asc_withSharedTarget CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon MTArray MTypes.simps(5) TypedMemSubPrefPtrs_trns f3 in2
                        lsublocs3 notSame sharedParentSharedSubLocTypes stl2Mcon t7)
                qed
              qed
            qed
          next
            case (MTValue x2)
            then show ?thesis 
            proof(cases " TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2")
              case True
              then show ?thesis
              proof(cases "prnt = l''")
                case t2:True
                then have tps:"len = len' \<and> arr' = subT" using lsublocs3 
                  using BothMConImpsNotCompMemType lsublocs t7 by blast
                have noSameL'':"l'' \<noteq> stl2" using t2 notSame by simp
                then show ?thesis
                proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                  case t3:True
                  then have " CompMemType (memory st) len subT (MTValue x2) l'' stl2" using l'SubLocs noSameL'' MTValue in0 by fastforce
                  then show ?thesis using tps True notSame MTValue t2 by simp
                next
                  case f3:False
                  then show ?thesis using True t2 tps by auto
                qed
              next
                case f2:False
                then have cmp:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
                then show ?thesis 
                proof(cases "l'' = stl2")
                  case t2:True
                  then show ?thesis using cmp True 
                    using CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefOneWay lsublocs t7 by blast
                next
                  case f3:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl2")
                    case t3:True
                    then have " CompMemType (memory st) len subT (MTValue x2) l'' stl2 "  using l'SubLocs f3 MTValue in0 by fastforce
                    then show ?thesis using True notSame MTValue f2 f3 t3 
                      by (metis (lifting) CompMemType_asc_withSharedTarget CompTypeRemainsMCon MTypes.simps(6) lsublocs3 t7)
                  next
                    case False
                    then show ?thesis using True 
                      using TypedMemSubPrefPtrs_trns cmp lsublocs t7 by blast
                  qed
                qed

              qed
            next
              case False
              then show ?thesis using notSame False MTValue by simp
            qed
          qed
        qed
      qed

      have prntToP:"TypedMemSubPrefPtrs (memory st') len' arr' prnt p" using 11 lInfo by force
      then have prntToP2:"CompMemType (memory st') len' arr' (MTArray x t) prnt p" using 11 lInfo by force
      have diffSubs_imps_prnt:"\<forall>tL tT loc. TypedMemSubPrefPtrs (memory st') tL tT loc p \<and> \<not>TypedMemSubPrefPtrs (memory st) tL tT loc p
                        \<longrightarrow> loc = prnt \<or> TypedMemSubPrefPtrs (memory st) tL tT loc prnt \<and> TypedMemSubPrefPtrs (memory st') tL tT loc prnt"
      proof intros
        fix tL tT loc
        assume in1:"TypedMemSubPrefPtrs (memory st') tL tT loc p \<and> \<not>TypedMemSubPrefPtrs (memory st) tL tT loc p "
        then show " loc = prnt \<or> TypedMemSubPrefPtrs (memory st) tL tT loc prnt \<and> TypedMemSubPrefPtrs (memory st') tL tT loc prnt" 
        proof(induction tT arbitrary:tL loc)
          case (MTArray x1 tT)
          then obtain i2 l2 where in2:"(i2<tL \<and> accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = Some (MPointer l2) \<and> (l2 = p \<or> TypedMemSubPrefPtrs (memory st') x1 tT l2 p))" 
            unfolding TypedMemSubPrefPtrs.simps by blast
          then have in3:"\<forall>i<tL. \<exists>l. accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) \<noteq> Some (MPointer l) \<or> (l \<noteq> p \<and> \<not>TypedMemSubPrefPtrs (memory st) x1 tT l p)" 
            using MTArray.prems by auto
          then show ?case 
          proof(cases "(hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) = l")
            case True
            then have "loc = prnt" using ldef ShowLNatDot 
              using hash_injective by blast
            then show ?thesis using in2 unfolding TypedMemSubPrefPtrs.simps by simp
          next
            case False
            then have "accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by simp
            then have "(l2 \<noteq> p \<and> \<not>TypedMemSubPrefPtrs (memory st) x1 tT l2 p)" using in2 in3 
              using MTArray.prems by force
            then have "l2 = prnt \<or> TypedMemSubPrefPtrs (memory st) x1 tT l2 prnt \<and> TypedMemSubPrefPtrs (memory st') x1 tT l2 prnt"
              using MTArray.IH[of x1 l2] in2 by auto
            then show ?thesis 
              using \<open>accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)\<close> in2 by force
          qed
        next
          case (MTValue x)
          then have "(\<exists>i<tL. hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) = p) \<and> \<not> (\<exists>i<tL. hash loc (ShowL\<^sub>n\<^sub>a\<^sub>t i) = p)"
            unfolding TypedMemSubPrefPtrs.simps by blast
          then show ?case by blast
        qed
      qed


      have subPNew_imp_old:"\<forall>stl2. TypedMemSubPrefPtrs (memory st') x t p stl2 \<longrightarrow> TypedMemSubPrefPtrs (memory st) x t p stl2"
      proof intros
        fix stl2
        assume in1:"TypedMemSubPrefPtrs (memory st') x t p stl2"
        then show "TypedMemSubPrefPtrs (memory st) x t p stl2 " using asf pNotPrnt
        proof(induction t arbitrary:x p)
          case (MTArray x1 t)
          obtain iin lin where linDef: "iin<x \<and> accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') = Some (MPointer lin) 
                                        \<and> (lin = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 t lin stl2)" 
            using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
          have "(hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) \<noteq> l" using MTArray.prems(3) ldef ShowLNatDot 
            by (metis hash_injective)
          then have sameAccess:" accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') =  accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "lin = stl2")
            case True
            then show ?thesis using MTArray.prems sameAccess linDef by force
          next
            case False
            then have "TypedMemSubPrefPtrs (memory st') x1 t lin stl2" using linDef by simp
            moreover have "\<not> TypedMemSubPrefPtrs (memory st) x1 t lin prnt" using MTArray.prems(2) linDef 
              using sameAccess by auto
            moreover have " lin \<noteq> prnt" using MTArray.prems linDef 
              using sameAccess by auto
            ultimately have "TypedMemSubPrefPtrs (memory st) x1 t lin stl2" 
              using MTArray.IH[of x1 lin] by blast
            then show ?thesis 
              using linDef sameAccess by auto
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have subPOld_imp_new_cmp:"\<forall>stl2 x11 x12. CompMemType (memory st) x t (MTArray x11 x12) p stl2 \<longrightarrow> CompMemType (memory st') x t (MTArray x11 x12) p stl2"
      proof intros
        fix stl2  x11 x12
        assume in1:" CompMemType (memory st) x t (MTArray x11 x12) p stl2"
        then show " CompMemType (memory st') x t (MTArray x11 x12) p stl2" using asf pNotPrnt
        proof(induction t arbitrary:x p)
          case (MTArray x1 t)
          obtain iin lin where linDef: "iin<x \<and> accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = Some (MPointer lin) 
                                        \<and> (lin = stl2 \<and> MTArray x1 t = MTArray x11 x12 \<or> CompMemType (memory st) x1 t (MTArray x11 x12) lin stl2)" 
            using MTArray.prems(1) unfolding CompMemType.simps by blast
          have "(hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) \<noteq> l" using MTArray.prems(3) ldef ShowLNatDot 
            by (metis hash_injective)
          then have sameAccess:" accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') =  accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "lin = stl2")
            case True
            then show ?thesis using MTArray.prems sameAccess linDef 
              by (metis (mono_tags, lifting) MTArray.IH CompMemType.simps(2) TypedMemSubPrefPtrs.simps(2))
          next
            case False
            then have "CompMemType (memory st) x1 t (MTArray x11 x12) lin stl2" using linDef by simp
            moreover have "\<not> TypedMemSubPrefPtrs (memory st) x1 t lin prnt" using MTArray.prems(2) linDef 
              using sameAccess by auto
            moreover have " lin \<noteq> prnt" using MTArray.prems linDef 
              using sameAccess by auto
            ultimately have "CompMemType (memory st') x1 t (MTArray x11 x12) lin stl2" 
              using MTArray.IH[of x1 lin] by blast
            then show ?thesis 
              using linDef sameAccess by auto
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntPNeg:"\<forall>stl2 x11 x12. \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p \<longrightarrow> \<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p"
      proof intros
        fix stl2 x11 x12
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p"
        show "\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p "
        proof
          assume in2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p"
          then show False using in1 
          proof(induction x12 arbitrary:x11 stl2)
            case (MTArray x1 t)
            obtain iin lin where linDef: "iin<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = Some (MPointer lin) 
                                        \<and> (lin = p \<or> TypedMemSubPrefPtrs (memory st) x1 t lin p)" 
              using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
            then show ?case 
            proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) = l")
              case True
              then have "accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') = Some (MPointer p)" using linDef 11 unfolding updateStore_def accessStore_def by simp
              then show ?thesis using MTArray.prems(2) linDef by auto
            next
              case False
              then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st')" using nonLocChanged by simp
              then show ?thesis 
              proof(cases "lin = p")
                case True
                then show ?thesis using MTArray.prems(2) linDef sameAccess by auto
              next
                case False
                then have "TypedMemSubPrefPtrs (memory st) x1 t lin p" using linDef by simp
                then show ?thesis using MTArray linDef sameAccess by auto
              qed
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed
      qed

      have subPNeg:"\<forall>stl2. \<not> TypedMemSubPrefPtrs (memory st') x t p stl2 \<longrightarrow> \<not> TypedMemSubPrefPtrs (memory st) x t p stl2"
      proof intros
        fix stl2 
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x t p stl2"
        show "\<not> TypedMemSubPrefPtrs (memory st) x t p stl2 "
        proof
          assume in2:" TypedMemSubPrefPtrs (memory st) x t p stl2"
          then show False using in1 asf pNotPrnt
          proof(induction t arbitrary:x p)
            case (MTArray x1 t)
            obtain iin lin where linDef: "iin<x \<and> accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = Some (MPointer lin) 
                                        \<and> (lin = stl2 \<or> TypedMemSubPrefPtrs (memory st) x1 t lin stl2)" 
              using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
            then have "(hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) \<noteq> l" using ldef MTArray.prems ShowLNatDot 
              by (metis hash_injective)

            then have sameAccess:"accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = accessStore (hash p (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st')" using nonLocChanged by simp
            then show ?thesis 
            proof(cases "lin = stl2")
              case True
              then show ?thesis using MTArray.prems(2) linDef sameAccess by auto
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st) x1 t lin stl2" using linDef by simp
              then show ?thesis using MTArray linDef sameAccess 
                by (metis TypedMemSubPrefPtrs.simps(2))
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed
      qed

      have prntPNeg_2:"\<forall>stl2 x11 x12 dloc1. \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 dloc1 
                                    \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1 "
      proof intros
        fix stl2 x11 x12 dloc1
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 dloc1"
        then show "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1"
        proof(induction x12 arbitrary:x11 stl2)
          case (MTArray x1 t)
          obtain iin lin where linDef: "iin<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') = Some (MPointer lin) 
                                      \<and> (lin = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 t lin dloc1)" 
            using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
          then show ?case 
          proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) = l")
            case True
            then have "accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') = Some (MPointer p)" using linDef 11 unfolding updateStore_def accessStore_def by simp
            then show ?thesis using MTArray.prems(1) linDef by auto
          next
            case False
            then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st')" using nonLocChanged by simp
            then show ?thesis 
            proof(cases "lin = dloc1")
              case True
              then show ?thesis using MTArray.prems(1) linDef sameAccess by auto
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st') x1 t lin dloc1" using linDef by simp
              then show ?thesis using MTArray linDef sameAccess by auto
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntPNeg_sublocs_comp:"\<forall>stl2 x11 x12 dloc1 dt. \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p \<and> CompMemType (memory st) x11 x12 dt stl2 dloc1 
                                    \<longrightarrow> CompMemType (memory st') x11 x12 dt stl2 dloc1 "
      proof intros
        fix stl2 x11 x12 dloc1 dt
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p \<and> CompMemType (memory st) x11 x12 dt stl2 dloc1"
        then show "CompMemType (memory st') x11 x12 dt stl2 dloc1"
        proof(induction x12 arbitrary:x11 stl2)
          case (MTArray x1 t)
          obtain iin lin where linDef: "iin<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = Some (MPointer lin) 
                                      \<and> (lin = dloc1 \<and> MTArray x1 t = dt \<or> CompMemType (memory st) x1 t dt  lin dloc1)" 
            using MTArray.prems(1) unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) = l")
            case True
            then have "accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st') = Some (MPointer p)" using linDef 11 unfolding updateStore_def accessStore_def by simp
            then show ?thesis using MTArray.prems(1) linDef by auto
          next
            case False
            then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iin)) (memory st')" using nonLocChanged by simp
            then show ?thesis 
            proof(cases "lin = dloc1")
              case True
              then show ?thesis using MTArray.prems(1) linDef sameAccess 
                using MTArray.IH by auto
            next
              case False
              then have "CompMemType (memory st) x1 t dt  lin dloc1" using linDef by simp
              then show ?thesis using MTArray linDef sameAccess by auto
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have pPrntsLim:"\<forall>x11 x12 stl2. CompMemType (memory st) x11 x12 (MTArray x t) stl2 p \<and> accessStore l (memory st) \<noteq> Some (MPointer p) \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p \<and>
    MCon (MTArray x11 x12) (memory st) stl2 \<longrightarrow> CompMemType (memory st') x11 x12 (MTArray x t) stl2 p"
      proof(intros)
        fix x11 x12 stl2
        assume "CompMemType (memory st) x11 x12 (MTArray x t) stl2 p \<and>
       accessStore l (memory st) \<noteq> Some (MPointer p) \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p \<and> MCon (MTArray x11 x12) (memory st) stl2"
        then show "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p"
        proof(induction x12 arbitrary: x11 stl2)
          case (MTArray x1 x12)
          obtain inI inL where inDef:"inI<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inI)) (memory st) = Some (MPointer inL) 
                              \<and> (inL = p \<or> TypedMemSubPrefPtrs (memory st) x1 x12 inL p)" 
            using MTArray.prems unfolding TypedMemSubPrefPtrs.simps by blast
          then show ?case 
          proof(cases "inL = p")
            case True
            then show ?thesis 
              by (metis MTArray.prems inDef
                  existingLocation_imps_allLocs_same nonLocChanged CompMemType.simps(2))
          next
            case False
            then have "TypedMemSubPrefPtrs (memory st) x1 x12 inL p" using inDef by auto
            moreover have "accessStore l (memory st) \<noteq> Some (MPointer p)" using MTArray.prems by simp
            moreover have "MCon (MTArray x1 x12) (memory st) inL" using MTArray.prems inDef 
              using MconSameTypeSameAccessWithTyping by blast
            moreover have "CompMemType (memory st) x1 x12 (MTArray x t) inL p" 
              by (meson False MTArray.prems existingLocation_imps_allLocs inDef)
            ultimately have "CompMemType (memory st') x1 x12 (MTArray x t) inL p" using MTArray.IH[of x1 inL] by blast
            moreover have "accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inI)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inI)) (memory st')" 
            proof -
              obtain nn :: "nat \<Rightarrow> String.literal \<Rightarrow> String.literal \<Rightarrow> nat" where
                f1: "\<forall>X1 X4 X5. (\<exists>X7. hash X4 (ShowL\<^sub>n\<^sub>a\<^sub>t X7) = X5 \<and> X7 < X1) \<longrightarrow> hash X4 (ShowL\<^sub>n\<^sub>a\<^sub>t (nn X1 X4 X5)) = X5 \<and> nn X1 X4 X5 < X1"
                by moura
              obtain nna :: "String.literal \<Rightarrow> String.literal \<Rightarrow> nat \<Rightarrow> MTypes \<Rightarrow> nat" and nnb :: "String.literal \<Rightarrow> String.literal \<Rightarrow> nat \<Rightarrow> MTypes \<Rightarrow> nat" where
                f2: "\<forall>l la n m. (TypedMemSubPref l la (MTArray n m) \<or> (\<forall>na. hash la (ShowL\<^sub>n\<^sub>a\<^sub>t na) \<noteq> l 
            \<and> \<not> TypedMemSubPref l (hash la (ShowL\<^sub>n\<^sub>a\<^sub>t na)) m \<or> \<not> na < n)) \<and> ((hash la (ShowL\<^sub>n\<^sub>a\<^sub>t(nna l la n m)) = l 
              \<or> TypedMemSubPref l (hash la (ShowL\<^sub>n\<^sub>a\<^sub>t(nna l la n m))) m) \<and> nna l la n m < n \<or> \<not> TypedMemSubPref l la (MTArray n m))"
                using TypedMemSubPref.simps(2) by moura
              obtain nnc :: "nat \<Rightarrow> String.literal \<Rightarrow> String.literal \<Rightarrow> nat" where
                f3: "\<forall>s n t m l la. (CompMemType s n (MTValue t) m l la \<or> (\<forall>na. hash l (ShowL\<^sub>n\<^sub>a\<^sub>t na) \<noteq> la \<or> \<not> na < n) 
          \<or> MTValue t \<noteq> m) \<and> ((hash l (ShowL\<^sub>n\<^sub>a\<^sub>t(nnc n l la)) = la \<and> nnc n l la < n) \<and> MTValue t = m \<or> \<not> CompMemType s n (MTValue t) m l la)"
                using f1 CompMemType.simps(1) by moura
              obtain ll :: "String.literal \<Rightarrow> nat \<Rightarrow> MTypes \<Rightarrow> Memoryvalue Store \<Rightarrow> String.literal" and lla :: "String.literal \<Rightarrow> nat \<Rightarrow> MTypes \<Rightarrow> Memoryvalue Store \<Rightarrow> String.literal" where
                f4: "TypedMemSubPref (ll inL x1 x12 (memory st)) inL (MTArray x1 x12) \<or> TypedMemSubPref p inL (MTArray x1 x12)"
                by (meson CompMemType_imps_TypedMemSubPrefPtrs \<open>CompMemType (memory st) x1 x12 (MTArray x t) inL p\<close> selfPoint_imps_TypedMemSubPref)
              obtain tt :: "MTypes \<Rightarrow> Types" and nnd :: "MTypes \<Rightarrow> nat" and mm :: "MTypes \<Rightarrow> MTypes" where
                "x12 = MTArray (nnd x12) (mm x12) \<or> x12 = MTValue (tt x12) \<or> 0 = x1"
                by (metis (no_types) \<open>MCon (MTArray x1 x12) (memory st) inL\<close> bot_nat_0.not_eq_extremum mcon_accessStore)
              then show ?thesis
                using f4 f3 f2 by (metis CompMemType_imps_CompMemJustType MConSubTypes Memoryvalue.inject(2) \<open>CompMemType (memory st) x1 x12 (MTArray x t) inL p\<close> \<open>MCon (MTArray x1 x12) (memory st) inL\<close> inDef lOrigin less_nat_zero_code mconlOld nonLocChanged option.inject CompMemJustType.simps(2) CompMemType.simps(2))
            qed         
            ultimately show ?thesis using inDef unfolding CompMemType.simps by metis
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed

      qed


      have pRelationsNew:"(\<forall>tp2  l2 stl2 dloc1. 
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if p = stl2 then (MTArray x t) = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 p then CompMemType (memory st') len2 arr2 (MTArray x t) stl2 p
                  else if TypedMemSubPrefPtrs (memory st') x t p stl2 then CompMemType (memory st') x t (MTArray len2 arr2) p stl2
                       else if TypedMemSubPrefPtrs (memory st') x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') x t dt p dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') x t p stl2 then CompMemType (memory st') x t (MTValue val2) p stl2 else True
              ))"
      proof intros
        fix tp2 l2 stl2 dloc1
        assume in0:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2)"
        show "if p = stl2 then MTArray x t = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 p then CompMemType (memory st') len2 arr2 (MTArray x t) stl2 p
              else if TypedMemSubPrefPtrs (memory st') x t p stl2 then CompMemType (memory st') x t (MTArray len2 arr2) p stl2
                   else if TypedMemSubPrefPtrs (memory st') x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') x t dt p dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') x t p stl2 then CompMemType (memory st') x t (MTValue val2) p stl2 else True" 
        proof(cases "p = stl2")
          case True
          then show ?thesis using pRelations in0 by simp
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p")
              case t1:True
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p")
                case True
                then have in7:"CompMemType (memory st) x11 x12 (MTArray x t) stl2 p" using pRelations MTArray notSame in0 by fastforce
                then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p" 
                proof(cases "accessStore l (memory st) = Some (MPointer p)")
                  case True
                  have "toploc (memory st) = toploc (memory st')" using 11(4) unfolding updateStore_def by auto
                  moreover have "\<forall>l. accessStore l (memory st) = accessStore l (memory st')" using True 11(4) unfolding updateStore_def accessStore_def by simp
                  ultimately have "memory st = memory st'" using fmap_same unfolding accessStore_def  by fastforce
                  then show ?thesis using in7 by auto
                next
                  case False
                  have mc2:"MCon (MTArray x11 x12) (memory st) stl2" 
                    using "2.prems"(1) MTArray in0 sameMemTSafe by blast

                  have y1:"  \<forall>i<x11. \<forall>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> l = p \<longrightarrow> MTArray x t = x12"
                    using existingLocation_imps_allLocs_same[OF in7 mc2] by auto

                  show ?thesis using in7 False True mc2 pPrntsLim by blast

                qed
                then show ?thesis 
                  by (simp add: CompMemType_imps_TypedMemSubPrefPtrs MTArray notSame)
              next
                case False
                then have r:"stl2 = prnt \<or> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt" 

                  by (simp add: diffSubs_imps_prnt t1)
                then show ?thesis 
                proof(cases "stl2 = prnt")
                  case True
                  then have "MTArray len' arr' = tp2" using prntRelations in0 by auto
                  then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p" using True prntToP2 MTArray by simp
                  then show ?thesis using notSame True t1 False MTArray by simp
                next
                  case False
                  have "CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" using r prntRelations False in0 MTArray by force
                  then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl2 prnt" 
                    using "2.prems"(1) MTArray compmemst' in0 sameMemTSafe by blast
                  then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p"  using  prntToP2 MTArray compMemTypes_trns  by blast
                  then show ?thesis  using notSame  t1 False MTArray by simp
                qed
              qed
            next
              case f3:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x t p stl2")
                case t5:True
                then have "TypedMemSubPrefPtrs (memory st) x t p stl2" using subPNew_imp_old by simp
                moreover have "\<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p" using f3 prntPNeg by simp
                ultimately have "CompMemType (memory st) x t (MTArray x11 x12) p stl2" using pRelations notSame MTArray in0 by force
                then have "CompMemType (memory st') x t (MTArray x11 x12) p stl2" using subPOld_imp_new_cmp by simp
                then show ?thesis using notSame  f3 t5 MTArray by simp
              next
                case f4:False
                have in6:"\<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl2 p" using f3 prntPNeg by simp
                then have in7:"\<not> TypedMemSubPrefPtrs (memory st) x t p stl2" using subPNeg f4 by simp
                then show ?thesis 
                proof(cases " TypedMemSubPrefPtrs (memory st') x t p dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 dloc1")
                  case t6:True
                  then have "TypedMemSubPrefPtrs (memory st) x t p dloc1 " 
                    by (simp add: subPNew_imp_old)
                  moreover have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1" using t6 in6 f3 prntPNeg_2 by simp 
                  ultimately have "\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) x t dt p dloc1" 
                    using pRelations in6 in7 in0 MTArray notSame by force
                  then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st') x t dt p dloc1" using prntPNeg_sublocs_comp 
                    by (metis TypedMemSubPrefPtrs_imps_notsame f3 mcPNew)
                  then show ?thesis using notSame  f3 f4 MTArray by simp
                next
                  case f5:False
                  then show ?thesis  using notSame  f3  MTArray f4 by auto
                qed
              qed
            qed
          next
            case (MTValue x2)
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st') x t p stl2")
              case True
              then show ?thesis using notSame MTValue 
                by (metis (lifting) MTypes.simps(6) TypedMemSubPrefPtrs_imps_notsame in0 mcPNew pRelations prntPNeg_sublocs_comp subPNew_imp_old)
            next
              case False
              then show ?thesis using MTValue notSame by simp
            qed
          qed
        qed
      qed

      have getToPrntNew_imps_Old:"\<forall>stl2 x11 x12. TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt \<and> prnt \<noteq> stl2 \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
      proof intros
        fix stl2 x11 x12 
        assume "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt \<and> prnt \<noteq> stl2"
        then show "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
        proof(induction x12 arbitrary:x11 stl2)
          case (MTArray x1 x12)
          obtain ii ll where llDef:"ii<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                                  \<and> (ll = prnt \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ll prnt)" 
            using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast

          then show ?case 
          proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) = l")
            case True
            then have "stl2 = prnt" using ldef ShowLNatDot 
              using hash_injective by blast
            then show ?thesis using MTArray.prems(1) by auto
          next
            case False
            then have same:" accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') =  accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
            then show ?thesis  
            proof(cases "ll = prnt")
              case True
              then show ?thesis using same llDef by force
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st') x1 x12 ll prnt" using llDef by simp
              then show ?thesis using MTArray.IH[of x1 ll] same False llDef by force
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntPrntNeg:"\<forall>stl2 x11 x12. \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt \<and> prnt \<noteq> stl2 \<longrightarrow> \<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
      proof intros
        fix stl2 x11 x12
        assume in1:"\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt \<and> prnt \<noteq> stl2"
        show "\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt "
        proof
          assume in2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt"
          then show False using in1 
          proof(induction x12 arbitrary:x11 stl2)
            case (MTArray x1 t)
            obtain iIn lin where linDef: "iIn<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st) = Some (MPointer lin) 
                                        \<and> (lin = prnt \<or> TypedMemSubPrefPtrs (memory st) x1 t lin prnt)" 
              using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
            then show ?case 
            proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) = l")
              case True
              then have "stl2 = prnt" using ldef ShowLNatDot 
                using hash_injective by blast
              then show ?thesis using MTArray.prems(2) linDef by simp
            next
              case False
              then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st')" using nonLocChanged by simp
              then show ?thesis 
              proof(cases "lin = prnt")
                case True
                then show ?thesis using MTArray.prems(2) linDef sameAccess by auto
              next
                case False
                then have "TypedMemSubPrefPtrs (memory st) x1 t lin prnt" using linDef by simp
                then show ?thesis using MTArray linDef sameAccess by auto
              qed
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed
      qed

      have mcAllNew:"\<forall>tp2 l2 stl2. (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)
                    \<longrightarrow> MCon tp2 (memory st') stl2"
      proof intros
        fix tp2 l2 stl2
        assume in1:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2)"
        then have in2:"\<forall>dloc1. (if prnt = stl2 then MTArray len' arr' = tp2
        else case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 prnt then CompMemType (memory st) len2 arr2 (MTArray len' arr') stl2 prnt
               else if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTArray len2 arr2) prnt stl2
                    else if TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2 then CompMemType (memory st) len' arr' (MTValue val2) prnt stl2 else True)" 
          using prntRelations by auto
        then have mcO:"MCon tp2 (memory st) stl2 " using 2(1) in1 unfolding TypeSafe_def typeCompat_def by force
        then show "MCon tp2 (memory st') stl2" 
        proof(cases "prnt = stl2")
          case True
          then show ?thesis using in2 mcPrntNew 
            by (simp add: lsublocs)
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have mcO:" MCon (MTArray x11 x12) (memory st) stl2" using MTArray mcO by blast

            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt")
              case True
              then have cpO:"CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" using in1 in2 notSame MTArray by simp

              have mcO:" MCon (MTArray x11 x12) (memory st) stl2" using MTArray mcO by blast
              moreover have "\<forall>newt newl. CompMemType (memory st) x11 x12 newt stl2 newl \<and> newl = prnt \<longrightarrow> newt = MTArray len' arr'" using CompMem_SameLocs_SameSubT[OF _ mcO] cpO  by auto
              ultimately have " MCon (MTArray x11 x12) (memory st') stl2" using notSame
              proof(induction x12 arbitrary: x11 stl2)
                case (MTArray x1 x12)
                then have "x11 \<noteq> 0" using MCon.simps by auto
                moreover have "\<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii assume iiDef:"ii<x11"
                  then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii))\<noteq> l" using MTArray.prems(3) ldef ShowLNatDot hash_injective by blast
                  then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by auto
                  then obtain v where vDef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer v) \<and> MCon (MTArray x1 x12) (memory st) v"
                    using MTArray.prems iiDef MCon_imps_sub_Mcon 
                    by (metis MConArrayPointers neq0_conv not_less_zero)
                  have "MCon (MTArray x1 x12) (memory st') v"
                  proof(cases "v = prnt")
                    case True
                    then have "MTArray len' arr' = MTArray x1 x12" using MTArray.prems(2) iiDef vDef same by auto
                    then show ?thesis using mcPrntNew True lsublocs by blast
                  next
                    case False
                    then show ?thesis using MTArray.IH[of x1 v] vDef MTArray.prems(2) iiDef same 
                      by (metis CompMemType.simps(2))
                  qed
                  then show "case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
         | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
         | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                    using vDef 
                    by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
                qed
                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None"
                proof(cases "stl2 = l")
                  case True
                  then show ?thesis using 11 by auto
                next
                  case False
                  then have "accessStore stl2 (memory st') = accessStore stl2 (memory st)" using nonLocChanged by simp
                  then show ?thesis using MTArray.prems(1) calculation(1) by simp
                qed
                ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "memory st'" stl2] by auto
              next
                case (MTValue x)
                then have "x11 \<noteq> 0" using MCon.simps by auto
                moreover have "\<forall>i<x11.
             (case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                proof intros
                  fix ii 
                  assume iiDef:"ii<x11"
                  have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using MTValue(3) ldef ShowLNatDot hash_injective by blast
                  then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by auto
                  then obtain v where vDef:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MValue v) \<and> MCon (MTValue x) (memory st) (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii))"
                    using MTValue iiDef MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val by presburger
                  then show "(case accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                    using same iiDef by auto
                qed
                moreover have "(\<exists>p. accessStore stl2 (memory st') = Some (MPointer p)) \<or> accessStore stl2 (memory st') = None"
                proof(cases "stl2 = l")
                  case True
                  then show ?thesis using 11 by auto
                next
                  case False
                  then have "accessStore stl2 (memory st') = accessStore stl2 (memory st)" using nonLocChanged by simp
                  then show ?thesis using MTValue.prems(1) calculation(1) by simp
                qed
                ultimately show ?case using MCon.simps(2)[of x11 "MTValue x" "memory st'" stl2] by simp
              qed
              then show ?thesis using MTArray by simp
            next
              case f2:False
              then have f2':" \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt " 
                using getToPrntNew_imps_Old notSame by auto
              have "MCon (MTArray x11 x12) (memory st') stl2" using limitedMemoryChange[OF f2 ] notSame nonLocChanged ldef 11 mcO 
                by (metis MConArrayPointers bot_nat_0.not_eq_extremum less_nat_zero_code mcPrntNew)
              then show ?thesis using MTArray by blast
            qed
          next
            case (MTValue x2)
            then have mcO2:"MCon (MTValue x2) (memory st) stl2 " using mcO by simp
            then have "stl2 \<noteq> l" using 11 unfolding updateStore_def accessStore_def 
              using lOrigin by fastforce
            then have "MCon (MTValue x2) (memory st') stl2 " unfolding MCon.simps using nonLocChanged mcO2 by simp
            then show ?thesis using MTValue by simp
          qed
        qed
      qed

      have limitedChanges1:"\<forall>x11' x12' stl2 stl1. (\<forall>newt newl. CompMemType (memory st') x11' x12' newt stl2 newl \<and> newl = p \<longrightarrow> newt = MTArray x t) \<and>
    TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
    \<not> TypedMemSubPrefPtrs (memory st') x t p stl1 \<and>
    stl1 \<noteq> p \<longrightarrow>  TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1
        assume in1:"(\<forall>newt newl. CompMemType (memory st') x11' x12' newt stl2 newl \<and> newl = p \<longrightarrow> newt = MTArray x t) \<and>
       TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and> \<not> TypedMemSubPrefPtrs (memory st') x t p stl1 \<and> stl1 \<noteq> p"
        then show "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1 "
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          then obtain ii ll where iiDef: "ii<x11'\<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                                          \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1)" 
            unfolding TypedMemSubPrefPtrs.simps by blast
          then have cmp:"CompMemType (memory st') x11' (MTArray x1 x12') (MTArray x1 x12') stl2 ll" using MTArray.prems by auto
          then show ?case 
          proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) = l")
            case True
            then have llIsP:"ll = p" using iiDef 11 by simp
            then have tps:"MTArray x t = (MTArray x1 x12')" using MTArray.prems cmp by blast
            then show ?thesis 
            proof(cases "ll = stl1")
              case True
              then show ?thesis using MTArray.prems llIsP by simp
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st') x1 x12' p stl1" using iiDef llIsP by simp
              then show ?thesis using MTArray.prems tps by blast
            qed
          next
            case False
            then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
            then show ?thesis
            proof(cases "ll = stl1")
              case True
              then show ?thesis using same iiDef by force
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1" using iiDef by simp
              then have "TypedMemSubPrefPtrs (memory st) x1 x12' ll stl1" using MTArray.IH[of x1 ll] MTArray.prems 
                using cmp compMemTypes_trns by blast
              then show ?thesis 
                using iiDef same by auto
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have limitedChanges2:"\<forall>x11' x12' stl2 stl1 dt. (\<forall>newt newl. CompMemType (memory st) x11' x12' newt stl2 newl \<and> newl = stl1 \<longrightarrow> newt = dt )\<and>
    TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
    stl1 \<noteq> p \<and>
    (\<forall>newt newl. CompMemType (memory st') x11' x12' newt stl2 newl \<and> newl = p \<longrightarrow> newt = MTArray x t) \<and>
    \<not> TypedMemSubPrefPtrs (memory st') x t p stl1 \<longrightarrow> CompMemType (memory st') x11' x12' dt stl2 stl1" 
      proof intros
        fix x11' x12' stl2 stl1 dt
        assume "(\<forall>newt newl. CompMemType (memory st) x11' x12' newt stl2 newl \<and> newl = stl1 \<longrightarrow> newt = dt) \<and>
       TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
       stl1 \<noteq> p \<and> (\<forall>newt newl. CompMemType (memory st') x11' x12' newt stl2 newl \<and> newl = p \<longrightarrow> newt = MTArray x t) \<and> \<not> TypedMemSubPrefPtrs (memory st') x t p stl1"
        then show "CompMemType (memory st') x11' x12' dt stl2 stl1"
        proof(induction x12' arbitrary: x11' stl2)
          case (MTArray x1 x12')
          then obtain ii ll where llDef: "ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                    \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1)" 
            unfolding TypedMemSubPrefPtrs.simps by blast
          then show ?case 
          proof(cases " (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) = l")
            case True
            then have llIsP:"ll = p" using llDef 11 by simp
            then show ?thesis 
            proof(cases "ll = stl1")
              case True
              then show ?thesis using MTArray.prems llIsP by blast
            next
              case False
              then have "TypedMemSubPrefPtrs (memory st') x1 x12' p stl1" using llDef llIsP by simp
              then show ?thesis using MTArray.prems llDef 
                by (metis MTypes.inject(1)  llIsP CompMemType.simps(2))
            qed
          next
            case False
            then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
            then show ?thesis 
            proof(cases "ll = stl1")
              case True
              then have "CompMemType (memory st) x11' (MTArray x1 x12') (MTArray x1 x12') stl2 ll" using llDef same by auto
              then have " (MTArray x1 x12')  = dt" using MTArray.prems True by blast
              then show ?thesis using  same llDef 
                using True CompMemType.simps(2) by blast
            next
              case False
              then have c1:"TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1" using llDef by simp
              have c2:" \<forall>newt newl. CompMemType (memory st) x1 x12' newt ll newl \<and> newl = stl1 \<longrightarrow> newt = dt" using MTArray.prems
                using llDef same by auto
              have "CompMemType (memory st') x1 x12' dt ll stl1"
                using MTArray.IH MTArray.prems 
                using llDef CompMemType.simps(2) 
                by (metis c1 c2)
              then show ?thesis 
                using llDef CompMemType.simps(2) by blast
            qed
          qed
        next
          case (MTValue x)
          then show ?case by auto
        qed
      qed

      have prntRelationsNew:"(\<forall>tp2  l2 stl2 dloc1.
        (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env)  \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
        (if prnt = stl2 then (MTArray len' arr') = tp2
         else 
                case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 prnt then CompMemType (memory st') len2 arr2 (MTArray len' arr') stl2 prnt
                  else if TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2 then CompMemType (memory st') len' arr' (MTArray len2 arr2) prnt stl2
                       else if TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2 then CompMemType (memory st') len' arr' (MTValue val2) prnt stl2 else True
              ))"
      proof intros
        fix tp2 l2 stl2 dloc1
        assume in0:"(Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) "
        show "if prnt = stl2 then MTArray len' arr' = tp2
       else case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 prnt then CompMemType (memory st') len2 arr2 (MTArray len' arr') stl2 prnt
              else if TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2 then CompMemType (memory st') len' arr' (MTArray len2 arr2) prnt stl2
                   else if TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2 then CompMemType (memory st') len' arr' (MTValue val2) prnt stl2 else True"
        proof(cases "prnt = stl2")
          case same:True
          then show ?thesis using prntRelations in0 by simp
        next
          case notSame:False
          then show ?thesis 
          proof(cases "tp2")
            case (MTArray x11 x12)
            then have stl2Mcon:"MCon (MTArray x11 x12) (memory st) stl2" using in0 2(1) unfolding TypeSafe_def typeCompat_def by fastforce
            then have stl2MconN:"MCon (MTArray x11 x12) (memory st') stl2" using mcAllNew in0 MTArray by blast
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt")
              case True
              then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt" 
                using getToPrntNew_imps_Old notSame by auto
              then have "CompMemType (memory st) x11 x12 (MTArray len' arr') stl2 prnt" using prntRelations notSame MTArray in0 by fastforce
              then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl2 prnt" 
                using compmemst' stl2Mcon by blast
              then show ?thesis using notSame MTArray True by simp
            next
              case f1:False
              then have f1':"\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt" 
                by (simp add: notSame prntPrntNeg)

              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2")
                case t1:True
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2")
                  case True
                  then have c1:"CompMemType (memory st) len' arr' (MTArray x11 x12) prnt stl2" 
                    using prntRelations in0 notSame MTArray f1 t1 f1' by fastforce
                  then have c2:"\<forall>newt newl. CompMemType (memory st) len' arr' newt prnt newl \<and> newl = stl2 \<longrightarrow> newt = MTArray x11 x12" 
                    using CompMem_SameLocs_SameSubT[OF c1 ] mconPrnt lsublocs by blast
                  then have aa1:"TypedMemSubPrefPtrs (memory st) len' (MTArray  x t)  prnt stl2" using True lsublocs by blast
                  have aa2:"TypedMemSubPrefPtrs (memory st') len' (MTArray  x t) prnt stl2" using t1 lsublocs by blast
                  have aa3:"CompMemType (memory st) len' (MTArray  x t) (MTArray x11 x12) prnt stl2" using lsublocs c1 by blast
                  then have aa4:"\<forall>newt newl. CompMemType (memory st) len'  (MTArray  x t) newt prnt newl \<and> newl = stl2 \<longrightarrow> newt = MTArray x11 x12"
                    using c2 lsublocs by blast
                  then have "CompMemType (memory st') len' (MTArray  x t) (MTArray x11 x12) prnt stl2" 
                  proof(cases "stl2 = p")
                    case True
                    then have "CompMemType (memory st') len' (MTArray x t) (MTArray x t) prnt p" using prntToP2 lsublocs by blast
                    then show ?thesis using True 
                      using aa1 aa3 existingLocation_imps_allLocs_same lsublocs pSubs by blast
                  next
                    case notP:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x t p stl2")
                      case gh:True
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p")
                        case True
                        then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p"  using pRelationsNew MTArray in0 gh notP by fastforce
                        then show ?thesis using gh 
                          using CompMemType_imps_CompMemJustType True TypedMemSubPrefOneWay mcPNew stl2MconN by blast
                      next
                        case False
                        then have "CompMemType (memory st') x t (MTArray x11 x12) p stl2" using pRelationsNew MTArray in0 gh notP by fastforce
                        then show ?thesis 
                          using compMemTypes_trns lsublocs prntToP2 by blast
                      qed
                    next
                      case False
                      then show ?thesis using limitedChanges2 notP
                        using aa2 aa4 lsublocs mcPrntNew prntToP2 CompMem_SameLocs_SameSubT by presburger
                    qed
                  qed
                  then show ?thesis 
                    using MTArray f1 lsublocs notSame t1 by auto
                next
                  case False
                  then have aa1:"\<not> TypedMemSubPrefPtrs (memory st) len' (MTArray  x t)  prnt stl2" using lsublocs by blast
                  have aa2:"TypedMemSubPrefPtrs (memory st') len' (MTArray  x t) prnt stl2" using t1 lsublocs by blast
                  have stl21:"stl2 = p \<or> TypedMemSubPrefPtrs (memory st') x t p stl2" 
                  proof -
                    obtain ii ll where llDef: "ii<len' \<and> accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) \<and> (ll = stl2 \<or> TypedMemSubPrefPtrs (memory st') x t ll stl2)" 
                      using aa2 unfolding TypedMemSubPrefPtrs.simps by blast
                    show "stl2 = p \<or> TypedMemSubPrefPtrs (memory st') x t p stl2"
                    proof(cases "ii = i")
                      case True
                      then have "(hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) = l" using ldef by simp
                      then show ?thesis using llDef 
                        using CompMemTypeSameLocsSameType False limitedChanges1 lsublocs mcPrntNew prntToP2 t1 by blast
                    next
                      case False
                      then show ?thesis 
                        using CompMemTypeSameLocsSameType aa1 limitedChanges1 lsublocs mcPrntNew prntToP2 t1 by blast
                    qed
                  qed
                  then show ?thesis
                  proof(cases "stl2 = p")
                    case True
                    then have "MTArray x t = (MTArray x11 x12)" using pRelationsNew in0 MTArray by simp
                    then show ?thesis using notSame MTArray f1 t1 
                      using True prntToP2 by auto
                  next
                    case f4:False
                    then have sb:"TypedMemSubPrefPtrs (memory st') x t p stl2" using stl21 by simp
                    then have "CompMemType (memory st') x t (MTArray x11 x12) p stl2" 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p")
                      case True
                      then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p" using pRelationsNew in0 MTArray f4 by force
                      then show ?thesis 
                        by (meson CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon TypedMemSubPrefOneWay \<open>TypedMemSubPrefPtrs (memory st') x t p stl2\<close>
                            stl2MconN)
                    next
                      case f2:False
                      then show ?thesis using pRelationsNew in0 MTArray f4 sb by fastforce
                    qed
                    then have "CompMemType (memory st') len' arr' (MTArray x11 x12) prnt stl2" 
                      by (meson compMemTypes_trns prntToP2)
                    then show ?thesis using False notSame in0 MTArray t1 f1 by simp
                  qed
                qed
              next
                case f3:False
                then show ?thesis
                proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 dloc1")
                  case t4:True
                  then have " \<exists>i<len'. \<exists>l. accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer l) \<and> (l = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x t l dloc1)" 
                    using lsublocs unfolding TypedMemSubPrefPtrs.simps by simp
                  then obtain ii where iiDef:"\<exists>l. ii<len'\<and>  accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer l) 
                                                \<and> (l = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x t l dloc1)" by blast
                  have t4':"TypedMemSubPrefPtrs (memory st') x11 x12 stl2 dloc1" using t4 by simp

                  then show ?thesis
                  proof(cases "ii = i")
                    case True
                    then have dloc1P:"dloc1 = p \<or> TypedMemSubPrefPtrs (memory st') x t p dloc1" using ldef 11 iiDef by auto

                    then show ?thesis 
                    proof(cases "dloc1 = p")
                      case t6:True
                      then show ?thesis 
                      proof(cases "stl2 = p")
                        case True
                        then show ?thesis using  f3 t4 t6 by simp
                      next
                        case f7:False
                        then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p" using pRelationsNew in0 t4' MTArray t6 by fastforce
                        then show ?thesis using prntToP2 f3 f1 MTArray in0 notSame t4 t6 by auto
                      qed
                    next
                      case False
                      then have t7:"TypedMemSubPrefPtrs (memory st') x t p dloc1" using dloc1P by simp
                      then show ?thesis 
                      proof(cases "stl2 = p")
                        case True
                        then show ?thesis using  f3 t4 t6 t7 by (simp add: prntToP)
                      next
                        case f7:False
                        then show ?thesis
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 p")
                          case True
                          then have "CompMemType (memory st') x11 x12 (MTArray x t) stl2 p" using pRelationsNew in0 t4' MTArray t6 f7 by fastforce
                          then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" using t7 prntToP2 
                            by (metis compMemTypes_trns f7 sharedParentSharedSubLocTypes stl2MconN)
                          then show ?thesis using prntToP2 f3 f1 MTArray in0 notSame t4 t6 t7 by simp
                        next
                          case f8:False
                          have "\<not>TypedMemSubPrefPtrs (memory st') x t p stl2" using t7 t4 f3 
                            using TypedMemSubPrefPtrs_trns lsublocs mcPNew mcPrntNew prntToP2 by blast
                          then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st') x t dt p dloc1" 
                            using pRelationsNew f8 f7 t7 t4' in0 MTArray by force
                          then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" using t7 prntToP2 
                            by (metis compMemTypes_trns)
                          then show ?thesis  using prntToP2 f3 f1 MTArray in0 notSame t4 t6 t7 by simp
                        qed
                      qed
                    qed
                  next
                    case False
                    then have same:" accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') =  accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using ldef nonLocChanged iiDef 
                      by (metis hashesIntSame)
                    then obtain ll where llDef:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                                                \<and> (ll = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x t ll dloc1)" using iiDef by blast
                    then have nnPrnt:"\<not>TypedMemSubPrefPtrs (memory st') x t ll prnt \<and> ll \<noteq> prnt" 
                      using TypedMemSubPrefPtrs_imps_notsame iiDef mcPrntNew TypedMemSubPrefPtrs.simps(2) by blast
                    then have cc1:"TypedMemSubPrefPtrs (memory st) len' (MTArray x t) prnt dloc1"
                    proof(cases "ll = dloc1")
                      case True
                      then show ?thesis using llDef iiDef same by auto
                    next
                      case False
                      then have "TypedMemSubPrefPtrs (memory st') x t ll dloc1" using llDef by simp
                      then have "TypedMemSubPrefPtrs (memory st) x t ll dloc1" using nnPrnt
                      proof(induction t arbitrary:x ll)
                        case (MTArray x1 t)
                        then obtain iIn llN where llNDef:"iIn<x \<and> accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st') = Some (MPointer llN) 
                                                            \<and> (llN = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 t llN dloc1)" 
                          unfolding TypedMemSubPrefPtrs.simps by blast
                        then have same2:"accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st') = accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st)" 
                          using nonLocChanged MTArray.prems ldef ShowLNatDot hash_injective by metis
                        then show ?case 
                        proof(cases "llN = dloc1")
                          case True
                          then show ?thesis using llNDef same2 by auto
                        next
                          case False
                          then have "TypedMemSubPrefPtrs (memory st') x1 t llN dloc1" using llNDef by simp
                          then show ?thesis using MTArray.IH[of x1 llN] using MTArray.prems same2 llNDef by force
                        qed
                      next
                        case (MTValue x'')
                        then show ?case unfolding TypedMemSubPrefPtrs.simps by simp
                      qed
                      then show ?thesis 
                        using iiDef llDef same by auto
                    qed

                    then have oo3:"ll = dloc1 \<or> TypedMemSubPrefPtrs (memory st) x t ll dloc1" using llDef same 
                      by (smt (verit, ccfv_SIG) CompMemType_asc_withSharedTarget CompMemType_imps_CompMemJustType CompTypeRemainsMCon MConSubTypes TypedMemSubPrefPtrs_trns diffSubs_imps_prnt iiDef
                          limitedChanges1 lsublocs mcPNew mcPrntNew nnPrnt pSubs prntPNeg_2 CompMemJustType.simps(2) CompMemType.simps(2) subPNew_imp_old)

                    then have nnPrntO:"\<not>TypedMemSubPrefPtrs (memory st) x t ll prnt \<and> ll \<noteq> prnt"
                      using TypedMemSubPrefPtrs_imps_notsame iiDef mcPrntNew TypedMemSubPrefPtrs.simps(2) 
                      using nnPrnt prntPrntNeg by blast

                    moreover have cc2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1" using t4' notSame f1'
                    proof(induction x12 arbitrary:x11 stl2)
                      case (MTArray x1 x12)
                      then obtain i2 ll2 where i2Def: "i2<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = Some (MPointer ll2) 
                                                      \<and> (ll2 = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ll2 dloc1)"
                        unfolding TypedMemSubPrefPtrs.simps by blast
                      then show ?case 
                      proof(cases "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) = l")
                        case True
                        then have "stl2 = prnt" using ldef ShowLNatDot hash_injective by blast
                        then show ?thesis using MTArray.prems by auto
                      next
                        case False
                        then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i2)) (memory st)" using nonLocChanged by simp
                        then show ?thesis 
                        proof(cases "ll2 = dloc1")
                          case True
                          then show ?thesis using i2Def same by auto
                        next
                          case False
                          then have "TypedMemSubPrefPtrs (memory st') x1 x12 ll2 dloc1" using i2Def by simp
                          then show ?thesis using MTArray.IH MTArray.prems same i2Def 
                            by (metis TypedMemSubPrefPtrs.simps(2))
                        qed
                      qed
                    next
                      case (MTValue x)
                      then show ?case by simp
                    qed

                    ultimately have cc3:"\<exists>dt. CompMemType (memory st) x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st) len' arr' dt prnt dloc1" 
                      using prntRelations in0 f1' notSame 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2")
                      case tt5:True
                      then have "CompMemType (memory st) len' arr' (MTArray x11 x12) prnt stl2" using prntRelations in0 f1' notSame  cc1 cc2 MTArray False by fastforce
                      then show ?thesis using cc2 cc1 prntToP2 
                        by (meson compMemTypes_trns lsublocs notSame sharedParentSharedSubLocTypes)
                    next
                      case False
                      have "TypedMemSubPrefPtrs (memory st) len' arr' prnt dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 dloc1" using cc1 cc2 lsublocs by simp
                      then show ?thesis  using prntRelations in0 f1' notSame  cc1 cc2 MTArray False by fastforce
                    qed
                    then obtain dt where dt1:"CompMemType (memory st) x11 x12 dt stl2 dloc1" and dt2:"CompMemType (memory st) len' arr' dt prnt dloc1" by blast+

                    have cc4:"CompMemType (memory st') x11 x12 dt stl2 dloc1" using dt1 f1' notSame stl2Mcon
                    proof(induction x12 arbitrary: x11 stl2)
                      case (MTArray x1 x12)
                      then obtain ii2 ll2 where ii2Def: "ii2<x11 \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st) = Some (MPointer ll2) 
                                                          \<and> (ll2 = dloc1 \<and> MTArray x1 x12 = dt \<or> CompMemType (memory st) x1 x12 dt ll2 dloc1)"
                        unfolding CompMemType.simps by blast
                      then have mc:"MCon (MTArray x1 x12) (memory st) ll2" using MTArray.prems(4) MCon.simps(2) by fastforce
                      have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) \<noteq> l" using ldef ShowLNatDot hash_injective MTArray.prems by blast
                      then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st')" using nonLocChanged by simp
                      then show ?case 
                      proof(cases "ll2 = dloc1")
                        case True
                        then have "MTArray x1 x12 = dt" using ii2Def MTArray.prems(4) 
                          using MTArray.prems(1) existingLocation_imps_allLocs_same by blast
                        then show ?thesis using True same ii2Def by force
                      next
                        case False
                        then have "CompMemType (memory st) x1 x12 dt ll2 dloc1" using ii2Def by simp
                        moreover have "\<not> TypedMemSubPrefPtrs (memory st) x1 x12 ll2 prnt" using MTArray.prems ii2Def by auto
                        moreover have "prnt \<noteq> ll2" using MTArray.prems ii2Def by auto

                        ultimately have "CompMemType (memory st') x1 x12 dt ll2 dloc1" using MTArray.IH[of x1 ll2] mc by blast

                        then show ?thesis unfolding CompMemType.simps using same ii2Def by metis
                      qed
                    next
                      case (MTValue x)
                      then show ?case by simp
                    qed
                    have cc5:"CompMemType (memory st') len' arr' dt prnt dloc1" 
                    proof(cases "ll = dloc1")
                      case True
                      then show ?thesis using llDef iiDef same dt2 
                        by (metis existingLocation_imps_allLocs_same lsublocs CompMemType.simps(2))
                    next
                      case False
                      then have cc7:"TypedMemSubPrefPtrs (memory st) x t ll dloc1" 
                        using oo3 by auto
                      have mcll:"MCon (MTArray x t) (memory st) ll" using mconPrnt llDef iiDef 
                        by (metis MCon_imps_sub_Mcon same)
                      have "CompMemType (memory st) x t dt ll dloc1" using nnPrntO dt2 lsublocs 
                        by (metis False \<open>TypedMemSubPrefPtrs (memory st) x t ll dloc1\<close> existingLocation_imps_allLocs iiDef llDef same)
                      then have "CompMemType (memory st') x t dt ll dloc1" using cc7 nnPrntO mcll
                      proof(induction t arbitrary:x ll)
                        case (MTArray x1 t)
                        then obtain ii2 ll2 where ii2Def: "ii2<x\<and> accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st) = Some (MPointer ll2) 
                                                          \<and> (ll2 = dloc1 \<and> MTArray x1 t = dt \<or> CompMemType (memory st) x1 t dt ll2 dloc1)" 
                          unfolding CompMemType.simps by blast
                        then have "(hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) \<noteq> l" using ldef ShowLNatDot hash_injective MTArray.prems by blast
                        then have same2:"accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st) = accessStore (hash ll (ShowL\<^sub>n\<^sub>a\<^sub>t ii2)) (memory st')" 
                          using nonLocChanged by simp
                        then show ?case 
                        proof(cases "ll2 = dloc1")
                          case True
                          then have "MTArray x1 t = dt" using ii2Def MTArray.prems 
                            by (metis existingLocation_imps_allLocs_same)
                          then show ?thesis using True ii2Def same2 by force
                        next
                          case False
                          then have "CompMemType (memory st) x1 t dt ll2 dloc1" using ii2Def by simp
                          then have "CompMemType (memory st') x1 t dt ll2 dloc1" using MTArray.IH[of x1 ll2] MTArray.prems 
                            by (metis CompMemType_imps_TypedMemSubPrefPtrs MCon_imps_sub_Mcon ii2Def TypedMemSubPrefPtrs.simps(2))
                          then show ?thesis using same2 ii2Def by force
                        qed
                      next
                        case (MTValue x)
                        then show ?case by simp
                      qed
                      then show ?thesis using nnPrntO dt2 lsublocs 
                        using iiDef llDef CompMemType.simps(2) by blast


                    qed
                    have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1"  using dt1 cc4 cc5 by blast

                    then show ?thesis using in0 MTArray f1 f3 notSame  by simp
                  qed


                next
                  case False
                  then show ?thesis using in0 MTArray f1 f3 notSame by auto
                qed

              qed
            qed
          next
            case (MTValue x2)
            then have stl2Mc:"MCon (MTValue x2) (memory st) stl2" using in0 2(1) 
              using sameMemTSafe by blast
            then have stl2McN:"MCon (MTValue x2) (memory st') stl2" using mcAllNew in0 MTValue by blast
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2")
              case t1:True
              then have tt:"TypedMemSubPrefPtrs (memory st') len' (MTArray x t) prnt stl2" using lsublocs by simp

              then have stl2NotP:"stl2 \<noteq> p" using mcPNew stl2McN prntToP2 mcPrntNew 
                by (metis MTValue MTypes.distinct(1) in0 pRelationsNew)

              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x t p stl2")
                case True
                then have "CompMemType (memory st') x t (MTValue x2) p stl2" using pRelationsNew in0 MTValue stl2NotP by force
                then show ?thesis using prntToP2 MTValue t1 notSame 
                  by (metis (lifting) MTypes.simps(6) compMemTypes_trns)
              next
                case f1:False
                then obtain iW lW where iWDef:"iW<len'\<and> accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW)) (memory st') = Some (MPointer lW) \<and> (lW = stl2 \<or> TypedMemSubPrefPtrs (memory st') x t lW stl2)" 
                  using tt unfolding  TypedMemSubPrefPtrs.simps by blast
                have "(hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW)) \<noteq> l"
                proof (rule ccontr)
                  assume "\<not> hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW) \<noteq> l"
                  then have "hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW) = l" by simp
                  then have "lW = p" using 11 iWDef by simp
                  then have "p = stl2 \<or> TypedMemSubPrefPtrs (memory st') x t p stl2" using iWDef by simp
                  then show False using f1 stl2NotP by simp
                qed
                then have same:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW)) (memory st') =  accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW)) (memory st)" 
                  using iWDef nonLocChanged by simp

                then have f2:"\<not>TypedMemSubPrefPtrs (memory st) x t p stl2" 
                  using subPNeg f1 by auto
                then have "TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2" using f1 
                  using CompMemTypeSameLocsSameType limitedChanges1 lsublocs mcPrntNew prntToP2 stl2NotP t1 by presburger
                then have "CompMemType (memory st) len' arr' (MTValue x2) prnt stl2" using prntRelations in0 MTValue notSame by fastforce
                then have cmpOld:"CompMemType (memory st) len' (MTArray x t) (MTValue x2) prnt stl2" using lsublocs by blast


                have tps:"\<forall>new newt. CompMemType (memory st) len' (MTArray x t) newt prnt new \<and> new = stl2 \<longrightarrow> newt = MTValue x2" 
                  using CompMem_SameLocs_SameSubT[OF cmpOld mconPrnt] by blast
                then have "lW = stl2 \<longrightarrow> (MTArray x t) = MTValue x2" using iWDef same by auto
                then have lwNotStl2:"lW \<noteq> stl2" by simp


                then have sub:"TypedMemSubPrefPtrs (memory st') x t lW stl2" using same iWDef by blast
                have access_st_at_field_iW:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t iW)) (memory st) = Some (MPointer lW)" using same iWDef by simp

                then have prntN:"\<not>TypedMemSubPrefPtrs (memory st') x t lW prnt" 
                  using iWDef lwNotStl2 CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon TypedMemSubPrefOneWay lsublocs lsublocs2 
                  by (meson TypedMemSubPrefPtrs_imps_notsame mcPrntNew TypedMemSubPrefPtrs.simps(2))
                have lwNotPrnt:"lW \<noteq> prnt" using iWDef 
                  using MConPtrsMustBeSubLocs access_st_at_field_iW lsublocs by blast

                have "\<forall>new newt. CompMemType (memory st) x t newt lW new \<and> new = stl2 \<longrightarrow> newt = MTValue x2" using same iWDef tps by force
                then have "CompMemType (memory st') x t (MTValue x2) lW stl2" using prntN sub lwNotPrnt
                proof(induction t arbitrary: x lW)
                  case (MTArray x1 t)
                  then obtain iIn lIn where iInDef: "iIn<x \<and> accessStore (hash lW (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st') = Some (MPointer lIn) 
                                                      \<and> (lIn = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 t lIn stl2)" 
                    unfolding  TypedMemSubPrefPtrs.simps by blast
                  then have "(hash lW (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) \<noteq> l" using MTArray.prems ldef hash_injective ShowLNatDot by blast
                  then have "accessStore (hash lW (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st') =accessStore (hash lW (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st)" using nonLocChanged by simp
                  then have cmp:" CompMemType (memory st) x (MTArray x1 t) (MTArray x1 t) lW lIn" using iInDef  by force
                  then show ?case 
                  proof(cases "lIn = stl2")
                    case True
                    then show ?thesis using cmp MTArray.prems by blast
                  next
                    case False
                    then have "TypedMemSubPrefPtrs (memory st') x1 t lIn stl2" using iInDef by simp
                    then have "CompMemType (memory st') x1 t (MTValue x2) lIn stl2" using MTArray.IH[of x1 lIn] MTArray.prems same iInDef 
                      by (metis cmp compMemTypes_trns TypedMemSubPrefPtrs.simps(2))
                    then show ?thesis using same iInDef by auto
                  qed
                next
                  case (MTValue x'')
                  then have "\<exists>i<x. hash lW (ShowL\<^sub>n\<^sub>a\<^sub>t i) = stl2" unfolding  TypedMemSubPrefPtrs.simps by simp
                  then show ?case unfolding CompMemType.simps using MTValue(1) by auto
                qed

                then have "CompMemType (memory st') len' (MTArray x t) (MTValue x2) prnt stl2" using iWDef by auto

                then show ?thesis using notSame in0 MTValue t1 lsublocs by simp
              qed  
            next
              case False
              then show ?thesis using notSame MTValue by auto
            qed
          qed            
        qed
      qed
      have prntLim3:"\<forall>x11' x12' stl2 stl1. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and> \<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1 \<and>
            stl2 \<noteq> prnt \<and> ( \<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')
            \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1
        assume "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
       \<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1 \<and>
       stl2 \<noteq> prnt \<and> (\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')"
        then have in1:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1"
          and "\<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1"
          and "stl2 \<noteq> prnt"
          and " (\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')" by simp+
        then show "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          then obtain ii ll where iiDef: "ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                      \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1)"
            unfolding TypedMemSubPrefPtrs.simps by blast
          then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray.prems by blast
          then have same:" accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "ll = stl1")
            case True
            then show ?thesis using iiDef same  by auto
          next
            case False
            then have s:"TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1" using iiDef by simp
            have llNotPrnt:"ll \<noteq> prnt"
            proof
              assume *:"ll = prnt"
              then have "MTArray x1 x12' = MTArray len' arr'" using MTArray.prems(4) iiDef by auto
              then show False using s MTArray.prems(2) * by simp
            qed
            then have "TypedMemSubPrefPtrs (memory st) x1 x12' ll stl1" 
              using MTArray.IH[OF s MTArray.prems(2) llNotPrnt] iiDef MTArray.prems(4) by auto
            then show ?thesis using same iiDef by force
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntLim3Neg:"\<forall>x11' x12' stl2 stl1. \<not>TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and> \<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1 \<and>
            stl2 \<noteq> prnt \<and> ( \<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')
            \<longrightarrow> \<not>TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1
        assume "\<not>TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
       \<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1 \<and>
       stl2 \<noteq> prnt \<and> (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')"
        then have in1:"\<not>TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1"
          and "\<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1"
          and "stl2 \<noteq> prnt"
          and " (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')" by simp+
        then show "\<not>TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          then have iiNeg: "\<forall>i<x11'. \<exists>l. accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') \<noteq> Some (MPointer l) 
                                          \<or> (l \<noteq> stl1 \<and> \<not>TypedMemSubPrefPtrs (memory st') x1 x12' l stl1)"
            unfolding TypedMemSubPrefPtrs.simps by blast
          show ?case 
          proof
            assume "TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 stl1"
            then obtain ii ll where iiDef: "ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = Some (MPointer ll) 
                      \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st) x1 x12' ll stl1)"
              unfolding TypedMemSubPrefPtrs.simps by blast
            then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray.prems by blast
            then have same:" accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
            show False
            proof(cases "ll = stl1")
              case True
              then show ?thesis using iiDef same iiNeg 
                using MTArray.prems(1) by auto
            next
              case False
              then have s:"TypedMemSubPrefPtrs (memory st) x1 x12' ll stl1" using iiDef by simp
              have llNotPrnt:"ll \<noteq> prnt"
              proof
                assume *:"ll = prnt"
                then have "MTArray x1 x12' = MTArray len' arr'" using MTArray.prems(4) iiDef by auto
                then show False using s MTArray.prems(2) * by simp
              qed
              then show ?thesis using same  MTArray.IH[OF ] iiDef MTArray.prems(4) 
                by (metis MTArray.prems(1,2) CompMemType.simps(2) TypedMemSubPrefPtrs.simps(2))
            qed
          qed

        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntLim4:"\<forall>x11' x12' stl2 stl1  dt. CompMemType (memory st) x11' x12' dt stl2 stl1 \<and> \<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1 \<and>
            stl2 \<noteq> prnt \<and> ( \<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr') \<and> MCon (MTArray x11' x12') (memory st) stl2 
            \<longrightarrow> CompMemType (memory st') x11' x12' dt stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1 dt
        assume "CompMemType (memory st) x11' x12' dt stl2 stl1 \<and>
       \<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1 \<and>
       stl2 \<noteq> prnt \<and> (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr') \<and> MCon (MTArray x11' x12') (memory st) stl2"
        then have in1:"CompMemType (memory st) x11' x12' dt stl2 stl1"
          and "\<not> TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1"
          and "stl2 \<noteq> prnt"
          and " (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')" 
          and "MCon (MTArray x11' x12') (memory st) stl2" by blast+
        then show "CompMemType (memory st') x11' x12' dt stl2 stl1"
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          then obtain ii ll where iiDef: "ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = Some (MPointer ll) 
                      \<and> (ll = stl1 \<and> MTArray x1 x12' = dt \<or> CompMemType (memory st) x1 x12' dt ll stl1)"
            unfolding CompMemType.simps by blast
          then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray.prems by blast
          then have same:" accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "ll = stl1")
            case True
            then have "MTArray x1 x12' = dt" using iiDef True 
              by (metis MTArray.prems(1,5) existingLocation_imps_allLocs_same)
            then show ?thesis using iiDef same True by force
          next
            case False
            then have s:"CompMemType (memory st) x1 x12' dt ll stl1" using iiDef by simp
            have llNotPrnt:"ll \<noteq> prnt"
            proof
              assume *:"ll = prnt"
              then have "MTArray x1 x12' = MTArray len' arr'" using MTArray.prems(4) iiDef same by auto
              then show False using s MTArray.prems(2) * same 
                by (simp add: CompMemType_imps_TypedMemSubPrefPtrs)
            qed
            have "MCon (MTArray x1 x12') (memory st) ll" using MTArray.prems(5) iiDef 
              using MconSameTypeSameAccessWithTyping by blast
            then have "CompMemType (memory st') x1 x12' dt ll stl1" 
              using MTArray.IH[OF s MTArray.prems(2) llNotPrnt] iiDef MTArray.prems(4,5) by auto
            then show ?thesis using same iiDef by auto
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have prntLim5:"\<forall>x11' x12' stl2 dloc1 dt. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 
                        \<and>  (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = dloc1 \<longrightarrow> newt = dt)
                      \<and> stl2 \<noteq> prnt \<and> \<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 
                    \<and> (\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')
                      \<longrightarrow> CompMemType (memory st') x11' x12' dt stl2 dloc1"
      proof intros
        fix x11' x12' stl2 dloc1 dt
        assume " TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<and>
       (\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = dloc1 \<longrightarrow> newt = dt) \<and>
       stl2 \<noteq> prnt \<and>
       \<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> (\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')"
        then have " TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" and
          "(\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = dloc1 \<longrightarrow> newt = dt)"
          and "stl2 \<noteq> prnt"
          and "\<not> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1" 
          and "(\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr')" by blast+
        then show "CompMemType (memory st') x11' x12' dt stl2 dloc1"
        proof(induction x12' arbitrary: x11' stl2)
          case (MTArray x1 x12')
          obtain ii ll where iiDef:"ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                                      \<and> (ll = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll dloc1)"
            using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by auto
          then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray.prems(3) by blast
          then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "ll = dloc1")
            case True
            then have "(MTArray x1 x12') = dt" using iiDef MTArray.prems(2) same by auto
            then show ?thesis using iiDef True by force
          next
            case False
            then have cc1:"TypedMemSubPrefPtrs (memory st') x1 x12' ll dloc1" using iiDef by simp
            have cc2:"\<forall>new newt. CompMemType (memory st) x1 x12' newt ll new \<and> new = dloc1 \<longrightarrow> newt = dt" using iiDef MTArray.prems(2) same by auto
            have cc3:"ll \<noteq> prnt"
            proof
              assume *:"ll = prnt"
              then have "(MTArray x1 x12') = MTArray len' arr'" using MTArray.prems(5) iiDef by auto
              then show False using MTArray.prems(4) cc1 * by simp
            qed
            have "\<forall>new newt. CompMemType (memory st') x1 x12' newt ll new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'" using MTArray.prems(5) same iiDef by force
            then have "CompMemType (memory st') x1 x12' dt ll dloc1" 
              using MTArray.IH[OF cc1 cc2 cc3 MTArray.prems(4)] MTArray.prems iiDef same  by blast
            then show ?thesis using iiDef same by auto
          qed
        next
          case (MTValue x)
          show ?case using MTValue(1,2) by auto
        qed
      qed

      have prntLim6:"\<forall>x11' x12' stl2 dloc1. \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt\<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1\<and> stl2 \<noteq> prnt
              \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1"
      proof intros
        fix x11' x12' stl2 dloc1
        assume " \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<and> stl2 \<noteq> prnt"
        then show "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1 "
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          obtain ii ll where iiDef:"ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) \<and>
                                         (ll = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll dloc1)" 
            using MTArray.prems unfolding TypedMemSubPrefPtrs.simps by blast
          then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray by blast
          then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') =accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "ll = dloc1")
            case True
            then show ?thesis using same iiDef by force
          next
            case False
            then show ?thesis using iiDef same MTArray by auto
          qed
        next
          case (MTValue x)
          then show ?case by auto
        qed
      qed

      have prntLim7:"\<forall>x11' x12' stl2 stl1 dt.(\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = stl1 \<longrightarrow> newt = dt) 
                     \<and> \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt \<and> stl2 \<noteq> prnt
                     \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 
                      \<longrightarrow> CompMemType (memory st') x11' x12' dt stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1 dt
        assume "(\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = stl1 \<longrightarrow> newt = dt) \<and>
       \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt \<and> stl2 \<noteq> prnt \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1"
        then have "(\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = stl1 \<longrightarrow> newt = dt)"
          and "\<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt"
          and "stl2 \<noteq> prnt"
          and "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1" by blast+
        then show "CompMemType (memory st') x11' x12' (dt) stl2 stl1"
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')
          then obtain ii ll where iiDef:"ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') = Some (MPointer ll) 
                                        \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ll stl1)"
            unfolding TypedMemSubPrefPtrs.simps by blast
          then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using MTArray.prems ldef ShowLNatDot hash_injective by blast
          then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st') =accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st)" using nonLocChanged by simp
          then show ?case 
          proof(cases "ll = stl1")
            case True
            then show ?thesis using same MTArray.prems(1) iiDef by force
          next
            case False
            then show ?thesis using same MTArray iiDef 
              by (metis (no_types, opaque_lifting) CompMemType.simps(2) TypedMemSubPrefPtrs.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case by auto
        qed
      qed

      have prntLim8:"\<forall>x11' x12' stl2 stl1. \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and>
                    \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt \<and> stl2 \<noteq> prnt
                    \<longrightarrow> \<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
      proof intros
        fix x11' x12' stl2 stl1
        assume "\<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 \<and> \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt \<and> stl2 \<noteq> prnt"
        then show "\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1"
        proof(induction x12' arbitrary:x11' stl2)
          case (MTArray x1 x12')

          show ?case 
          proof
            assume *:"TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 stl1"
            then obtain ii ll where  iiDef:"ii<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = Some (MPointer ll) 
                                            \<and> (ll = stl1 \<or> TypedMemSubPrefPtrs (memory st) x1 x12' ll stl1)"
              unfolding TypedMemSubPrefPtrs.simps by blast
            then have " (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) \<noteq> l" using ldef hash_injective ShowLNatDot MTArray.prems by blast
            then have same:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st) = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t ii)) (memory st')" using nonLocChanged by simp
            show False
            proof(cases "ll = stl2")
              case True
              then show ?thesis using iiDef same MTArray.prems 
                using MTArray.IH by force
            next
              case False
              then show ?thesis using iiDef same MTArray by auto 
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed


      show ?thesis unfolding TypeSafe_def StateInvariant_def
      proof intros 
        show "AddressTypes (accounts st')" using 2(1) 11 unfolding TypeSafe_def by simp
      next 
        show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
        then show "compPointers (stack st')  (denvalue env)"  using sameStack  sameStorage by simp
      next 
        show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
      next 
        show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "balanceTypes (accounts st')" using 11 using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
          using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have **:"toploc (stack st) = toploc (stack st')" using 11 unfolding updateStore_def by auto
        show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
        proof intros

          fix tloc loc 
          assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
          then show "accessStore loc (stack st') = None" using *  
            by (simp add: sameStack)
        next 
          fix loc y 
          assume h1:" accessStore loc (stack st') = Some y"
          then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
            by (metis sameStack)
        qed
      next 
        show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
      next
        have a12:"toploc (memory st) = toploc (memory st')" using 11 unfolding updateStore_def by auto
        have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
        proof intros
          fix tloc loc 
          assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have b20:"toploc (memory st) \<le> tloc" using a12 tloc a12 
            by force

          then show "accessStore loc (memory st') = None " 
            by (metis a15 b10 lOrigin lessThanSome_imps_Locs lessThanTopLocs_def linorder_not_less nonLocChanged)
        next 
          fix loc y 
          assume "accessStore loc (memory st') = Some y "
          then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
            by (metis a12 a15 lOrigin lessThanTopLocs_def nonLocChanged)
        qed
      next 
        show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
          unfolding typeCompat_def
        proof intros
          fix tLook lLook
          assume inDen:" (tLook, lLook) |\<in>| fmran (denvalue env)"
          show " case lLook of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tLook of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tLook of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case tLook of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tLook of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tLook of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
          proof(cases lLook)
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc by force
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some  by force
              next
                case (KCDptr x2)
                then show ?thesis  using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some by force
              next
                case (KMemptr x3)
                then obtain struct where stT: "tLook = Memory struct" using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some 
                  by (cases tLook; fastforce)
                then have "MCon struct (memory st') x3"  using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some KMemptr 
                  using mcAllNew by auto
                then show ?thesis using sameStorage inDen sameStack Stackloc Some KMemptr stT by simp
              next
                case (KStoptr x4)
                then show ?thesis  using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen sameStack Stackloc Some by (cases tLook; force)
              qed
            qed
          next
            case (Storeloc x2)
            then show ?thesis using 2(1) unfolding TypeSafe_def typeCompat_def using sameStorage inDen 
              by (metis Denvalue.simps(6))
          qed
        qed
        then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd " using sameStack by simp
      next 
        have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
        show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
        proof intros
          fix tp1 tp2 l1 l2 stl1 stl2 dloc1
          assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
          have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
            using 2(1)  unfolding TypeSafe_def unique_locations_def by blast

          have a3:"\<forall>dloc1.
     (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
     (if stl1 = stl2 then tp1 = tp2
      else case tp1 of
           MTArray len arr \<Rightarrow>
             (case tp2 of
             MTArray len2 arr2 \<Rightarrow>
               if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
               else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                    else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                         then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
             | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
           | MTValue val \<Rightarrow>
               (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
               | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

          then show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)"
          proof(cases "stl1 = stl2")
            case same:True
            then show ?thesis using a1 a0 same unfolding compMemPtrs_def 
              by (simp add: sameStack)
          next
            case notSame:False

            then show ?thesis 
            proof(cases tp1)
              case mta1:(MTArray x11 x12)
              then have mcStl1:"MCon (MTArray x11 x12) (memory st') stl1" using a1 mcAllNew sameStack by metis
              have mcStl1O:" MCon (MTArray x11 x12) (memory st) stl1" using a1 sameStack 2(1) mta1 unfolding TypeSafe_def typeCompat_def by fastforce

              then show ?thesis 
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                then have mcStl2:"MCon (MTArray x11' x12') (memory st') stl2" using a1 mcAllNew sameStack by metis
                have mcStl2O:" MCon (MTArray x11' x12') (memory st) stl2" using a1 sameStack 2(1) mta2 unfolding TypeSafe_def typeCompat_def by fastforce
                then show ?thesis 
                proof(cases "stl1 = prnt")
                  case stl1IsPrnt:True
                  then have tp1PrntTp:"MTArray len' arr' = MTArray x11 x12" using prntRelationsNew a1 mta1 sameStack by metis
                  have stl2NotPrnt:"stl2 \<noteq> prnt" using notSame stl1IsPrnt by simp
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                    case t2:True
                    then have "CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt" 
                      using prntRelationsNew mta2 stl2NotPrnt stl1IsPrnt a1 sameStack by fastforce
                    then show ?thesis using notSame mta1 mta2 a1 stl1IsPrnt tp1PrntTp t2 by simp
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                      case t2:True
                      then have "CompMemType (memory st') len' arr' (MTArray x11' x12') prnt stl2"
                        using prntRelationsNew mta2 stl2NotPrnt stl1IsPrnt tp1PrntTp a1 sameStack f2 by fastforce
                      then show ?thesis  using notSame mta1 mta2 a1 stl1IsPrnt tp1PrntTp t2 f2 by simp
                    next
                      case f3:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                        case t2:True
                        then have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" 
                          using prntRelationsNew mta2 stl2NotPrnt stl1IsPrnt tp1PrntTp a1 sameStack f2 f3 by fastforce
                        then show ?thesis  using notSame mta1 mta2 a1 stl1IsPrnt tp1PrntTp t2 f2 f3 by simp
                      next
                        case False
                        then show ?thesis using notSame mta1 mta2 a1 stl1IsPrnt tp1PrntTp f2 f3 by auto
                      qed
                    qed
                  qed
                next
                  case stl1NotPrnt:False
                  then show ?thesis 
                  proof(cases "stl2 = prnt")
                    case stl2IsPrnt:True
                    then have tp2PrntTp:"MTArray len' arr' = MTArray x11' x12'" using prntRelationsNew a1 mta2 sameStack by metis
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                      case t2:True
                      then have "CompMemType (memory st') len' arr' (MTArray x11 x12) stl2 stl1" 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                        case True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt"
                          using prntRelationsNew mta1 stl1NotPrnt stl2IsPrnt a1 sameStack by fastforce
                        then show ?thesis using t2 TypedMemSubPrefOneWay mcStl2 mcStl1 stl2IsPrnt tp2PrntTp True 
                          by (metis TypedMemSubPrefPtrs_imps_notsame TypedMemSubPrefPtrs_trns)
                      next
                        case False
                        then show ?thesis using prntRelationsNew mta1 stl1NotPrnt stl2IsPrnt a1 sameStack t2 tp2PrntTp by fastforce
                      qed
                      then show ?thesis using notSame mta1 mta2 a1 stl2IsPrnt tp2PrntTp t2 by simp
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                        case t2:True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt"
                          using prntRelationsNew mta1 stl1NotPrnt stl2IsPrnt tp2PrntTp a1 sameStack f2 
                          by fastforce
                        then show ?thesis  using notSame mta1 mta2 a1 stl2IsPrnt tp2PrntTp t2 f2 by simp
                      next
                        case f3:False
                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                          case t2:True
                          then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" 
                            using prntRelationsNew mta1 stl1NotPrnt stl2IsPrnt tp2PrntTp a1 sameStack f2 f3 by fastforce
                          then show ?thesis  using notSame mta1 mta2 a1 stl2IsPrnt tp2PrntTp t2 f2 f3 by auto
                        next
                          case False
                          then show ?thesis using notSame mta1 mta2 a1 stl2IsPrnt tp2PrntTp f2 f3 by auto
                        qed
                      qed
                    qed
                  next
                    case stl2NotPrnt:False
                    then show ?thesis
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 prnt")
                      case stl1ToPrnt:True
                      then have stl1ToPrntTPS:"CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt" 
                        using prntRelationsNew mta1 a1 sameStack stl1NotPrnt by fastforce
                      then have prntNotToStl1:"\<not>TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1" using stl1ToPrnt 
                        using CompMemType_imps_CompMemJustType CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl1 by blast
                      have stl1ToPrntO:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt" using stl1ToPrnt 
                        using getToPrntNew_imps_Old stl1NotPrnt by auto
                      then have stl1ToPrntTPSO:"CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt" 
                        using prntRelations mta1 a1 sameStack stl1NotPrnt by fastforce
                      then have prntNotToStl1O:"\<not>TypedMemSubPrefPtrs (memory st) len' arr' prnt stl1" 
                        using stl1ToPrntO mcStl1O CompTypeRemainsMCon TypedMemSubPrefOneWay CompMemType_imps_CompMemJustType by metis
                      have tp1Sub:"\<forall>new newt. CompMemType (memory st') x11 x12 newt stl1 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'" 
                        using CompMem_SameLocs_SameSubT[OF stl1ToPrntTPS mcStl1] by simp
                      have tp1SubO:"\<forall>new newt. CompMemType (memory st) x11 x12 newt stl1 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'"
                        using CompMem_SameLocs_SameSubT[OF stl1ToPrntTPSO mcStl1O] by simp
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt")
                        case stl2ToPrnt:True
                        then have stl2ToPrntTPS:"CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt" 
                          using prntRelationsNew mta2 a1 sameStack stl2NotPrnt by fastforce
                        then have prntNotToStl2:"\<not>TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2" using stl2ToPrnt 
                          using CompMemType_imps_CompMemJustType CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl2 by blast
                        have stl2ToPrntO:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt" using stl1ToPrnt 
                          using getToPrntNew_imps_Old stl2NotPrnt stl2ToPrnt by auto
                        then have stl2ToPrntTPSO:"CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt" 
                          using prntRelations mta2 a1 sameStack stl2NotPrnt by fastforce
                        have tp2Sub:"\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'" 
                          using CompMem_SameLocs_SameSubT[OF stl2ToPrntTPS mcStl2] by simp
                        have tp2SubO:"\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'"
                          using CompMem_SameLocs_SameSubT[OF stl2ToPrntTPSO mcStl2O] by simp
                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                          case True
                          have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using True prntNotToStl1 stl2NotPrnt tp2Sub prntLim3 by blast
                          then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using a3 a1 sameStack notSame mta1 mta2 by simp
                          then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" 
                            using stl1ToPrntTPS stl2ToPrntTPS prntLim4 tp2SubO prntNotToStl1O mcStl2O stl2NotPrnt by blast
                          then show ?thesis using notSame True mta1 mta2 by simp
                        next
                          case f2:False
                          then have f2':"\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using prntLim3Neg 
                            by (simp add: prntNotToStl1O stl2NotPrnt tp2SubO)
                          then show ?thesis 
                          proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                            case t2:True
                            have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using t2 prntNotToStl2 stl1NotPrnt tp1Sub prntLim3 by blast
                            then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using a3 a1 sameStack notSame mta1 mta2 f2' by auto
                            then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" 
                              using prntLim4 
                              by (metis CompMemType_imps_CompMemJustType CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl1O stl1NotPrnt stl2ToPrntO stl2ToPrntTPSO tp1SubO)
                            then show ?thesis using notSame f2 mta1 mta2 t2 by simp
                          next
                            case f3:False
                            then have f3':"\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2 " 
                              using CompMemType_imps_CompMemJustType TypedMemSubPrefOneWay lsublocs mcStl2O prntLim3Neg stl1NotPrnt stl2ToPrntO stl2ToPrntTPSO tp1SubO by blast

                            then show ?thesis 
                            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                              case t2:True
                              then have " \<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              proof(cases "dloc1 = prnt")
                                case t3:True
                                then show ?thesis using stl2ToPrntTPS stl1ToPrntTPS by auto
                              next
                                case f4:False
                                then show ?thesis 
                                proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1")
                                  case t4:True
                                  then show ?thesis using t2 stl2ToPrntTPS stl1ToPrntTPS 
                                    by (meson compMemTypes_trns mcStl2 sharedParentSharedSubLocTypes stl2NotPrnt)
                                next
                                  case f5:False
                                  then have o1:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1" using prntLim3 t2 
                                    by (simp add: stl1NotPrnt tp1Sub)
                                  have o2:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1"  using prntLim3 t2 f5 
                                    using stl2NotPrnt tp2Sub by blast
                                  then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                                    using a3 a1 sameStack notSame mta1 mta2 f2' f3' o1 o2 by simp
                                  then obtain dt where ocmp2:"CompMemType (memory st) x11' x12' dt stl2 dloc1"
                                    and ocmp1:"CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast 

                                  then have ocmp22:"\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = dloc1 \<longrightarrow> newt = dt" using CompMem_SameLocs_SameSubT[OF ocmp2 mcStl2O] by blast
                                  have "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" using t2 by blast
                                  then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using    ocmp22 stl2NotPrnt f5  tp2Sub prntLim5 by blast
                                  moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" using prntLim5 
                                    using CompMemTypeSameLocsSameType f5 mcStl1O ocmp1 stl1NotPrnt t2 tp1Sub by blast
                                  ultimately show ?thesis by auto
                                qed
                              qed
                              then show ?thesis  using notSame f2 f3 mta1 mta2 t2 by simp
                            next
                              case False
                              then show ?thesis using notSame f2 f3 mta1 mta2 by auto
                            qed

                          qed
                        qed
                      next
                        case notPPrnt:False
                        then have notPPrnt':"\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt " 
                          using prntPrntNeg stl2NotPrnt by blast
                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                          case t2:True
                          then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using notPPrnt 
                            using CompMemType_imps_TypedMemSubPrefPtrs prntLim3 prntNotToStl1 stl2NotPrnt by blast
                          then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
                            using notSame a3 a1 mta1 mta2 sameStack by simp
                          then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using notPPrnt notPPrnt' 
                            using CompMemType_imps_TypedMemSubPrefPtrs compMemTypes_trns stl1ToPrntTPSO by blast
                          then show ?thesis using notSame a3 a1 mta1 mta2 t2 by simp
                        next
                          case f3:False
                          then have f3':"\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1 " 
                            using CompMemType_imps_TypedMemSubPrefPtrs notPPrnt' prntLim3Neg prntNotToStl1O stl2NotPrnt by blast
                          then show ?thesis 
                          proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                            case t2:True
                            then show ?thesis 
                            proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2")
                              case t6:True
                              then have "CompMemType (memory st') len' arr' (MTArray x11' x12') prnt stl2" 
                                using prntRelationsNew stl2NotPrnt notPPrnt a1 mta2 sameStack by fastforce
                              then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" 
                                using compMemTypes_trns stl1ToPrntTPS by blast
                              then show ?thesis using notSame a3 a1 mta1 mta2 t2  f3 by simp
                            next
                              case False
                              then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using f3 t2  prntLim3 stl1NotPrnt mta1 tp1Sub by simp
                              then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using a3 a1 notSame f3' mta1 mta2 sameStack by simp
                              then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" 
                                using False mcStl1O prntLim5 stl1NotPrnt t2 CompMem_SameLocs_SameSubT tp1Sub by blast
                              then show ?thesis  using notSame a3 a1 mta1 mta2 t2  f3 by simp
                            qed
                          next
                            case f4:False
                            then show ?thesis 
                            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                              case t2:True
                              then have p1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" and p2:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" 
                                by blast+
                              have stl2ODl:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" using notPPrnt p2 stl2NotPrnt prntLim6 by simp

                              then have " \<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1"  
                              proof(cases "prnt = dloc1")
                                case True
                                then show ?thesis using notPPrnt t2 by auto
                              next
                                case f5:False
                                then show ?thesis 
                                proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1")
                                  case True
                                  then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1" using p1 
                                    by (meson compMemTypes_trns mcStl1 sharedParentSharedSubLocTypes stl1NotPrnt stl1ToPrntTPS)
                                  moreover have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" 
                                  proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2")
                                    case t6:True
                                    then have "CompMemType (memory st') len' arr' (MTArray x11' x12') prnt stl2" 
                                      using prntRelationsNew notPPrnt stl2NotPrnt a1 sameStack mta2  by fastforce
                                    then show ?thesis using True 
                                      by (metis CompMemType_imps_TypedMemSubPrefPtrs compMemTypes_trns f4 stl1ToPrntTPS)
                                  next
                                    case False
                                    then show ?thesis  using prntRelationsNew notPPrnt stl2NotPrnt a1 sameStack mta2 True p2 by fastforce
                                  qed
                                  ultimately have " \<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                                    using compMemTypes_trns stl1ToPrntTPS by blast
                                  then show ?thesis by simp
                                next
                                  case False
                                  then have stl1ODl:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 " using p1 
                                    by (simp add: prntLim3 stl1NotPrnt tp1Sub)
                                      (*then have True using notSame a3 a1 mta1 mta2 t2  f3' *)
                                  then show ?thesis 
                                  proof(cases " TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2")
                                    case t8:True
                                    then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using notSame a3 a1 mta1 mta2 t2  f3' sameStack by simp
                                    then obtain dt where dtDef:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" using stl1ODl stl2ODl 
                                      by (meson compMemTypes_trns mcStl1O notSame sharedParentSharedSubLocTypes)
                                    then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using False 
                                      by (metis CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs mcStl2O notPPrnt prntLim5 stl2NotPrnt t2)
                                    moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" using False dtDef t2 
                                      by (metis (no_types, lifting) CompMemTypeSameLocsSameType mcStl1O prntLim5 stl1NotPrnt tp1Sub)
                                    ultimately show ?thesis  by auto
                                  next
                                    case f2:False
                                    then obtain dt where dtDef:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                                      using notSame a3 a1 mta1 mta2 t2  f3' sameStack stl1ODl stl2ODl by fastforce
                                    then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using False 
                                      by (metis CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs mcStl2O notPPrnt prntLim5 stl2NotPrnt t2)
                                    moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" using False dtDef t2 
                                      by (metis (no_types, lifting) CompMemTypeSameLocsSameType mcStl1O prntLim5 stl1NotPrnt tp1Sub)
                                    ultimately show ?thesis by auto
                                  qed
                                qed
                              qed

                              then show ?thesis  using notSame f4 f3 mta1 mta2 t2 by simp
                            next
                              case False
                              then show ?thesis using notSame f4 f3 mta1 mta2 by auto
                            qed
                          qed
                        qed
                      qed

                    next
                      case notPPrnt:False
                      then have notPPrnt':" \<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt"  
                        using prntPrntNeg stl1NotPrnt by auto
                      then show ?thesis
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt")
                        case stl2ToPrnt:True
                        then have stl2ToPrntTPS:"CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt" 
                          using prntRelationsNew mta2 a1 sameStack stl2NotPrnt by fastforce
                        then have prntNotToStl2:"\<not>TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2" using stl2ToPrnt 
                          using CompMemType_imps_CompMemJustType CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl2 by blast

                        have stl2ToPrntO:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt"  
                          using getToPrntNew_imps_Old stl2NotPrnt stl2ToPrnt by auto
                        then have stl2ToPrntTPSO:"CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt" 
                          using prntRelations mta2 a1 sameStack stl2NotPrnt by fastforce
                        then have prntNotToStl2:"\<not>TypedMemSubPrefPtrs (memory st) len' arr' prnt stl2" using stl2ToPrnt 
                          by (meson CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl2O)
                        have tp2Sub:"\<forall>new newt. CompMemType (memory st') x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'" 
                          using CompMem_SameLocs_SameSubT[OF stl2ToPrntTPS mcStl2] by simp
                        have tp2SubO:"\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = prnt \<longrightarrow> newt = MTArray len' arr'"
                          using CompMem_SameLocs_SameSubT[OF stl2ToPrntTPSO mcStl2O] by simp
                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                          case t2:True
                          then show ?thesis
                          proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1")
                            case t6:True
                            then have "CompMemType (memory st') len' arr' (MTArray x11 x12) prnt stl1" 
                              using prntRelationsNew stl1NotPrnt notPPrnt a1 mta1 sameStack by fastforce
                            then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" 
                              using compMemTypes_trns stl2ToPrntTPS by blast
                            then show ?thesis using notSame a3 a1 mta1 mta2 t2 by simp
                          next
                            case False
                            then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using t2  prntLim3 stl2NotPrnt mta1 tp2Sub by simp
                            then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using a3 a1 notSame  mta1 mta2 sameStack by simp
                            then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" 
                              using False mcStl2O prntLim5 stl2NotPrnt t2 CompMem_SameLocs_SameSubT tp2Sub by blast
                            then show ?thesis  using notSame a3 a1 mta1 mta2 t2  by simp
                          qed
                        next
                          case f3:False
                          then show ?thesis
                          proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                            case t2:True
                            then have t2':"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using notPPrnt 
                              using CompMemType_imps_TypedMemSubPrefPtrs prntLim3 prntNotToStl2 stl1NotPrnt 
                              using prntLim6 by blast

                            then show ?thesis
                            proof(cases "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1")
                              case True
                              then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using a3 a1 notSame  mta1 mta2 sameStack by simp
                              then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" 
                                by (meson CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs CompTypeRemainsMCon TypedMemSubPrefOneWay mcStl2O t2')
                              then show ?thesis using CompMemType_imps_TypedMemSubPrefPtrs f3 by blast
                            next
                              case False
                              then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2"
                                using t2' notSame a3 a1 mta1 mta2 sameStack by simp
                              then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using notPPrnt notPPrnt' 
                                using CompMemType_imps_TypedMemSubPrefPtrs compMemTypes_trns stl2ToPrntTPSO by blast
                              then show ?thesis using notSame a3 a1 mta1 mta2 t2 f3 
                                using CompMemType_imps_TypedMemSubPrefPtrs by blast
                            qed


                          next
                            case f4:False
                            then have f4':" \<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2 " 
                              using CompMemType_imps_TypedMemSubPrefPtrs notPPrnt' prntLim3Neg prntNotToStl2 stl1NotPrnt by blast
                            then show ?thesis 
                            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                              case t2:True
                              then have p1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" and p2:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" 
                                by blast+
                              have stl1ODl:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1" using notPPrnt p1 stl1NotPrnt prntLim6 by simp

                              then have " \<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1"  
                              proof(cases "prnt = dloc1")
                                case True
                                then show ?thesis using notPPrnt t2 by auto
                              next
                                case f5:False
                                then show ?thesis 
                                proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1")
                                  case True
                                  then have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1" using p1 
                                    by (meson compMemTypes_trns mcStl2 sharedParentSharedSubLocTypes stl2NotPrnt stl2ToPrntTPS)
                                  moreover have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') len' arr' dt prnt dloc1" 
                                  proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1")
                                    case t6:True
                                    then have "CompMemType (memory st') len' arr' (MTArray x11 x12) prnt stl1" 
                                      using prntRelationsNew notPPrnt stl1NotPrnt a1 sameStack mta1  by fastforce
                                    then show ?thesis using True 
                                      using TypedMemSubPrefPtrs_trns f3 mcPrntNew mcStl2 stl2ToPrntTPS t6 by blast
                                  next
                                    case False
                                    then show ?thesis using prntRelationsNew notPPrnt stl1NotPrnt a1 sameStack mta1 True p1 by force
                                  qed
                                  ultimately have " \<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                                    using compMemTypes_trns stl2ToPrntTPS by blast
                                  then show ?thesis by simp
                                next
                                  case False
                                  then have stl2ODl:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1 " using p2
                                    by (simp add: prntLim3 stl2NotPrnt tp2Sub)
                                  then show ?thesis 
                                  proof(cases " TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1")
                                    case t8:True
                                    then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using notSame a3 a1 mta1 mta2 t2  f3 sameStack by simp
                                    then obtain dt where dtDef:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" using  stl2ODl 
                                      by (metis compMemTypes_trns mcStl2O notPPrnt notSame prntLim6 sharedParentSharedSubLocTypes stl1NotPrnt t2)
                                    then have "CompMemType (memory st') x11 x12 dt stl1 dloc1" using False 
                                      by (metis CompMemType_imps_TypedMemSubPrefPtrs mcStl1O notPPrnt p1 prntLim5 stl1NotPrnt CompMem_SameLocs_SameSubT)
                                    moreover have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using False dtDef t2 
                                      by (metis (no_types, lifting) CompMemTypeSameLocsSameType mcStl2O prntLim5 stl2NotPrnt tp2Sub)
                                    ultimately show ?thesis  by auto
                                  next
                                    case f2:False
                                    then obtain dt where dtDef:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                                      using notSame a3 a1 mta1 mta2 t2   sameStack stl1ODl stl2ODl f4' by fastforce
                                    then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using False 
                                      using mcStl2O p2 prntLim5 stl2NotPrnt CompMem_SameLocs_SameSubT tp2Sub by blast
                                    moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" using False dtDef t2 
                                      by (metis CompMemTypeSameLocsSameType CompMemType_imps_TypedMemSubPrefPtrs mcStl1O notPPrnt prntLim5 stl1NotPrnt)
                                    ultimately show ?thesis by auto
                                  qed
                                qed
                              qed

                              then show ?thesis  using notSame f4 f3 mta1 mta2 t2 by simp
                            next
                              case False
                              then show ?thesis using notSame f4 f3 mta1 mta2 by auto
                            qed
                          qed
                        qed

                      next
                        case notPPrnt2:False
                        then have notPPrnt2':" \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt"  
                          using prntPrntNeg stl2NotPrnt by auto
                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1 ")
                          case t2:True
                          then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using notPPrnt2 notPPrnt stl2NotPrnt stl1NotPrnt 
                            by (simp add: prntLim6)
                          then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" using a1 a3 sameStack notSame mta1 mta2 by auto
                          then have "\<forall>new newt. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = stl1 \<longrightarrow> newt = (MTArray x11 x12)" 
                            using CompMem_SameLocs_SameSubT[OF _ mcStl2O] by simp
                          then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using notPPrnt2 stl2NotPrnt  t2 prntLim7 by blast
                          then show ?thesis using t2 notSame mta1 mta2 by simp
                        next
                          case f3:False
                          then have f3':"\<not> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1 " using notPPrnt2 stl2NotPrnt prntLim8 by simp
                          then show ?thesis 
                          proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                            case t2:True
                            then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                              by (simp add: notPPrnt prntLim6 stl1NotPrnt)
                            then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" using a1 a3 sameStack notSame mta1 mta2 f3' by auto
                            then have "\<forall>new newt. CompMemType (memory st) x11 x12 newt stl1 new \<and> new = stl2 \<longrightarrow> newt = (MTArray x11' x12')" 
                              using CompMem_SameLocs_SameSubT[OF _ mcStl1O] by simp
                            then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using notPPrnt stl1NotPrnt  t2 prntLim7 by blast
                            then show ?thesis using t2 notSame mta1 mta2 f3 by simp
                          next
                            case f4:False
                            then have f4':"\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using prntLim8 
                              using notPPrnt stl1NotPrnt by auto
                            then show ?thesis 
                            proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                              case True
                              then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" 
                                using notPPrnt notPPrnt2' prntLim6 stl1NotPrnt stl2NotPrnt by auto
                              then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                                using a1 a3 sameStack notSame mta1 mta2 f3' f4' by simp
                              then obtain dt where cc1:"CompMemType (memory st) x11' x12' dt stl2 dloc1" and cc2:"CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                              then have "\<forall>newt new. CompMemType (memory st) x11' x12' newt stl2 new \<and> new = dloc1 \<longrightarrow> newt = dt" using CompMem_SameLocs_SameSubT[OF cc1 mcStl2O] by blast
                              then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" using cc1 prntLim7  
                                using True notPPrnt2' stl2NotPrnt by blast
                              moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1"  using cc2 prntLim7  CompMem_SameLocs_SameSubT mcStl1O 
                                using True notPPrnt stl1NotPrnt by blast
                              ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" by blast
                              then show ?thesis using notSame mta1 mta2 f3 f4 by simp
                            next
                              case False
                              then show ?thesis using notSame mta1 mta2 f3 f4 by auto
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              next
                case mtv1:(MTValue x2)
                then have mcStl2:"MCon (MTValue x2) (memory st') stl2" using a1 mcAllNew sameStack by metis
                have mcStl2O:" MCon (MTValue x2) (memory st) stl2" using a1 sameStack 2(1) mtv1 unfolding TypeSafe_def typeCompat_def by fastforce
                then have stl2NotPrnt:"stl2 \<noteq> prnt" 
                  by (metis MTypes.distinct(1) a1 mtv1 prntRelations sameStack)

                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                  case t2:True
                  have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2"
                  proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl2")
                    case t3:True
                    then have cmpP2:"CompMemType (memory st') len' arr' (MTValue x2) prnt stl2" using prntRelationsNew a1 sameStack mtv1 stl2NotPrnt by fastforce
                    then show ?thesis 
                    proof(cases "stl1 = prnt")
                      case True
                      then have "MTArray len' arr' = MTArray x11 x12" using prntRelationsNew t2 t3 a1 sameStack mta1 cmpP2 by metis
                      then show ?thesis using cmpP2 True by simp
                    next
                      case f2:False
                      then show ?thesis using prntRelations
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 prnt")
                        case t2:True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt" 
                          using prntRelationsNew t2 t3 a1 sameStack mta1 f2 by fastforce
                        then show ?thesis using cmpP2 compMemTypes_trns by blast
                      next
                        case f3:False
                        then have "\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt " 
                          using f2 prntPrntNeg by auto
                        have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using t2 
                          by (simp add: f2 f3 prntLim6)
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis using f2 f3 mcStl1O prntLim7 t2 CompMem_SameLocs_SameSubT by blast
                      qed
                    qed
                  next
                    case f2:False                    
                    then show ?thesis 
                    proof(cases "prnt = stl1")
                      case True
                      then show ?thesis using t2 prntRelationsNew f2 a1 sameStack mta1 by fastforce
                    next
                      case f3:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 prnt")
                        case True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt" 
                          using prntRelationsNew t2 f3 a1 sameStack mta1 f2 by fastforce
                        then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using t2 f2 
                          using CompMemTypeSameLocsSameType f3 mcStl1 prntLim3 by auto
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis 
                          using \<open>CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt\<close> f2 f3 mcStl1 mcStl1O prntLim5 t2 CompMem_SameLocs_SameSubT by blast
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using t2 f2 
                          using f3 prntLim6 by auto
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis 
                          using CompMemTypeSameLocsSameType False f3 mcStl1O prntLim7 t2 by presburger
                      qed
                    qed
                  qed
                  then show ?thesis using a1 mtv1 mta1 sameStack notSame by auto
                next
                  case False
                  then show ?thesis using a1 mtv1 mta1 sameStack notSame by simp
                qed
              qed
            next
              case mtv1:(MTValue x2)
              then have mcStl1:"MCon (MTValue x2) (memory st') stl1" using a1 mcAllNew sameStack by metis
              have mcStl1O:" MCon (MTValue x2) (memory st) stl1" using a1 sameStack 2(1) mtv1 unfolding TypeSafe_def typeCompat_def by fastforce
              then have stl1NotPrnt:"stl1 \<noteq> prnt" 
                by (metis MTypes.distinct(1) a1 mtv1 prntRelations sameStack)
              then show ?thesis 
              proof(cases tp2)
                case mta1:(MTArray x11 x12)
                then have mcStl2:"MCon (MTArray x11 x12) (memory st') stl2" using a1 mcAllNew sameStack by metis
                have mcStl2O:" MCon (MTArray x11 x12) (memory st) stl2" using a1 sameStack 2(1) mta1 unfolding TypeSafe_def typeCompat_def by fastforce
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1")
                  case t2:True
                  have "CompMemType (memory st') x11 x12 (MTValue x2) stl2 stl1 "
                  proof(cases "TypedMemSubPrefPtrs (memory st') len' arr' prnt stl1")
                    case t3:True
                    then have cmpP2:"CompMemType (memory st') len' arr' (MTValue x2) prnt stl1" using prntRelationsNew a1 sameStack mtv1 stl1NotPrnt by fastforce
                    then show ?thesis 
                    proof(cases "stl2 = prnt")
                      case True
                      then have "MTArray len' arr' = MTArray x11 x12" using prntRelationsNew t2 t3 a1 sameStack mta1 cmpP2 by metis
                      then show ?thesis using cmpP2 True by simp
                    next
                      case f2:False
                      then show ?thesis using prntRelations
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt")
                        case t2:True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl2 prnt" 
                          using prntRelationsNew t2 t3 a1 sameStack mta1 f2 by fastforce
                        then show ?thesis using cmpP2 compMemTypes_trns by blast
                      next
                        case f3:False
                        then have "\<not> TypedMemSubPrefPtrs (memory st) x11 x12 stl2 prnt " 
                          using f2 prntPrntNeg by auto
                        have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" using t2 
                          by (simp add: f2 f3 prntLim6)
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis using f2 f3 mcStl2O prntLim7 t2 CompMem_SameLocs_SameSubT by blast
                      qed
                    qed
                  next
                    case f2:False                    
                    then show ?thesis 
                    proof(cases "prnt = stl2")
                      case True
                      then show ?thesis using t2 prntRelationsNew f2 a1 sameStack mta1 by fastforce
                    next
                      case f3:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 prnt")
                        case True
                        then have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl2 prnt" 
                          using prntRelationsNew t2 f3 a1 sameStack mta1 f2 by fastforce
                        then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" using t2 f2 
                          using CompMemTypeSameLocsSameType f3 mcStl2 prntLim3 by auto
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis 
                          using \<open>CompMemType (memory st') x11 x12 (MTArray len' arr') stl2 prnt\<close> f2 f3 mcStl2 mcStl2O prntLim5 t2 CompMem_SameLocs_SameSubT by blast
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" using t2 f2 
                          using f3 prntLim6 by auto
                        then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" using a1 notSame a3 sameStack mta1 mtv1 by simp
                        then show ?thesis 
                          using CompMemTypeSameLocsSameType False f3 mcStl2O prntLim7 t2 by presburger
                      qed
                    qed
                  qed
                  then show ?thesis  using mta1 mtv1 notSame a1 sameStack by simp
                next
                  case False
                  then show ?thesis using mta1 mtv1 notSame a1 sameStack by simp
                qed
              next
                case (MTValue x2)
                then show ?thesis using mtv1 notSame a1 sameStack by simp
              qed
            qed

          qed
        qed

      next 
        have "accounts st'= accounts st" using 11 by auto
        then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 11 unfolding fullyInitialised_def  by auto

      qed
    qed
  next
    case (12 p x t g l t' g' p' m st'')
    have nonChangedStack:"\<forall>loc. loc \<noteq> l \<longrightarrow> accessStore loc (stack st) = accessStore loc (stack st')" using 12 unfolding accessStore_def updateStore_def by auto
    have accessLStack:"accessStore l (stack st') = Some (KMemptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 12 unfolding accessStore_def updateStore_def by auto
    have sameStorage:"storage st'  = storage st " using 12 by auto
    have lInDen:"(Memory t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[of lv env cd g st l ] 12(2) by simp
    have nonLocChanged:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
      using 12(6) unfolding cps2m_def using  cps2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" "(snd (allocate (memory st)))" x m] 
      by simp
    have a30:"\<forall>locs. locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> TypedStoSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (STArray x t) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
      using  12(6) unfolding cps2m_def using cps2mSingleChange2[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" "(snd (allocate (memory st)))" x m]  by fastforce
    have selfPoint:"\<forall>l l'. TypedStoSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (STArray x t) \<and> accessStore l m = Some (MPointer l') \<longrightarrow> l' = l" 
      using  12(6) unfolding cps2m_def using cps2mSelfPointers[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" " (snd (allocate (memory st)))" x m ] by blast
    have mInStd:"m = memory st'" using 12 by simp

    obtain memArr where memArrDef: "t' = MTArray x memArr" using 12(3) cps2mTypeCompatible.simps 
      by (metis MTypes.exhaust)

    have p'MCon:"MCon t' (memory st) p'" using 2 12(4) unfolding TypeSafe_def typeCompat_def using lInDen by (auto split:Denvalue.splits option.splits Stackvalue.splits Type.splits)

    have MConsrc:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) \<and> (\<exists>xx. KStoptr p = KStoptr xx)"
      using 2(1) 12(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KStoptr p" "Storage (STArray x t)" g] 

      using 2(3) unfolding fullyInitialised_def 
      by (auto split:Type.splits if_splits )
    have "(\<exists>p. accessStore p' (memory st) = Some (MPointer p)) \<or> accessStore p' (memory st) = None" using p'MCon 12(3,4,5) 
      using cps2mTypeCompatible.elims(2) by fastforce

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
    then have MCondest:"MCon (MTArray x memArr) m (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using  12(6,3) unfolding cps2m_def
      using cps2m[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" " (snd (allocate (memory st)))" x m memArr] MConsrc extractValueType.simps(2) memArrDef by simp
    have selfPoint2:"\<forall>l l'. LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> accessStore l (memory st') = Some (MPointer l') \<longrightarrow> l' = l" using selfPoint limitSt1 limitSt 
        "12"(6) a30 accessPrePost1 allocateSameAccess cpm2m_def eq_imp_le hash_inequality not_Some_eq 
      by (metis cps2mAccessPrePost cps2m_def mInStd)

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                              \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 12 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st') (denvalue env)"  unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
         (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
         (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
          using a0 nonChangedStack accessLStack sameStorage
          by (smt (verit) Stackvalue.distinct(11) compPointers_def option.inject)
      qed
    next 
      show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 12 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
                (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 12 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
      proof intros

        fix tloc loc 
        assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
        then show "accessStore loc (stack st') = None" using *  
          by (metis "12"(4) nonChangedStack not_None_eq)
      next 
        fix loc y 
        assume h1:" accessStore loc (stack st') = Some y"
        then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
          by (metis "12"(4) nonChangedStack)        
      qed
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      have a10:"toploc (snd (allocate (memory st))) = toploc m" using cps2mTopLocSame 12(6) mInStd unfolding cps2m_def  by blast
      have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp

      have a30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m" using nonLocChanged
        by (metis allocateSameAccess)
      have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
      show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
      proof intros
        fix tloc loc 
        assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then have b20:"toploc (memory st) \<le> tloc" using a10 tloc mInStd by simp
        have "\<not>LSubPrefL2 loc p'" 
        proof(rule ccontr)
          assume c10:"\<not> \<not> LSubPrefL2 loc p'"
          then have c20: "LSubPrefL2 loc p'" by simp
          then have c30:"LSubPrefL2 p' (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using b10  MemLSubPrefTransitive by auto
          then show False
          proof -
            have "MCon t' (memory st) p'" using 12(4) 2(1) unfolding TypeSafe_def typeCompat_def using lInDen by fastforce
            then obtain x i where c40: "accessStore p' (memory st) = Some x \<or> accessStore (hash p' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" using MCon_imps_Some by blast
            then show ?thesis
            proof(cases "accessStore p' (memory st) = Some x")
              case True
              then show ?thesis using lessThanSome_imps_Locs[of st p' x "tloc"] c30 a15 b20 by simp
            next
              case False
              then have "accessStore (hash p' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some x" using c40 by simp
              then show ?thesis using lessThanSome_imps_Locs2  c30 a15 b20 by fastforce
            qed
          qed
        qed
        then show "accessStore loc (memory st') = None " using b10 b20 nonLocChanged a10 mInStd a15 a30 
          by (metis (no_types, lifting) LSubPrefL2_def MemLSubPrefTransitive antisym_conv2 hash_inequality hash_suffixes_associative hashesIntSame lessThanTopLocs_def order_less_le_trans tloc)

      next 
        fix loc y 
        assume "accessStore loc (memory st') = Some y "
        then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
          by (metis a10 a15 a30 lessThanTopLocs_def order_less_trans mInStd tloc)
      qed
    next 
      show tcN:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"
        then have memComp:" (\<forall>tp1 tp2 l1 l2 stl1 stl2 dloc1.
            (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
            (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
            (if stl1 = stl2 then tp1 = tp2
             else case tp1 of
                  MTArray len arr \<Rightarrow>
                    (case tp2 of
                    MTArray len2 arr2 \<Rightarrow>
                      if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
                      else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                           else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                                then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
                    | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
                  | MTValue val \<Rightarrow>
                      (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
                      | MTValue val2 \<Rightarrow> True)))" 
          using 2(1) unfolding TypeSafe_def compMemPtrs_def by blast

        show " case l' of
               Stackloc loc \<Rightarrow>
                 (case accessStore loc (stack st') of None \<Rightarrow> False 
                  | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                  | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                  | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                  | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
               | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False) " 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using accessLStack nonChangedStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) accessLStack nonChangedStack unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(3) Stackvalue.simps(17) option.inject)
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) accessLStack nonChangedStack unfolding TypeSafe_def   typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(7) Stackvalue.simps(18) option.inject)
          next
            case (KMemptr x3)
            then have "\<exists>struct. t'' = Memory struct" 
            proof(cases "x1 = l")
              case True
              have "accessStore l (stack st) = Some (KMemptr p')" using 12(4) by simp
              then show ?thesis using Stackloc adef  inDen Stackloc 2(1) KMemptr True unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            next
              case False
              then have "accessStore x1 (stack st) = accessStore x1 (stack st')" using accessLStack nonChangedStack by simp
              then show ?thesis using Stackloc adef  inDen Stackloc 2(1) KMemptr unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            qed
            then obtain struct where structdef:"t'' = Memory struct" by blast

            have "MCon struct (memory st') x3" 
            proof(cases "x1 = l")
              case True
              then have "x3 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using 12 KMemptr adef unfolding accessStore_def updateStore_def by auto
              moreover have "struct = t'" using MCondest 12 Stackloc True inDen lInDen mInStd memComp structdef by fastforce
              ultimately show ?thesis using MCondest 12 Stackloc True inDen lInDen mInStd memComp structdef memArrDef by metis
            next
              case False
              then have "accessStore x1 (stack st) = accessStore x1 (stack st')" using accessLStack nonChangedStack by simp
              then have "accessStore x1 (stack st) = Some (KMemptr x3)" using adef KMemptr by simp
              then have mgh:"MCon struct (memory st) x3" using inDen KMemptr Stackloc adef structdef 2(1) unfolding TypeSafe_def typeCompat_def by force
              then show ?thesis using originalSConStillMCon[OF mgh limitSt ] mInStd allocateSameAccess a30  memArrDef nonLocChanged 
                by (metis (no_types, lifting) "12"(6) cps2mAccessPrePost cps2m_def hash_inequality)
            qed
            then show ?thesis  using structdef KMemptr Stackloc adef  inDen Stackloc 2(1) unfolding TypeSafe_def by simp

          next
            case (KStoptr x4)  
            then show ?thesis using Stackloc adef sameStorage  inDen Stackloc KStoptr 2(1) accessLStack nonChangedStack unfolding TypeSafe_def typeCompat_def apply(cases t'') 
              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(3) Type.simps(17) lInDen old.prod.inject snd_eqD uniqueLocs)
              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(7) Type.simps(18) lInDen old.prod.inject snd_eqD uniqueLocs)
              apply (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.distinct(11) Stackvalue.simps(20) Type.simps(19) option.inject)
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(20) Type.distinct(11) Type.simps(20) lInDen prod.inject snd_conv uniqueLocs)
          qed

        next
          case (Storeloc x2)
          then show ?thesis using sameStorage inDen 2(1) unfolding TypeSafe_def typeCompat_def by (cases t''; force)
        qed
      qed
      have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"
        show " case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st) of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False) 
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then show ?thesis 
          proof(cases "x1 = l")
            case True
            then have acc:"accessStore x1 (stack st) = Some (KMemptr p')" using 12(4) by simp 
            then obtain struct where structdef: "t'' = Memory struct" 
              using Stackloc  inDen Stackloc 2(1) True unfolding TypeSafe_def typeCompat_def by (cases t'';force+) 
            have "struct = t'" using MCondest 12 Stackloc True inDen lInDen mInStd structdef 
              by (metis "2.prems"(1) Type.inject(3) prod.inject snd_conv uniqueLocs typeSafeUnique)
            then have "MCon struct (memory st') p'" 
              using MCondest 12 Stackloc True inDen lInDen mInStd structdef memArrDef acc 
              by (smt (verit, best) PreExistMconNotChangeByToploc allocateSame cps2mSingleChange cps2m_def limitSt limitSt1 p'MCon)

            then show ?thesis using MCondest 12 Stackloc True inDen lInDen mInStd structdef memArrDef by fastforce
          next
            case False
            then have "accessStore x1 (stack st) = accessStore x1 (stack st')" 
              using nonChangedStack by blast
            then show ?thesis using inDen tcN Stackloc unfolding typeCompat_def by force
          qed
        next
          case (Storeloc x2)
          then show ?thesis using inDen tcN unfolding typeCompat_def by fastforce
        qed
      qed
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def
      proof(intros)
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast

        then have c30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"   using nonLocChanged
          by simp
        moreover have st'IsM:"memory st' = m" using 12 by simp
        ultimately have c35:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st') = accessStore locs (memory st)" by simp
        assume h1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
         (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2)"

        show "if stl1 = stl2 then tp1 = tp2
         else case tp1 of
              MTArray len arr \<Rightarrow>
                (case tp2 of
                MTArray len2 arr2 \<Rightarrow>
                  if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                  else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                       else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                            then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
                | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
              | MTValue val \<Rightarrow>
                  (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                  | MTValue val2 \<Rightarrow> True)"
        proof(cases "stl1 = stl2")
          case True
          show ?thesis 
          proof(cases "stl1 = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
            case t2:True
            then have "l1 = l" using 2(1) unfolding TypeSafe_def 
              by (metis "2.prems"(1) MCon_imps_Some LSubPrefL2_def h1 lessThanSome_imps_Locs nat_neq_iff nonChangedStack sameMemTSafe)
            moreover have "l2 = l" using 2(1) unfolding TypeSafe_def using t2 True 
              by (metis "2.prems"(1) MCon_imps_Some LSubPrefL2_def h1 lessThanSome_imps_Locs nat_neq_iff nonChangedStack sameMemTSafe)
            ultimately show ?thesis using 2(1) unfolding TypeSafe_def unique_locations_def using h1 by auto
          next
            case False
            moreover have "l1 \<noteq> l" using 12 h1 calculation unfolding accessStore_def updateStore_def by auto
            moreover have "accessStore l1 (stack st') = accessStore l1 (stack st)" using 12 calculation unfolding accessStore_def updateStore_def by auto
            ultimately show ?thesis using 2(1) unfolding TypeSafe_def unique_locations_def using h1 True 
              by (smt (verit) Stackvalue.inject(3) accessLStack compMemPtrs_def nonChangedStack option.inject)
          qed
        next
          case False
          then show ?thesis 
          proof(cases tp1)
            case mta1:(MTArray x11 x12)
            then show ?thesis 
            proof(cases tp2)
              case mta2:(MTArray x11' x12')
              then show ?thesis 
              proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                case stl2Toploc:True
                then have "stl1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                then have mcon1Old:" MCon tp1 (memory st) stl1" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                  by (metis Stackvalue.inject(3) accessLStack option.inject)
                have "l2 = l" using stl2Toploc h1 stackDenvalLimits nonChangedStack 
                  by (metis LSubPrefL2_def)
                have stl2NotParentStl1:" \<not> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1" 
                  using MCondest LSubPrefL2_def TS_imps_InDenLessStack2 c35 limitSt limitSt1 mcon1Old selfPoint2 st'IsM stl2Toploc by blast
                have stl1NotParentStl2:"\<not>TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" 
                  using TS_imps_InDenLessStack3 MCondest LSubPrefL2_def c35 limitSt limitSt1 mcon1Old selfPoint2 st'IsM stl2Toploc 
                  using mta1 by blast
                have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<longrightarrow> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                  using SubPtrs_top selfPoint2 LSubPrefL2_def stl2Toploc by blast
                moreover have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<longrightarrow> \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                  using subPtrs_nonTop LSubPrefL2_def c35 limitSt limitSt1 mcon1Old mta1 by blast
                ultimately have "\<not>(TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1)" by auto
                then show ?thesis using stl2NotParentStl1 stl1NotParentStl2 mta1 mta2 False by auto
              next
                case f2:False
                then have stl2NotTop:"stl2 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                then have mcon2Old:" MCon tp2 (memory st) stl2" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                  by (metis Stackvalue.inject(3) accessLStack option.inject)
                then show ?thesis 
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                  case stl1Toploc: True

                  have "l1 = l" using stl1Toploc h1 stackDenvalLimits nonChangedStack 
                    by (metis LSubPrefL2_def)
                  have stl2NotParentStl1:" \<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" 
                    using MCondest LSubPrefL2_def TS_imps_InDenLessStack2 c35 limitSt limitSt1 mcon2Old selfPoint2 st'IsM stl1Toploc by blast
                  have stl1NotParentStl2:"\<not>TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1" 
                    using TS_imps_InDenLessStack3 MCondest LSubPrefL2_def c35 limitSt limitSt1 mcon2Old selfPoint2 st'IsM stl1Toploc 
                    using mta1 mta2 by blast
                  have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<longrightarrow> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    using SubPtrs_top selfPoint2 LSubPrefL2_def stl1Toploc by blast
                  moreover have "\<forall>dloc1. TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1 \<longrightarrow> \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    using subPtrs_nonTop LSubPrefL2_def c35 limitSt limitSt1 mcon2Old mta1 mta2 by blast
                  ultimately have "\<not>(TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1)" by auto
                  then show ?thesis using stl2NotParentStl1 stl1NotParentStl2 mta1 mta2 False by auto
                next
                  case f3:False
                  then have stl1NotTop:"stl1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using False by simp
                  then have mcon1Old:" MCon tp1 (memory st) stl1" using h1 2(1) nonChangedStack unfolding TypeSafe_def using "2.prems"(1) sameMemTSafe
                    by (metis Stackvalue.inject(3) accessLStack option.inject)

                  then have l2StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack stl2NotTop  
                    by (metis Stackvalue.inject(3) accessLStack h1 option.inject)
                  then have l1StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack stl1NotTop  
                    by (metis Stackvalue.inject(3) accessLStack h1 option.inject)

                  then show ?thesis
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                    case True
                    then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using  h1  mta2  l2StackSame l1StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl2NotTop
                      by (metis (lifting) c35 le_refl limitSt mcon2Old stackDenvalLimits)
                    then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" 
                      using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False unfolding TypeSafe_def compMemPtrs_def 
                      by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using mcon1Old mcon2Old mta1 mta2 False 
                      by (smt (verit, ccfv_SIG) c35 cpm2mCompMemTypeOld_imps_CompMemType h1 l2StackSame limitSt nle_le stackDenvalLimits)
                    then show ?thesis  using mta1 mta2 False h1 True by simp
                  next
                    case f4:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2 ")
                      case True
                      then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                        using  h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl1NotTop mcon1Old 
                        by (metis c35 le_refl limitSt stackDenvalLimits)
                      then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" 
                        using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False unfolding TypeSafe_def compMemPtrs_def 
                        by (auto split: MTypes.splits)
                      then have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using mcon1Old mcon2Old mta1 mta2 False 
                        by (smt (verit, ccfv_SIG) c35 cpm2mCompMemTypeOld_imps_CompMemType h1 l1StackSame limitSt nle_le stackDenvalLimits)
                      then show ?thesis  using mta1 mta2 False h1 True f4 by simp
                    next
                      case f5:False
                      then have n1:"\<not>TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 stl1NotTop mcon1Old  
                        by (smt (verit, best) c35 cpm2mTPrefOld_imps_TPref le_refl limitSt stackDenvalLimits)
                      have n2:"\<not>TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using h1 mta2 l1StackSame l2StackSame 2(1) f2 f3 stl2NotTop mcon2Old f4
                        by (smt (verit, best) c35 cpm2mTPrefOld_imps_TPref le_refl limitSt stackDenvalLimits)
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                        case tp:True
                        then have tsu1:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1"
                          using  h1 mta1 l1StackSame l2StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl1NotTop mcon1Old 
                          by (metis c35 le_refl limitSt stackDenvalLimits)
                        have tsu2:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1"
                          using  h1  mta2  l2StackSame l1StackSame 2(1) f2 f3 inv_cpm2mTPrefOld_imps_TPref stl2NotTop tp
                          by (metis (lifting) c35 le_refl limitSt mcon2Old stackDenvalLimits)
                        have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                          using 2(1) h1 l2StackSame l1StackSame mta1 mta2 False tsu1 tsu2 f4 f5 n1 n2 unfolding TypeSafe_def compMemPtrs_def 
                          by (auto split: MTypes.splits) 
                        then obtain dt where cp1:"CompMemType (memory st) x11' x12' dt stl2 dloc1" and cp2:"CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                        have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                          using cpm2mCompMemTypeOld_imps_CompMemType[OF cp1] c35  LSubPrefL2_def stl2NotTop mcon2Old limitSt 
                          by (metis dual_order.refl h1 l2StackSame mta2 stackDenvalLimits)
                        moreover have " CompMemType (memory st') x11 x12 dt stl1 dloc1"
                          using cpm2mCompMemTypeOld_imps_CompMemType[OF cp2] c35  LSubPrefL2_def stl1NotTop mcon1Old limitSt 
                          by (metis dual_order.refl h1 l1StackSame mta1 stackDenvalLimits)
                        ultimately show ?thesis using mta1 mta2 f2 f3 f4 f5 False by auto
                      next
                        case f6:False
                        then show ?thesis using mta1 mta2 False h1 f4 f5 f6 by auto
                      qed
                    qed
                  qed
                qed
              qed
            next
              case mtv2:(MTValue x2)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                case t2:True
                then show ?thesis 
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                  case t3:True
                  then have "l2 = l"using  h1 stackDenvalLimits nonChangedStack LSubPrefL2_def by metis
                  then have "tp2 =  MTArray x memArr" using memArrDef 12(3) lInDen 2(1) h1 unfolding TypeSafe_def unique_locations_def by auto
                  then show ?thesis using mtv2 by simp
                next
                  case f3:False
                  then have "l2 \<noteq> l" using 12(5,7) h1 unfolding updateStore_def accessStore_def by auto
                  then have l1StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack by auto
                  then show ?thesis 
                  proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                    case True
                    then have "toploc (memory st) = toploc (memory st) \<and> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                      by (simp add: LSubPrefL2_def)  
                    have mconstl1Old:"MCon tp2 (memory st) stl2" using sameMemTSafe h1 2(1) unfolding TypeSafe_def 
                      by (metis l1StackSame)

                    then have "\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2" using TS_imps_InDenLessStack2[of tp2 st stl2 stl1 st' _ x11 x12] True LSubPrefL2_def limitSt limitSt1 selfPoint2 
                      using MCondest c35 st'IsM by blast

                    then show ?thesis using t2 by simp
                  next
                    case f4:False
                    then have "l1 \<noteq> l" using 12(5,7) h1 unfolding updateStore_def accessStore_def by auto
                    then have l2StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack by auto
                    then have mconstl2Old:"MCon tp1 (memory st) stl1" using h1 2(1) unfolding TypeSafe_def 
                      by (metis "2.prems"(1) sameMemTSafe)
                    then have "MCon (MTArray x11 x12) (memory st') stl1" using originalSConStillMCon[OF mconstl2Old limitSt ] mInStd allocateSameAccess a30  nonLocChanged mta1 
                      by (metis (no_types, lifting) "12"(6) cps2mAccessPrePost cps2m_def hash_inequality)
                    moreover have "\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                    proof
                      assume "LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                      then have "\<exists>i. stl1 = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" unfolding LSubPrefL2_def using f4 by simp
                      then show False using mconstl2Old 
                        by (metis MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt option.distinct(1))
                    qed

                    ultimately have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using inv_cpm2mTPrefOld_imps_TPref t2 c35 limitSt mta1
                      by (smt (verit, ccfv_SIG) inv_cpm2mTPrefOld_imps_TPref mconstl2Old order_refl)
                    then have "CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2" 
                      using 2(1) unfolding TypeSafe_def compMemPtrs_def using h1 l2StackSame l1StackSame False  mtv2 mta1 by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" 
                      by (smt (verit, ccfv_SIG) \<open>\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> c35 cpm2mCompMemTypeOld_imps_CompMemType le_eq_less_or_eq limitSt mconstl2Old mta1)
                    then show ?thesis using h1 2(1) a30 f3 mta1 mtv2 False t2 l1StackSame l2StackSame by simp
                  qed
                qed
              next
                case f2:False
                then show ?thesis using mtv2 mta1 False by simp
              qed
            qed
          next
            case mtv1:(MTValue x2)
            then show ?thesis 
            proof(cases tp2)
              case mta2:(MTArray x11 x12)
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1")
                case t2:True
                then show ?thesis
                proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl1")
                  case t3:True
                  then have "l1 = l" using 2(1) h1 unfolding TypeSafe_def 
                    by (metis "2.prems"(1) Option.option.simps(4) \<open>accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None\<close> allocateSameAccess mtv1 nonChangedStack sameMemTSafe MCon.simps(1))
                  then have "tp1 =  MTArray x memArr" using memArrDef 12(3) lInDen 2(1) h1 unfolding TypeSafe_def unique_locations_def by auto
                  then show ?thesis using mtv1 by simp
                next
                  case f3:False
                  then have "l1 \<noteq> l" using 12(5,7) h1 unfolding updateStore_def accessStore_def by auto
                  then have l1StackSame:"accessStore l1 (stack st') =  accessStore l1 (stack st)" using nonChangedStack by auto
                  then show ?thesis 
                  proof(cases "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) = stl2")
                    case True
                    then have "toploc (memory st) = toploc (memory st) \<and> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                      by (simp add: LSubPrefL2_def)  
                    have mconstl1Old:"MCon tp1 (memory st) stl1" using sameMemTSafe h1 2(1) unfolding TypeSafe_def 
                      by (metis l1StackSame)

                    then have "\<not> TypedMemSubPrefPtrs (memory st') x11 x12 stl2 stl1" using TS_imps_InDenLessStack2[of tp1 st stl1 stl2 st' _ x11 x12] True LSubPrefL2_def limitSt limitSt1 selfPoint2 
                      using MCondest c35 st'IsM by blast

                    then show ?thesis using t2 by simp
                  next
                    case f4:False
                    then have "l2 \<noteq> l" using 12(5,7) h1 unfolding updateStore_def accessStore_def by auto
                    then have l2StackSame:"accessStore l2 (stack st') =  accessStore l2 (stack st)" using nonChangedStack by auto
                    then have mconstl2Old:"MCon tp2 (memory st) stl2" using h1 2(1) unfolding TypeSafe_def 
                      by (metis "2.prems"(1) sameMemTSafe)
                    then have "MCon (MTArray x11 x12) (memory st') stl2" using originalSConStillMCon[OF mconstl2Old limitSt ] mInStd allocateSameAccess a30  nonLocChanged mta2 
                      by (metis (no_types, lifting) "12"(6) cps2mAccessPrePost cps2m_def hash_inequality)
                    moreover have "\<not> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                    proof
                      assume "LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
                      then have "\<exists>i. stl2 = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" unfolding LSubPrefL2_def using f4 by simp
                      then show False using mconstl2Old 
                        by (metis MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt option.distinct(1))
                    qed

                    ultimately have "TypedMemSubPrefPtrs (memory st) x11 x12 stl2 stl1" using inv_cpm2mTPrefOld_imps_TPref t2 c35 limitSt mta2 
                      by (smt (verit, ccfv_SIG) inv_cpm2mTPrefOld_imps_TPref mconstl2Old order_refl)
                    then have "CompMemType (memory st) x11 x12 (MTValue x2) stl2 stl1" 
                      using 2(1) unfolding TypeSafe_def compMemPtrs_def using h1 l2StackSame l1StackSame False  mtv1 mta2 by (auto split: MTypes.splits)
                    then have "CompMemType (memory st') x11 x12 (MTValue x2) stl2 stl1" 
                      by (smt (verit, ccfv_SIG) \<open>\<not> LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> c35 cpm2mCompMemTypeOld_imps_CompMemType le_eq_less_or_eq limitSt mconstl2Old mta2)
                    then show ?thesis using h1 2(1) a30 f3 mta2 mtv1 False t2 l1StackSame l2StackSame by simp
                  qed
                qed
              next
                case f2:False
                then show ?thesis using mta2 mtv1 False by (auto split:if_splits)
              qed
            next
              case mtv2:(MTValue x2')
              then show ?thesis using mtv1 False by simp
            qed
          qed
        qed
      qed
    next 
      have "accounts st'= accounts st" using 12 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) 12 unfolding fullyInitialised_def updateStore_def accessStore_def by auto
    next 
      have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
      have topLocEq:"toploc (snd (allocate (memory st))) = toploc (memory st')" 
        using cps2mTopLocSame 12(6) cps2m_def mInStd MCondest 
        by (metis (no_types, lifting))

    qed             
  next
    case (13 p x t g l t' g')
    then have stackChanged:"\<forall>l'. l' \<noteq> l \<longrightarrow> accessStore l' (stack st) = accessStore l' (stack st')" unfolding updateStore_def accessStore_def by simp
    have t'InDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[OF 13(2)] by blast
    then have lDen:"\<forall>t'. (t', Stackloc l) |\<in>| fmran (denvalue env) \<longrightarrow> t'= (Storage (STArray x t))" using 13 2(1) unfolding TypeSafe_def unique_locations_def by auto

    have pOrigin:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) \<and>
        (\<exists>xx. KStoptr p = KStoptr xx) \<and>
        (\<exists>stloc tp'' .
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue env) \<and>
            (tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p))))" 
      using 2(1) 13(1) 2(3) using
        exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KStoptr p" "Storage (STArray x t)" g] 
      by (auto split:Type.splits if_splits )
    obtain pParent pParentT  where 
      pOrigin:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) 
          \<and>(Storage pParentT, Storeloc pParent) |\<in>| fmran (denvalue env) \<and>
            (pParentT = (STArray x t) \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STArray x t) pParent (extractValueType (KStoptr p)))"
      using pOrigin by auto
    have a0: "compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    then have pParentRelations:"(\<forall>tp2 l2  l2'  stl2.
        (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
        
        (l2 = Stackloc l2' \<and> accessStore l2' (stack (st)) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True))" 
      using compPointers_def pOrigin  by blast
    have pSCon:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st) (address env))" using pOrigin by force

    have pRelations:"(\<forall>tp2 l2 l2' stl2 . 
    (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and> 
    ((l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some(KStoptr stl2)) \<or> (l2 = Storeloc stl2)) 
     \<longrightarrow>
    (if TypedStoSubpref p stl2 tp2 then CompStoType tp2 (STArray x t) stl2 p 
     else if TypedStoSubpref stl2 p (STArray x t) then CompStoType (STArray x t) tp2 p stl2
     else True))" 
    proof intros 
      fix tp2 l2 l2' stl2
      assume in1:"(Storage tp2, l2) |\<in>| fmran (denvalue env) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"

      show "if TypedStoSubpref p stl2 tp2 then CompStoType tp2 (STArray x t) stl2 p else if TypedStoSubpref stl2 p (STArray x t) then CompStoType (STArray x t) tp2 p stl2 else True"
      proof(cases "l2 = Stackloc l2'")
        case StL2:True
        then have mcStl2:"SCon tp2 stl2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using in1 by fastforce

        then have "SCon pParentT pParent (storage st (address env))" using pOrigin using 2(1) unfolding TypeSafe_def typeCompat_def by force
        have prnt:" pParentT = STArray x t \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STArray x t) pParent (extractValueType (KStoptr p))"
          using pOrigin by simp
        then have comp:"(if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 
                      else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True)"
          using pParentRelations in1  StL2 prnt by force 
        then show ?thesis 
        proof(cases "TypedStoSubpref p stl2 tp2")
          case pToStl2:True        

          then show ?thesis 
          proof(cases "pParentT = (STArray x t)")
            case True
            then have cc1:"KStoptr p = KStoptr pParent " using prnt 
              using comp_stotype_same_type_same_loc by blast
            then have cc2:"TypedStoSubpref pParent stl2 tp2" using pToStl2 by auto
            then have "CompStoType tp2 (STArray x t) stl2 p"
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case t2:True
              then show ?thesis using comp 
                by (metis CompStoType_sameLoc_sameType Stackvalue.inject(4) True cc1 cc2 typedStoSub_imps_negInv)
            next
              case False
              then have "CompStoType tp2 pParentT stl2 pParent" using comp 
                by (simp add: cc2)
              then show ?thesis 
                using True cc1 by auto
            qed
            then show ?thesis by (simp add: pToStl2)
          next
            case False
            then have cmp:" CompStoType pParentT (STArray x t) pParent p" using prnt by simp
            then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
            then show ?thesis 
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case True
              then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
              have "CompStoType tp2 (STArray x t) stl2 p " using pToStl2 prntStl2  CompStoType_sharedSub cmp by simp
              then show ?thesis using pToStl2 by simp
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref pParent stl2 tp2")
                case True
                then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                then have "CompStoType tp2 (STArray x t) stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                then show ?thesis using pToStl2 by simp
              next
                case False
                then have "\<not>TypedStoSubpref p stl2 tp2" using f1 cmp tsp NotRelatedPrnt_imps_notRelatedChild[of stl2 pParent pParentT tp2 p]  by simp
                then show ?thesis using f1 pToStl2 cmp by simp
              qed
            qed
          qed
        next
          case f1:False
          then show ?thesis 
          proof(cases " TypedStoSubpref stl2 p (STArray x t)")
            case stl2ToP:True
            have " CompStoType (STArray x t) tp2 p stl2"
            proof(cases "pParentT = (STArray x t)")
              case True
              then have cc1:"KStoptr p = KStoptr pParent " using prnt 
                using comp_stotype_same_type_same_loc by blast
              then have cc2:"TypedStoSubpref stl2 pParent (STArray x t)" using stl2ToP by auto
              then have " CompStoType (STArray x t) tp2 p stl2"
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case t2:True
                then have "CompStoType pParentT tp2 pParent stl2" using comp by simp
                then have "CompStoType (STArray x t) tp2 p stl2" using cc1 True  by blast
                then show ?thesis by blast
              next
                case False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp False by simp
                  then show ?thesis using True cc1 f1 by auto
                next
                  case f2:False
                  then show ?thesis using False True cc2 by blast
                qed
              qed
              then show ?thesis by blast
            next
              case False
              then have cmp:" CompStoType pParentT (STArray x t) pParent p" using prnt by simp
              then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
              then show ?thesis 
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case True
                then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
                then show ?thesis using CompStoType_sharedSub[OF prntStl2 stl2ToP cmp] by simp
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                  then have "CompStoType tp2 (STArray x t) stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                  then show ?thesis 
                    using CompStoType_sameLocNdTyp CompStoType_sharedSub stl2ToP by blast
                next
                  case False
                  then show ?thesis 
                    using NotReachablePrnt_imps_notReachableChild cmp f1 stl2ToP by blast
                qed
              qed
            qed
            then show ?thesis using f1 by (simp )
          next
            case False
            then show ?thesis 
              using f1 by auto
          qed
        qed

      next
        case f3:False
        then have StL2:"l2 = Storeloc stl2" 
          using in1 by auto

        then have "SCon pParentT pParent (storage st (address env))" using pOrigin using 2(1) unfolding TypeSafe_def typeCompat_def by force
        have prnt:" pParentT = STArray x t \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STArray x t) pParent (extractValueType (KStoptr p))"
          using  pOrigin by simp
        then have comp:"(if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 
                      else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True)"
          using pParentRelations in1  StL2 prnt by force 
        then show ?thesis 
        proof(cases "TypedStoSubpref p stl2 tp2")
          case pToStl2:True        

          then show ?thesis 
          proof(cases "pParentT = (STArray x t)")
            case True
            then have cc1:"KStoptr p = KStoptr pParent " using prnt 
              using comp_stotype_same_type_same_loc by blast
            then have cc2:"TypedStoSubpref pParent stl2 tp2" using pToStl2 by auto
            then have "CompStoType tp2 (STArray x t) stl2 p"
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case t2:True
              then show ?thesis using comp 
                by (metis CompStoType_sameLoc_sameType Stackvalue.inject(4) True cc1 cc2 typedStoSub_imps_negInv)
            next
              case False
              then have "CompStoType tp2 pParentT stl2 pParent" using comp 
                by (simp add: cc2)
              then show ?thesis 
                using True cc1 by auto
            qed
            then show ?thesis by (simp add: pToStl2)
          next
            case False
            then have cmp:" CompStoType pParentT (STArray x t) pParent p" using prnt by simp
            then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
            then show ?thesis 
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case True
              then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
              have "CompStoType tp2 (STArray x t) stl2 p " using pToStl2 prntStl2  CompStoType_sharedSub cmp by simp
              then show ?thesis using pToStl2 by simp
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref pParent stl2 tp2")
                case True
                then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                then have "CompStoType tp2 (STArray x t) stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                then show ?thesis using pToStl2 by simp
              next
                case False
                then have "\<not>TypedStoSubpref p stl2 tp2" using f1 cmp tsp NotRelatedPrnt_imps_notRelatedChild[of stl2 pParent pParentT tp2 p]  by simp
                then show ?thesis using f1 pToStl2 cmp by simp
              qed
            qed
          qed
        next
          case f1:False
          then show ?thesis 
          proof(cases " TypedStoSubpref stl2 p (STArray x t)")
            case stl2ToP:True
            have " CompStoType (STArray x t) tp2 p stl2"
            proof(cases "pParentT = (STArray x t)")
              case True
              then have cc1:"KStoptr p = KStoptr pParent " using prnt 
                using comp_stotype_same_type_same_loc by blast
              then have cc2:"TypedStoSubpref stl2 pParent (STArray x t)" using stl2ToP by auto
              then have " CompStoType (STArray x t) tp2 p stl2"
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case t2:True
                then have "CompStoType pParentT tp2 pParent stl2" using comp by simp
                then have "CompStoType (STArray x t) tp2 p stl2" using cc1 True  by blast
                then show ?thesis by blast
              next
                case False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp False by simp
                  then show ?thesis using True cc1 f1 by auto
                next
                  case f2:False
                  then show ?thesis using False True cc2 by blast
                qed
              qed
              then show ?thesis by blast
            next
              case False
              then have cmp:" CompStoType pParentT (STArray x t) pParent p" using prnt by simp
              then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
              then show ?thesis 
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case True
                then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
                then show ?thesis using CompStoType_sharedSub[OF prntStl2 stl2ToP cmp] by simp
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                  then have "CompStoType tp2 (STArray x t) stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                  then show ?thesis 
                    using CompStoType_sameLocNdTyp CompStoType_sharedSub stl2ToP by blast
                next
                  case False
                  then show ?thesis 
                    using NotReachablePrnt_imps_notReachableChild cmp f1 stl2ToP by blast
                qed
              qed
            qed
            then show ?thesis using f1 by (simp )
          next
            case False
            then show ?thesis using f1 by auto
          qed
        qed
      qed
    qed

    have storageSame:"(storage st' (address env)) = (storage st (address env))" using 13 by simp
    have memorySame:"memory st = memory st'" using 13 by simp
    show ?thesis unfolding TypeSafe_def StateInvariant_def 
    proof (intros)
      show tcN:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False )" 
        proof (split Denvalue.split, intros)
          fix loc assume a20:"l' = Stackloc loc"
          show "case accessStore loc (stack st') of None \<Rightarrow> False 
          | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
          | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
          | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
          | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
          proof (cases "loc = l") 
            case False
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then have "accessStore loc (stack st) = None" using 13(4) False by (simp add:stackSingleUpdate)
              then show False using a30 a20 a10 assms TypeSafe_def False "2.prems"(1) 
                by (metis option.distinct(1) typeSafeLocExists)
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have a40:"accessStore loc (stack st) = Some x2" using 13(4) False by (simp add:stackSingleUpdate)
              then have a50:"(memory st) = (memory st')" using 13(4) by simp
              then have a60:"(storage st) = (storage st')" using 13(4) by simp
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False )
                  | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                  | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                  | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)" 
                using a10 a20 a30 a40 a50 a60  "2.prems"(1) unfolding TypeSafe_def typeCompat_def by (cases x2; cases t; force)
            qed
          next 
            case sameLoc:True
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then show False using a20 a10 assms(1) sameLoc 13(4) notNoneUpdate[of st' g' loc "(KMemptr p)" st] by simp
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have x2IsP:"x2 = KStoptr p" using 13 sameLoc by auto
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False )
              | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
              proof(cases "x2")
                case (KValue x1)

                then show ?thesis using x2IsP by auto
              next
                case (KCDptr x2)
                then show ?thesis using x2IsP by (simp add:sameLoc)
              next
                case (KMemptr x3)
                then show ?thesis  using x2IsP by (simp add:sameLoc)
              next
                case (KStoptr x4)
                then show ?thesis using x2IsP a10 a20 lDen storageSame sameLoc 
                  using pSCon by force
              qed
            qed
          qed
        next
          fix x2 assume a20:"l' = Storeloc x2"
          then have "(storage st' (address env)) = (storage st (address env))" using 13(4) by simp
          then show "case t of Storage typ \<Rightarrow> SCon typ x2 (storage st' (address env)) | _ \<Rightarrow> False"  using a10 a20 TypeSafe_def "2.prems"(1) pSCon a10 a20 lDen storageSame 
          proof -
            have "\<And>t d. (t, d) |\<notin>| fmran (denvalue env) \<or> 
                  (case d of Stackloc l \<Rightarrow> 
                  (case accessStore l (stack st) of None \<Rightarrow> False 
                  | Some (KValue l) \<Rightarrow> (case t of Value t \<Rightarrow> typeCon t l | _ \<Rightarrow> False) 
                  | Some (KCDptr l) \<Rightarrow> (case t of Calldata m \<Rightarrow> MCon m cd l | _ \<Rightarrow> False) 
                  | Some (KMemptr l) \<Rightarrow> (case t of Memory m \<Rightarrow> MCon m (memory st) l | _ \<Rightarrow> False) 
                  | Some (KStoptr l) \<Rightarrow> (case t of Storage s \<Rightarrow> SCon s l (storage st (address env)) | _ \<Rightarrow> False)) 
                  | Storeloc l \<Rightarrow> (case t of Storage s \<Rightarrow> SCon s l (storage st (address env)) | _ \<Rightarrow> False))"
              using "2.prems"(1) TypeSafe_def typeCompat_def by auto
            then show ?thesis
              by (metis (no_types) Denvalue.simps(6) a10 a20 storageSame)
          qed 
        qed
      qed
      have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
         Stackloc loc \<Rightarrow>
           (case accessStore loc (stack st) of None \<Rightarrow> False 
            | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
            | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
            | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
            | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
         | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False) " 
        proof(cases l')
          case (Stackloc x1)
          then show ?thesis 
          proof(cases "x1 = l")
            case sameLoc:True
            then show ?thesis 
            proof (cases "accessStore x1 (stack st)")
              case None
              then show ?thesis using Stackloc a10 assms(1) sameLoc 13(4)  
                by (metis "2.prems"(1) option.distinct(1) typeSafeAllStacklocsExist)
            next
              case (Some a)
              then show ?thesis 
              proof(cases "a")
                case (KValue x1)
                then show ?thesis using a10 Stackloc Some "2.prems"(1) unfolding TypeSafe_def typeCompat_def
                  by fastforce
              next
                case (KCDptr x2)
                then show ?thesis using a10 Stackloc Some "2.prems"(1) unfolding TypeSafe_def typeCompat_def
                  by fastforce
              next
                case (KMemptr x3)
                then show ?thesis using a10 Stackloc Some "2.prems"(1) unfolding TypeSafe_def typeCompat_def  
                  by (metis (lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(19) Type.simps(20) sameLoc t'InDen)
              next
                case (KStoptr x4)
                then show ?thesis using a10 Stackloc Some "2.prems"(1) unfolding TypeSafe_def typeCompat_def using lDen storageSame sameLoc 
                  using pSCon by force
              qed
            qed
          next
            case False
            then have "accessStore x1 (stack st) = accessStore x1 (stack st')" 
              using stackChanged by auto
            then show ?thesis using tcN Stackloc a10 unfolding typeCompat_def by fastforce
          qed
        next
          case (Storeloc x2)
          then show ?thesis using a10 tcN unfolding typeCompat_def by fastforce
        qed
      qed
    next
      show "unique_locations (denvalue env)" using 2(1) typeSafeUnique by auto
    next
      have "(accounts st) = accounts(st')" using 13 by simp
      then show "balanceTypes (accounts st')" using balanceTypes_def balanceTypes_def 2(1) typeSafeAccounts by simp
    next
      have a0:"compPointers (stack st)(denvalue env)" using 2(1) storageSame unfolding TypeSafe_def by simp
      show " compPointers (stack st') (denvalue env)" unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l22 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
     (Storage tp2, l22) |\<in>| fmran (denvalue env) \<and>
     (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
     (l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l22 = Storeloc stl2)"
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using  2(1) unfolding TypeSafe_def unique_locations_def by simp

        then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "l1 = Storeloc stl1")
          case t1:True
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case True
            then show ?thesis using t1 a0 a1 unfolding compPointers_def by blast
          next
            case False
            then have a4:"l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2)" using a1 by simp
            then show ?thesis 
            proof(cases "l2' = l")
              case True
              then have "stl2 = p" using a4 13 by simp
              then show ?thesis using pRelations a1 a0 t1  True a4 lDen by blast
            next
              case False
              then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
              then show ?thesis using a0 a1 t1 unfolding compPointers_def by metis
            qed
          qed
        next
          case f1:False
          then have a4:"l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1)" using a1 by simp
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case t1:True
            then show ?thesis
            proof(cases "l1' = l")
              case True
              then have "stl1 = p" using a4 13 by simp
              then show ?thesis using pRelations a1 a0 t1  True a4 lDen 
                by (metis CompStoType_sameLoc_sameType Type.inject(4) typedStoSub_imps_negInv)
            next
              case False
              then have " accessStore l1' (stack st') =  accessStore l1' (stack st)" using  stackChanged a4 by simp
              then show ?thesis using a0 a1 t1 unfolding compPointers_def by metis
            qed
          next
            case False
            then have a4':"l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2)" using a1 by simp
            then show ?thesis 
            proof(cases "l1' = l")
              case True
              then have p1:"stl1 = p" using a4 13 by simp
              then have tp1c:"tp1 = (STArray x t)" using lDen a1 
                using True a4 by auto
              then show ?thesis 
              proof(cases "l2' = l")
                case True
                then have p2:"stl2 = p" using a4' 13 by auto
                then have tp2c:"tp2 = STArray x t" using lDen a1 True a4' by auto
                then show ?thesis using p2 p1 tp1c tp2c by auto
              next
                case False
                then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
                then show ?thesis 
                  by (metis CompStoType_sameLoc_sameType a1 p1 pRelations tp1c typedStoSub_imps_negInv)
              qed
            next
              case False
              then have same1:" accessStore l1' (stack st') =  accessStore l1' (stack st)" using  stackChanged a4 by simp
              then show ?thesis 
              proof(cases "l2' = l")
                case True
                then have p2:"stl2 = p" using a4' 13 by auto
                then have tp2c:"tp2 = STArray x t" using lDen a1 True a4' by auto
                then show ?thesis using same1 pRelations p2 tp2c a1 
                  by metis
              next
                case False
                then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
                then show ?thesis using a1 a0 same1 
                  using compPointers_def by auto
              qed
            qed
          qed
        qed
      qed
    next
      show "svalueTypes (svalue env)" using svalueTypes_def typeSafeSvalue 2(1) by simp
    next
      have "(storage st') = (storage st)" using 13(4) by simp
      then show "safeContract (storage st')" using 2(1) unfolding safeContract_def TypeSafe_def  by auto
    next
      have a10:"toploc (stack st') = toploc (stack st)" using 13(4) unfolding updateStore_def by simp
      then have a20:"\<exists>val. accessStore l (stack st) = Some val" using t'InDen typeSafeLocExists 2(1) TypeSafe_def by blast
      then have a30:"(\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                   \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using 2(1) unfolding TypeSafe_def  lessThanTopLocs_def by simp
      then have a40:"(\<forall>tloc loc. toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                    \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using a10 by simp
      show "lessThanTopLocs (stack st')" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then show "accessStore loc (stack st') = None"
        proof(cases "loc = l")
          case True
          then show ?thesis using * a10 
            by (metis a20 a30 option.distinct(1)) 
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 13(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using 2(1) a40 * a10 False a30 by simp
        qed
      next 
        fix loc y 
        assume *:" accessStore loc (stack st') = Some y "
        show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        proof(cases "loc = l")
          case True
          then show ?thesis using *a10 a20 a30 by simp
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 13(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using * 2(1) a40 by simp
        qed
      qed
    next
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def using 13 by auto
    next 
      show "lessThanTopLocs (memory st')" using 2(1) unfolding TypeSafe_def using 13 by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def  by auto
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using 2(1) t'InDen unfolding TypeSafe_def unique_locations_def by blast

        have a3:"\<forall>dloc1.
   (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
   (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
   (if stl1 = stl2 then tp1 = tp2
    else case tp1 of
         MTArray len arr \<Rightarrow>
           (case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                       then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
           | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
         | MTValue val \<Rightarrow>
             (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
             | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

        then have "l1 \<noteq> l \<and> l2 \<noteq> l" using lDen a1 by blast
        then have "accessStore l1 (stack st) = Some (KMemptr stl1) \<and>  accessStore l2 (stack st) = Some (KMemptr stl2)" using stackChanged a1 by simp

        then show "if stl1 = stl2 then tp1 = tp2
     else case tp1 of
          MTArray len arr \<Rightarrow>
            (case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
              else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                   else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
          | MTValue val \<Rightarrow>
              (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
              | MTValue val2 \<Rightarrow> True)" using a3 memorySame storageSame a1 
          by (metis (lifting) ext)
      qed
    next 
      show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using 13 by simp
    next 
      have accSame:"accounts st'= accounts st" using 13 by auto
      show "fullyInitialised env  (accounts st') (stack st')" unfolding fullyInitialised_def
      proof intros
        show "\<exists>c. type (accounts st' (address env)) = Some (Contract c) \<and> contract env = c" using accSame 
          using "2.prems"(3) fullyInitialised_def by force
        show "\<And>id ct dud v. (ep $$ contract env = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue env $$ id = Some (Storage v, Storeloc id))"
          using "2.prems"(3) fullyInitialised_def by blast
        fix t'' l'' p'' 
        assume in1:"(Storage t'', Stackloc l'') |\<in>| fmran (denvalue env) \<and> accessStore l'' (stack st') = Some (KStoptr p'')"
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue env) \<and> CompStoType t' t'' l' p''"
        proof(cases "l'' = l")
          case True
          then have isST:"t'' = STArray x t" using in1 
            using lDen by blast
          then have isP:"p'' = p" using 13(4) in1 True unfolding accessStore_def updateStore_def by simp
          then have "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue env) \<and> CompStoType t' (STArray x t) l' p" 
            using pOrigin isST isP  by force
          then show ?thesis 
            by (simp add: isP isST)
        next
          case False
          then have sameAcc:"accessStore l'' (stack st') =accessStore l'' (stack st)" 
            by (simp add: stackChanged)
          then show ?thesis using "2.prems"(3) unfolding fullyInitialised_def using in1 by auto
        qed
      qed
    next 
      have inDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using t'InDen by simp
      have denAc:"(\<forall>t l. (t, l) |\<in>| fmran (denvalue env) \<longrightarrow>
           (case l of
            Stackloc loc \<Rightarrow>
              (case accessStore loc (stack st) of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow>( case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st) stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address env)) | _ \<Rightarrow> False))
            | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address env)) | _ \<Rightarrow> False)))" using 2(1) unfolding TypeSafe_def typeCompat_def by simp
      have isVal:"\<exists>val. accessStore l (stack st) = Some (KStoptr val)" 
      proof(cases "accessStore l (stack st)")
        case None
        then show ?thesis using inDen denAc by fastforce
      next
        case (Some a)
        then show ?thesis 
        proof(cases a)
          case (KValue x1)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KCDptr x2)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KMemptr x3)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KStoptr x4)
          then show ?thesis using inDen denAc Some by simp
        qed
      qed

      have memSame:"memory st = memory st'" using 13(4) by simp
      have cc0:"\<forall>l ptr. (accessStore l (stack st) = Some (KMemptr ptr)) = (accessStore l (stack st') = Some (KMemptr ptr))" 
      proof intros
        fix l2 ptr
        show " (accessStore l2 (stack st) = Some (KMemptr ptr)) = (accessStore l2 (stack st') = Some (KMemptr ptr)) "
        proof
          assume *:"accessStore l2 (stack st) = Some (KMemptr ptr)"
          then have "l \<noteq> l2" using isVal by auto
          then show "accessStore l2 (stack st') = Some (KMemptr ptr)" 
            using 13(4) * unfolding updateStore_def accessStore_def by auto
        next 
          assume *:"accessStore l2 (stack st') = Some (KMemptr ptr)" 
          then have "l \<noteq> l2" using 13(4) by auto
          then show "accessStore l2 (stack st) = Some (KMemptr ptr) " 
            using * 13(4) unfolding updateStore_def accessStore_def by simp
        qed
      qed

    qed
  next
    case (14 p x t g l t' g' s)
    have sameStack:"(stack st) = (stack st')" using 14 unfolding accessStore_def updateStore_def by auto
    have sameMemory:"memory st' = memory st " using 14 by auto
    have nonLocChanged:"\<forall>t' locs. \<not> LSubPrefL2 locs l \<or> locs = l \<longrightarrow> accessStorage t' locs (storage st (address env)) = accessStorage t' locs s" 
      using 14(4) unfolding copy_def using  copySingleChange[of p l t "(storage st (address env))" x s]  
      by fastforce
    have a30:"\<forall>locs t''. \<not> TypedStoSubpref locs l (STArray x t) \<longrightarrow> accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs s" 
      using  14(4) unfolding copy_def using copySingleChange2[of p l t "(storage st (address env))" x s]  by simp
    then have a35:"\<forall>locs t''. locs \<noteq> l \<and> \<not> TypedStoSubpref locs l (STArray x t) \<longrightarrow>
       accessStorage t'' locs (storage st (address env)) = accessStorage t'' locs (storage st' (address env))" 
      using 14 by auto
    have mInStd:"s = storage st' (address env)" using 14 by simp

    obtain stloc tp'' where MConsrc:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) \<and> (\<exists>xx. KStoptr p = KStoptr xx) \<and>
            
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue env) \<and>
            (tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))"
      using 2(1) 14(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KStoptr p" "Storage (STArray x t)" g] 
      using 2(3) 
      by (auto split:Type.splits if_splits )

    have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
    moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast
    ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto

    have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                            \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto

    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof intros 
      show "AddressTypes (accounts st')" using 2(1) 14 unfolding TypeSafe_def by simp
    next 
      show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      show "compPointers (stack st') (denvalue env)"  unfolding compPointers_def 
      proof(intros)
        fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
        then show " if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "TypedStoSubpref stl2 stl1 tp1")
          case True
          then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
        next
          case f1:False
          then show ?thesis 
          proof(cases "TypedStoSubpref stl1 stl2 tp2")
            case True
            then show ?thesis using a1 sameStack a0 unfolding compPointers_def by simp
          next
            case False
            then show ?thesis using f1 by simp
          qed
        qed
      qed
    next 
      have "safeContract (storage st)" using 2(1) unfolding TypeSafe_def by simp 
      show "safeContract (storage st')" unfolding safeContract_def
      proof intros
        fix e ct dud i tp
        assume *:"ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp)"
        obtain c where **:"type (accounts st (address env)) = Some (Contract c) \<and> contract env = c" 
          using 2(3) unfolding fullyInitialised_def using 2 by blast

        then show " SCon tp i (storage st' (address e))" 
          using 2(3) unfolding fullyInitialised_def using 2 unfolding TypeSafe_def safeContract_def  
          by (smt (z3) AddressTypes_def Member.inject(3) STypes.distinct(3) fmupd_lookup option.inject prod.inject)
      qed
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "balanceTypes (accounts st')" using 14 using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
    next 
      have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have **:"toploc (stack st) = toploc (stack st')" using 14 unfolding updateStore_def by auto
      show "lessThanTopLocs (stack st')"  using sameStack * ** unfolding lessThanTopLocs_def by auto
    next 
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
    next
      show "lessThanTopLocs (memory st')" using sameMemory unfolding lessThanTopLocs_def 
        by (simp add: limitSt limitSt1)
    next 
      show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t'' l'
        assume inDen:" (t'', l') |\<in>| fmran (denvalue env)"

        show " case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t'' of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t'' of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case t'' of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t'' of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t'' of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases l')
          case (Stackloc x1)
          then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def using sameStack by fastforce
          then show ?thesis 
          proof(cases "a")
            case (KValue x1)
            then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack  unfolding TypeSafe_def typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
          next
            case (KCDptr x2)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def   typeCompat_def
              by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(18))
          next
            case (KMemptr x3)
            then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack sameMemory unfolding TypeSafe_def typeCompat_def by (cases t''; fastforce)
          next
            case (KStoptr x4)  
            then obtain struct where structDef: "t'' = Storage struct" using Stackloc adef inDen Stackloc 2(1) sameStack unfolding TypeSafe_def typeCompat_def
              by (cases t''; fastforce)

            have "SCon struct x4 (storage st' (address env))" 
            proof(cases rule:lexpStorageG[OF 2(1) 14(2) 2(3)])
              case lInDen:1
              then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14
                  sameStoLocTSafe by blast

              have p:"((if TypedStoSubpref stloc l t' then CompStoType t' tp'' l stloc
                 else if TypedStoSubpref l stloc tp'' then CompStoType tp'' t' stloc l else True))"
                using 2(1) unfolding TypeSafe_def compPointers_def using lInDen MConsrc by blast

              then have SCondest:"SCon (STArray x t) l s" 
              proof - 
                have denSub:"(if TypedStoSubpref stloc l (STArray x t) then CompStoType (STArray x t) tp'' l stloc
                 else if TypedStoSubpref l stloc tp'' then CompStoType tp'' (STArray x t) stloc l else True)" using p 14(3) by blast
                have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                  using MConsrc by simp
                have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

                then show ?thesis 
                proof(cases "p = l")
                  case pIsL:True
                  then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                    by (metis copy_def)
                next
                  case pNotl:False
                  then show ?thesis 
                  proof(cases "p = stloc")
                    case True
                    then have j1:"(if TypedStoSubpref p l (STArray x t) then CompStoType (STArray x t) (STArray x t) l p
                   else if TypedStoSubpref l p (STArray x t) then CompStoType (STArray x t) (STArray x t) p l else True)" 
                      using denSub paInf by fastforce
                    then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                      using comp_stotype_same_type_same_loc j1 pNotl by metis
                    moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                      using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                      using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                    ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                  next
                    case False
                    then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                    show ?thesis 
                    proof(cases "TypedStoSubpref stloc l (STArray x t)")
                      case True
                      then have "CompStoType (STArray x t) tp'' l stloc" using denSub by simp
                      then have "CompStoType (STArray x t) (STArray x t) stloc p" 
                        using CompStoType_trns comp_stotype_same_type_same_loc j1 pNotl by blast
                      then show ?thesis using comp_stotype_same_type_same_loc j1 pNotl False by blast
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedStoSubpref l stloc tp''")
                        case True
                        then have j5:"CompStoType tp'' (STArray x t) stloc l" using denSub f2 by auto
                        moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp
                        ultimately have j20:"stloc \<noteq> l \<and> stloc \<noteq> p" using pNotl 
                          using False TypedStoSubpref_sameLoc f2 by blast

                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      next
                        case False
                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                          by (meson NotReachablePrnt_imps_notReachableChild)
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      qed
                    qed
                  qed
                qed
              qed

              then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
                by (simp add: mInStd)
              then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
                by (simp add: mInStd )

              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage (STArray x t), Storeloc l) |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t) x4 l
                 else if TypedStoSubpref x4 l  (STArray x t) then CompStoType  (STArray x t) struct l x4 else True)" 
                using 2(1) 14(3) lInDen inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l x4 struct then CompStoType struct  (STArray x t) x4 l
                 else if TypedStoSubpref x4 l  (STArray x t) then CompStoType  (STArray x t) struct l x4 else True)"
                using  14(3) lInDen inDen adef Stackloc KStoptr structDef  sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l x4 struct")
                case True
                then have "CompStoType struct (STArray x t) x4 l" using cmpStoPtr2 by simp
                then show ?thesis using SCondest2  SConx4Old a35 14(3) php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l  (STArray x t)")
                  case True
                  then have "CompStoType t' struct l x4 " using cmpStoPtr2 f1 14(3) by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs by blast
                next
                  case False
                  have notSame:"x4 \<noteq> l" using False by auto
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t) \<longrightarrow> locs \<noteq> x4" using False by auto
                  show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
                qed
              qed
              then show ?thesis by simp
            next
              case sub2:(2 l''' t''')
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t''', Storeloc l''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) 
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t''' x4 l'''
                 else if TypedStoSubpref x4 l''' t''' then CompStoType t''' struct l''' x4 else True)" 
                using 2(1) 14(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t''' x4 l'''
                 else if TypedStoSubpref x4 l''' t''' then CompStoType t''' struct l''' x4 else True)"
                using  14(3) sub2 inDen adef Stackloc KStoptr structDef  sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t''' l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce
              (*This needs to be revisited, is essentially a generalisation of the proof for SCondest above*)

              then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14
                  sameStoLocTSafe sub2 
                using SCon_imps_sublocs by blast

              have p:"(
                (if TypedStoSubpref stloc l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True))"
                using 2(1) unfolding TypeSafe_def compPointers_def using sub2 MConsrc  by blast

              then have SCondest:"SCon (STArray x t) l s" 
              proof - 
                have denSub:"(if TypedStoSubpref stloc  l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True)" using p 14(3) by blast
                have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                  using MConsrc  by simp
                have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

                then show ?thesis 
                proof(cases "p = l")
                  case pIsL:True
                  then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                    by (metis copy_def)
                next
                  case pNotl:False
                  then show ?thesis 
                  proof(cases "p = stloc")
                    case True
                    then have j1:"(if TypedStoSubpref p l''' t''' then CompStoType t''' (STArray x t) l''' p
                   else if TypedStoSubpref l''' p (STArray x t) then CompStoType (STArray x t) t''' p l''' else True)" 
                      using denSub paInf by fastforce
                    then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                      using comp_stotype_same_type_same_loc j1 pNotl 
                      by (metis "14"(3) CompStoType_same_type_same_depth CompStoType_trns NotReachablePrnt_imps_notReachableChild NotRelatedPrnt_imps_notRelatedChild same_depth_imp_neg_TypedStoSubpref
                          sub2(2))
                    moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                      using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                      using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                    ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                  next
                    case False
                    then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                    show ?thesis 
                    proof(cases "TypedStoSubpref stloc l''' t'''")
                      case True
                      then have "CompStoType t''' tp'' l''' stloc" using denSub by simp

                      then have j5:"CompStoType  t''' (STArray x t) l''' p " using j1 False  
                        using CompStoType_trns by blast
                      moreover have j10:"CompStoType t''' (STArray x t) l''' l" using sub2 14(3) by auto
                      ultimately have j20:"l''' \<noteq> l \<and> l''' \<noteq> p" using pNotl 
                        using False TypedStoSubpref_sameLoc  
                        using CompStoType_sameLoc_sameType comp_stotype_same_type_same_loc by blast

                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_same_type_same_depth j5 j10  pNotl same_depth_imp_neg_TypedStoSubpref by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7  
                        by (metis (lifting) copy_def h8)
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedStoSubpref l''' stloc tp''")
                        case True
                        then have j5:" CompStoType tp'' t''' stloc l'''" using denSub f2 by auto
                        moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp


                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref 
                          by (metis "14"(3) CompStoType_trns sub2(2))
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      next
                        case False
                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                          by (metis "14"(3) NotReachablePrnt_imps_notReachableChild sub2(2))
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      qed
                    qed
                  qed
                qed
              qed
              then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
                by (simp add: mInStd)
              then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
                by (simp add: mInStd )

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t''' x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t) x4 l" using sub2 
                  using CompStoType_trns 14(3) by blast
                then show ?thesis using   SConx4Old a35 14(3) php1 SCon_sub_imps_Parent SCondest2 by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis 
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t''' struct l''' x4" using cmpStoPtr2 f1 14(3) True   
                      using sub2(2) by auto
                    moreover have "CompStoType t''' t' l''' x4" using t5 sub2 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, ccfv_SIG) "14"(3) NotReachablePrnt_imps_notReachableChild NotRelatedPrnt_imps_notRelatedChild SCon_imps_sublocs 
                            SCon_sub_imps_Parent SCondest2 SConx4Old Scon_NoChange
                            a35 cmpStoPtr2 f1 scl''' sub2(2))
                    qed
                  qed
                next
                  case False
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] 14(3) 
                    by (smt (verit, ccfv_SIG) NotReachablePrnt_imps_notReachableChild NotRelatedPrnt_imps_notRelatedChild SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 a35 cmpStoPtr2 f1 scl'''
                        sub2(2))
                qed
              qed
              then show ?thesis by simp
            next
              case sub3:(3 l''' t''' l'''')
              have cmpStoPtr:"(
                (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
                (Storage t''', Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 l' = Stackloc x1 \<and> accessStore x1 (stack st) = Some (KStoptr x4)) \<and> accessStore l'''' (stack st) = Some (KStoptr l''')
                 \<longrightarrow>
                (if TypedStoSubpref l''' x4 struct then CompStoType struct t''' x4 l'''
                 else if TypedStoSubpref x4 l''' t''' then CompStoType t''' struct l''' x4 else True)" 
                using 2(1) 14(3) inDen adef Stackloc KStoptr structDef unfolding TypeSafe_def compPointers_def by blast

              then have cmpStoPtr2:"(if TypedStoSubpref l''' x4 struct then CompStoType struct t''' x4 l'''
                 else if TypedStoSubpref x4 l''' t''' then CompStoType t''' struct l''' x4 else True)"
                using  14(3) sub3 inDen adef Stackloc KStoptr structDef  sameStack by auto

              have SConx4Old:"SCon struct x4 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using adef Stackloc KStoptr  inDen  2(1) sameStack structDef  
                by fastforce
              have scl''':"SCon t''' l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub3 by fastforce

              (* This needs to be revisited, is essentially a generalisation of the proof for SCondest above*)
              then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14
                  sameStoLocTSafe sub3
                using SCon_imps_sublocs by blast

              have p:"((if TypedStoSubpref stloc l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True))"
                using 2(1) unfolding TypeSafe_def compPointers_def using sub3 MConsrc  by blast

              then have SCondest:"SCon (STArray x t) l s" 
              proof -

                have denSub:"(if TypedStoSubpref stloc  l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True)" using p 14(3) by blast
                have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                  using MConsrc  by simp
                have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

                then show ?thesis 
                proof(cases "p = l")
                  case pIsL:True
                  then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                    by (metis copy_def)
                next
                  case pNotl:False
                  then show ?thesis 
                  proof(cases "p = stloc")
                    case True
                    then have j1:"(if TypedStoSubpref p l''' t''' then CompStoType t''' (STArray x t) l''' p
                   else if TypedStoSubpref l''' p (STArray x t) then CompStoType (STArray x t) t''' p l''' else True)" 
                      using denSub paInf by fastforce
                    then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                      using comp_stotype_same_type_same_loc j1 pNotl 
                      by (metis "14"(3) CompStoType_same_type_same_depth CompStoType_trns NotReachablePrnt_imps_notReachableChild NotRelatedPrnt_imps_notRelatedChild same_depth_imp_neg_TypedStoSubpref
                          sub3(3))
                    moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                      using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                      using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                    ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                  next
                    case False
                    then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                    show ?thesis 
                    proof(cases "TypedStoSubpref stloc l''' t'''")
                      case True
                      then have "CompStoType t''' tp'' l''' stloc" using denSub by simp

                      then have j5:"CompStoType  t''' (STArray x t) l''' p " using j1 False  
                        using CompStoType_trns by blast
                      moreover have j10:"CompStoType t''' (STArray x t) l''' l" using sub3 14(3) by auto
                      ultimately have j20:"l''' \<noteq> l \<and> l''' \<noteq> p" using pNotl 
                        using False TypedStoSubpref_sameLoc  
                        using CompStoType_sameLoc_sameType comp_stotype_same_type_same_loc by blast

                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_same_type_same_depth j5 j10  pNotl same_depth_imp_neg_TypedStoSubpref by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7  
                        by (metis (lifting) copy_def h8)
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedStoSubpref l''' stloc tp''")
                        case True
                        then have j5:" CompStoType tp'' t''' stloc l'''" using denSub f2 by auto
                        moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp


                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref 
                          by (metis "14"(3) CompStoType_trns sub3(3))
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      next
                        case False
                        then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                          using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                          by (metis "14"(3) NotReachablePrnt_imps_notReachableChild sub3(3))
                        moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                          using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                        moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                          using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                        ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                      qed
                    qed
                  qed
                qed
              qed
              then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
                by (simp add: mInStd)
              then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
                by (simp add: mInStd )

              have "SCon struct x4 (storage st' (address env))" 
              proof(cases "TypedStoSubpref l''' x4 struct")
                case True
                then have "CompStoType struct t''' x4 l'''" using cmpStoPtr2 by simp
                then have "CompStoType struct (STArray x t) x4 l" using sub3 
                  using CompStoType_trns 14(3) by blast
                then show ?thesis using SCondest2  SConx4Old a35 14(3) php1 SCon_sub_imps_Parent 
                  by blast
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref x4 l''' t'''")
                  case True
                  then have "l''' \<noteq> x4" using f1 
                    using TypedStoSubpref_sameLoc by auto
                  then show ?thesis 
                  proof(cases "l = x4")
                    case t5:True
                    then have " CompStoType t''' struct l''' x4" using cmpStoPtr2 f1 14(3) True by simp
                    moreover have "CompStoType t''' t' l''' x4" using t5 sub3 by auto
                    ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                      by simp
                    then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                  next
                    case False
                    then have " CompStoType t''' struct l''' x4" using cmpStoPtr2 f1 14(3)  True by simp                
                    then show ?thesis 
                    proof(cases "CompStoType t' struct l x4 ")
                      case True
                      then show ?thesis 
                        using SCon_imps_sublocs SCondest3 by blast
                    next
                      case False
                      then show ?thesis 
                        by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t''' struct l''' x4\<close> a35 scl''' sub3(3) 14(3))
                    qed
                  qed
                next
                  case False                                                             
                  then have asm10:"\<not> TypedStoSubpref l x4 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                  then have asm20:"\<not> TypedStoSubpref x4 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                  have notSame:"x4 \<noteq> l" using False sub3 by blast
                  have k7:"\<forall>locs. TypedStoSubpref locs x4 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                  have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t) \<longrightarrow> locs \<noteq> x4" using False sub3 14(3) asm10 asm20 by blast
                  show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 14(3) by blast
                qed
              qed
              then show ?thesis by simp
            qed
            then show ?thesis using Stackloc  inDen  2(1) sameStack KStoptr adef structDef by simp
          qed
        next
          case (Storeloc x2)
          then obtain struct where structDef: "t'' = Storage struct" using Storeloc  inDen  2(1) sameStack unfolding TypeSafe_def typeCompat_def
            by (cases t''; fastforce)

          have "SCon struct x2 (storage st' (address env))" 
          proof(cases rule:lexpStorageG[OF 2(1) 14(2) 2(3)])
            case lInDen:1
            have cmpStoPtr:"(
              (Storage struct, l') |\<in>| fmran (denvalue env) \<and>
              (Storage (STArray x t), Storeloc l) |\<in>| fmran (denvalue env) \<and>
               l' = Storeloc x2) 
               \<longrightarrow>
              (if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t) x2 l
               else if TypedStoSubpref x2 l  (STArray x t) then CompStoType  (STArray x t) struct l x2 else True)" 
              using 2(1) 14(3) lInDen inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l x2 struct then CompStoType struct  (STArray x t) x2 l
               else if TypedStoSubpref x2 l  (STArray x t) then CompStoType  (STArray x t) struct l x2 else True)"
              using  14(3) lInDen inDen Storeloc structDef  sameStack by simp

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce

            then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14 lInDen
                sameStoLocTSafe by blast

            have p:"((if TypedStoSubpref stloc l t' then CompStoType t' tp'' l stloc
               else if TypedStoSubpref l stloc tp'' then CompStoType tp'' t' stloc l else True))"
              using 2(1) unfolding TypeSafe_def compPointers_def using lInDen MConsrc by blast

            then have SCondest:"SCon (STArray x t) l s" 
            proof -
              have denSub:"(if TypedStoSubpref stloc l (STArray x t) then CompStoType (STArray x t) tp'' l stloc
                 else if TypedStoSubpref l stloc tp'' then CompStoType tp'' (STArray x t) stloc l else True)" using p 14(3) by blast
              have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                using MConsrc Storeloc by simp
              have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

              then show ?thesis 
              proof(cases "p = l")
                case pIsL:True
                then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                  by (metis copy_def)
              next
                case pNotl:False
                then show ?thesis 
                proof(cases "p = stloc")
                  case True
                  then have j1:"(if TypedStoSubpref p l (STArray x t) then CompStoType (STArray x t) (STArray x t) l p
                   else if TypedStoSubpref l p (STArray x t) then CompStoType (STArray x t) (STArray x t) p l else True)" 
                    using denSub paInf by fastforce
                  then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                    using comp_stotype_same_type_same_loc j1 pNotl by metis
                  moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                    using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                  moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                    using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                  ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                next
                  case False
                  then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                  show ?thesis 
                  proof(cases "TypedStoSubpref stloc l (STArray x t)")
                    case True
                    then have "CompStoType (STArray x t) tp'' l stloc" using denSub by simp
                    then have "CompStoType (STArray x t) (STArray x t) stloc p" 
                      using CompStoType_trns comp_stotype_same_type_same_loc j1 pNotl by blast
                    then show ?thesis using comp_stotype_same_type_same_loc j1 pNotl False by blast
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref l stloc tp''")
                      case True
                      then have j5:"CompStoType tp'' (STArray x t) stloc l" using denSub f2 by auto
                      moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp
                      ultimately have j20:"stloc \<noteq> l \<and> stloc \<noteq> p" using pNotl 
                        using False TypedStoSubpref_sameLoc f2 by blast

                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    next
                      case False
                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                        by (meson NotReachablePrnt_imps_notReachableChild)
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    qed
                  qed
                qed
              qed
            qed

            then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
              by (simp add: mInStd)
            then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
              by (simp add: mInStd )

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l x2 struct")
              case True
              then have "CompStoType struct (STArray x t) x2 l" 
                by (simp add: cmpStoPtr2)
              then show ?thesis using SCondest2  SConx4Old a35  php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l  (STArray x t)")
                case True
                then have "CompStoType t' struct l x2 " using cmpStoPtr2 f1 14(3) by simp
                then show ?thesis using SCondest3  SCon_imps_sublocs by blast
              next
                case False
                have notSame:"x2 \<noteq> l" using False by auto
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t) \<longrightarrow> locs \<noteq> x2" using False by auto
                show ?thesis  using sublocs_nonchanged_SCon[OF f1 a35 SConx4Old False] by blast      
              qed
            qed
            then show ?thesis by simp
          next
            case sub2:(2 l''' t''')
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t''', Storeloc l''') |\<in>| fmran (denvalue env) )
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t''' x2 l'''
                 else if TypedStoSubpref x2 l''' t''' then CompStoType t''' struct l''' x2 else True)" 
              using 2(1) 14(3) inDen  Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t''' x2 l'''
                 else if TypedStoSubpref x2 l''' t''' then CompStoType t''' struct l''' x2 else True)"
              using  14(3) sub2 inDen Storeloc  structDef  sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t''' l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub2 by fastforce
            (* This needs to be revisited, is essentially a generalisation of the proof for SCondest above*)

            then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14
                sameStoLocTSafe sub2 
              using SCon_imps_sublocs by blast

            have p:"((if TypedStoSubpref stloc l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True))"
              using 2(1) unfolding TypeSafe_def compPointers_def using sub2 MConsrc  by blast

            then have SCondest:"SCon (STArray x t) l s" 
            proof -
              have denSub:"(if TypedStoSubpref stloc  l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True)" using p 14(3) by blast
              have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                using MConsrc Storeloc by simp
              have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

              then show ?thesis 
              proof(cases "p = l")
                case pIsL:True
                then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                  by (metis copy_def)
              next
                case pNotl:False
                then show ?thesis 
                proof(cases "p = stloc")
                  case True
                  then have j1:"(if TypedStoSubpref p l''' t''' then CompStoType t''' (STArray x t) l''' p
                   else if TypedStoSubpref l''' p (STArray x t) then CompStoType (STArray x t) t''' p l''' else True)" 
                    using denSub paInf by fastforce
                  then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                    using comp_stotype_same_type_same_loc j1 pNotl 
                    by (metis "14"(3) CompStoType_same_type_same_depth CompStoType_trns NotReachablePrnt_imps_notReachableChild 
                        NotRelatedPrnt_imps_notRelatedChild same_depth_imp_neg_TypedStoSubpref
                        sub2(2))
                  moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                    using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                  moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                    using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                  ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                next
                  case False
                  then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                  show ?thesis 
                  proof(cases "TypedStoSubpref stloc l''' t'''")
                    case True
                    then have "CompStoType t''' tp'' l''' stloc" using denSub by simp

                    then have j5:"CompStoType  t''' (STArray x t) l''' p " using j1 False  
                      using CompStoType_trns by blast
                    moreover have j10:"CompStoType t''' (STArray x t) l''' l" using sub2 14(3) by auto
                    ultimately have j20:"l''' \<noteq> l \<and> l''' \<noteq> p" using pNotl 
                      using False TypedStoSubpref_sameLoc  
                      using CompStoType_sameLoc_sameType comp_stotype_same_type_same_loc by blast

                    then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                      using CompStoType_same_type_same_depth j5 j10  pNotl same_depth_imp_neg_TypedStoSubpref by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                      using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                      using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                    ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7  
                      by (metis (lifting) copy_def h8)
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref l''' stloc tp''")
                      case True
                      then have j5:" CompStoType tp'' t''' stloc l'''" using denSub f2 by auto
                      moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp

                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref 
                        by (metis "14"(3) CompStoType_trns sub2(2))
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    next
                      case False
                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                        by (metis "14"(3) NotReachablePrnt_imps_notReachableChild sub2(2))
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    qed
                  qed
                qed
              qed
            qed
            then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
              by (simp add: mInStd)
            then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
              by (simp add: mInStd )

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t''' x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t) x2 l" using sub2 
                using CompStoType_trns 14(3) by blast
              then show ?thesis using SCondest2  SConx4Old a35 14(3)  php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t'''")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis 
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t''' struct l''' x2" using cmpStoPtr2 f1 14(3) True by simp
                  moreover have "CompStoType t''' t' l''' x2" using t5 sub2 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t''' struct l''' x2" using cmpStoPtr2 f1 14(3)  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t''' struct l''' x2\<close> a35 scl''' sub2(2) 14(3))
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub2 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub2 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub2 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub2 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t) \<longrightarrow> locs \<noteq> x2" using False sub2 14(3) asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 14(3) by blast
              qed
            qed

            then show ?thesis by simp
          next
            case sub3:(3 l''' t''' l'''')
            have cmpStoPtr:"(
                (Storage struct, Storeloc x2) |\<in>| fmran (denvalue env) \<and>
                (Storage t''', Stackloc l'''') |\<in>| fmran (denvalue env) \<and>
                 accessStore l'''' (stack st) = Some (KStoptr l'''))
                 \<longrightarrow>
                (if TypedStoSubpref l''' x2 struct then CompStoType struct t''' x2 l'''
                 else if TypedStoSubpref x2 l''' t''' then CompStoType t''' struct l''' x2 else True)" 
              using 2(1) 14(3) inDen Storeloc structDef unfolding TypeSafe_def compPointers_def by blast

            then have cmpStoPtr2:"(if TypedStoSubpref l''' x2 struct then CompStoType struct t''' x2 l'''
                 else if TypedStoSubpref x2 l''' t''' then CompStoType t''' struct l''' x2 else True)"
              using  14(3) sub3 inDen Storeloc structDef 14(3) sameStack by auto

            have SConx4Old:"SCon struct x2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using Storeloc  inDen  2(1) sameStack structDef  
              by fastforce
            have scl''':"SCon t''' l''' (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using sub3 by fastforce
            (*This needs to be revisited, is essentially a generalisation of the proof for SCondest above*)

            then have h7:"SCon (STArray x t) l (storage st (address env))" using 2(1) 14
                sameStoLocTSafe sub3
              using SCon_imps_sublocs by blast

            have p:"(
                (if TypedStoSubpref stloc l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True))"
              using 2(1) unfolding TypeSafe_def compPointers_def using sub3 MConsrc  by blast

            then have SCondest:"SCon (STArray x t) l s" 
            proof -
              have denSub:"(if TypedStoSubpref stloc  l''' t''' then CompStoType t''' tp'' l''' stloc
                 else if TypedStoSubpref l''' stloc tp'' then CompStoType tp'' t''' stloc l''' else True)" using p 14(3) by blast
              have paInf:"(tp'' = (STArray x t) \<and> KStoptr p = KStoptr stloc 
                      \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STArray x t) stloc (extractValueType (KStoptr p)))" 
                using MConsrc Storeloc by simp
              have h8:"SCon (STArray x t) p (storage st (address env))" using MConsrc by simp

              then show ?thesis 
              proof(cases "p = l")
                case pIsL:True
                then show ?thesis using copy_same_Scon 14(4) 14(3) h7 
                  by (metis copy_def)
              next
                case pNotl:False
                then show ?thesis 
                proof(cases "p = stloc")
                  case True
                  then have j1:"(if TypedStoSubpref p l''' t''' then CompStoType t''' (STArray x t) l''' p
                   else if TypedStoSubpref l''' p (STArray x t) then CompStoType (STArray x t) t''' p l''' else True)" 
                    using denSub paInf by fastforce
                  then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                    using comp_stotype_same_type_same_loc j1 pNotl 
                    by (metis "14"(3) CompStoType_same_type_same_depth CompStoType_trns NotReachablePrnt_imps_notReachableChild NotRelatedPrnt_imps_notRelatedChild same_depth_imp_neg_TypedStoSubpref
                        sub3(3))
                  moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                    using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                  moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                    using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                  ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                next
                  case False
                  then have j1:"CompStoType tp'' (STArray x t) stloc p" using paInf by simp
                  show ?thesis 
                  proof(cases "TypedStoSubpref stloc l''' t'''")
                    case True
                    then have "CompStoType t''' tp'' l''' stloc" using denSub by simp

                    then have j5:"CompStoType  t''' (STArray x t) l''' p " using j1 False  
                      using CompStoType_trns by blast
                    moreover have j10:"CompStoType t''' (STArray x t) l''' l" using sub3 14(3) by auto
                    ultimately have j20:"l''' \<noteq> l \<and> l''' \<noteq> p" using pNotl 
                      using False TypedStoSubpref_sameLoc  
                      using CompStoType_sameLoc_sameType comp_stotype_same_type_same_loc by blast

                    then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                      using CompStoType_same_type_same_depth j5 j10  pNotl same_depth_imp_neg_TypedStoSubpref by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                      using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                    moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                      using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                    ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7  
                      by (metis (lifting) copy_def h8)
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedStoSubpref l''' stloc tp''")
                      case True
                      then have j5:" CompStoType tp'' t''' stloc l'''" using denSub f2 by auto
                      moreover have j10:"CompStoType tp'' (STArray x t) stloc p" using j1 by simp

                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_same_type_same_depth j10 j5 pNotl same_depth_imp_neg_TypedStoSubpref 
                        by (metis "14"(3) CompStoType_trns sub3(3))
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    next
                      case False
                      then have j2:"\<not>TypedStoSubpref p l (STArray x t) \<and> \<not>TypedStoSubpref l p (STArray x t)" 
                        using CompStoType_imps_TypedStoSubpref NotRelatedPrnt_imps_notRelatedChild f2 j1 
                        by (metis "14"(3) NotReachablePrnt_imps_notReachableChild sub3(3))
                      moreover have "\<forall>subL. TypedStoSubpref subL l (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL p (STArray x t)" 
                        using NotRelatedPrnt_imps_notRelatedChild[of p l "(STArray x t)" "(STArray x t)"] j2 by blast
                      moreover have "\<forall>subL. TypedStoSubpref subL p (STArray x t) \<longrightarrow> \<not> TypedStoSubpref subL l (STArray x t)" 
                        using j2 NotRelatedPrnt_imps_notRelatedChild by blast
                      ultimately show ?thesis using copy_notSub_Scon 14(4) 14(3) h7 by (metis (lifting) copy_def h8)
                    qed
                  qed
                qed
              qed
            qed
            then have SCondest2:"SCon (STArray x t) l (storage st' (address env))" 
              by (simp add: mInStd)
            then have SCondest3:"SCon t' l (storage st' (address env))" using 14(3)
              by (simp add: mInStd )

            have "SCon struct x2 (storage st' (address env))" 
            proof(cases "TypedStoSubpref l''' x2 struct")
              case True
              then have "CompStoType struct t''' x2 l'''" using cmpStoPtr2 by simp
              then have "CompStoType struct (STArray x t) x2 l" using sub3 
                using CompStoType_trns 14(3) by blast
              then show ?thesis using SCondest2  SConx4Old a35 14(3) php1 SCon_sub_imps_Parent 
                by blast
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref x2 l''' t'''")
                case True
                then have "l''' \<noteq> x2" using f1 
                  using TypedStoSubpref_sameLoc by auto
                then show ?thesis
                proof(cases "l = x2")
                  case t5:True
                  then have " CompStoType t''' struct l''' x2" using cmpStoPtr2 f1 14(3) True by simp
                  moreover have "CompStoType t''' t' l''' x2" using t5 sub3 by auto
                  ultimately have "t' = struct"  using  CompStoType_sameLocs_sameType 
                    by simp
                  then show ?thesis using SCondest3  SCon_imps_sublocs t5  by simp
                next
                  case False
                  then have " CompStoType t''' struct l''' x2" using cmpStoPtr2 f1 14(3)  True by simp                
                  then show ?thesis 
                  proof(cases "CompStoType t' struct l x2 ")
                    case True
                    then show ?thesis 
                      using SCon_imps_sublocs SCondest3 by blast
                  next
                    case False
                    then show ?thesis 
                      by (smt (verit, best) SCon_imps_sublocs SCon_sub_imps_Parent SCondest2 \<open>CompStoType t''' struct l''' x2\<close> a35 scl''' sub3(3) 14(3))
                  qed
                qed
              next
                case False                                                             
                then have asm10:"\<not> TypedStoSubpref l x2 struct" using NotRelatedPrnt_imps_notRelatedChild[OF False f1 ] sub3 by blast
                then have asm20:"\<not> TypedStoSubpref x2 l t'" using sub3 NotReachablePrnt_imps_notReachableChild False f1 by blast
                have notSame:"x2 \<noteq> l" using False sub3 by blast
                have k7:"\<forall>locs. TypedStoSubpref locs x2 struct \<longrightarrow> locs \<noteq> l " using f1 sub3 asm10 asm20  by blast
                have k8:"\<forall>locs. TypedStoSubpref locs l (STArray x t) \<longrightarrow> locs \<noteq> x2" using False sub3 14(3) asm10 asm20 by blast
                show ?thesis  using sublocs_nonchanged_SCon[OF _ a35 SConx4Old] asm10 asm20 14(3) by blast
              qed
            qed
            then show ?thesis by simp
          qed


          then show ?thesis using Storeloc  inDen  2(1) sameStack Storeloc structDef by simp
        qed
      qed
      then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd " using sameStack by simp
    next 
      have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
      then show "compMemPtrs (stack st') (memory st') (denvalue env)" using sameStack sameMemory by auto
    next 
      have "accounts st'= accounts st" using 14 by auto
      then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) unfolding fullyInitialised_def 
        using sameStack by presburger

    qed
  next
    case (15 p x t g l t' g' m m')
    have temp:"TypeSafe env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd" 
      using 2(1) by simp
    have ttt:"fullyInitialised env (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>))" using 2(3) unfolding fullyInitialised_def by simp

    then show ?thesis
    proof(cases rule:lexpIndexMem[OF 15(2) temp ttt])
      case lInfo:(1 x21 x22 tp tParent l' l'' prnt len' arr' i)
      have nonChangedStack:"\<forall>loc. loc \<noteq> l \<longrightarrow> accessStore loc (stack st) = accessStore loc (stack st')" using 15 unfolding accessStore_def updateStore_def by auto
      have sameStack:"(stack st') = stack st" using 15 unfolding accessStore_def updateStore_def by auto
      have sameStorage:"storage st'  = storage st " using 15 by auto
      have nonLocChanged:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using 15(4) unfolding cps2m_def using  cps2mSingleChange[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" " (snd (allocate (memory st)))" x m ]   cps2m_def[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" x t "(storage st (address env))" " (snd (allocate (memory st)))" ]  
        by fastforce
      have a30:"\<forall>locs. locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> TypedStoSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (STArray x t) \<longrightarrow> accessStore locs (snd (allocate (memory st))) = accessStore locs m" 
        using  15(4) unfolding cps2m_def using cps2mSingleChange2[of p  "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" " (snd (allocate (memory st)))" x m ]  by fastforce
      then have a32:"\<forall>locs. \<not> TypedStoSubPref locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (STArray x t) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"   
        by (metis allocateSameAccess nonLocChanged)
      have selfPoint:"\<forall>l l'. TypedStoSubPref l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (STArray x t) \<and> accessStore l m = Some (MPointer l') \<longrightarrow> l' = l \<and> l \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using 15(4) unfolding cps2m_def 
        using cps2mSelfPointers[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" " (snd (allocate (memory st)))" x m ] 
        by (metis LSubPrefL2_def hash_inequality hash_suffixes_associative TypedStoSubPref.simps(2) stoTypedPrefix_imp_SubPref)
      have mInStd:"m' = memory st'" using 15 by simp
      have NonChangeM'm:"\<forall>locs. locs \<noteq> l \<longrightarrow> accessStore locs m = accessStore locs m'" using 15(5) unfolding accessStore_def updateStore_def by auto
      have accessL:"accessStore l m' = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 15(5) unfolding accessStore_def updateStore_def by auto

      have MConsrc:"SCon (STArray x t) (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) \<and> (\<exists>xx. KStoptr p = KStoptr xx)"
        using 2(1) 15(1) exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" ] 2(3)unfolding fullyInitialised_def
        by (auto split:Type.splits if_splits )

      obtain memArr where memArrDef: "t' = MTArray x memArr" using 15(3) cps2mTypeCompatible.simps 
        by (metis MTypes.exhaust)

      have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  
        using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
      moreover have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" 
        using allocateSameAccess by blast
      ultimately have "accessStore (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (snd (allocate (memory st))) = None" using LSubPrefL2_def by auto
      then have MCondest:" MCon (MTArray x memArr) m (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using 15(4,3) unfolding cps2m_def
        using cps2m[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" "(snd (allocate (memory st)))" x m memArr] 
          MConsrc extractValueType.simps(2) memArrDef by auto
      have "\<exists>x. accessStore l (memory st) = Some x" using lInfo by (auto split:option.splits)
      then have l_not_toploc_orSub:"\<not>LSubPrefL2 l (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using limitSt by fastforce 

      have selfPoint2:"\<forall>l1 l2. LSubPrefL2 l1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) 
                        \<and> accessStore l1 (memory st') = Some (MPointer l2) \<longrightarrow> l2 = l1 \<and> l1 \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        by (metis NonChangeM'm a32 l_not_toploc_orSub leI less_irrefl_nat limitSt mInStd not_Some_eq selfPoint)

      obtain len subT where tParentType:"tParent = MTArray len subT" using lInfo by blast
      then obtain p'' where lOrigin:"accessStore l (memory (st)) = Some (MPointer p'')" 
        and  compType:"CompMemType (memory (st\<lparr>gas := g\<rparr>)) len subT (MTArray x memArr) l'' p''" 
        and lsublocs:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len' \<and> arr' = (MTArray x memArr) \<and> MCon (MTArray len' arr') (memory (st)) prnt" 
        and lsublocs3:"(prnt = l'' \<and> len = len' \<and> arr' = subT \<or> CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt)"
        using lInfo 15(3) memArrDef by force
      then have lsublocs2:" CompMemType (memory (st)) len' arr' (MTArray x memArr) prnt p''" 
        using "15"(3) CompMemType.simps(2) memArrDef by blast

      then have bb9:"\<forall>subT subloc. CompMemType (memory (st)) len' arr' subT prnt subloc \<and> subloc = p''
                                  \<longrightarrow> subT = (MTArray x memArr)" 
        using CompMemTypeSameLocsSameType lsublocs by blast

      have mconPrnt:"MCon (MTArray len' (MTArray x memArr)) (memory st) prnt" using lsublocs by auto
      have ldef:"l = hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i) \<and> i < len'" using lsublocs by auto

      have t6:"(Memory tParent,  Stackloc l') |\<in>| fmran (denvalue env)" using lInfo by blast
      have t7:" MCon (MTArray len subT) (memory (st)) l''" using lInfo 
        using tParentType by auto
      then have t8:"\<not> LSubPrefL2 l'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt limitSt1 typeSafe_noDenElementOverToploc_mem[OF 2(1) t6] lInfo(3) by simp
      have comptype2:"CompMemType m len subT (MTArray x memArr) l'' p''" using 
          cpm2mCompMemTypeOld_imps_CompMemType[of "(memory (st\<lparr>gas := g\<rparr>))" len subT "(MTArray x memArr)" l'' p'' "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" m ] 
          compType nonLocChanged limitSt t7 t8 allocateSame by auto
      have t10:"CompMemType (memory st) len subT (MTArray x memArr) l'' p''"
        using 
          cpm2mCompMemTypeOld_imps_CompMemType[of "(memory (st\<lparr>gas := g\<rparr>))" len subT "(MTArray x memArr)" l'' p'' "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" m ] 
          compType nonLocChanged limitSt t7 t8 allocateSame by auto
      then have mconlOld:"MCon (MTArray x memArr) (memory st) p''" using memArrDef 15(3) lInfo lOrigin by auto

      have nonLocChanged2:"\<forall>locs. locs \<noteq> l \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs (memory st')" 
        using 15 nonLocChanged LSubPrefL2_def NonChangeM'm mInStd allocateSame by metis
      have stackDenvalLimits:"\<forall>struct loc stloc. (Memory struct, Stackloc loc) |\<in>| fmran (denvalue env) 
                          \<and> accessStore loc (stack st) = Some (KMemptr stloc) \<longrightarrow> \<not> LSubPrefL2 stloc (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
        using typeSafe_noDenElementOverToploc_mem[OF 2(1)] by auto
      have MCondest2:" MCon (MTArray x memArr) (memory st') (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using 15 MCondest memArrDef
        by (smt (verit, ccfv_SIG) LSubPrefL2_def MemLSubPrefTransitive NonChangeM'm frd l_not_toploc_orSub mInStd selfPoint)

      have bb:"\<forall>locs tp. CompMemType (memory st) len subT tp l'' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
      proof intros
        fix locs tp 
        assume asm1:"CompMemType (memory st) len subT tp l'' locs"
        then have a2:"locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using t7
        proof(induction subT arbitrary:len l'')
          case (MTArray x1 subT)
          then show ?case 
            using CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def limitSt limitSt1 subPtrs_nonTop by blast
        next
          case (MTValue x)
          then show ?case 
            by (metis (no_types, lifting) CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def limitSt limitSt1 subPtrs_nonTop)
        qed
        then show " locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" by simp
        show "\<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using a2 by simp
      qed
      have b8:"\<forall>locs tp. CompMemType m len subT tp l'' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"
      proof intros
        fix locs tp 
        assume asm1:"CompMemType m len subT tp l'' locs"
        then show "locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))"  using t7 bb a32
        proof(induction subT arbitrary:len l'')
          case (MTArray x1 subT)
          obtain i' ptr' where i'Def:"i'<len \<and> accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m = Some (MPointer ptr') \<and> (ptr' = locs \<and> MTArray x1 subT = tp \<or> CompMemType m x1 subT tp ptr' locs)" 
            using MTArray.prems(1) unfolding CompMemType.simps by blast
          have "\<not> TypedMemSubPref (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) (MTArray x memArr)" 

            by (metis MTArray.prems(2) bot_nat_0.extremum_unique i'Def leI limitSt mcon_accessStore nat_less_le neg_MemLSubPrefL2_imps_TypedMemSubPref not_Some_eq)
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m" using MTArray.prems memArrDef 
            by (metis MConArrayPointers allocateSame bot_nat_0.extremum_strict bot_nat_0.not_eq_extremum i'Def le_refl limitSt nonLocChanged option.distinct(1))
          then show ?case 
          proof(cases "ptr' = locs")
            case True
            then show ?thesis 
              using MTArray.prems(3) \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m\<close> i'Def by auto
          next
            case False
            then have "CompMemType m x1 subT tp ptr' locs" 
              using i'Def by blast
            moreover have "MCon (MTArray x1 subT) (memory st) ptr'" 
              by (metis MCon_imps_sub_Mcon MTArray.prems(2) \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i')) m\<close> i'Def)
            moreover have "\<forall>locs tp. CompMemType (memory st) x1 subT tp ptr' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
              using MTArray.prems(3) 
              by (metis (no_types, lifting) CompTypeRemainsMCon MCon_imps_Some LSubPrefL2_def \<open>MCon (MTArray x1 subT) (memory st) ptr'\<close> Not_Sub_More_Specific le_refl limitSt option.distinct(1))
            ultimately show ?thesis using MTArray.IH[of x1 ptr']  using MTArray.prems by blast
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have nonLocChanged22:" \<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<or> locs = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m" using nonLocChanged 
        by (simp add: allocateSame)
      then have l''mMcon:" MCon (MTArray len subT) m l''" using  t7 bb
      proof(induction subT arbitrary: len l'')
        case (MTArray x1 subT)
        have "\<forall>i<len.
             (case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<len"
          then obtain  ptr' where ptr'def:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer ptr')
                          \<and> MCon (MTArray x1 subT) (memory st) ptr'" using MTArray(3) 
            by (metis MConArrayPointers MCon_imps_sub_Mcon MCon.simps(2))
          have "CompMemType (memory st) len  (MTArray x1 subT)  (MTArray x1 subT) l'' (ptr')" 
            using ptr'def asm1 by auto
          then have "ptr' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 ptr' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTArray.prems(3) by blast
          have same:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" using nonLocChanged22 
            by (metis Read_Show_nat'_id antisym_conv1 limitSt option.distinct(1) ptr'def readLintNotEqual)

          have "\<forall>locs tp. CompMemType (memory st) x1 subT tp ptr' locs \<longrightarrow> locs \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTArray.prems(3) \<open>CompMemType (memory st) len (MTArray x1 subT) (MTArray x1 subT) l'' ptr'\<close> compMemTypes_trns by blast
          then have "MCon (MTArray x1 subT) m ptr'" using MTArray.IH[of x1 ptr'] ptr'def 
            using nonLocChanged22 by blast
          then show "(case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) m loc2 | MTValue Types \<Rightarrow> False))" using same ptr'def 
            by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
        qed
        moreover have "len > 0" using MTArray.prems unfolding MCon.simps by blast
        moreover have "(\<exists>p. accessStore l'' m = Some (MPointer p)) \<or> accessStore l'' m = None"
        proof(cases "l'' = l")
          case True
          then show ?thesis 
            using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
        next
          case False
          then have "accessStore (l'' ) (memory st) = accessStore (l'') (m)" using nonLocChanged22 
            by (metis MConArrayPointers MTArray.prems(2) Read_Show_nat'_id calculation(2) lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 readLintNotEqual)
          then show ?thesis 
            using MTArray.prems(2) calculation(2) by force
        qed
        ultimately show ?case using MCon.simps(2)[of len "MTArray x1 subT" m l''] 
          by simp
      next
        case (MTValue x)
        have "\<forall>i<len.
             (case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<len"
          then obtain val where ptr':"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue val)
                          \<and> MCon (MTValue x) (memory st) (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTValue(2) 
            by (metis MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
          then have " CompMemType (memory st) len (MTValue x) (MTValue x) l'' (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using asm1 by auto
          then have "(hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            using MTValue by blast
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" using nonLocChanged22 by auto
          then show "(case accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False | Some (MValue val) \<Rightarrow> 
(case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) m (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) m loc2 | MTValue Types \<Rightarrow> False))" 
            using ptr' asm1 
            by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) MCon.simps(1))
        qed
        moreover have "(\<exists>p. accessStore l'' m = Some (MPointer p)) \<or> accessStore l'' m = None"
        proof(cases "l'' =l")
          case True
          then show ?thesis 
            using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
        next
          case False
          then have "accessStore (l'' ) (memory st) = accessStore (l'') (m)" using nonLocChanged22  
            by (metis MCon_imps_Some MTValue.prems(2) Read_Show_nat'_id antisym_conv1 lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 option.discI readLintNotEqual)

          then show ?thesis 
            by (metis MTValue.prems(2) MCon.simps(2))
        qed
        moreover have "len > 0" using MTValue by fastforce
        ultimately show ?case using MCon.simps(2)[of len "MTValue x" m l''] by simp
      qed

      have p''mMcon:"MCon (MTArray x memArr) m p''" using mconlOld 
      proof(induction memArr arbitrary:x p'')
        case (MTArray x1 t)
        have samep'':"p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
          by (metis (no_types, lifting) MCon_imps_Some MTArray(2) LSubPrefL2_def Not_Sub_More_Specific le_refl limitSt option.distinct(1))
        have "x > 0" using MTArray 
          using zero_less_iff_neq_zero by force
        moreover have "(\<exists>p. accessStore p'' m = Some (MPointer p)) \<or> accessStore p'' m = None" using MTArray samep'' 
          using nonLocChanged22 calculation(1) by force
        moreover have "\<forall>i<x. (case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) m loc2 | MTValue Types \<Rightarrow> False))" 
        proof(intros)
          fix i assume asm1:"i<x"
          then obtain ptr where ptr':"accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer ptr) \<and> MCon (MTArray x1 t) (memory st) ptr" using MTArray 
            by (meson MConArrayPointers MCon_imps_sub_Mcon \<open>0 < x\<close>)
          moreover have "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m = accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st)"
            using MemLSubPrefL2_specific_imps_general \<open>p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> nonLocChanged22 by metis
          moreover have "accessStore ptr (memory st) = accessStore ptr (m)"
            using  nonLocChanged22 
            by (metis MCon_imps_Some Read_Show_nat'_id antisym_conv1 calculation(1) lessThanSome_imps_Locs2 lessThanTopLocs_def limitSt limitSt1 option.discI readLintNotEqual)
          moreover have "MCon (MTArray x1 t) m ptr" using MTArray.IH ptr' by blast
          ultimately show "case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
        | Some (MValue val) \<Rightarrow> (case MTArray x1 t of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 t) m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
         | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 t of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 t) m loc2 | MTValue Types \<Rightarrow> False)" by simp
        qed
        ultimately show ?case using MCon.simps(2)[of x "MTArray x1 t" m p''] by simp
      next
        case (MTValue x')
        have "p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not>LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
          by (metis (no_types, lifting) MCon_imps_Some MTValue LSubPrefL2_def Not_Sub_More_Specific le_refl limitSt option.distinct(1))
        then have samep':"accessStore p'' (memory st) = accessStore p'' m" 
          by (simp add: nonLocChanged22)
        have "\<forall>i<x. (case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') m loc2 | MTValue Types \<Rightarrow> False))"
        proof(intros)
          fix i assume asm1:"i<x" 
          then obtain val where "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MValue val) \<and> MCon (MTValue x') (memory st) (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i))" using MTValue 
            by (meson MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
          moreover have "accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (m)" 
            using MemLSubPrefL2_specific_imps_general \<open>p'' \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 p'' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))\<close> nonLocChanged22 by blast
          ultimately show "(case accessStore (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m of None \<Rightarrow> False 
                  | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') m (hash p'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') m loc2 | MTValue Types \<Rightarrow> False))" 
            by auto
        qed
        moreover have "x > 0" using MTValue 
          using zero_less_iff_neq_zero by force
        moreover have "(\<exists>p. accessStore p'' m = Some (MPointer p)) \<or> accessStore p'' m = None" using MTValue samep' 
          using calculation(2) by auto
        ultimately show ?case using MCon.simps(2)[of x "MTValue x'" m p''] by simp
      qed

      have prntMconNew:"MCon (MTArray len' (MTArray x memArr)) (memory st') prnt"
      proof - 
        have " \<forall>i<len'.
             (case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x memArr of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x memArr) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x memArr of MTArray len' arr' \<Rightarrow> MCon (MTArray x memArr) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
        proof intros
          fix i' assume asm1:"i'<len'"
          then obtain ptr where ptrDef': "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = Some(MPointer ptr)
                                  " and ptrDef'2:"MCon (MTArray x memArr) (memory st) ptr"
            using mconPrnt by (metis MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum not_less_zero)

          show "case accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x memArr of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x memArr) (memory st') (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x memArr of MTArray len' arr' \<Rightarrow> MCon (MTArray x memArr) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
          proof(cases "i' = i")
            case True
            then show ?thesis 
              using MCondest2 accessL ldef mInStd by force
          next
            case False
            then have "accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st) = accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st')" using ldef 
              by (metis hashesIntSame limitSt nle_le nonLocChanged2 option.distinct(1) ptrDef')
            then have same:"accessStore (hash prnt (ShowL\<^sub>n\<^sub>a\<^sub>t i')) (memory st') =  Some(MPointer ptr)" using ptrDef' by simp
            have notPrnt:"ptr \<noteq> prnt" 
              using MConSubTypes mconPrnt ptrDef' CompMemJustType.simps(2) ptrDef'2 by blast

            have locRule:"\<forall>ct locs ints. CompMemType (memory st) len' (MTArray x memArr) ct prnt locs \<longrightarrow> locs \<noteq> prnt \<and> hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t ints) \<noteq> l"  
              using BothMConImpsNotCompMemType CompTypeRemainsMCon mconPrnt ldef  ShowLNatDot hash_injective by metis
            have "CompMemType (memory st) len' (MTArray x memArr) (MTArray x memArr)  prnt ptr" using ptrDef' asm1 by auto
            then have "MCon (MTArray x memArr) (memory st') ptr" using ptrDef'2 locRule 
            proof(induction memArr arbitrary: x ptr len' prnt)
              case (MTArray x11 x12)
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case MTArray x11 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x11 x12) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
               | Some (MPointer loc2) \<Rightarrow> (case MTArray x11 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x11 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume "i''<x"
                then obtain ptr' where ptr'Def:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = Some(MPointer ptr')
                                                \<and> MCon (MTArray x11 x12) (memory st) ptr'" using  MTArray.prems(2)
                  by (metis MConArrayPointers MCon_imps_sub_Mcon  neq0_conv not_less_zero)
                have "ptr \<noteq> prnt" using MTArray.prems by blast
                then have "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems ShowLNatDot hash_injective by blast
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st')" 
                  by (metis less_or_eq_imp_le limitSt nonLocChanged2 option.discI ptr'Def)
                then have same2:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some(MPointer ptr')" using ptr'Def by simp

                have "MCon (MTArray x11 x12) (memory st) ptr'" using ptr'Def by blast
                moreover have "CompMemType (memory st) x (MTArray x11 x12) (MTArray x11 x12) ptr ptr'" using ptr'Def 
                  using \<open>i'' < x\<close> by auto
                moreover have "\<forall>ct locs ints. CompMemType (memory st) x (MTArray x11 x12) ct ptr locs \<longrightarrow> locs \<noteq> ptr \<and> hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t ints) \<noteq> l" 
                  by (metis BothMConImpsNotCompMemType CompTypeRemainsMCon MTArray.prems(1,2,3) compMemTypes_trns)
                ultimately have "MCon (MTArray x11 x12) (memory st') ptr'" using MTArray.IH[of x x11 ptr ptr'] by blast
                then show "(case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
               | Some (MValue val) \<Rightarrow> (case MTArray x11 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x11 x12) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
               | Some (MPointer loc2) \<Rightarrow> (case MTArray x11 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x11 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                  using ptrDef' same2 by auto
              qed

              moreover have xNotZero:"x>0" using MTArray.prems(2) 
                using bot_nat_0.not_eq_extremum by fastforce
              moreover have "(\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None"
              proof(cases "ptr = l")
                case True
                then have " accessStore ptr (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 15 by auto
                then show ?thesis by blast
              next
                case False
                then have pdef:"(\<exists>p. accessStore ptr (memory st) = Some (MPointer p)) \<or> accessStore ptr (memory st) = None" 
                  using MTArray.prems(2) MCon.simps(2)[of x _ "memory st" ptr] xNotZero by simp
                then have "\<not> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt1 limitSt 
                  by (metis (no_types, lifting) MCon_imps_Some MTArray.prems(2) LSubPrefL2_def Not_Sub_More_Specific le_refl option.distinct(1))
                then have "accessStore ptr (memory st) =accessStore ptr (memory st') " using False nonLocChanged2 by simp
                then show ?thesis using pdef by simp
              qed
              ultimately show ?case  using MCon.simps(2)[of x "MTArray x11 x12" "memory st'" ptr]  by simp
            next
              case (MTValue x2)
              have "\<forall>i<x. (case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                 | Some (MValue val) \<Rightarrow> (case MTValue x2 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x2) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                 | Some (MPointer loc2) \<Rightarrow> (case MTValue x2 of MTArray len' arr' \<Rightarrow> MCon (MTValue x2) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume "i''<x"
                then obtain val where oldDef:"accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = Some(MValue val)
                                                \<and> MCon (MTValue x2) (memory st) (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using MTValue ptrDef' 
                  by (meson MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val)
                have "(hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l " using MTValue ldef ShowLNatDot hash_injective by blast
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st) = accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i''))  (memory st')" 
                  by (metis less_or_eq_imp_le limitSt nonLocChanged2 option.discI oldDef)
                then have "accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some(MValue val)" using oldDef by simp
                then show "case accessStore (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                       | Some (MValue val) \<Rightarrow> (case MTValue x2 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x2) (memory st') (hash ptr (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                       | Some (MPointer loc2) \<Rightarrow> (case MTValue x2 of MTArray len' arr' \<Rightarrow> MCon (MTValue x2) (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                  using oldDef by auto
              qed
              moreover have xNotZero:"x>0" using MTValue(2) 
                using bot_nat_0.not_eq_extremum by fastforce
              moreover have "(\<exists>p. accessStore ptr (memory st') = Some (MPointer p)) \<or> accessStore ptr (memory st') = None"
              proof(cases "ptr = l")
                case True
                then have " accessStore ptr (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" using 15 by auto
                then show ?thesis by blast
              next
                case False
                then have pdef:"(\<exists>p. accessStore ptr (memory st) = Some (MPointer p)) \<or> accessStore ptr (memory st) = None" 
                  using MTValue(2) MCon.simps(2)[of x _ "memory st" ptr] xNotZero by simp
                then have "\<not> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using limitSt1 limitSt 
                  by (metis (no_types, lifting) MCon_imps_Some MTValue(2) LSubPrefL2_def Not_Sub_More_Specific le_refl option.distinct(1))
                then have "accessStore ptr (memory st) =accessStore ptr (memory st') " using False nonLocChanged2 by simp
                then show ?thesis using pdef by simp
              qed

              ultimately show ?case using MCon.simps(2)[of x "MTValue x2" "memory st'" ptr] by simp
            qed
            then show ?thesis using same asm1 by simp
          qed
        qed

        moreover have "len' > 0" using mconPrnt 
          using ldef by auto
        moreover have "prnt \<noteq> l" using ldef 
          by (metis hash_inequality)
        moreover have "(\<exists>p. accessStore prnt (memory st') = Some (MPointer p)) \<or> accessStore prnt (memory st') = None"
        proof(cases "LSubPrefL2 prnt (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
          case True
          then show ?thesis 
            by (metis LSubPrefL2_def Not_Sub_More_Specific l_not_toploc_orSub ldef)
        next
          case False
          then show ?thesis using nonLocChanged2 calculation mconPrnt by simp
        qed
        ultimately show ?thesis using MCon.simps(2)[of len' "MTArray x memArr" "memory st'" prnt] mconPrnt  nonLocChanged2 ldef by simp
      qed

      have compmemst':"\<forall>locs lens subTs. CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt 
                            \<and> MCon (MTArray lens subTs) (memory st) locs 
                          \<longrightarrow> CompMemType (memory (st')) lens subTs (MTArray len' arr') locs prnt \<and> CompMemType (m) lens subTs (MTArray len' arr') locs prnt"
      proof intros
        fix locs lens subTs
        assume asm1:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt  \<and> MCon (MTArray lens subTs) (memory st) locs"
        then have asm5:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" by blast
        have asm6:"MCon (MTArray lens subTs) (memory st) locs" using asm1 by blast
        have asm2:"\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory (st)) = accessStore locs m"
          using nonLocChanged allocateSame by auto
        have mconl'':"MCon (MTArray len subT) (memory st) l''" using  lInfo(5) tParentType  by simp

        have a5:"CompMemType m lens subTs (MTArray len' arr') locs prnt" using cpm2mCompMemTypeOld_imps_CompMemType[OF asm5 asm2 ] asm6 limitSt 
          by (metis (no_types, opaque_lifting) MCon_imps_Some LSubPrefL2_def eq_imp_le Not_Sub_More_Specific not_None_eq)
        then have a10:"CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt \<and> CompMemType m lens subTs (MTArray len' arr') locs prnt" using asm6 
        proof(induction subTs arbitrary: lens locs)
          case (MTArray x11 x12)
          then have "CompMemType m lens (MTArray x11 x12) (MTArray len' arr') locs prnt" using a5 by simp
          then obtain iIn lIn where iInDef:"iIn<lens \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m = Some (MPointer lIn) 
                    \<and> (lIn = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType m x11 x12 (MTArray len' arr') lIn prnt)"
            unfolding CompMemType.simps by blast
          have same2:" accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m =  accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st)" 
            using MConArrayPointers MTArray.prems(2) allocateSame bot_nat_0.not_eq_extremum iInDef le_eq_less_or_eq limitSt nonLocChanged not_less_zero option.discI by metis
          then have mcIn:"MCon (MTArray x11 x12) (memory st) lIn" using same2 iInDef MTArray.prems
            by (metis MCon_imps_sub_Mcon)
          then show ?case
          proof(cases "lIn = prnt")
            case True
            have "prnt \<noteq> l" using ldef 
              by (metis hash_inequality)
            moreover have "MTArray x11 x12 = MTArray len' arr'" using iInDef True 
              by (metis CompMemType_imps_CompMemJustType MConSubTypes \<open>MCon (MTArray x11 x12) (memory st) lIn\<close> lsublocs mconPrnt CompMemJustType.simps(2))
            ultimately show ?thesis using True 
              by (metis MConPtrsMustBeSubLocs NonChangeM'm iInDef lsublocs mInStd same2 CompMemType.simps(2))
          next
            case False
            then have "CompMemType m x11 x12 (MTArray len' arr') lIn prnt" using iInDef by blast
            then have cp:"CompMemType (memory st') x11 x12 (MTArray len' arr') lIn prnt" using MTArray.IH[of x11 lIn] mcIn by blast
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) \<noteq> l" 
              by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc MConSubTypes Memoryvalue.inject(2) iInDef lOrigin lsublocs mcIn mconlOld option.inject same2
                  CompMemJustType.simps(2))
            then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t iIn)) (memory st')" 
              by (simp add: NonChangeM'm mInStd)
            then have "\<exists>i<lens. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') = Some (MPointer l)
                \<and> (l = prnt \<and> MTArray x11 x12 = MTArray len' arr' \<or> CompMemType (memory st') x11 x12 (MTArray len' arr') l prnt)"
              using False cp iInDef by metis
            then show ?thesis unfolding CompMemType.simps(2) 
              using iInDef by blast
          qed
        next
          case (MTValue x2)
          then show ?case 
            using compType by auto
        qed
        then show "CompMemType (memory st') lens subTs (MTArray len' arr') locs prnt" by blast
        show "CompMemType m lens subTs (MTArray len' arr') locs prnt " using a10 by simp
      qed

      then have l''Top'':"CompMemType (memory (st)) len subT (MTArray x memArr) l'' p''" using  lsublocs3 lsublocs 
        using compMemTypes_trns lsublocs2 by blast

      have l''MConst':"\<forall>locs lens subTs. CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt 
                            \<and> MCon (MTArray lens subTs) (memory st) locs \<and> MCon (MTArray lens subTs) m locs \<longrightarrow> MCon (MTArray lens subTs) (memory st') locs"
      proof intros

        fix locs lens subTs
        assume asm6:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt \<and> MCon (MTArray lens subTs) (memory st) locs \<and> MCon (MTArray lens subTs) m locs "
        then have asm7:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" by simp
        have asm8:"MCon (MTArray lens subTs) (memory st) locs" using asm6 by blast
        have asm9:"MCon (MTArray lens subTs) m locs " using asm6 by blast
        show "MCon (MTArray lens subTs) (memory st') locs "
        proof(cases "locs = prnt")
          case True
          then show ?thesis 
            using MConPtrsMustBeSubLocs2 lsublocs lsublocs3 prntMconNew asm8 asm7 by blast
        next
          case False
          then have cpMemo:"CompMemType (memory st) lens subTs (MTArray len' arr') locs prnt" 
            using asm6 by blast  
          then have asm10:"CompMemType m lens subTs (MTArray len' arr') locs prnt" using compmemst' asm8 by blast
          then have "CompMemType (memory (st')) lens subTs (MTArray len' arr') locs prnt" using compmemst' 
            using asm8 cpMemo by blast
          have "CompMemType m lens subTs (MTArray x memArr) locs p''" using asm10 compType 
            by (metis allocateSame compMemTypes_trns lOrigin l_not_toploc_orSub lsublocs nonLocChanged CompMemType.simps(2))
          then have "\<forall>locs' loct. CompMemType  m lens subTs loct locs locs' \<and> locs' = p'' \<longrightarrow> loct = (MTArray x memArr)" using  CompMem_SameLocs_SameSubT  
            using p''mMcon  asm9 asm7  by simp
          then show ?thesis using asm9 p''mMcon ldef lOrigin
          proof(induction subTs arbitrary: lens locs)
            case (MTArray x1 subT)
            have "\<forall>i<lens.
             (case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
            proof intros
              fix i'' assume asm1:"i''<lens"
              then obtain ptr where ptrDef:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 subT) m ptr" using MTArray.prems(2) 
                by (metis MConArrayPointers MconSameTypeSameAccessWithTyping bot_nat_0.not_eq_extremum less_nat_zero_code)

              show "(case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 subT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 subT) (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 subT of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 subT) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
              proof(cases "ptr = p''")
                case True
                then have sameTp:" (MTArray x1 subT) =  (MTArray x memArr)" using MTArray.prems ptrDef asm1 by auto 
                then show ?thesis 
                proof(cases "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
                  case True
                  then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" 
                    using accessL mInStd by auto
                  then show ?thesis using sameTp  MCondest2 by fastforce
                next
                  case False
                  then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                    by (simp add: NonChangeM'm mInStd)
                  have "\<forall>locs loct.  CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x memArr" 
                    using CompMemTypeSameLocsSameType ptrDef 
                    using MTArray.prems(1) asm1 CompMemType.simps(2) by blast
                  moreover have "MCon (MTArray x1 subT) (memory st') ptr" using MTArray.IH[of x1 ptr] MTArray.prems  ptrDef calculation by blast
                  ultimately show ?thesis 
                    by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)
                qed
              next
                case False
                then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems Memoryvalue.inject(2) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 subT) m ptr\<close>  option.inject

                  by (metis l_not_toploc_orSub nonLocChanged22)
                then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                  by (simp add: NonChangeM'm mInStd)
                have "\<forall>locs loct.  CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x memArr" 
                  using CompMemTypeSameLocsSameType ptrDef 
                  using MTArray.prems(1) asm1 CompMemType.simps(2) by blast
                moreover have "MCon (MTArray x1 subT) (memory st') ptr" using MTArray.IH[of x1 ptr] MTArray.prems  ptrDef calculation by blast
                ultimately show ?thesis 
                  by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) \<open>accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)
              qed
            qed
            moreover have "lens > 0" using MTArray by force
            moreover have "(\<exists>p. accessStore locs (memory st') = Some (MPointer p)) \<or> accessStore locs (memory st') = None"
            proof(cases "locs = l")
              case True
              then show ?thesis 
                using accessL mInStd by auto
            next
              case False
              then have "accessStore locs (memory st') = accessStore locs m" 
                by (simp add: NonChangeM'm mInStd)
              then show ?thesis using MTArray(3) calculation(2) by simp
            qed

            ultimately show ?case using MCon.simps(2)[of lens "MTArray x1 subT" "memory st'" locs] by simp
          next
            case (MTValue x')
            have "\<forall>i<lens.
             (case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False))"
            proof(intros)
              fix i'' assume asm1:"i''<lens"
              then obtain ptr where ptrDef:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some(MValue ptr) \<and> MCon (MTValue x') m (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                using MCon_sub_MTVal_imps_val MTValue.prems(2) MconSameTypeSameAccessWithTyping by presburger
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" 
                using allocateSame lOrigin l_not_toploc_orSub nonLocChanged by fastforce
              then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                by (simp add: NonChangeM'm mInStd)
              then show "case accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                using ptrDef 
                by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) MCon.simps(1))
            qed
            moreover have "lens > 0" using MTValue by fastforce
            moreover have "(\<exists>p. accessStore locs (memory st') = Some (MPointer p)) \<or> accessStore locs (memory st') = None"
            proof(cases "locs = l")
              case True
              then show ?thesis 
                using accessL mInStd by auto
            next
              case False
              then have "accessStore locs (memory st') = accessStore locs m" 
                by (simp add: NonChangeM'm mInStd)
              then show ?thesis using MTValue(2) calculation(2) by simp
            qed
            ultimately show ?case using MCon.simps(2)[of lens "MTValue x'" "memory st'" locs] by simp
          qed
        qed
      qed

      have aaa:"\<forall>sT sL. CompMemType (memory (st)) len subT sT l'' sL \<and> sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray len subT) (memory (st)) l''
                            \<longrightarrow>  CompMemType m len subT sT l'' sL"
      proof(intros)
        fix sT sL
        assume asm1: " CompMemType (memory st) len subT sT l'' sL \<and> sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray len subT) (memory (st)) l''"
        then show " CompMemType m len subT sT l'' sL"
        proof(induction subT arbitrary: len l'')
          case (MTArray x1 subT)
          obtain i'' ptr where i''Def:"(i''<len \<and> accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) \<and> (ptr = sL \<and> MTArray x1 subT = sT \<or> CompMemType (memory st) x1 subT sT ptr sL))"
            using MTArray.prems unfolding CompMemType.simps by auto
          then have "accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m" using MTArray.prems 
            by (metis Read_Show_nat'_id antisym_conv1 limitSt nonLocChanged22 option.distinct(1) readLintNotEqual)

          then show ?case 
          proof(cases "ptr = sL")
            case True
            then have "MTArray x1 subT = sT" using i''Def MTArray.prems 
              by (meson BothMConImpsNotCompMemType CompTypeRemainsMCon MCon_imps_sub_Mcon)
            then show ?thesis using True i''Def 
              using \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> by force
          next
            case False
            then have "CompMemType m x1 subT sT ptr sL" using MTArray.IH[of x1 ptr] using i''Def MTArray.prems by force
            then show ?thesis 
              by (metis \<open>accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> i''Def CompMemType.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case 
            by auto
        qed
      qed

      have l''Sublocs:"\<forall>sT sL. CompMemType (memory (st)) len subT sT l'' sL \<longrightarrow> MCon sT (memory st') sL"
      proof intros
        fix sT sL
        assume asm1: "CompMemType (memory (st)) len subT sT l'' sL"
        show "MCon sT (memory st') sL"
        proof(cases "CompMemType (memory st') len subT sT l'' sL")
          case True
          then show ?thesis using asm1 l''MConst' CompTypeRemainsMCon 
            using l''mMcon lsublocs lsublocs3 prntMconNew t7 by blast
        next
          case False
          have asm5:"\<forall>locs loct. CompMemType  m len subT loct l'' locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x memArr)" using comptype2 CompMem_SameLocs_SameSubT  
            using p''mMcon l''mMcon by blast
          then have notTop:"sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> \<not> LSubPrefL2 sL (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using bb asm1 by auto
          then have cpm:"CompMemType m len subT sT l'' sL" using aaa 
            using asm1 t7 by blast


          then have comps:"CompMemType m x memArr sT p'' sL \<or> sL = p'' \<and> (MTArray x memArr) = sT" using False p''mMcon asm5
          proof(induction subT arbitrary:len l'')
            case (MTArray x1 subT)
            have "\<exists>i<len. \<exists>l. accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) m = Some (MPointer l) \<and> (l = sL \<and> MTArray x1 subT = sT \<or> CompMemType m x1 subT sT l sL)" 
              using MTArray.prems(1) unfolding CompMemType.simps(2) by blast
            then obtain i'' ptr where ptrDef:"i''<len \<and>  accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> (ptr = sL \<and> MTArray x1 subT = sT \<or> CompMemType m x1 subT sT ptr sL)"
              by auto
            have asm4:"(\<forall>i<len. \<exists>l. accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') \<noteq> Some (MPointer l) \<or> (l \<noteq> sL \<or> MTArray x1 subT \<noteq> sT \<and> \<not>CompMemType (memory st') x1 subT sT l sL))" 
              using MTArray.prems(2) unfolding CompMemType.simps(2) by blast
            then show ?case 
            proof(cases "(hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
              case t1:True
              then have ptrP'':"ptr = p''" using ptrDef 
                using lOrigin l_not_toploc_orSub nonLocChanged22 by auto
              then have sameType: "MTArray x1 subT = MTArray x memArr" using MTArray.prems(4) ptrDef
                by (metis MTArray.prems(4) CompMemType.simps(2))
              then show ?thesis 
              proof(cases "ptr = sL")
                case True
                then show ?thesis using ptrP'' 
                  using comptype2 cpm l''mMcon CompMem_SameLocs_SameSubT by blast
              next
                case False
                then have "CompMemType m x1 subT sT ptr sL" using ptrDef by simp
                then show ?thesis using False ptrP'' sameType by simp
              qed
            next
              case False
              then have saemAccess:"accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                using NonChangeM'm mInStd by auto
              then have neg1:"(ptr \<noteq> sL \<or> MTArray x1 subT \<noteq> sT \<and> \<not>CompMemType (memory st') x1 subT sT ptr sL)" using ptrDef  MTArray.prems(2) by force
              then have "\<not>CompMemType (memory st') x1 subT sT ptr sL" 
                using MTArray.prems(2) ptrDef saemAccess by fastforce
              moreover have "CompMemType m x1 subT sT ptr sL" using ptrDef neg1 by blast
              moreover have "\<forall>locs loct. CompMemType m x1 subT loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x memArr" 
                using MTArray.prems(4) ptrDef by auto
              ultimately show ?thesis using MTArray.IH[of x1 ptr] 
                using p''mMcon by fastforce
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed

          have notTop2:"sL \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using notTop by simp
          then have "MCon sT m sL" 
            using CompTypeRemainsMCon l''mMcon cpm by blast
          then show ?thesis 
            using notTop2 comps 
          proof(induction sT arbitrary:sL)
            case (MTArray x1 sT)
            then show ?case 
            proof(cases sT)
              case mta:(MTArray x11 x12)
              have "\<forall>i<x1.
                  (case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                  | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof(intros)
                fix i'' assume asm3: "i''<x1"
                then obtain ptr where ptrDef:" accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x11 x12) m ptr" 
                  using MTArray.prems(1)  MCon.simps(2)[of x1 sT m sL] MConArrayPointers MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum 
                  by (metis mta)

                show "case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                      | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False)"
                proof(cases "ptr =  p''")
                  case True
                  then show ?thesis 
                    by (metis CompMemType_imps_CompMemJustType CompMemType_imps_TypedMemSubPrefPtrs MConPtrsMustBeSubLocs MTArray.prems(1,3) TypedMemSubPrefOneWay asm3 mta p''mMcon ptrDef
                        TypedMemSubPrefPtrs.simps(2))
                next
                  case False
                  then have "(hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef lsublocs ptrDef lOrigin 
                    using l_not_toploc_orSub nonLocChanged22 by fastforce

                  then have sameAccess:"accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                    by (simp add: NonChangeM'm mInStd)
                  then have "ptr \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
                    by (metis CompMemType_imps_CompMemJustType CompMemTypes_asc MConSubTypes MCondest MTArray.prems(3) mta ptrDef CompMemJustType.simps(2))
                  then have "MCon sT (memory st') ptr" using ptrDef MTArray.IH[of ptr] mta MTArray.prems(3) asm3 
                    by (metis MTypes.inject(1) compMemTypes_trns CompMemType.simps(2))
                  then show ?thesis using MCon.simps(2)[of x1 "MTArray x11 x12" "memory st'" sL] mta ptrDef sameAccess by simp
                qed
              qed
              moreover have "x1>0" using MTArray.prems(1) unfolding MCon.simps by presburger
              moreover have "(\<exists>p. accessStore sL (memory st') = Some (MPointer p)) \<or> accessStore sL (memory st') = None" 
                using MTArray.prems(1) calculation(2)  
                by (metis NonChangeM'm accessL mInStd MCon.simps(2))
              ultimately show ?thesis using MCon.simps(2)[of x1 sT "memory st'" sL] by simp
            next
              case (MTValue x2)
              have " \<forall>i<x1.
             (case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False | Some (MValue val) \<Rightarrow> 
(case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False))"
              proof intros
                fix i'' assume asm6:"i''<x1"
                then obtain ptr where ptrDef:" accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MValue ptr) \<and> MCon (MTValue x2) m (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                  using MTArray.prems(1)  MCon.simps(2)[of x1 sT m sL]  MCon_imps_sub_Mcon bot_nat_0.not_eq_extremum 
                  by (metis MCon_sub_MTVal_imps_val MTValue)
                then have "(hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" 
                  using allocateSame lOrigin l_not_toploc_orSub nonLocChanged by fastforce
                then have "accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
                  by (simp add: NonChangeM'm mInStd)

                have "MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using asm6 MTValue 
                  using \<open>accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef by fastforce
                then show "case accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False 
| Some (MValue val) \<Rightarrow> (case sT of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon sT (memory st') (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
         | Some (MPointer loc2) \<Rightarrow> (case sT of MTArray len' arr' \<Rightarrow> MCon sT (memory st') loc2 | MTValue Types \<Rightarrow> False)" 
                  using asm6 MTValue 
                  by (metis MTypes.simps(6) Memoryvalue.simps(5) Option.option.simps(5) \<open>accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash sL (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> ptrDef)

              qed
              moreover have "x1>0" using MTArray(2) MCon.simps(2) 
                using zero_less_iff_neq_zero by fastforce
              moreover have "(\<exists>p. accessStore sL (memory st') = Some (MPointer p)) \<or> accessStore sL (memory st') = None" using MTArray.prems(1) calculation(2)  
                by (metis NonChangeM'm accessL mInStd MCon.simps(2))
              ultimately show ?thesis using MCon.simps(2)[of x1 sT "memory st'" sL] by simp
            qed      
          next
            case (MTValue x)
            then have "accessStore sL m = accessStore sL (memory st')" 
              by (metis MConAccessSame.simps(1) Memoryvalue.distinct(1) NonChangeM'm SameMCon_imps_MConAccessSame lOrigin l_not_toploc_orSub mInStd nonLocChanged22 option.inject)
            then show ?case using MTValue by simp
          qed
        qed
      qed

      have mcf:"\<forall>x11 x12 x3. CompMemType (memory st) x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) (memory st) x3
            \<longrightarrow> CompMemType m x11 x12 (MTArray len subT) x3 l''"
      proof(intros)
        fix x11 x12 x3
        assume asm3:"CompMemType (memory st) x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) (memory st) x3"
        then show "CompMemType m x11 x12 (MTArray len subT) x3 l''"
        proof(induction x12 arbitrary: x11 x3)
          case (MTArray x1 x12)
          then obtain i'' ptr where ptrDef:"(i''<x11 \<and> accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) \<and> (ptr = l'' \<and> MTArray x1 x12 = MTArray len subT \<or> CompMemType (memory st) x1 x12 (MTArray len subT) ptr l''))" 
            unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "ptr = l''")
            case True
            then show ?thesis 
              by (metis MTArray.prems allocateSame limitSt nle_le nonLocChanged option.discI ptrDef CompMemType.simps(2) CompMem_SameLocs_SameSubT)
          next
            case False
            then have " CompMemType (memory st) x1 x12 (MTArray len subT) ptr l''" using ptrDef by simp
            moreover have "MCon (MTArray x1 x12) (memory st) ptr" 
              using MCon_imps_sub_Mcon MTArray.prems ptrDef by blast
            ultimately show ?thesis using MTArray.IH[of x1 ptr] 
              by (metis limitSt nat_le_linear nonLocChanged22 not_Some_eq ptrDef CompMemType.simps(2))
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have mcg:"\<forall>x11 x12 x3. CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3 
            \<longrightarrow> CompMemType (memory st') x11 x12 (MTArray len subT) x3 l''"
      proof(intros)
        fix x11 x12 x3
        assume asm3:" CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3 "
        then have asm6:"\<forall>locs loct. CompMemType  m x11 x12 loct x3 locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x memArr)" 
          using CompMemTypeSameLocsSameType asm3  by (meson compMemTypes_trns comptype2)
        show "CompMemType (memory st') x11 x12 (MTArray len subT) x3 l''" using asm3 asm6
        proof(induction x12 arbitrary: x11 x3)
          case (MTArray x1 x12)
          then obtain i'' ptr where ptrDef:"(i''<x11 \<and> accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> (ptr = l'' \<and> MTArray x1 x12 = MTArray len subT \<or> CompMemType m x1 x12 (MTArray len subT) ptr l''))" 
            unfolding CompMemType.simps by blast
          then show ?case 
          proof(cases "ptr = p''")
            case True
            then have sameType:"(MTArray x1 x12) = MTArray x memArr" using MTArray.prems ptrDef 
              using asm3 CompMemType.simps(2) by blast 
            then show ?thesis using True 
              using BothMConImpsNotCompMemType compMemTypes_trns comptype2 p''mMcon ptrDef by blast
          next
            case False
            then have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems 
              using lOrigin l_not_toploc_orSub nonLocChanged22 ptrDef by force
            then have sameAc:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
              by (simp add: NonChangeM'm mInStd)
            have g1:"\<forall>locs loct. CompMemType m x1 x12 loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x memArr " using MTArray.prems ptrDef 
              using asm3 CompMemType.simps(2) by blast
            then show ?thesis 
            proof(cases "ptr = l''")
              case True
              then show ?thesis using sameAc False ptrDef 
                by (metis BothMConImpsNotCompMemType MCon_imps_sub_Mcon MTArray.prems(1) l''mMcon CompMemType.simps(2))
            next
              case False
              then have "CompMemType (memory st') x1 x12 (MTArray len subT) ptr l''" using MTArray.IH[of x1 ptr] ptrDef sameAc g1 ptrDef 
                using MCon_imps_sub_Mcon MTArray.prems(1) by blast
              then show ?thesis 
                using ptrDef sameAc by auto
            qed
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed

      have mconParents:"\<forall>x11 x12 x3. CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3
            \<longrightarrow> MCon (MTArray x11 x12) (memory st') x3"
      proof intros
        fix x11 x12 x3
        assume asm3:"CompMemType m x11 x12 (MTArray len subT) x3 l'' \<and> MCon (MTArray x11 x12) m x3"
        then have asm4: "CompMemType m x11 x12 (MTArray len subT) x3 l''" by blast
        then have asm6:"\<forall>locs loct. CompMemType  m x11 x12 loct x3 locs \<and> locs = p'' \<longrightarrow> loct = (MTArray x memArr)" 

          using CompMemTypeSameLocsSameType asm3  
          by (meson compMemTypes_trns comptype2)
        have asm5:"MCon (MTArray x11 x12) m x3" using asm3 by blast
        then show "MCon (MTArray x11 x12) (memory st') x3" using asm6 
        proof(induction x12 arbitrary:x11 x3)
          case (MTArray x1 x12)
          have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
          proof intros
            fix i'' assume asm3:"i''<x11"
            then obtain ptr where ptrDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some (MPointer ptr) \<and> MCon (MTArray x1 x12) m ptr" using MTArray.prems(1) 
              by (metis MConArrayPointers MCon_imps_sub_Mcon less_nat_zero_code neq0_conv)
            show "(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
            proof(cases "ptr = p''")
              case True
              then have sameType:"(MTArray x1 x12) = MTArray x memArr" using MTArray.prems ptrDef 
                using asm3 CompMemType.simps(2) by blast 

              show ?thesis 
              proof(cases "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l")
                case True
                then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))))" 
                  using accessL mInStd by auto
                then show ?thesis using sameType 
                  using MCondest2 by auto
              next
                case False
                then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m" 
                  using NonChangeM'm mInStd by auto
                then show ?thesis using False 
                  by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5) True l''Sublocs ptrDef sameType t10)
              qed

            next
              case False
              then have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using MTArray.prems 
                using lOrigin l_not_toploc_orSub nonLocChanged22 ptrDef by force
              then have sameAc:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
                by (simp add: NonChangeM'm mInStd)
              have "\<forall>locs loct. CompMemType m x1 x12 loct ptr locs \<and> locs = p'' \<longrightarrow> loct = MTArray x memArr " using MTArray.prems ptrDef 
                using asm3 CompMemType.simps(2) by blast
              then have "MCon (MTArray x1 x12) (memory st') ptr" using MTArray.IH[of x1 ptr] ptrDef by blast
              then show ?thesis using sameAc ptrDef asm3 
                by (metis MTypes.simps(5) Memoryvalue.simps(6) Option.option.simps(5))
            qed
          qed
          moreover have "x11 > 0" using MTArray.prems unfolding MCon.simps by force
          moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" 
            using MTArray.prems unfolding MCon.simps 
            by (metis NonChangeM'm accessL mInStd)
          ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "memory st'" x3] by auto
        next
          case (MTValue x')
          have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False))"
          proof intros
            fix i'' assume asm3:"i''<x11"
            then obtain val where valdef: "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = Some(MValue val) \<and> MCon (MTValue x') m (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" using MTValue(1) 
              using MCon_imps_sub_Mcon MCon_sub_MTVal_imps_val by presburger
            moreover have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" 
              by (metis Memoryvalue.distinct(1) NonChangeM'm lOrigin l_not_toploc_orSub mInStd nonLocChanged22 option.inject valdef)
            ultimately show "case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTValue x' of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x') (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
              | Some (MPointer loc2) \<Rightarrow> (case MTValue x' of MTArray len' arr' \<Rightarrow> MCon (MTValue x') (memory st') loc2 | MTValue Types \<Rightarrow> False)" by auto
          qed
          moreover have "x11 > 0" using MTValue unfolding MCon.simps by presburger
          moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" using MTValue unfolding MCon.simps 
            by (metis NonChangeM'm accessL mInStd)
          ultimately show ?case using MCon.simps(2)[of x11 "MTValue x'" "memory st'" x3] by simp
        qed
      qed

      have nonChangesSublocs:"\<forall>locs tlen tTp locs' tlen' tTp'. \<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt
                                              \<and> CompMemType (memory (st)) tlen tTp tTp' locs locs'
                                              \<and> MCon (MTArray tlen tTp) (memory st) locs  \<and> locs \<noteq> prnt
              \<longrightarrow>  CompMemType (memory st') tlen tTp tTp' locs locs'"
      proof(intros)
        fix locs tlen tTp locs' tlen' tTp'
        assume *:"\<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt \<and> CompMemType (memory st) tlen tTp tTp' locs locs' \<and> MCon (MTArray tlen tTp) (memory st) locs \<and> locs \<noteq> prnt"
        then have asm3:"\<not>TypedMemSubPrefPtrs (memory (st)) tlen tTp locs prnt" by blast
        have asm4:"CompMemType (memory st) tlen tTp tTp' locs locs'" using * by blast
        have asm5:"MCon (MTArray tlen tTp) (memory st) locs" using * by blast
        have asm6:"locs \<noteq> prnt" using * by blast 
        show "CompMemType (memory st') tlen tTp tTp' locs locs' " using asm3 asm4 asm5 asm6
        proof(induction tTp arbitrary:tlen locs)
          case (MTArray x1 tTp)
          have neg:"(\<forall>i<tlen. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> (l \<noteq> prnt \<and> \<not>TypedMemSubPrefPtrs (memory st) x1 tTp l prnt))"
            using MTArray.prems(1,3)  MConArrayPointers less_nat_zero_code neq0_conv unfolding TypedMemSubPrefPtrs.simps by metis
          have "\<exists>i<tlen. \<exists>l. accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st) = Some (MPointer l) \<and> (l = locs' \<and> MTArray x1 tTp = tTp' \<or> CompMemType (memory st) x1 tTp tTp' l locs')" 
            using MTArray.prems(2) unfolding CompMemType.simps by auto
          then obtain i'' ptr where ptrDef:"i''<tlen \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr) 
                                    \<and> (ptr = locs' \<and> MTArray x1 tTp = tTp' \<or> CompMemType (memory st) x1 tTp tTp' ptr locs')" by blast
          then show ?case 
          proof(cases "ptr = locs'")
            case True
            then have sameT:"MTArray x1 tTp = tTp'" using ptrDef 
              using BothMConImpsNotCompMemType CompTypeRemainsMCon MCon_imps_sub_Mcon MTArray.prems(3) by blast
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTArray.prems(4) ptrDef ShowLNatDot hash_injective by blast
            then have "accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
              by (metis limitSt nat_le_linear nonLocChanged2 option.distinct(1))
            then show ?thesis using ptrDef True sameT using CompMemType.simps(2)[of "memory st'" tlen x1 tTp tTp' locs locs'] by metis
          next
            case False
            have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTArray.prems(4) ptrDef ShowLNatDot hash_injective by blast
            then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using ptrDef 
              by (metis limitSt nat_le_linear nonLocChanged2 option.distinct(1))
            then have "CompMemType (memory st) x1 tTp tTp' ptr locs'" using ptrDef False by simp
            have "ptr \<noteq> prnt" using neg ptrDef by auto
            then have "CompMemType (memory st') x1 tTp tTp' ptr locs'" using MTArray.IH[of x1 ptr] 
              by (metis MCon_imps_sub_Mcon MTArray.prems(1,3) \<open>CompMemType (memory st) x1 tTp tTp' ptr locs'\<close> ptrDef TypedMemSubPrefPtrs.simps(2))
            then show ?thesis using CompMemType.simps(2)[of "memory st'" tlen x1 tTp' tTp' locs locs'] ptrDef False sameAccess by auto
          qed
        next
          case (MTValue x)
          then show ?case by simp
        qed
      qed
      have BT3:"\<forall>locs tp x t. \<not>LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> \<not>CompMemType (memory (st')) x t tp (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) locs 
                                                                    \<and> \<not>TypedMemSubPrefPtrs (memory (st')) x t (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) locs" 
        using CompMemType_imps_TypedMemSubPrefPtrs LSubPrefL2_def SubPtrs_top selfPoint2 by blast

      have mconL''New:"MCon (MTArray len subT) (memory st') l''" using lsublocs3
      proof(cases "prnt = l''")
        case True
        then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
          using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
          using BothMConImpsNotCompMemType t7 by blast
        then have sameTypes:"len = len' \<and> arr' = subT " using lsublocs3 by simp
        then show ?thesis using prntMconNew True 
          using lsublocs by blast
      next
        case False
        then have "CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
        then have a:"CompMemType (memory (st')) len subT (MTArray len' (MTArray x memArr)) l'' prnt" using compmemst'  lsublocs  
          using t7 by blast
        then show ?thesis using False l''MConst' t7  
          using \<open>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt\<close> l''mMcon by blast
      qed

      show ?thesis unfolding TypeSafe_def StateInvariant_def
      proof intros 
        show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using 15 by simp
      next 
        show "unique_locations (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have a0:" compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast
        then show "compPointers (stack st') (denvalue env)"  using sameStack  sameStorage by simp
      next 
        show "safeContract (storage st')" using sameStorage using 2(1) unfolding TypeSafe_def safeContract_def by auto
      next 
        show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "balanceTypes (accounts st')" using 15 using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue env)" using 2(1) unfolding TypeSafe_def by simp
      next 
        have *:"((\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None) \<and>
              (\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))) " 
          using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
        have **:"toploc (stack st) = toploc (stack st')" using 15 unfolding updateStore_def by auto
        show "lessThanTopLocs (stack st')"  unfolding lessThanTopLocs_def
        proof intros

          fix tloc loc 
          assume h1:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have "toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** by simp
          then show "accessStore loc (stack st') = None" using *  
            by (simp add: sameStack)
        next 
          fix loc y 
          assume h1:" accessStore loc (stack st') = Some y"
          then show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" using ** * 
            by (metis sameStack)
        qed
      next 
        show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def by simp
      next
        have a10:"toploc (snd (allocate (memory st))) = toploc m" 
          using cps2mTopLocSame[of p "(ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" t "(storage st (address env))" "(snd (allocate (memory st)))" x m] 15(4) mInStd unfolding cps2m_def by fastforce
        then have a12:"toploc m = toploc m'" using 15(5) unfolding updateStore_def by auto
        have a15:"lessThanTopLocs (memory st)" using 2 unfolding TypeSafe_def by simp
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        show "lessThanTopLocs (memory st')" unfolding lessThanTopLocs_def 
        proof intros
          fix tloc loc 
          assume b10: "toploc (memory st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
          then have b20:"toploc (memory st) \<le> tloc" using a10 tloc a12 
            using mInStd by force

          then show "accessStore loc (memory st') = None " 
            by (metis (no_types, lifting) LSubPrefL2_def MemLSubPrefTransitive NonChangeM'm \<open>\<exists>x. accessStore l (memory st) = Some x\<close> a10 a12 allocateSame antisym_conv2 b10 hash_inequality
                hash_suffixes_associative hashesIntSame limitSt mInStd nonLocChanged option.discI order_less_le_trans tloc)
        next 
          fix loc y 
          assume "accessStore loc (memory st') = Some y "
          then show "\<exists>tloc<toploc (memory st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)" 
            by (metis NonChangeM'm \<open>\<exists>x. accessStore l (memory st) = Some x\<close> a10 a12 allocateSameAccess limitSt1 mInStd nonLocChanged order_less_trans tloc)
        qed
      next 
        show "typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
          unfolding typeCompat_def
        proof intros
          fix tLook lLook
          assume inDen:" (tLook, lLook) |\<in>| fmran (denvalue env)"
          show " case lLook of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st') of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case tLook of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case tLook of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False )
                | Some (KMemptr stloc) \<Rightarrow> (case tLook of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case tLook of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case tLook of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
          proof(cases lLook)
            case (Stackloc x1)
            then obtain a where  adef:"accessStore x1 (stack st') = Some a" using inDen Stackloc 2(1) unfolding TypeSafe_def typeCompat_def  using sameStack nonChangedStack by fastforce
            then show ?thesis 
            proof(cases "a")
              case (KValue x1)
              then show ?thesis using Stackloc adef inDen Stackloc 2(1) sameStack nonChangedStack unfolding TypeSafe_def typeCompat_def
                by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5) Stackvalue.simps(17) )
            next
              case (KCDptr x2)
              then show ?thesis  using Stackloc adef inDen Stackloc 2(1) sameStack nonChangedStack unfolding TypeSafe_def typeCompat_def
                by (metis (no_types, lifting) Denvalue.simps(5) Option.option.simps(5)  Stackvalue.simps(18) )
            next
              case (KMemptr x3)
              then have "\<exists>struct. tLook = Memory struct" using Stackloc adef  inDen Stackloc 2(1) KMemptr sameStack unfolding TypeSafe_def typeCompat_def by (cases tLook;force+) 
              then obtain struct where structdef:"tLook = Memory struct" by blast

              then have mcOld:"MCon struct (memory st) x3" using 2(1) unfolding TypeSafe_def typeCompat_def
                using Stackloc adef inDen KMemptr sameStack by (auto split:Type.splits Denvalue.splits Stackvalue.splits option.splits)
              then have mcM:"MCon struct m x3" using PreExistMconNotChangeByToploc  limitSt limitSt1 nonLocChanged22 
                by auto

              then have ptrs:"(\<forall>dloc1. (if x3 = l'' then struct = tParent
                           else case struct of
                                MTArray len arr \<Rightarrow>
                                  (case tParent of
                                  MTArray len2 arr2 \<Rightarrow>
                                    if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' x3 then CompMemType (memory st) len2 arr2 (MTArray len arr) l'' x3
                                    else if TypedMemSubPrefPtrs (memory st) len arr x3 l'' then CompMemType (memory st) len arr (MTArray len2 arr2) x3 l''
                                         else if TypedMemSubPrefPtrs (memory st) len arr x3 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                                              then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len arr dt x3 dloc1 else True
                                  | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr x3 l'' then CompMemType (memory st) len arr (MTValue val2) x3 l'' else True)
                                | MTValue val \<Rightarrow>
                                    (case tParent of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' x3 then CompMemType (memory st) len2 arr2 (MTValue val) l'' x3 else True
                                    | MTValue val2 \<Rightarrow> True)))"  
                using 2(1) unfolding TypeSafe_def compMemPtrs_def 
                using inDen lInfo Stackloc KMemptr structdef adef sameStack by auto

              have "MCon struct (memory st') x3"
              proof(cases "x3 = l''")
                case True
                then have "struct = tParent" using ptrs by simp
                then have i1:"MCon (MTArray len subT) (memory st) l''" using True tParentType mcOld by simp
                then have "MCon (MTArray len subT) (memory st') l''" using lsublocs3
                proof(cases "prnt = l''")
                  case True
                  then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
                    using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
                    using BothMConImpsNotCompMemType t7 by blast
                  then have sameTypes:"len = len' \<and> arr' = subT " using lsublocs3 by simp
                  then show ?thesis using prntMconNew True 
                    using lsublocs by blast
                next
                  case False
                  then have "CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" using lsublocs3 True by simp
                  then have a:"CompMemType (memory (st')) len subT (MTArray len' (MTArray x memArr)) l'' prnt" using compmemst'  lsublocs  
                    using t7 by blast
                  then show ?thesis using i1 False l''MConst' t7  
                    using \<open>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt\<close> l''mMcon by blast
                qed
                then show ?thesis using lOrigin mconlOld lInfo True
                  using \<open>struct = tParent\<close> tParentType by auto
              next
                case notSame:False
                then show ?thesis 
                proof(cases "struct")
                  case mta4:(MTArray x11 x12)
                  then show ?thesis 
                  proof(cases tParent)
                    case mta5:(MTArray x11' x12')
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' x3")
                      case True
                      then have "CompMemType (memory st) len subT (MTArray x11 x12) l'' x3" using ptrs notSame mta4 mta5 tParentType by simp
                      then have "MCon (MTArray x11 x12) (memory st') x3" using l''Sublocs by blast
                      then show ?thesis using mta4 by auto
                    next
                      case f2:False
                      then show ?thesis 
                      proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 x3 l''")
                        case True
                        then have " CompMemType (memory st) x11 x12 (MTArray len subT) x3 l''" using ptrs notSame tParentType mta4 mta5 f2 by simp
                        then show ?thesis using mconParents mcf 
                          using mcM mcOld mta4 by blast
                      next
                        case f3:False
                        then have "TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt" using lsublocs3 
                          using CompMemType_imps_TypedMemSubPrefPtrs by auto

                        then show ?thesis
                        proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 x3 prnt")
                          case True
                          then have "\<exists>dt. CompMemType (memory st) len subT dt l'' prnt \<and> CompMemType (memory st) x11 x12 dt x3 prnt" 
                            using ptrs notSame tParentType mta4 mta5 f2 f3 
                            using \<open>TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt\<close> by auto
                          then obtain dt where dtDef:"CompMemType (memory st) len subT dt l'' prnt \<and> CompMemType (memory st) x11 x12 dt x3 prnt" by blast
                          then have "CompMemType (memory st') len subT dt l'' prnt" 
                            using CompMemTypeSameLocsSameType True compmemst' f3 lInfo(6) t7 tParentType 
                            using lsublocs3 by blast
                          have "CompMemType (memory st') x11 x12 dt x3 prnt" using dtDef compmemst' 
                            using CompMemTypeSameLocsSameType True f3 lsublocs3 mcOld mta4 t7 by blast
                          then show ?thesis using l''MConst' 
                            using CompMemTypeSameLocsSameType True dtDef f3 lsublocs3 mcM mcOld mta4 t7 by blast
                        next
                          case f4:False
                          then have sameAccess:"accessStore x3 (memory st) = accessStore x3 m "  
                            using MCon_imps_Some LSubPrefL2_def hash_suffixes_associative le_refl limitSt nonLocChanged22
                            by (metis KMemptr Stackloc \<open>\<And>thesis. (\<And>struct. tLook = Memory struct \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close> adef inDen sameStack stackDenvalLimits)
                          have notx3:"x3 \<noteq> prnt" 
                            using \<open>TypedMemSubPrefPtrs (memory st) len subT l'' prnt \<or> l'' = prnt\<close> f2 notSame by auto

                          have g1:"MCon (MTArray x11 x12) (memory st) x3" using mta4 
                            using mcOld by auto
                          have g2:"MCon (MTArray x11 x12) m x3" using mta4 mcM by simp
                          have "MCon (MTArray x11 x12) (memory st') x3" using notx3 g1 g2 f4
                          proof(induction x12 arbitrary: x11 x3)
                            case (MTArray x1 x12)
                            have "\<forall>i<x11.
             (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
              | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
              | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                            proof (intros)
                              fix i'' assume asm3:"i''<x11"
                              then obtain ptr where valDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some (MPointer ptr) \<and> MCon (MTArray x1 x12) m ptr" 

                                by (metis MConArrayPointers MCon_imps_sub_Mcon MTArray.prems(3) bot_nat_0.not_eq_extremum not_less_zero)

                              have g6:"(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef 
                              proof -
                                obtain nn :: "MTypes \<Rightarrow> nat \<Rightarrow> String.literal \<Rightarrow> String.literal \<Rightarrow> nat" where
                                  f1: "\<forall>x0 x1b x2 x3b. (\<exists>v4<x1b. TypedMemSubPref x3b (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t v4)) x0 \<or> x3b = hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t v4)) 
                = (nn x0 x1b x2 x3b < x1b \<and> (TypedMemSubPref x3b (hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t (nn x0 x1b x2 x3b))) x0 \<or> x3b = hash x2 (ShowL\<^sub>n\<^sub>a\<^sub>t (nn x0 x1b x2 x3b))))"
                                  by moura
                                obtain ll :: "String.literal \<Rightarrow> String.literal \<Rightarrow> String.literal" where
                                  "\<forall>x0 x1b. (\<exists>v2. x1b = hash x0 v2) = (x1b = hash x0 (ll x0 x1b))"
                                  by moura
                                then have f2: "\<forall>l la. (\<not> LSubPrefL2 l la \<or> l = hash la (ll la l) \<or> l = la) \<and> (LSubPrefL2 l la \<or> (\<forall>lb. l \<noteq> hash la lb) \<and> l \<noteq> la)"
                                  using LSubPrefL2_def by blast
                                then have "LSubPrefL2 (ShowL\<^sub>n\<^sub>a\<^sub>t i) (ShowL\<^sub>n\<^sub>a\<^sub>t i)"
                                  by blast
                                then show ?thesis
                                  using f2 f1 
                                  
                                  by (smt (z3) MTArray.prems(1) MemLSubPrefL2_specific_imps_general TypedStoSubPref.simps(1) Mutual_NonSub_SpecificNonSub hash_inequality hash_never_equal_sufix hash_suffixes_associative ldef TypedMemSubPref.simps(2) stoTypedPrefix_imp_SubPref typedPrefix_imp_SubPref)
                              qed
                              then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m)" 
                                by (simp add: NonChangeM'm mInStd)
                              moreover have "ptr \<noteq> prnt" using MTArray.prems(4) valDef 
                                by (metis asm3 bb calculation lsublocs3 nonLocChanged22 selfPoint2 TypedMemSubPrefPtrs.simps(2) t8)
                              moreover have "\<not> TypedMemSubPrefPtrs (memory st) x1 x12 ptr prnt" using MTArray.prems(4) valDef 
                                using MTArray.prems(2) asm3 calculation(1) g6 limitSt nonLocChanged2 by fastforce
                              moreover have " MCon (MTArray x1 x12) (memory st) ptr" using MTArray.prems(2) valDef 
                                by (metis (mono_tags, lifting) MConArrayPointers MconSameTypeSameAccessWithTyping asm3 limitSt nat_le_linear neq0_conv nonLocChanged22 not_less_zero option.discI)
                              ultimately have "MCon (MTArray x1 x12) (memory st') ptr" using MTArray.IH[of ptr x1] g6 valDef by blast

                              then show " (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                                            | Some (MValue val) \<Rightarrow> (case MTArray x1 x12 of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTArray x1 x12) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                                            | Some (MPointer loc2) \<Rightarrow> (case MTArray x1 x12 of MTArray len' arr' \<Rightarrow> MCon (MTArray x1 x12) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                                by (simp add: \<open>accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) m\<close> valDef)
                            qed
                            moreover have "x11>0" using MTArray.prems(3) unfolding MCon.simps by presburger
                            moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None"
                              using MTArray.prems(3) unfolding MCon.simps 
                              using NonChangeM'm accessL calculation(2) mInStd by auto
                            ultimately show ?case using MCon.simps(2)[of x11 "MTArray x1 x12" "(memory st')" x3] by auto
                          next
                            case (MTValue x)
                            have "\<forall>i<x11.
                                   (case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)) (memory st') of None \<Rightarrow> False
                                    | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i)))
                                    | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))"
                            proof(intros)
                              fix i'' assume asm3:"i''<x11"
                              then obtain val where valDef:"accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m) = Some (MValue val) \<and> MCon (MTValue x) m (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i''))" 
                                using MTValue.prems(3) MCon_sub_MTVal_imps_val 
                                by (meson MCon_imps_sub_Mcon)

                              have "(hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using ldef MTValue.prems(1) 
                                  Memoryvalue.distinct(1)  lOrigin l_not_toploc_orSub nonLocChanged22 option.inject
                                using valDef by fastforce
                              then have "accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (m)" 
                                by (simp add: NonChangeM'm mInStd)
                              then show "(case accessStore (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') of None \<Rightarrow> False
                                    | Some (MValue val) \<Rightarrow> (case MTValue x of MTArray l a \<Rightarrow> False | MTValue typ \<Rightarrow> MCon (MTValue x) (memory st') (hash x3 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')))
                                    | Some (MPointer loc2) \<Rightarrow> (case MTValue x of MTArray len' arr' \<Rightarrow> MCon (MTValue x) (memory st') loc2 | MTValue Types \<Rightarrow> False))" 
                                using valDef by auto
                            qed
                            moreover have "x11 > 0" using MTValue(3) unfolding MCon.simps by presburger
                            moreover have "(\<exists>p. accessStore x3 (memory st') = Some (MPointer p)) \<or> accessStore x3 (memory st') = None" 
                              using MTValue(3) unfolding MCon.simps using calculation(2) 
                              by (metis NonChangeM'm accessL mInStd)
                            ultimately show ?case  using MCon.simps(2)[of x11 "MTValue x" "memory st'" x3] by simp
                          qed
                          then show ?thesis using mta4 by simp

                        qed

                      qed
                    qed
                  next
                    case (MTValue x2)
                    then show ?thesis using tParentType by simp
                  qed
                next
                  case (MTValue x2)
                  then show ?thesis using ptrs 
                    by (metis (lifting) Memoryvalue.simps(6) NonChangeM'm Option.option.simps(5) lOrigin mInStd mcM mcOld MCon.simps(1))
                qed
              qed
              then show ?thesis  using structdef KMemptr Stackloc adef  inDen Stackloc 2(1) unfolding TypeSafe_def by simp
            next
              case (KStoptr x4)  
              then show ?thesis using Stackloc adef sameStorage  inDen Stackloc KStoptr 2(1) nonChangedStack sameStack unfolding TypeSafe_def typeCompat_def
                apply(cases tLook) by fastforce+
            qed
          next
            case (Storeloc x2)
            then show ?thesis using sameStorage inDen 2(1) unfolding TypeSafe_def typeCompat_def by (cases tLook; force)
          qed
        qed
        then have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd " using sameStack by simp
      next 
        have compOld:" compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by blast

        have isPrntTypeSame:"\<forall>tp1 l1 stl1. (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1)
                  \<and> stl1 = prnt \<longrightarrow> tp1 = (MTArray len' arr')"
        proof intros
          fix tp1 l1 stl1 
          assume asm3:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> stl1 = prnt"
          have "\<forall>dloc1. (if stl1 = l'' then tp1 = MTArray len subT
        else case tp1 of
             MTArray len' arr' \<Rightarrow>
               (case MTArray len subT of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case MTArray len subT of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" 
            using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def  by fastforce
          then have asm5:"\<forall>dloc1. (if stl1 = l'' then tp1 = MTArray len subT
                      else case tp1 of
                           MTArray len' arr' \<Rightarrow>
                               if TypedMemSubPrefPtrs (memory st) len subT l'' stl1 then CompMemType (memory st) len subT (MTArray len' arr') l'' stl1
                               else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len subT) stl1 l''
                                    else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len subT l'' dloc1
                                         then \<exists>dt. CompMemType (memory st) len subT dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
                           | MTValue val \<Rightarrow>
                               if TypedMemSubPrefPtrs (memory st) len subT l'' stl1 then CompMemType (memory st) len subT (MTValue val) l'' stl1 else True )" 
            by (auto split:MTypes.splits)
          show "tp1 = MTArray len' arr'"
          proof(cases "stl1 = l''")
            case True
            then have "l'' = prnt" using asm3 by simp
            then have notComp:"\<not>CompMemType (memory (st)) len subT (MTArray len' arr') l'' prnt" 
              using  lsublocs BothMConImpsNotCompMemType[of len subT "memory st" l'' "(MTArray len' arr')"] lsublocs3  
              using BothMConImpsNotCompMemType t7 by blast
            then have " len = len' \<and> arr' = subT" using lsublocs3 by simp
            then show ?thesis using True asm5 by simp
          next
            case notSame:False
            then have lNotp:"l'' \<noteq> prnt" using notSame asm3 by simp
            then have g1:"CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by auto
            then have g5:"TypedMemSubPrefPtrs (memory st) len subT l'' stl1" using g1 asm3 CompMemType_imps_TypedMemSubPrefPtrs by simp
            then show ?thesis 
            proof(cases "tp1")
              case (MTArray x11 x12)
              then have stl1Mc:"MCon (MTArray x11 x12) (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len subT l'' stl1")
                case True
                then have "CompMemType (memory st) len subT (MTArray  x11 x12) l'' stl1"
                  using notSame MTArray g1 lNotp asm5 stl1Mc lsublocs by simp
                then show ?thesis using MTArray g1 asm3 CompMemTypeSameLocsSameType 
                  using t7 by blast
              next
                case False
                then show ?thesis  using notSame MTArray g1 lNotp asm5 stl1Mc lsublocs 
                  by (simp add: g5)
              qed
            next
              case (MTValue x2)
              then have g2:"CompMemType (memory st) len subT (MTValue x2) l'' prnt" using g5 asm3 asm5 MTValue notSame by auto
              have "MCon (MTValue x2) (memory st) stl1" using asm3 2(1) MTValue sameStack unfolding TypeSafe_def typeCompat_def by force
              then show ?thesis using g1 g2 lsublocs asm3 by fastforce
            qed
          qed
        qed

        have isPrntTypeSub:"\<forall>l1 stl1 len'' arr''. (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1) 
                  \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' \<noteq> prnt\<longrightarrow> (CompMemType (memory st) len'' arr'' (MTArray len' arr') stl1 prnt)"
        proof intros
          fix l1 stl1  len'' arr''
          assume asm3:"(Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1)
                           \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' \<noteq> prnt"
          then have stl1Mc:"MCon (MTArray len'' arr'') (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
          then have stl1NotPrnt:"stl1 \<noteq> prnt" using asm3 TypedMemSubPrefPtrs_imps_notsame 
            by blast
          have "\<forall>dloc1.
       (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l' (stack st) = Some (KMemptr l'') \<longrightarrow>
       (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
        else case (MTArray len'' arr'') of
             MTArray len' arr' \<Rightarrow>
               (case (MTArray len subT) of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case (MTArray len subT) of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" 
            using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def by blast
          moreover have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env)" using lInfo(2,3,4) tParentType by blast
          moreover have "accessStore l' (stack st) = Some (KMemptr l'')" using lInfo by auto
          ultimately have asm6:"\<forall>dloc1. (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
              else if TypedMemSubPrefPtrs (memory st)  len subT l'' stl1 then CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l'' then CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st)  len subT l'' dloc1
                           then \<exists>dt. CompMemType (memory st)  len subT dt l'' dloc1 \<and> CompMemType (memory st) len'' arr'' dt stl1 dloc1 else True)" 
            using asm3 using sameStack by auto
          show "CompMemType (memory st) len'' arr'' (MTArray len' arr') stl1 prnt"
          proof(cases "stl1 = l''")
            case True
            then have "l'' \<noteq> prnt" using stl1NotPrnt by simp
            then have "CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
            then show ?thesis using True asm3 lsublocs3 asm6 by auto
          next
            case notSame:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st)  len subT l'' stl1")
              case True
              then have "CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1" using asm6 
                by (simp add: notSame)
              then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3  
                by (metis CompMemType_asc_withSharedTarget stl1Mc t7)
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l''")
                case True
                then have g6:"CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''"
                  using asm6  notSame f1 by simp
                then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3 
                  using compMemTypes_trns by blast
              next
                case f2:False
                then show ?thesis  using lsublocs lsublocs2 lsublocs3 asm3 asm6 notSame f1 f2 CompMemType_imps_TypedMemSubPrefPtrs
                  by (metis CompMemTypeSameLocsSameType t7)
              qed
            qed
          qed
        qed

(*Can probably replaced with the one above*)
        have isl''TypeSub:"\<forall>l1 stl1 len'' arr''. (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>  accessStore l1 (stack st') = Some (KMemptr stl1) 
                  \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' = prnt\<longrightarrow> (CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 prnt)"
        proof intros
          fix l1 stl1  len'' arr''
          assume asm3:"(Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1)
                           \<and> TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 prnt \<and> l'' = prnt"
          then have stl1Mc:"MCon (MTArray len'' arr'') (memory st) stl1" using asm3 2(1) sameStack unfolding TypeSafe_def typeCompat_def by fastforce
          then have stl1NotPrnt:"stl1 \<noteq> prnt" using asm3 TypedMemSubPrefPtrs_imps_notsame 
            by blast

          have notl''prnt:"\<not>CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using asm3 
            using CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame t7 by blast
          have "\<forall>dloc1.
       (Memory (MTArray len'' arr''), Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l' (stack st) = Some (KMemptr l'') \<longrightarrow>
       (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
        else case (MTArray len'' arr'') of
             MTArray len' arr' \<Rightarrow>
               (case (MTArray len subT) of
               MTArray len2 arr2 \<Rightarrow>
                 if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTArray len' arr') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTArray len2 arr2) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len' arr' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 l'' dloc1
                           then \<exists>dt. CompMemType (memory st) len2 arr2 dt l'' dloc1 \<and> CompMemType (memory st) len' arr' dt stl1 dloc1 else True
               | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len' arr' stl1 l'' then CompMemType (memory st) len' arr' (MTValue val2) stl1 l'' else True)
             | MTValue val \<Rightarrow>
                 (case (MTArray len subT) of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 l'' stl1 then CompMemType (memory st) len2 arr2 (MTValue val) l'' stl1 else True
                 | MTValue val2 \<Rightarrow> True))" 
            using asm3 compOld sameStack lInfo(2,3,4) tParentType lsublocs3 unfolding compMemPtrs_def by blast
          moreover have "(Memory (MTArray len subT), Stackloc l') |\<in>| fmran (denvalue env)" using lInfo(2,3,4) tParentType by blast
          moreover have "accessStore l' (stack st) = Some (KMemptr l'')" using lInfo by auto
          ultimately have asm6:"\<forall>dloc1. (if stl1 = l'' then (MTArray len'' arr'') = (MTArray len subT)
              else if TypedMemSubPrefPtrs (memory st)  len subT l'' stl1 then CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1
                 else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l'' then CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''
                      else if TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st)  len subT l'' dloc1
                           then \<exists>dt. CompMemType (memory st)  len subT dt l'' dloc1 \<and> CompMemType (memory st) len'' arr'' dt stl1 dloc1 else True)" 
            using asm3 using sameStack by auto
          show "CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 prnt"
          proof(cases "stl1 = l''")
            case True
            then have "l'' \<noteq> prnt" using stl1NotPrnt by simp
            then have "CompMemType (memory st) len subT (MTArray len' arr') l'' prnt" using lsublocs3 by simp
            then show ?thesis using lsublocs3 True asm3 lsublocs3 asm6 notl''prnt by auto
          next
            case notSame:False
            then show ?thesis 
            proof(cases "TypedMemSubPrefPtrs (memory st)  len subT l'' stl1")
              case True
              then have "CompMemType (memory st)  len subT (MTArray len'' arr'') l'' stl1" using asm6 
                by (simp add: notSame)
              then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3  
                by (metis CompMemType_imps_CompMemJustType True TypedMemSubPrefOneWay stl1Mc t7)
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedMemSubPrefPtrs (memory st) len'' arr'' stl1 l''")
                case True
                then have g6:"CompMemType (memory st) len'' arr'' (MTArray  len subT) stl1 l''"
                  using asm6  notSame f1 by simp
                then show ?thesis using lsublocs lsublocs2 lsublocs3 asm3 
                  using compMemTypes_trns by blast
              next
                case f2:False
                then show ?thesis  using lsublocs lsublocs2 lsublocs3 asm3 asm6 notSame f1 f2 CompMemType_imps_TypedMemSubPrefPtrs
                  by (metis)
              qed
            qed
          qed
        qed

        have notTopSublocs_inv:"\<forall>dloc1 x11 x12 stl1 i. \<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 
                            \<longrightarrow> TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1"
        proof intros
          fix dloc1 x11 x12 stl1
          assume "\<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1"
          then have asm3:"\<not> LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
            and asm4:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" by simp+
          show "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 " using asm3 asm4
          proof(induction x12 arbitrary:x11 stl1)
            case (MTArray x1 x12)
            obtain i'' ptr where ptrDef:"i''<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                    \<and> (ptr = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptr dloc1)"
              using MTArray.prems(2) unfolding TypedMemSubPrefPtrs.simps by auto
            then have notl:"(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using  MTArray.prems(1) 
              by (metis BT3 LSubPrefL2_def Memoryvalue.inject(2) accessL mInStd option.inject)
            have notSub:"\<not>LSubPrefL2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" 
              using SubPtrs_top asm3 ptrDef selfPoint2 by blast
            have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
              using notl notSub nonLocChanged2 by auto
            then show ?case 
            proof(cases "ptr = dloc1")
              case True
              then show ?thesis using sameAccess ptrDef by force
            next
              case False
              then show ?thesis using MTArray.IH sameAccess ptrDef 
                by (metis asm3 TypedMemSubPrefPtrs.simps(2))
            qed
          next
            case (MTValue x)
            then show ?case by simp
          qed
        qed


        show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def
        proof(intros)
          fix tp1 tp2 l1 l2 stl1 stl2 dloc1
          have limitSt1:"(\<forall>loc y. accessStore loc (memory st) = Some y \<longrightarrow> (\<exists>tloc<toploc (memory st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
          have limitSt:"(\<forall>tloc loc. toploc (memory st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (memory st) = None)"  using 2(1) unfolding TypeSafe_def lessThanTopLocs_def by simp
          have allocateSame:"\<forall>loc. accessStore loc (memory st) = accessStore loc (snd (allocate (memory st)))" using allocateSameAccess by blast

          then have c30: "\<forall>locs. \<not> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<longrightarrow> accessStore locs (memory st) = accessStore locs m"   using nonLocChanged
            by simp
          assume h1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
       (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2)"
          then have tp1MconSt:"MCon tp1 (memory st) stl1" using 2(1) unfolding TypeSafe_def 
            by (metis "2.prems"(1) sameMemTSafe sameStack)
          then have tp2MconSt:"MCon tp2 (memory st) stl2" using 2(1) h1 unfolding TypeSafe_def 
            by (metis "2.prems"(1) sameMemTSafe sameStack)
          have tp1MconM:"MCon tp1 m stl1" using tp1MconSt PreExistMconNotChangeByToploc limitSt limitSt1 nonLocChanged22  
            by auto
          have tp2MconM:"MCon tp2 m stl2" using tp2MconSt PreExistMconNotChangeByToploc limitSt limitSt1 nonLocChanged22  
            by auto
          have stl1Lim:"\<not>LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using typeSafe_noDenElementOverToploc_mem[OF 2(1)] h1 sameStack by auto
          have stl2Lim:"\<not>LSubPrefL2 stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using typeSafe_noDenElementOverToploc_mem[OF 2(1)] h1 sameStack by auto
          have "l \<noteq> (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using lInfo 
            using LSubPrefL2_def l_not_toploc_orSub by blast
          have accessLGen:"\<exists>ptr. accessStore l m' = Some (MPointer ptr) \<and> LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and> MCon (MTArray x memArr) (memory st') ptr " using MCondest2 accessL 
            by (simp add: LSubPrefL2_def )

          have subLocs1:"\<forall>len' arr' locs. TypedMemSubPrefPtrs (memory st') len' arr' locs stl1
                  \<longrightarrow> TypedMemSubPrefPtrs (memory st) len' arr' locs stl1"
          proof intros
            fix len' arr' locs
            assume asm3:"TypedMemSubPrefPtrs (memory st') len' arr' locs stl1"
            then show "TypedMemSubPrefPtrs (memory st) len' arr' locs stl1"
            proof(induction arr' arbitrary: len' locs)
              case (MTArray x1 arr')
              obtain i'' ptr where ptrDef:"i''<len' \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 arr' ptr stl1)"  
                using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using stl1Lim 
                using BT3 accessL accessLGen mInStd by force
              then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
                by (metis MTArray.prems MemLSubPrefL2_specific_imps_general SubPtrs_top nonLocChanged2 selfPoint2 stl1Lim)
              then show ?case 
              proof(cases "ptr = stl1")
                case True
                then show ?thesis using sameAccess 
                  using ptrDef by force
              next
                case False
                then show ?thesis using ptrDef sameAccess 
                  using MTArray.IH by auto
              qed
            next
              case (MTValue x)
              then show ?case by simp
            qed 
          qed     
            (*Can be replaced by a generalisation of the above*)
          have subLocs2:"\<forall>len' arr' locs. TypedMemSubPrefPtrs (memory st') len' arr' locs stl2
                  \<longrightarrow> TypedMemSubPrefPtrs (memory st) len' arr' locs stl2"
          proof intros
            fix len' arr' locs
            assume asm3:"TypedMemSubPrefPtrs (memory st') len' arr' locs stl2"
            then show "TypedMemSubPrefPtrs (memory st) len' arr' locs stl2"
            proof(induction arr' arbitrary: len' locs)
              case (MTArray x1 arr')
              obtain i'' ptr where ptrDef:"i''<len' \<and> accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 arr' ptr stl2)"  
                using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
              then have "(hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) \<noteq> l" using stl2Lim 
                using BT3 accessL accessLGen mInStd by force
              then have sameAccess:"accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = accessStore (hash locs (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st)" 
                by (metis MTArray.prems MemLSubPrefL2_specific_imps_general SubPtrs_top nonLocChanged2 selfPoint2 stl2Lim)
              then show ?case 
              proof(cases "ptr = stl2")
                case True
                then show ?thesis using sameAccess 
                  using ptrDef by force
              next
                case False
                then show ?thesis using ptrDef sameAccess 
                  using MTArray.IH by auto
              qed
            next
              case (MTValue x)
              then show ?case by simp
            qed 
          qed

          have subLocs3:"\<forall>x11 x12 locs stl1. \<not>LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) 
                                                  \<and> MCon (MTArray x11 x12) (memory st) stl1 
                                                  \<and> TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs
                                                  \<and> LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))
                                                  \<and> (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt)
                                                  \<and> (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt)
                                                  \<and> (stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr')
                  \<longrightarrow> (CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" 
          proof intros
            fix x11 x12 locs stl1
            assume asm3:"\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and>
       MCon (MTArray x11 x12) (memory st) stl1 \<and>
       TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs \<and>
       LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) \<and>
       (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt) \<and>
       (TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt) \<and> (stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr')"
            have asm8:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt "
              using asm3 by simp
            have  asm9:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt"
              using asm3 by simp
            have  asm10:"stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr'"
              using asm3 by simp
            then have asm4:"\<not> LSubPrefL2 stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using asm3 by simp

            have asm5:"MCon (MTArray x11 x12) (memory st) stl1" using asm3 by blast
            have asm6:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 locs" using asm3 by blast
            have asm7:"LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using asm3 by blast
            have conc:"(CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" 
              using asm4 asm5 asm6 asm7 asm8 asm9 asm10
            proof(induction x12 arbitrary: x11 stl1)
              case (MTArray x1 arr'')
              obtain i'' ptr where ptrDef:"i''<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                      \<and> (ptr = locs \<or> TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs)"  
                using MTArray.prems(3) unfolding TypedMemSubPrefPtrs.simps by blast
              then obtain ptr' where old:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = Some (MPointer ptr') " using MTArray.prems(2) 
                by (metis MConArrayPointers bot_nat_0.not_eq_extremum less_nat_zero_code)
              then have mc:"MCon (MTArray x1 arr'') (memory st) ptr'" using MTArray.prems(2) 
                by (meson MCon_imps_sub_Mcon ptrDef)
              then have oldLim:"\<not>LSubPrefL2 ptr' (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) " using limitSt limitSt1 old 
                by (metis MCon_imps_Some le_refl lessThanSome_imps_Locs2 lessThanTopLocs_def nat_less_le option.distinct(1))
              then show ?case 
              proof(cases "ptr = locs")
                case True
                then have *:"LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using MTArray.prems(4) by simp
                then show ?thesis 
                proof(cases "ptr = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                  case True
                  then have "ptr \<noteq> ptr'" using oldLim 
                    using LSubPrefL2_def by auto
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l \<or> LSubPrefL2 (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using nonLocChanged2 old ptrDef 
                    by auto
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l" using MTArray.prems(1) LSubPrefL2_def 
                    using MemLSubPrefL2_specific_imps_general by blast
                  then have "stl1 = prnt" using ldef hash_injective ShowLNatDot by blast
                  moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" 
                    using MTArray.prems(7) MTArray.prems(3) calculation by blast
                  ultimately show ?thesis 
                    using CompMemType_imps_TypedMemSubPrefPtrs TypedMemSubPrefPtrs_imps_notsame lsublocs3 t7 by blast
                next
                  case False
                  then have "\<exists>i. ptr = hash (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st))) i" using * unfolding LSubPrefL2_def by simp
                  then show ?thesis 
                    by (metis False LSubPrefL2_def Memoryvalue.inject(2) NonChangeM'm accessL c30 le_refl limitSt mInStd old oldLim option.discI option.inject ptrDef)
                qed
              next
                case False
                then have "TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs" using ptrDef by simp
                then show ?thesis 
                proof(cases "LSubPrefL2 ptr (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                  case True
                  then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) = l" 
                    by (metis MTArray.prems(1) MemLSubPrefL2_specific_imps_general Memoryvalue.inject(2) nonLocChanged2 old oldLim option.inject ptrDef)
                  then have "stl1 = prnt" using ldef hash_injective ShowLNatDot by blast
                  moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" 
                    using  MTArray.prems(7) 
                    using MTArray.prems(3) calculation by auto
                  ultimately show ?thesis 
                    using BothMConImpsNotCompMemType CompTypeRemainsMCon lsublocs3 t7 by blast
                next
                  case f2:False
                  then have "accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')" using False 
                    by (metis MTArray.prems(1) LSubPrefL2_def MemLSubPrefL2_specific_imps_general Memoryvalue.inject(2) accessL mInStd nonLocChanged2 option.inject ptrDef)
                  then have "MCon (MTArray x1 arr'') (memory st) ptr" using ptrDef MTArray.prems(2) 
                    by (metis MCon_imps_sub_Mcon)
                  moreover have "TypedMemSubPrefPtrs (memory st') x1 arr'' ptr locs" using ptrDef False by simp
                  moreover have "LSubPrefL2 locs (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))" using MTArray(5) by simp
                  moreover have "TypedMemSubPrefPtrs (memory st) x1 arr'' ptr prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 arr'' (MTArray len' arr') ptr prnt" 
                    by (metis (full_types) CompMemType_asc_withSharedTarget MTArray.prems(2,5) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close>
                        existingLocation_imps_allLocs existingLocation_imps_allLocs_same lsublocs ptrDef TypedMemSubPrefPtrs.simps(2))
                  moreover have "TypedMemSubPrefPtrs (memory st) x1 arr'' ptr prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 arr'' (MTArray len subT) ptr prnt"
                    by (metis CompMemType_asc_withSharedTarget MTArray.prems(2,6) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> calculation(1)
                        existingLocation_imps_allLocs existingLocation_imps_allLocs_same ptrDef TypedMemSubPrefPtrs.simps(2))
                  moreover have "ptr = prnt \<longrightarrow> MTArray x1 arr'' = MTArray len' arr'" 
                    by (metis MTArray.prems(2,5,6) \<open>accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st) = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st')\<close> compMemTypes_trns
                        existingLocation_imps_allLocs_same lsublocs3 ptrDef TypedMemSubPrefPtrs.simps(2))
                  ultimately have "(CompMemType (memory st') x1 arr'' (MTArray len' arr') ptr prnt \<or> ptr = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt locs"
                    using MTArray.IH[of ptr x1] f2 MTArray.prems(4) by blast
                  then show ?thesis 
                    using ptrDef 
                    using MTArray.prems(5) 
                    using \<open>ptr = prnt \<longrightarrow> MTArray x1 arr'' = MTArray len' arr'\<close> CompMemType.simps(2) 
                    by (metis MConPtrsMustBeSubLocs2 lsublocs lsublocs3 t7)
                qed
              qed
            next
              case (MTValue x)
              then show ?case 
                by (metis MemLSubPrefL2_specific_imps_general TypedMemSubPrefPtrs.simps(1))
            qed
            then show "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt" by simp
            show "TypedMemSubPrefPtrs (memory st') len' arr' prnt locs" using conc by blast
            show "prnt = l'' \<Longrightarrow> MTArray len' arr' = MTArray len subT" using conc by simp
          qed     

          show "if stl1 = stl2 then tp1 = tp2
       else case tp1 of
            MTArray len arr \<Rightarrow>
              (case tp2 of
              MTArray len2 arr2 \<Rightarrow>
                if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
                else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                     else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                          then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
              | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
            | MTValue val \<Rightarrow>
                (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
                | MTValue val2 \<Rightarrow> True)" using sameStack 
          proof(cases "stl1 = stl2")
            case True
            then show ?thesis  
              using compMemPtrs_def compOld h1 sameStack by auto                                                                                     
          next
            case notSame:False
            then show ?thesis 
            proof(cases "tp1")
              case mta1:(MTArray x11 x12)
              have g1:"MCon (MTArray x11 x12) (memory st) stl1" using tp1MconSt mta1 by blast
              have prntT1:"stl1 = prnt \<longrightarrow> MTArray x11 x12 = MTArray len' arr'" using h1 isPrntTypeSame mta1 by auto
              have subTs1: "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11 x12 (MTArray len' arr') stl1 prnt)" using isPrntTypeSub h1  mta1 by auto
              then have gk1:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11 x12 (MTArray len subT) stl1 prnt" 
                using isl''TypeSub h1 mta1  by blast
              then show ?thesis
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                have g2:"MCon (MTArray x11' x12') (memory st) stl2" using tp2MconSt mta2 by blast
                have prntT:"stl2 = prnt \<longrightarrow> MTArray x11' x12' = MTArray len' arr'" using h1 isPrntTypeSame mta2 by auto
                have subTs: "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt)" using isPrntTypeSub h1  mta2 by auto
                then have gk:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11' x12' (MTArray len subT) stl2 prnt" 
                  using isl''TypeSub h1 mta2  by blast
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case o:True
                  then have oldType:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" using subLocs1 o by simp
                  then have old:"CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1"
                    using compOld unfolding compMemPtrs_def using mta1 mta2 notSame h1 sameStack by force

                  have "CompMemType (memory st') x11' x12' (MTArray x11 x12) stl2 stl1" using o g2 old prntT gk subTs
                  proof(induction x12' arbitrary:x11' stl2)
                    case (MTArray x1 x12')
                    obtain inew ptrNew where ptrNewDef: "inew<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl2 = prnt")
                      case True
                      then have "inew \<noteq> i" 
                        using BT3 accessL accessLGen ldef mInStd stl1Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12') (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 
                          using MConPtrsMustBeSubLocs[OF mc ] 
                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12' (MTArray x11 x12) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTArray x11 x12) ptrNew stl1" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12') (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12' (MTArray x11 x12) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12' = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11' (MTArray x1 x12') (MTArray len subT) stl2 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTArray x11 x12) ptrNew stl1" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed

                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed
                  then show ?thesis using mta1 mta2 notSame o by simp

                next
                  case f1:False
                  then show ?thesis 
                  proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                    case o:True
                    then have oldType:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" using subLocs2 o by simp
                    then have old:"CompMemType (memory st)  x11 x12 (MTArray x11' x12') stl1 stl2"
                      using compOld unfolding compMemPtrs_def using mta1 mta2 notSame h1 sameStack by force
                    have "CompMemType (memory st') x11 x12 (MTArray x11' x12') stl1 stl2" using o g1 old prntT1 gk1 subTs1
                    proof(induction x12 arbitrary:x11 stl1)
                      case (MTArray x1 x12)
                      obtain inew ptrNew where ptrNewDef: "inew<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2)" 
                        using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                      then show ?case 
                      proof(cases "stl1 = prnt")
                        case True
                        then have "inew \<noteq> i"
                          using BT3 accessL accessLGen ldef mInStd stl2Lim  ptrNewDef by force
                        then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                          by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                        then have mc:"MCon (MTArray x1 x12) (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                          by (metis MCon_imps_sub_Mcon)
                        then show ?thesis 
                        proof(cases "ptrNew = stl2")
                          case True
                          then show ?thesis using MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2)
                            by (metis )
                        next
                          case False
                          have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 

                            using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                          have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using False ptrNewDef by simp
                          moreover have "CompMemType (memory st) x1 x12 (MTArray x11' x12') ptrNew stl2" 
                            by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                            by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt" 
                            by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                          ultimately have "CompMemType (memory st') x1 x12 (MTArray x11' x12') ptrNew stl2" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                          then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                        qed
                      next
                        case notPrnt:False
                        then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                        then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                          by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                        then show ?thesis 
                        proof(cases "ptrNew = stl2")
                          case True
                          then show ?thesis 
                            by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                        next
                          case False
                          then have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using ptrNewDef by simp
                          moreover have "MCon (MTArray x1 x12) (memory st) ptrNew" 
                            by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                          moreover have "CompMemType (memory st) x1 x12 (MTArray x11' x12') ptrNew stl2" 
                            by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                          moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12 = MTArray len' arr'" 
                            by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                          proof
                            assume *:"TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt"
                            then have "TypedMemSubPrefPtrs (memory st) x11 (MTArray x1 x12) stl1 prnt" using notPrnt 
                              using ptrNewDef sameAccess by auto
                            then have "CompMemType (memory st) x11 (MTArray x1 x12) (MTArray len subT) stl1 prnt" using MTArray.prems(5) * by blast
                            then show "CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                              by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                          qed
                          moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt"
                            using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                            by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                          ultimately have "CompMemType (memory st') x1 x12 (MTArray x11' x12') ptrNew stl2" using MTArray.IH[of x1 ptrNew] by blast
                          then show ?thesis 
                            using ptrNewDef by auto
                        qed
                      qed

                    next
                      case (MTValue x)
                      then show ?case by simp
                    qed
                    then show ?thesis using mta1 mta2 notSame o f1 by simp
                  next
                    case f2:False
                    then show ?thesis 
                    proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1")
                      case tc:True
                      then have p1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" by simp
                      then show ?thesis  using subLocs3
                      proof(cases "LSubPrefL2 dloc1 (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (memory st)))")
                        case dlocLessTop:True
                        then have j6:"(CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt \<or> stl2 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1 \<and> (prnt = l'' \<longrightarrow> MTArray len' arr' = MTArray len subT)" using subLocs3 
                          using g2 stl2Lim tc gk subTs 
                          using prntT by blast                                                                                                                                      
                        have j7:"(CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt \<or> stl1 = prnt) \<and> TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1" using subLocs3  
                          using dlocLessTop g1 stl1Lim tc gk1 subTs1 
                          using j6 by blast
                        show ?thesis 
                        proof(cases "stl2 = prnt")
                          case t8:True
                          then have stl1ToPrnt:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 prnt" using notSame j7 
                            using CompMemType_imps_TypedMemSubPrefPtrs by blast
                          have "MTArray x11' x12' = MTArray len' arr'" using t8 by (simp add: prntT)
                          then show ?thesis using f2 t8 by (simp add: stl1ToPrnt)
                        next
                          case f8:False
                          then show ?thesis 
                          proof(cases "stl1 = prnt")
                            case True
                            then have stl2ToPrnt:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 prnt" using notSame j6 using CompMemType_imps_TypedMemSubPrefPtrs by blast
                            then show ?thesis using f1 True by auto
                          next
                            case f9:False
                            then show ?thesis 
                            proof(cases "prnt = l''")
                              case True
                              have "CompMemType (memory st') x11' x12' (MTArray len subT) stl2 l''" using j6 f8 True by blast
                              moreover have "CompMemType (memory st') x11 x12 (MTArray len subT) stl1 l''" using j7 f9 j6 True by simp
                              have "TypedMemSubPrefPtrs (memory st') len subT l'' dloc1" using j7 j6 True by simp
                              then have "\<exists>dt. CompMemType (memory st') len subT dt l'' dloc1" 
                              proof(induction subT arbitrary:len l'')
                                case (MTArray x1 subT)
                                obtain i'' ptr where ptrDef: "i''<len \<and>  accessStore (hash l'' (ShowL\<^sub>n\<^sub>a\<^sub>t i'')) (memory st') = Some (MPointer ptr) 
                                                                \<and> (ptr = dloc1 \<or> TypedMemSubPrefPtrs (memory st') x1 subT ptr dloc1)" 
                                  using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                                then show ?case 
                                proof(cases "ptr = dloc1")
                                  case True
                                  then show ?thesis unfolding CompMemType.simps using ptrDef by blast
                                next
                                  case False
                                  then have "TypedMemSubPrefPtrs (memory st') x1 subT ptr dloc1" using ptrDef by simp
                                  then show ?thesis using MTArray.IH[of x1 ptr] 
                                    using ptrDef CompMemType.simps(2) by blast
                                qed
                              next
                                case (MTValue x)
                                then show ?case by simp
                              qed

                              then have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                                using \<open>CompMemType (memory st') x11 x12 (MTArray len subT) stl1 l''\<close> \<open>CompMemType (memory st') x11' x12' (MTArray len subT) stl2 l''\<close> compMemTypes_trns by blast
                              then show ?thesis  using mta1 mta2 f1 f2 notSame by auto
                            next
                              case False
                              have "CompMemType (memory st') x11' x12' (MTArray len' arr') stl2 prnt" using j6 f8 by simp
                              moreover have "CompMemType (memory st') x11 x12 (MTArray len' arr') stl1 prnt" using j7 f9 by simp
                              moreover have "TypedMemSubPrefPtrs (memory st') len' arr' prnt dloc1" using j7 by simp
                              ultimately have "\<exists>dt. CompMemType (memory st') x11 x12 dt stl1 dloc1 \<and> CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                                by (metis False compMemTypes_trns compmemst' l''MConst' l''mMcon lsublocs3 sharedParentSharedSubLocTypes t7)
                              then show ?thesis  using mta1 mta2 f1 f2 notSame by auto
                            qed
                          qed
                        qed
                      next
                        case False
                        then have o2:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" 
                          using notTopSublocs_inv tc by simp
                        then have "dloc1 \<noteq> stl2" using tc f2 ldef by auto
                        have "dloc1 \<noteq> stl1" using o2 
                          using f1 tc by auto
                        have k1:"TypedMemSubPrefPtrs (memory st') x11 x12 stl1 dloc1" using tc by simp
                        have k2:"TypedMemSubPrefPtrs (memory st') x11' x12' stl2 dloc1" using tc by simp
                        have k3:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 dloc1" using o2 by simp
                        have k4:"TypedMemSubPrefPtrs (memory st) x11 x12 stl1 dloc1" using o2 by simp

                        then show ?thesis 
                        proof(cases "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2")
                          case True
                          then have "CompMemType (memory st) x11 x12 (MTArray x11' x12') stl1 stl2" 
                            using compOld notSame mta1 mta2 h1 sameStack unfolding compMemPtrs_def by force
                          then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                            using o2 by (meson compMemTypes_trns g1 notSame sharedParentSharedSubLocTypes)
                          then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                          then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                          then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                            using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                          moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                            using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                          ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                            by auto
                          then show ?thesis using mta1 mta2 h1 notSame f1 f2 True tc by simp
                        next
                          case f11:False
                          then show ?thesis 
                          proof(cases "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1")
                            case True
                            then have "CompMemType (memory st) x11' x12' (MTArray x11 x12) stl2 stl1" 
                              using f11 compOld notSame mta1 mta2 h1 sameStack unfolding compMemPtrs_def by force
                            then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" 
                              using o2 by (metis compMemTypes_trns g2 notSame sharedParentSharedSubLocTypes)
                            then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                            then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                            then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                              using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              by auto
                            then show ?thesis using mta1 mta2 h1 notSame f1 f2 True tc by simp
                          next
                            case f12:False
                            then have "\<exists>dt. CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1"
                              using f11 compOld notSame mta1 mta2 h1 sameStack o2 unfolding compMemPtrs_def 
                              by force
                            then obtain dt where l1:"CompMemType (memory st) x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st) x11 x12 dt stl1 dloc1" by blast
                            then have l2:"CompMemType (memory st) x11' x12' dt stl2 dloc1" by simp
                            then have "CompMemType (memory st') x11' x12' dt stl2 dloc1" 
                              using CompMemForTopLocs[OF l2 False k2 g2 stl2Lim k3 ] accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            moreover have "CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              using CompMemForTopLocs l1 False k1 g1 stl1Lim k4 accessLGen mInStd nonLocChanged2 BT3 accessL notTopSublocs_inv SubPtrs_top selfPoint2 by blast
                            ultimately have "\<exists>dt. CompMemType (memory st') x11' x12' dt stl2 dloc1 \<and> CompMemType (memory st') x11 x12 dt stl1 dloc1" 
                              by auto
                            then show ?thesis using mta1 mta2 h1 notSame f1 f2 tc by simp
                          qed
                        qed
                      qed
                    next
                      case False
                      then show ?thesis using mta1 mta2 f1 f2 notSame by auto
                    qed
                  qed
                qed
              next
                case mtv1:(MTValue x2)
                have g2:"MCon (MTValue x2) (memory st) stl2" using tp2MconSt mtv1 by blast

                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11 x12 stl1 stl2")
                  case o:True
                  then have "TypedMemSubPrefPtrs (memory st) x11 x12 stl1 stl2" 
                    by (simp add: subLocs2)
                  then have old:"CompMemType (memory st) x11 x12 (MTValue x2) stl1 stl2"
                    using compOld unfolding compMemPtrs_def using mta1 mtv1 notSame h1 sameStack by force           
                  have "CompMemType (memory st') x11 x12 (MTValue x2) stl1 stl2" using o g1 old prntT1 gk1 subTs1
                  proof(induction x12 arbitrary:x11 stl1)
                    case (MTArray x1 x12)
                    obtain inew ptrNew where ptrNewDef: "inew<x11 \<and> accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl2 \<or> TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl1 = prnt")
                      case True
                      then have "inew \<noteq> i"
                        using BT3 accessL accessLGen ldef mInStd stl2Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12) (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl2")
                        case True
                        then show ?thesis using MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2)
                          by (metis )
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 

                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12 (MTValue x2) ptrNew stl2" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12 (MTValue x2) ptrNew stl2" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl1 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl2")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12 ptrNew stl2" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12) (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12 (MTValue x2) ptrNew stl2" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs2)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12 = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11 (MTArray x1 x12) stl1 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11 (MTArray x1 x12) (MTArray len subT) stl1 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12 (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12 ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12 (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12 (MTValue x2) ptrNew stl2" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed
                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed
                  then show ?thesis  using mtv1 mta1 notSame by simp
                next
                  case False
                  then show ?thesis using mtv1 mta1 notSame by simp
                qed
              qed
            next
              case mtv1:(MTValue x2)
              then show ?thesis 
              proof(cases "tp2")
                case mta2:(MTArray x11' x12')
                have g2:"MCon (MTArray x11' x12') (memory st) stl2" using tp2MconSt mta2 by blast
                have prntT:"stl2 = prnt \<longrightarrow> MTArray x11' x12' = MTArray len' arr'" using h1 isPrntTypeSame mta2 by auto
                have subTs: "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' \<noteq> prnt \<longrightarrow>
                    ( CompMemType (memory st) x11' x12' (MTArray len' arr') stl2 prnt)" using isPrntTypeSub h1  mta2 by auto
                then have gk:"TypedMemSubPrefPtrs (memory st) x11' x12' stl2 prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x11' x12' (MTArray len subT) stl2 prnt" 
                  using isl''TypeSub h1 mta2  by blast
                then show ?thesis 
                proof(cases "TypedMemSubPrefPtrs (memory st') x11' x12' stl2 stl1")
                  case o:True
                  then have "TypedMemSubPrefPtrs (memory st) x11' x12' stl2 stl1" 
                    by (simp add: subLocs1)
                  then have old:"CompMemType (memory st) x11' x12' (MTValue x2) stl2 stl1"
                    using compOld unfolding compMemPtrs_def using mtv1 mta2 notSame h1 sameStack by force    
                  have "CompMemType (memory st') x11' x12' (MTValue x2) stl2 stl1" using o g2 old prntT gk subTs
                  proof(induction x12' arbitrary:x11' stl2)
                    case (MTArray x1 x12')
                    obtain inew ptrNew where ptrNewDef: "inew<x11' \<and> accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = Some (MPointer ptrNew) 
                            \<and> (ptrNew = stl1 \<or> TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1)" 
                      using MTArray.prems(1) unfolding TypedMemSubPrefPtrs.simps by blast
                    then show ?case 
                    proof(cases "stl2 = prnt")
                      case True
                      then have "inew \<noteq> i"
                        using BT3 accessL accessLGen ldef mInStd stl1Lim  ptrNewDef by force
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MemLSubPrefL2_specific_imps_general True bb hashesIntSame ldef lsublocs3 nonLocChanged2 t8)
                      then have mc:"MCon (MTArray x1 x12') (memory st) ptrNew" using MTArray.prems(2) ptrNewDef  
                        by (metis MCon_imps_sub_Mcon)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        have notPrnt:"ptrNew \<noteq> prnt" using ptrNewDef 
                          using MConPtrsMustBeSubLocs[OF mc ] 
                          using MConSubTypes MTArray.prems(2) True mc CompMemJustType.simps(2) by blast   
                        have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using False ptrNewDef by simp
                        moreover have "CompMemType (memory st) x1 x12' (MTValue x2) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,5) True ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2) t7)
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt" 
                          by (metis MConPtrsMustBeSubLocs2 MTArray.prems(2,6) True lsublocs ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTValue x2) ptrNew stl1" using MTArray.IH[of x1 ptrNew] notPrnt mc by blast
                        then show ?thesis using ptrNewDef CompMemType.simps(2) by blast
                      qed
                    next
                      case notPrnt:False
                      then have "(hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) \<noteq> l" using ldef hashesIntSame hash_injective ShowLNatDot by blast
                      then have sameAccess:"accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st') = accessStore (hash stl2 (ShowL\<^sub>n\<^sub>a\<^sub>t inew)) (memory st)" 
                        by (metis MConArrayPointers MTArray.prems(2) bot_nat_0.not_eq_extremum less_nat_zero_code less_or_eq_imp_le limitSt nonLocChanged2 not_None_eq ptrNewDef)
                      then show ?thesis 
                      proof(cases "ptrNew = stl1")
                        case True
                        then show ?thesis 
                          by (metis MTArray.prems(2,3) existingLocation_imps_allLocs_same ptrNewDef sameAccess CompMemType.simps(2))
                      next
                        case False
                        then have "TypedMemSubPrefPtrs (memory st') x1 x12' ptrNew stl1" using ptrNewDef by simp
                        moreover have "MCon (MTArray x1 x12') (memory st) ptrNew" 
                          by (metis MCon_imps_sub_Mcon MTArray.prems(2) ptrNewDef sameAccess)
                        moreover have "CompMemType (memory st) x1 x12' (MTValue x2) ptrNew stl1" 
                          by (metis False MTArray.prems(2,3) existingLocation_imps_allLocs ptrNewDef sameAccess subLocs1)
                        moreover have "ptrNew = prnt \<longrightarrow> MTArray x1 x12' = MTArray len' arr'" 
                          by (metis MTArray.prems(2,5,6) compMemTypes_trns existingLocation_imps_allLocs_same lsublocs3 ptrNewDef sameAccess TypedMemSubPrefPtrs.simps(2))
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" 
                        proof
                          assume *:"TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' = prnt"
                          then have "TypedMemSubPrefPtrs (memory st) x11' (MTArray x1 x12') stl2 prnt" using notPrnt 
                            using ptrNewDef sameAccess by auto
                          then have "CompMemType (memory st) x11' (MTArray x1 x12') (MTArray len subT) stl2 prnt" using MTArray.prems(5) * by blast
                          then show "CompMemType (memory st) x1 x12' (MTArray len subT) ptrNew prnt" using notPrnt ptrNewDef sameAccess 
                            by (metis "*" MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs)
                        qed
                        moreover have "TypedMemSubPrefPtrs (memory st) x1 x12' ptrNew prnt \<and> l'' \<noteq> prnt \<longrightarrow> CompMemType (memory st) x1 x12' (MTArray len' arr') ptrNew prnt"
                          using ptrNewDef sameAccess MTArray.prems(2) TypedMemSubPrefPtrs_imps_notsame calculation(2) existingLocation_imps_allLocs notPrnt sameAccess 
                          by (metis MTArray.prems(6) TypedMemSubPrefPtrs.simps(2))
                        ultimately have "CompMemType (memory st') x1 x12' (MTValue x2) ptrNew stl1" using MTArray.IH[of x1 ptrNew] by blast
                        then show ?thesis 
                          using ptrNewDef by auto
                      qed
                    qed
                  next
                    case (MTValue x)
                    then show ?case by simp
                  qed
                  then show ?thesis using mtv1 mta2 notSame by simp
                next
                  case False
                  then show ?thesis using mtv1 mta2 notSame by simp
                qed      
              next
                case (MTValue x2)
                then show ?thesis using mtv1 notSame by simp
              qed
            qed
          qed

        qed
      next 
        have "accounts st'= accounts st" using 15 by auto
        then show "fullyInitialised env  (accounts st') (stack st')" using 2(3) unfolding fullyInitialised_def 
          using sameStack by presburger
      next 
        have tloc:"toploc (memory st) < toploc  (snd (allocate (memory st)))" unfolding allocate_def by simp
        have topLocEq:"toploc (snd (allocate (memory st))) = toploc m" 
          using cps2mTopLocSame 15(4) mInStd unfolding cps2m_def by blast
        then have topmm':"toploc m = toploc m'" using 15(5) unfolding updateStore_def by auto

      qed
    qed
  next
    case (16 p t g' g l t'' t')
    then have stackChanged:"\<forall>l'. l' \<noteq> l \<longrightarrow> accessStore l' (stack st) = accessStore l' (stack st')" unfolding updateStore_def accessStore_def by simp
    have t'InDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using lexpStackloc_imps_inDen[OF 16(2)] by blast
    then have lDen:"\<forall>t'. (t', Stackloc l) |\<in>| fmran (denvalue env) \<longrightarrow> t'= (Storage (STMap t g'))" using 16 2(1) unfolding TypeSafe_def unique_locations_def by auto

    have pOrigin:"SCon (STMap t g') (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) \<and>
        (\<exists>xx. KStoptr p = KStoptr xx) \<and>
        (\<exists>stloc tp'' .
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue env) \<and>
            (tp'' = (STMap t g') \<and> KStoptr p = KStoptr stloc \<or> extractValueType (KStoptr p) \<noteq> stloc \<and> CompStoType tp'' (STMap t g') stloc (extractValueType (KStoptr p))))" 
      using 2(1) 16(1) 2(3) using
        exprTypeconInduct(3)[of ex env cd "(st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>)" "(gas st - costs (ASSIGN lv ex) env cd st)" "KStoptr p" "Storage (STMap t g')" g] 
      by (auto split:Type.splits if_splits )
    obtain pParent pParentT  where 
      pOrigin:"SCon (STMap t g') (extractValueType (KStoptr p)) (storage (st\<lparr>gas := gas st - costs (ASSIGN lv ex) env cd st\<rparr>) (address env)) 
          \<and>(Storage pParentT, Storeloc pParent) |\<in>| fmran (denvalue env) \<and>
            (pParentT = (STMap t g') \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STMap t g') pParent (extractValueType (KStoptr p)))"
      using pOrigin by auto
    have a0: "compPointers (stack st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
    then have pParentRelations:"(\<forall>tp2 l2  l2'  stl2.
        (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and>
        
        (l2 = Stackloc l2' \<and> accessStore l2' (stack (st)) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
        (if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True))" 
      using compPointers_def pOrigin  by blast
    have pSCon:"SCon (STMap t g') (extractValueType (KStoptr p)) (storage (st) (address env))" using pOrigin by force

(*All locations that can get to p must have a parent type of MTArray x t and all locations lower than p similarly*)
    have pRelations:"(\<forall>tp2 l2 l2' stl2 . 
    (Storage tp2, l2) |\<in>| fmran (denvalue env) \<and> 
    ((l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some(KStoptr stl2)) \<or> (l2 = Storeloc stl2)) 
     \<longrightarrow>
    (if TypedStoSubpref p stl2 tp2 then CompStoType tp2 (STMap t g') stl2 p 
     else if TypedStoSubpref stl2 p (STMap t g') then CompStoType (STMap t g') tp2 p stl2
     else True))" 
    proof intros 
      fix tp2 l2 l2' stl2
      assume in1:"(Storage tp2, l2) |\<in>| fmran (denvalue env) \<and> (l2 = Stackloc l2' \<and> accessStore l2' (stack st) = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"

      show "if TypedStoSubpref p stl2 tp2 then CompStoType tp2 (STMap t g') stl2 p else if TypedStoSubpref stl2 p (STMap t g') then CompStoType (STMap t g') tp2 p stl2 else True"
      proof(cases "l2 = Stackloc l2'")
        case StL2:True
        then have mcStl2:"SCon tp2 stl2 (storage st (address env))" using 2(1) unfolding TypeSafe_def typeCompat_def using in1 by fastforce

        have "SCon pParentT pParent (storage st (address env))" using pOrigin using 2(1) unfolding TypeSafe_def typeCompat_def by force
        have prnt:" pParentT = (STMap t g') \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STMap t g') pParent (extractValueType (KStoptr p))"
          using pOrigin by simp
        then have comp:"(if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 
                      else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True)"
          using pParentRelations in1 StL2 prnt by force 
        then show ?thesis 
        proof(cases "TypedStoSubpref p stl2 tp2")
          case pToStl2:True        
          then show ?thesis 
          proof(cases "pParentT = (STMap t g')")
            case True
            then have cc1:"KStoptr p = KStoptr pParent " using prnt 
              using comp_stotype_same_type_same_loc by blast
            then have cc2:"TypedStoSubpref pParent stl2 tp2" using pToStl2 by auto
            then have "CompStoType tp2 (STMap t g') stl2 p"
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case t2:True
              then show ?thesis using comp 
                by (metis CompStoType_sameLoc_sameType Stackvalue.inject(4) True cc1 cc2 typedStoSub_imps_negInv)
            next
              case False
              then have "CompStoType tp2 pParentT stl2 pParent" using comp 
                by (simp add: cc2)
              then show ?thesis 
                using True cc1 by auto
            qed
            then show ?thesis by (simp add: pToStl2)
          next
            case False
            then have cmp:" CompStoType pParentT (STMap t g') pParent p" using prnt by simp
            then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
            then show ?thesis 
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case True
              then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
              have "CompStoType tp2 (STMap t g') stl2 p " using pToStl2 prntStl2  CompStoType_sharedSub cmp by simp
              then show ?thesis using pToStl2 by simp
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref pParent stl2 tp2")
                case True
                then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                then have "CompStoType tp2 (STMap t g') stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                then show ?thesis using pToStl2 by simp
              next
                case False
                then have "\<not>TypedStoSubpref p stl2 tp2" using f1 cmp tsp NotRelatedPrnt_imps_notRelatedChild[of stl2 pParent pParentT tp2 p]  by simp
                then show ?thesis using f1 pToStl2 cmp by simp
              qed
            qed
          qed
        next
          case f1:False
          then show ?thesis 
          proof(cases " TypedStoSubpref stl2 p (STMap t g')")
            case stl2ToP:True
            have " CompStoType (STMap t g') tp2 p stl2"
            proof(cases "pParentT = (STMap t g')")
              case True
              then have cc1:"KStoptr p = KStoptr pParent " using prnt 
                using comp_stotype_same_type_same_loc by blast
              then have cc2:"TypedStoSubpref stl2 pParent (STMap t g')" using stl2ToP by auto
              then have " CompStoType (STMap t g') tp2 p stl2"
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case t2:True
                then have "CompStoType pParentT tp2 pParent stl2" using comp by simp
                then have "CompStoType (STMap t g') tp2 p stl2" using cc1 True  by blast
                then show ?thesis by blast
              next
                case False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp False by simp
                  then show ?thesis using True cc1 f1 by auto
                next
                  case f2:False
                  then show ?thesis using False True cc2 by blast
                qed
              qed
              then show ?thesis by blast
            next
              case False
              then have cmp:" CompStoType pParentT (STMap t g') pParent p" using prnt by simp
              then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
              then show ?thesis 
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case True
                then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
                then show ?thesis using CompStoType_sharedSub[OF prntStl2 stl2ToP cmp] by simp
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                  then have "CompStoType tp2 (STMap t g') stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                  then show ?thesis 
                    using CompStoType_sameLocNdTyp CompStoType_sharedSub stl2ToP by blast
                next
                  case False
                  then show ?thesis 
                    using NotReachablePrnt_imps_notReachableChild cmp f1 stl2ToP by blast
                qed
              qed
            qed
            then show ?thesis using f1 by (simp )
          next
            case False
            then show ?thesis 
              using f1 by auto
          qed
        qed
      next
        case f3:False
        then have StL2:"l2 = Storeloc stl2" 
          using in1 by auto

        then have "SCon pParentT pParent (storage st (address env))" using pOrigin using 2(1) unfolding TypeSafe_def typeCompat_def by force
        have prnt:" pParentT = (STMap t g') \<and> KStoptr p = KStoptr pParent \<or> extractValueType (KStoptr p) \<noteq> pParent \<and> CompStoType pParentT (STMap t g') pParent (extractValueType (KStoptr p))"
          using  pOrigin by simp
        then have comp:"(if TypedStoSubpref stl2 pParent pParentT then CompStoType pParentT tp2 pParent stl2 
                      else if TypedStoSubpref pParent stl2 tp2 then CompStoType tp2 pParentT stl2 pParent else True)"
          using pParentRelations in1  StL2 prnt by force 
        then show ?thesis 
        proof(cases "TypedStoSubpref p stl2 tp2")
          case pToStl2:True        
          then show ?thesis 
          proof(cases "pParentT = (STMap t g')")
            case True
            then have cc1:"KStoptr p = KStoptr pParent " using prnt 
              using comp_stotype_same_type_same_loc by blast
            then have cc2:"TypedStoSubpref pParent stl2 tp2" using pToStl2 by auto
            then have "CompStoType tp2 (STMap t g') stl2 p"
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case t2:True
              then show ?thesis using comp 
                by (metis CompStoType_sameLoc_sameType Stackvalue.inject(4) True cc1 cc2 typedStoSub_imps_negInv)
            next
              case False
              then have "CompStoType tp2 pParentT stl2 pParent" using comp 
                by (simp add: cc2)
              then show ?thesis 
                using True cc1 by auto
            qed
            then show ?thesis by (simp add: pToStl2)
          next
            case False
            then have cmp:" CompStoType pParentT (STMap t g') pParent p" using prnt by simp
            then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
            then show ?thesis 
            proof(cases "TypedStoSubpref stl2 pParent pParentT")
              case True
              then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
              have "CompStoType tp2 (STMap t g') stl2 p " using pToStl2 prntStl2  CompStoType_sharedSub cmp by simp
              then show ?thesis using pToStl2 by simp
            next
              case f1:False
              then show ?thesis 
              proof(cases "TypedStoSubpref pParent stl2 tp2")
                case True
                then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                then have "CompStoType tp2 (STMap t g') stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                then show ?thesis using pToStl2 by simp
              next
                case False
                then have "\<not>TypedStoSubpref p stl2 tp2" using f1 cmp tsp NotRelatedPrnt_imps_notRelatedChild[of stl2 pParent pParentT tp2 p]  by simp
                then show ?thesis using f1 pToStl2 cmp by simp
              qed
            qed
          qed
        next
          case f1:False
          then show ?thesis 
          proof(cases " TypedStoSubpref stl2 p (STMap t g')")
            case stl2ToP:True
            have " CompStoType (STMap t g') tp2 p stl2"
            proof(cases "pParentT = (STMap t g')")
              case True
              then have cc1:"KStoptr p = KStoptr pParent " using prnt 
                using comp_stotype_same_type_same_loc by blast
              then have cc2:"TypedStoSubpref stl2 pParent (STMap t g')" using stl2ToP by auto
              then have " CompStoType (STMap t g') tp2 p stl2"
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case t2:True
                then have "CompStoType pParentT tp2 pParent stl2" using comp by simp
                then have "CompStoType (STMap t g') tp2 p stl2" using cc1 True  by blast
                then show ?thesis by blast
              next
                case False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp False by simp
                  then show ?thesis using True cc1 f1 by auto
                next
                  case f2:False
                  then show ?thesis using False True cc2 by blast
                qed
              qed
              then show ?thesis by blast
            next
              case False
              then have cmp:" CompStoType pParentT (STMap t g') pParent p" using prnt by simp
              then have tsp:"TypedStoSubpref p pParent pParentT" using CompStoType_imps_TypedStoSubpref by simp
              then show ?thesis 
              proof(cases "TypedStoSubpref stl2 pParent pParentT")
                case True
                then have prntStl2:" CompStoType pParentT tp2 pParent stl2" using comp by simp
                then show ?thesis using CompStoType_sharedSub[OF prntStl2 stl2ToP cmp] by simp
              next
                case f1:False
                then show ?thesis 
                proof(cases "TypedStoSubpref pParent stl2 tp2")
                  case True
                  then have "CompStoType tp2 pParentT stl2 pParent" using comp f1 by simp
                  then have "CompStoType tp2 (STMap t g') stl2 p" using cmp CompStoType_trns[of tp2 ] by blast
                  then show ?thesis 
                    using CompStoType_sameLocNdTyp CompStoType_sharedSub stl2ToP by blast
                next
                  case False
                  then show ?thesis 
                    using NotReachablePrnt_imps_notReachableChild cmp f1 stl2ToP by blast
                qed
              qed
            qed
            then show ?thesis using f1 by simp
          next
            case False
            then show ?thesis using f1 by auto
          qed
        qed
      qed
    qed
    have storageSame:"(storage st' (address env)) = (storage st (address env))" using 16 by simp
    have memorySame:"memory st = memory st'" using 16 by simp
    show ?thesis unfolding TypeSafe_def StateInvariant_def
    proof (intros)
      show tcN:"typeCompat (denvalue env) (stack st') (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof (split Denvalue.split, intros)
          fix loc assume a20:"l' = Stackloc loc"
          show "case accessStore loc (stack st') of None \<Rightarrow> False 
          | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
          | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
          | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
          | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
          proof (cases "loc = l") 

            case False
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then have "accessStore loc (stack st) = None" using 16(4) False by (simp add:stackSingleUpdate)
              then show False using a30 a20 a10 assms TypeSafe_def typeCompat_def False "2.prems"(1) 
                by (metis option.distinct(1) typeSafeLocExists)
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have a40:"accessStore loc (stack st) = Some x2" using 16(4) False by (simp add:stackSingleUpdate)
              then have a50:"(memory st) = (memory st')" using 16(4) by simp
              then have a60:"(storage st) = (storage st')" using 16(4) by simp
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False )
                  | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                  | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                  | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)" 
                using a10 a20 a30 a40 a50 a60  "2.prems"(1) unfolding TypeSafe_def typeCompat_def by (cases x2; cases t; force)
            qed
          next 
            case sameLoc:True
            show ?thesis
            proof (split option.split, intros)
              assume a30:"accessStore loc (stack st') = None"
              then show False using a20 a10 assms(1) sameLoc 16(4) notNoneUpdate by simp
            next
              fix x2 assume a30:"accessStore loc (stack st') = Some x2"
              then have x2IsP:"x2 = KStoptr p" using 16 sameLoc by auto
              show "case x2 of KValue val \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | KCDptr stloc \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | KMemptr stloc \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | KStoptr stloc \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False)"
              proof(cases "x2")
                case (KValue x1)
                then show ?thesis using x2IsP by auto
              next
                case (KCDptr x2)
                then show ?thesis using x2IsP by (simp add:sameLoc)
              next
                case (KMemptr x3)
                then show ?thesis  using x2IsP by (simp add:sameLoc)
              next
                case (KStoptr x4)
                then show ?thesis using x2IsP a10 a20 lDen storageSame sameLoc 
                  using pSCon by force
              qed
            qed
          qed
        next
          fix x2 assume a20:"l' = Storeloc x2"
          then have "(storage st' (address env)) = (storage st (address env))" using 16(4) by simp
          then show "case t of Storage typ \<Rightarrow> SCon typ x2 (storage st' (address env)) | _ \<Rightarrow> False"  using a10 a20 TypeSafe_def "2.prems"(1) pSCon a10 a20 lDen storageSame 
          proof -
            have "\<And>t d. (t, d) |\<notin>| fmran (denvalue env) \<or> 
                    (case d of Stackloc l \<Rightarrow> (case accessStore l (stack st) of None \<Rightarrow> False 
                    | Some (KValue l) \<Rightarrow> (case t of Value t \<Rightarrow> typeCon t l | _ \<Rightarrow> False )
                    | Some (KCDptr l) \<Rightarrow> (case t of Calldata m \<Rightarrow> MCon m cd l | _ \<Rightarrow> False )
                    | Some (KMemptr l) \<Rightarrow> (case t of Memory m \<Rightarrow> MCon m (memory st) l | _ \<Rightarrow> False )
                    | Some (KStoptr l) \<Rightarrow> (case t of Storage s \<Rightarrow> SCon s l (storage st (address env)) | _ \<Rightarrow> False))
                    | Storeloc l \<Rightarrow> (case t of Storage s \<Rightarrow> SCon s l (storage st (address env)) | _ \<Rightarrow> False))"
              using "2.prems"(1) unfolding TypeSafe_def typeCompat_def by auto
            then show ?thesis
              by (metis (no_types) Denvalue.simps(6) a10 a20 storageSame)
          qed 
        qed
      qed
      have "typeCompat (denvalue env) (stack st) (memory st') (storage st' (address env)) cd"
        unfolding typeCompat_def
      proof intros
        fix t l' assume a10:"(t, l') |\<in>| fmran (denvalue env)"
        show "case l' of
             Stackloc loc \<Rightarrow>
               (case accessStore loc (stack st) of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address env)) | _ \<Rightarrow> False))
             | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address env)) | _ \<Rightarrow> False)" 
        proof(cases "l'")
          case (Stackloc x1)
          then show ?thesis 
          proof(cases "x1 = l")
            case sameLoc:True
            then show ?thesis 
            proof(cases "accessStore x1 (stack st)")
              case None
              then show ?thesis using Stackloc a10 assms(1) sameLoc 16(4) 
                by (metis "2.prems"(1) option.distinct(1) typeSafeAllStacklocsExist)
            next
              case (Some a)
              then obtain t''' where "t = Storage t'''" using lDen a10 Stackloc 2(1) sameLoc by blast
              then have x2IsP:"\<exists>p. a = KStoptr p" using 16 sameLoc  2(1) a10 Stackloc Some  unfolding TypeSafe_def typeCompat_def
                by (cases a, force,simp,fastforce+)
              then show ?thesis using x2IsP a10 Stackloc lDen storageSame sameLoc Some "2.prems"(1) unfolding TypeSafe_def typeCompat_def
                using pSCon by force
            qed
          next
            case False
            then have "accessStore x1 (stack st) = accessStore x1 (stack st')"
              using stackChanged by auto
            then show ?thesis using a10 Stackloc tcN unfolding typeCompat_def by force
          qed
        next
          case (Storeloc x2)
          then show ?thesis using a10 tcN unfolding typeCompat_def by force
        qed
      qed
    next
      show "unique_locations (denvalue env)" using 2(1) typeSafeUnique by auto
    next
      have "(accounts st) = accounts(st')" using 16 by simp
      then show "balanceTypes (accounts st')" using balanceTypes_def balanceTypes_def 2(1) typeSafeAccounts by simp
    next
      have a0:"compPointers (stack st) (denvalue env)" using 2(1) storageSame unfolding TypeSafe_def by simp
      show " compPointers (stack st') (denvalue env)" unfolding compPointers_def
      proof(intros)
        fix tp1 tp2 l1 l22 l1' l2' stl1 stl2
        assume a1:"(Storage tp1, l1) |\<in>| fmran (denvalue env) \<and>
     (Storage tp2, l22) |\<in>| fmran (denvalue env) \<and>
     (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
     (l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l22 = Storeloc stl2)"
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using  2(1) unfolding TypeSafe_def unique_locations_def by simp

        then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
        proof(cases "l1 = Storeloc stl1")
          case t1:True
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case True
            then show ?thesis using t1 a0 a1 unfolding compPointers_def by blast
          next
            case False
            then have a4:"l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2)" using a1 by simp
            then show ?thesis 
            proof(cases "l2' = l")
              case True
              then have "stl2 = p" using a4 16 by simp
              then show ?thesis using pRelations a1 a0 t1  True a4 lDen by blast
            next
              case False
              then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
              then show ?thesis using a0 a1 t1 unfolding compPointers_def by metis
            qed
          qed
        next
          case f1:False
          then have a4:"l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1)" using a1 by simp
          then show ?thesis 
          proof(cases "l22 = Storeloc stl2")
            case t1:True
            then show ?thesis
            proof(cases "l1' = l")
              case True
              then have "stl1 = p" using a4 16 by simp
              then show ?thesis using pRelations a1 a0 t1  True a4 lDen 
                by (metis CompStoType_sameLoc_sameType Type.inject(4) typedStoSub_imps_negInv)
            next
              case False
              then have " accessStore l1' (stack st') =  accessStore l1' (stack st)" using  stackChanged a4 by simp
              then show ?thesis using a0 a1 t1 unfolding compPointers_def by metis
            qed
          next
            case False
            then have a4':"l22 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2)" using a1 by simp
            then show ?thesis 
            proof(cases "l1' = l")
              case True
              then have p1:"stl1 = p" using a4 16 by simp
              then have tp1c:"tp1 = (STMap t g')" using lDen a1 
                using True a4 by auto
              then show ?thesis 
              proof(cases "l2' = l")
                case True
                then have p2:"stl2 = p" using a4' 16 by auto
                then have tp2c:"tp2 = (STMap t g')" using lDen a1 True a4' by auto
                then show ?thesis using p2 p1 tp1c tp2c by auto
              next
                case False
                then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
                then show ?thesis 
                  by (metis CompStoType_sameLoc_sameType a1 p1 pRelations tp1c typedStoSub_imps_negInv)
              qed
            next
              case False
              then have same1:" accessStore l1' (stack st') =  accessStore l1' (stack st)" using  stackChanged a4 by simp
              then show ?thesis 
              proof(cases "l2' = l")
                case True
                then have p2:"stl2 = p" using a4' 16 by auto
                then have tp2c:"tp2 = (STMap t g')" using lDen a1 True a4' by auto
                then show ?thesis using same1 pRelations p2 tp2c a1 
                  by metis
              next
                case False
                then have " accessStore l2' (stack st') =  accessStore l2' (stack st)" using  stackChanged a4 by simp
                then show ?thesis using a1 a0 same1 
                  using compPointers_def by auto
              qed
            qed 
          qed
        qed
      qed
    next
      show "svalueTypes (svalue env)" using svalueTypes_def typeSafeSvalue 2(1) by simp
    next
      have "(storage st') = (storage st)" using 16(4) by simp
      then show "safeContract (storage st')" using 2(1) unfolding safeContract_def TypeSafe_def  by auto
    next
      have a10:"toploc (stack st') = toploc (stack st)" using 16(4) unfolding updateStore_def by simp
      then have a20:"\<exists>val. accessStore l (stack st) = Some val" using t'InDen typeSafeLocExists 2(1) TypeSafe_def by blast
      then have a30:"(\<forall>tloc loc. toploc (stack st) \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                   \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using 2(1) unfolding TypeSafe_def  lessThanTopLocs_def by simp
      then have a40:"(\<forall>tloc loc. toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc) \<longrightarrow> accessStore loc (stack st) = None)
                    \<and>(\<forall>loc y. accessStore loc (stack st) = Some y \<longrightarrow> (\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)))" 
        using a10 by simp
      show "lessThanTopLocs (stack st')" unfolding lessThanTopLocs_def
      proof intros
        fix tloc loc
        assume *:"toploc (stack st') \<le> tloc \<and> LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        then show "accessStore loc (stack st') = None"
        proof(cases "loc = l")
          case True
          then show ?thesis using * a10 
            by (metis a20 a30 option.distinct(1)) 
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 16(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using 2(1) a40 * a10 False a30 by simp
        qed
      next 
        fix loc y 
        assume *:" accessStore loc (stack st') = Some y "
        show "\<exists>tloc<toploc (stack st'). LSubPrefL2 loc (ShowL\<^sub>n\<^sub>a\<^sub>t tloc)"
        proof(cases "loc = l")
          case True
          then show ?thesis using *a10 a20 a30 by simp
        next
          case False
          then have a50:"accessStore loc (stack st) = accessStore loc (stack st')" using 16(4) unfolding updateStore_def accessStore_def by simp
          then show ?thesis using * 2(1) a40 by simp
        qed
      qed
    next
      show "lessThanTopLocs cd" using 2(1) unfolding TypeSafe_def using 16 by auto
    next 
      show "lessThanTopLocs (memory st')" using 2(1) unfolding TypeSafe_def using 16 by auto
    next 
      show "methodVarsNoPref" using 2(1) unfolding TypeSafe_def  by auto
    next 
      show "addressFormat (address env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      show "addressFormat (sender env)" using 2(1) unfolding TypeSafe_def by auto
    next 
      have a0: "compMemPtrs (stack st) (memory st) (denvalue env)" using 2(1) unfolding TypeSafe_def by simp
      show "compMemPtrs (stack st') (memory st') (denvalue env)" unfolding compMemPtrs_def 
      proof intros
        fix tp1 tp2 l1 l2 stl1 stl2 dloc1
        assume a1:"(Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
     (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st') = Some (KMemptr stl1) \<and> accessStore l2 (stack st') = Some (KMemptr stl2) "
        have a2:"(\<forall>x y. x |\<in>| fmran (denvalue env) \<and> y |\<in>| fmran (denvalue env) \<and> snd x = snd y \<longrightarrow> x = y)"
          using 2(1) t'InDen unfolding TypeSafe_def unique_locations_def by blast

        have a3:"\<forall>dloc1.
   (Memory tp1, Stackloc l1) |\<in>| fmran (denvalue env) \<and>
   (Memory tp2, Stackloc l2) |\<in>| fmran (denvalue env) \<and> accessStore l1 (stack st) = Some (KMemptr stl1) \<and> accessStore l2 (stack st) = Some (KMemptr stl2) \<longrightarrow>
   (if stl1 = stl2 then tp1 = tp2
    else case tp1 of
         MTArray len arr \<Rightarrow>
           (case tp2 of
           MTArray len2 arr2 \<Rightarrow>
             if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTArray len arr) stl2 stl1
             else if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTArray len2 arr2) stl1 stl2
                  else if TypedMemSubPrefPtrs (memory st) len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 dloc1
                       then \<exists>dt. CompMemType (memory st) len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st) len arr dt stl1 dloc1 else True
           | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len arr stl1 stl2 then CompMemType (memory st) len arr (MTValue val2) stl1 stl2 else True)
         | MTValue val \<Rightarrow>
             (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st) len2 arr2 stl2 stl1 then CompMemType (memory st) len2 arr2 (MTValue val) stl2 stl1 else True
             | MTValue val2 \<Rightarrow> True))" using a0 unfolding compMemPtrs_def by auto

        then have "l1 \<noteq> l \<and> l2 \<noteq> l" using lDen a1 by blast
        then have "accessStore l1 (stack st) = Some (KMemptr stl1) \<and>  accessStore l2 (stack st) = Some (KMemptr stl2)" using stackChanged a1 by simp

        then show "if stl1 = stl2 then tp1 = tp2
     else case tp1 of
          MTArray len arr \<Rightarrow>
            (case tp2 of
            MTArray len2 arr2 \<Rightarrow>
              if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTArray len arr) stl2 stl1
              else if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTArray len2 arr2) stl1 stl2
                   else if TypedMemSubPrefPtrs (memory st') len arr stl1 dloc1 \<and> TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 dloc1
                        then \<exists>dt. CompMemType (memory st') len2 arr2 dt stl2 dloc1 \<and> CompMemType (memory st') len arr dt stl1 dloc1 else True
            | MTValue val2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len arr stl1 stl2 then CompMemType (memory st') len arr (MTValue val2) stl1 stl2 else True)
          | MTValue val \<Rightarrow>
              (case tp2 of MTArray len2 arr2 \<Rightarrow> if TypedMemSubPrefPtrs (memory st') len2 arr2 stl2 stl1 then CompMemType (memory st') len2 arr2 (MTValue val) stl2 stl1 else True
              | MTValue val2 \<Rightarrow> True)" using a3 memorySame storageSame a1 
          by (metis (lifting) ext)
      qed
    next 
      show "AddressTypes (accounts st')" using 2(1) unfolding TypeSafe_def using 16 by simp
    next 
      have "accounts st'= accounts st" using 16 by auto
      show "fullyInitialised env  (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address env)) = Some (Contract c) \<and> contract env = c" using 2(3) unfolding fullyInitialised_def 
          using \<open>accounts st' = accounts st\<close> by presburger
        show "\<And>id ct dud v. (ep $$ contract env = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue env $$ id = Some (Storage v, Storeloc id))"
          using 2(3) unfolding fullyInitialised_def by blast
        fix t''' l''' p''' 
        assume in1:"(Storage t''', Stackloc l''') |\<in>| fmran (denvalue env)\<and>accessStore l''' (stack st') = Some (KStoptr p''') "
        show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue env) \<and> CompStoType t' t''' l' p'''"
        proof(cases "l''' = l")
          case True
          then have "p''' = p" using 16 in1 unfolding accessStore_def updateStore_def by simp
          then show ?thesis using pOrigin 
            by (metis CompStoType_sameLocNdTyp True Type.inject(4) in1 lDen extractValueType.simps(4))
        next
          case False
          then have "accessStore l''' (stack st') = accessStore l''' (stack st)" 
            using stackChanged by force
          then show ?thesis using 16 using 2(3) unfolding fullyInitialised_def using in1  by simp
        qed
      qed

    next       
      have inDen:"(Storage t', Stackloc l) |\<in>| fmran (denvalue env)" using t'InDen by simp
      have denAc:"(\<forall>t l. (t, l) |\<in>| fmran (denvalue env) \<longrightarrow>
           (case l of
            Stackloc loc \<Rightarrow>
              (case accessStore loc (stack st) of None \<Rightarrow> False 
                | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st) stloc | _ \<Rightarrow> False)
                | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address env)) | _ \<Rightarrow> False))
            | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st (address env)) | _ \<Rightarrow> False)))" using 2(1) unfolding TypeSafe_def typeCompat_def by simp
      have isVal:"\<exists>val. accessStore l (stack st) = Some (KStoptr val)" 
      proof(cases "accessStore l (stack st)")
        case None
        then show ?thesis using inDen denAc by fastforce
      next
        case (Some a)
        then show ?thesis 
        proof(cases a)
          case (KValue x1)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KCDptr x2)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KMemptr x3)
          then show ?thesis using inDen denAc Some by fastforce
        next
          case (KStoptr x4)
          then show ?thesis using inDen denAc Some by simp
        qed
      qed

      have memSame:"memory st = memory st'" using 16(4) by simp
      have cc0:"\<forall>l ptr. (accessStore l (stack st) = Some (KMemptr ptr)) = (accessStore l (stack st') = Some (KMemptr ptr))" 
      proof intros
        fix l2 ptr
        show " (accessStore l2 (stack st) = Some (KMemptr ptr)) = (accessStore l2 (stack st') = Some (KMemptr ptr)) "
        proof
          assume *:"accessStore l2 (stack st) = Some (KMemptr ptr)"
          then have "l \<noteq> l2" using isVal by auto
          then show "accessStore l2 (stack st') = Some (KMemptr ptr)" 
            using 16(4) * unfolding updateStore_def accessStore_def by auto
        next 
          assume *:"accessStore l2 (stack st') = Some (KMemptr ptr)" 
          then have "l \<noteq> l2" using 16(4) by auto
          then show "accessStore l2 (stack st) = Some (KMemptr ptr) " 
            using * 16(4) unfolding updateStore_def accessStore_def by simp
        qed
      qed
     
    qed
  qed 
next
  case (3 s1 s2 e cd st)
  show ?case
  proof(cases "gas st > costs (COMP s1 s2) e cd st")
    case True  
    then have a5:"assert Gas (\<lambda>st. costs (COMP s1 s2) e cd st < gas st) st = Normal ((), st)" by simp
    then obtain sgas where *:"sgas = st\<lparr>gas := gas st - costs (COMP s1 s2) e cd st\<rparr>" by simp
    then have a6:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (COMP s1 s2) e cd st\<rparr>) st = Normal ((), sgas)" by simp
    moreover have sStackSame:"stack st = stack sgas" using * by simp
    moreover have sgasSame:"memory st = memory sgas" using * by simp
    moreover have "storage st = storage sgas" using * by simp
    moreover have "accounts st = accounts sgas" using * by simp
    ultimately have a10:"TypeSafe e (accounts sgas) (stack sgas) (memory sgas) (storage sgas) cd" 
      using 3(3) TypeSafe_def True by simp
    then obtain sts1 where s1:"stmt s1 e cd sgas = Normal ((), sts1)" using 3 * stmt.simps(3) comp by meson
    have fi:"fullyInitialised e (accounts sgas) (stack sgas)" using 3(5) unfolding fullyInitialised_def using *  by simp
    then have cc0:"StateInvariant e sgas sts1 cd" using 3(1)[OF a5 a6 a10 s1]   by blast

    then have ts: "TypeSafe e (accounts sts1) (stack sts1) (memory sts1) (storage sts1) cd"
      using a10 3(1)[of "()" st "()" sgas sts1] a5 a6 * s1  unfolding StateInvariant_def by simp
    then have "stmt s2 e cd sts1 = Normal ((),st')" using 3(4) * s1 using comp by fastforce
    then have cc2:"StateInvariant e sts1 st' cd" using 3(2)[of "()" st "()" sgas "()" "sts1" st'] a5 a6 * s1 ts fi
      using atype_same 
      by (metis cc0 statement_with_gas.StateInvariant_def statement_with_gas_axioms)
    then have cc5:"TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd"
      unfolding StateInvariant_def by blast
    have cc10:"fullyInitialised e (accounts st') (stack st')" using cc2 unfolding StateInvariant_def by blast
    then have cc12:"TypeSafe e (accounts sts1) (stack sts1) (memory sts1) (storage sts1) cd \<and>
    fullyInitialised e (accounts sts1) (stack sts1)" 
      using cc0 unfolding StateInvariant_def by simp
    have cc15:"TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd \<and>
  fullyInitialised e (accounts st') (stack st')" 
      using cc2 unfolding StateInvariant_def by blast
    show ?thesis using cc5 cc10 cc15 cc12 unfolding StateInvariant_def 
      by (metis)
  next
    case False
    then have "assert Gas (\<lambda>st. costs (COMP s1 s2) e cd st < gas st) st = Exception Gas" by simp
    then show ?thesis using 3(4) stmt.simps(3) by simp
  qed
next
  case (4 ex s1 s2 e cd st)
  then show ?case
  proof(cases "gas st> costs (ITE ex s1 s2) e cd st")
    case True
    then have a5:"assert Gas (\<lambda>st. costs (ITE ex s1 s2) e cd st < gas st) st = Normal ((), st)" by simp
    then obtain sgas where *:"sgas = st\<lparr>gas := gas st - costs (ITE ex s1 s2) e cd st\<rparr>" by simp
    then have a6:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (ITE ex s1 s2) e cd st\<rparr>) st = Normal ((), sgas)" by simp
    moreover have "stack st = stack sgas" using * by simp
    moreover have "memory st = memory sgas" using * by simp
    moreover have "storage st = storage sgas" using * by simp
    moreover have "accounts st = accounts sgas" using * by simp
    ultimately have a10:"TypeSafe e (accounts sgas) (stack sgas) (memory sgas) (storage sgas) cd" using 4(3) True by simp
    then consider (atrue) g where "expr ex e cd sgas (gas sgas) = Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), Value TBool),g)"
      |(afalse) g where "expr ex e cd sgas (gas sgas) = Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False), Value TBool),g)" using * 4(4) stmt.simps(4) by (simp split:if_split_asm result.split_asm prod.split_asm Stackvalue.split_asm Type.split_asm Types.split_asm)
    then show ?thesis
    proof (cases)
      case atrue 
      then obtain g where a20:"expr ex e cd sgas (gas sgas) = Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), Value TBool), g)" by simp
      then obtain s'' where a25:"s'' = sgas\<lparr>gas:= g\<rparr>" by simp
      moreover have "stack s'' = stack sgas" using a25 by simp
      moreover have "memory s'' = memory sgas" using a25 by simp
      moreover have "storage s'' = storage sgas" using a25 by simp
      moreover have "accounts s'' = accounts sgas" using a25 by simp
      ultimately have "TypeSafe e (accounts s'') (stack s'') (memory s'') (storage s'') cd" using assms 4 True atrue a10 a25 by metis
      moreover have "stmt s1 e cd s'' = Normal((),st')" using * a20 stmt.simps(4) 4(4) a25 by (simp split:if_split_asm result.split_asm prod.split_asm)
      moreover have "fullyInitialised e (accounts s'') (stack s'')" using 4(5)  
        using \<open>accounts s'' = accounts sgas\<close> \<open>accounts st = accounts sgas\<close> 
        by (simp add: \<open>stack s'' = stack sgas\<close> \<open>stack st = stack sgas\<close>)
      ultimately have "StateInvariant e s'' st' cd" using 4(1)[of "()" st "()" sgas "(KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), Value TBool)" s'' "(ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True)" s'' st'] a5 a6 a20 a25 
        unfolding StateInvariant_def by simp
      then show ?thesis unfolding StateInvariant_def 
        by (metis)
    next
      case afalse
      then obtain g where a20:"expr ex e cd sgas (gas sgas) = Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False), Value TBool), g)" and 
        a21: "expr ex e cd sgas (gas sgas) \<noteq> Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), Value TBool), g)" by fastforce
      then obtain s'' where a25:"s'' = sgas\<lparr>gas:= g\<rparr>" by simp
      moreover have "stack s'' = stack sgas" using a25 by simp
      moreover have "memory s'' = memory sgas" using a25 by simp
      moreover have "storage s'' = storage sgas" using a25 by simp
      moreover have "accounts s'' = accounts sgas" using a25 by simp
      ultimately have "TypeSafe e (accounts s'') (stack s'') (memory s'') (storage s'') cd" using assms 4 True afalse a10 a25 by metis
      moreover have "stmt s2 e cd s'' = Normal((),st')" using * a20 a21 stmt.simps(4)[of ex s1 s2 e cd st ] 4(4) a25 by (simp split:if_split_asm result.split_asm prod.split_asm)
      moreover have "fullyInitialised e (accounts s'') (stack s'')" using 4(5) unfolding fullyInitialised_def 
        using \<open>accounts s'' = accounts sgas\<close> \<open>accounts st = accounts sgas\<close> 
        by (simp add: \<open>stack s'' = stack sgas\<close> \<open>stack st = stack sgas\<close>)
      moreover have "StateInvariant e s'' st' cd" using 4(2)[of "()" st "()" sgas "(KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False), Value TBool)" s'' "(ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l False)" s'' st'] 
          a5 a6 a20 a21 a25 calculation by auto
      ultimately show ?thesis 
        unfolding StateInvariant_def 
        by (metis)
    qed
  next
    case False
    then show ?thesis using 4(4) stmt.simps(4) by simp
  qed
next
  case (5 ex s0 e cd st)
  show ?case 
  proof(cases rule:while[OF 5(4)])
    case (1 g st'')
    then have a5:"assert Gas (\<lambda>st. costs (WHILE ex s0) e cd st < gas st) st = Normal ((), st)" by simp
    then obtain sgas where *:"sgas = st\<lparr>gas := gas st - costs (WHILE ex s0) e cd st\<rparr>" by simp
    then have a6:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (WHILE ex s0) e cd st\<rparr>) st = Normal ((), sgas)" by simp

    then have a10:"toState (expr ex e cd) sgas
          = Normal ((KValue (ShowL\<^sub>b\<^sub>o\<^sub>o\<^sub>l True), Value TBool), (st\<lparr>gas := g\<rparr>))" using 1 * by auto


    have a20:"TypeSafe e (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd"
      using 5(3) by simp
    have a25:"fullyInitialised e (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>))" using 5(5) unfolding fullyInitialised_def by simp
    then have a30:"StateInvariant e (st\<lparr>gas := g\<rparr>) st'' cd"
      using 5(1)[OF a5 a6 a10 _ _ a20 1(3) ] unfolding StateInvariant_def by simp
    have cc0:"StateInvariant e st'' st' cd"
      using 5(2)[OF a5 a6 a10 _ _ 1(3)  _ 1(4)] a30 unfolding StateInvariant_def  by simp

    then have ts:"TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd \<and>
  fullyInitialised e (accounts st') (stack st')" using cc0 unfolding StateInvariant_def by blast
    have "memory st = memory (st\<lparr>gas := g\<rparr>) \<and> stack st = stack (st\<lparr>gas := g\<rparr>)" by simp
    then show ?thesis unfolding StateInvariant_def  using ts by auto
  next
    case (2 g)
    then have "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd " 
      by (simp add: "5.prems"(1))
    moreover have "fullyInitialised e (accounts st') (stack st')" using 2 
      using "5.prems"(2,3) atype_same fullyInitialised_def by simp
    moreover have "memory st = memory st' \<and> stack st = stack st'" using 2 by simp
    ultimately show ?thesis unfolding StateInvariant_def by simp
  qed
next
  case (6 i xe e cd st)
  have *:"st' = st\<lparr>gas := gas st - costs (INVOKE i xe) e cd st\<rparr>" using 6 invoke by simp
  moreover have "stack st = stack st'" using * by simp
  moreover have memSame:"memory st' = memory st" using * by simp
  moreover have "storage st' = storage st" using * by simp
  moreover have "accounts st' = accounts st" using * by simp
  moreover have "WrittenMem_between (memory st) (memory st') = {}" using calculation unfolding WrittenMem_between_def by simp
  moreover have "ReachableMem e (stack st') (memory st') = ReachableMem e (stack st) (memory st)" unfolding ReachableMem.simps using calculation by metis
  ultimately show ?case using assms 6 * unfolding StateInvariant_def fullyInitialised_def  by auto
next
  case (7 ad i xe val e cd st)
  show ?case
  proof(cases rule:external[OF 7(4)])
    case (1 adv c g ct cn fb' v t g' v' fp f e\<^sub>l cd\<^sub>l k\<^sub>l m\<^sub>l g'' acc st'')
    then obtain cc where ccDef: "c = contract cc" 
      by (metis Environment.select_convs(2))

    then have a5:"assert Gas (\<lambda>st. costs (EXTERNAL ad i xe val) e cd st < gas st) st =  Normal ((), st)" using 1 by simp
    then obtain sgas where *:"sgas = st\<lparr>gas := gas st - costs (EXTERNAL ad i xe val) e cd st\<rparr>" by simp
    then have a6:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (EXTERNAL ad i xe val) e cd st\<rparr>) st = Normal ((), sgas)" by simp
    obtain expGas where a10:" toState (local.expr ad e cd) sgas = Normal ((KValue adv, Value TAddr), expGas)" using 1(2) a6 * by simp
    then have a20:"(case (KValue adv, Value TAddr) of (KValue adv, Value TAddr) \<Rightarrow> return adv | (KValue adv, Value _) \<Rightarrow> throw Err 
                    | (KValue adv, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err) expGas =
    Normal (adv, expGas)" by simp
    then obtain vd where a30:"assert Err (\<lambda>_. adv \<noteq> address e) expGas = Normal (vd, expGas)" using 1 by simp
    then have a40:"(case type (accounts expGas adv) of None \<Rightarrow> throw Err expGas 
                | Some EOA \<Rightarrow> throw Err expGas 
                | Some (Contract c) \<Rightarrow> return c expGas) = Normal (c, expGas)" using 1 a10 * by auto
    then have a50:"option Err (\<lambda>_. ep $$ c) expGas = Normal ((ct, cn, fb'), expGas)" using 1 by simp
    then have a60:"toState (local.expr val e cd) expGas = Normal ((KValue v, Value t), expGas\<lparr>gas := g'\<rparr>)" using 1 a10 * by auto
    then have a70:"(case (KValue v, Value t) of (KValue v, Value t) \<Rightarrow> return (v, t) 
                    | (KValue v, _) \<Rightarrow> throw Err 
                    | (_, b) \<Rightarrow> throw Err) (expGas\<lparr>gas := g'\<rparr>) = Normal ((v,t), expGas\<lparr>gas := g'\<rparr>)" using 1 a10 * by simp
    then have a80:"option Err (\<lambda>_. convert t (TUInt b256) v) (expGas\<lparr>gas := g'\<rparr>) = Normal (v', expGas\<lparr>gas := g'\<rparr>)" using 1 by simp
    then obtain loaded where a90:"loaded = ffold_init ct (emptyEnv adv c (address e) v') (fmdom ct)" using 1(9) by blast
    then have a100:"toState (local.load True fp xe loaded emptyStore emptyStore emptyStore e cd) (expGas\<lparr>gas := g'\<rparr>) = Normal ((e\<^sub>l, cd\<^sub>l, k\<^sub>l, m\<^sub>l), expGas\<lparr>gas := g''\<rparr>)"
      using 1 * a10 by auto
    then have a110:"option Err (\<lambda>st. transfer (address e) adv v' (accounts st)) (expGas\<lparr>gas := g''\<rparr>) = Normal (acc, expGas\<lparr>gas := g''\<rparr>)" 
      using 1 * a10 by auto
    then have a120:"modify (\<lambda>st. st\<lparr>accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) (expGas\<lparr>gas := g''\<rparr>) = Normal ((), (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))" 
      using 1 * a10 by auto

    have contractLoaded:"contract e\<^sub>l = c" using a90 a100 
      using "1"(9) emptyEnv_members ffold_init_contract msel_ssel_expr_load_rexp_gas(4) by presburger
    have addressLoaded: "address e\<^sub>l = address loaded" using a90 a100 
      using "1"(9) ffold_init_def msel_ssel_expr_load_rexp_gas(4) by presburger

    have tsInitAcc:"\<forall>x y. TypeSafe loaded acc emptyStore emptyStore (storage st) emptyStore \<and>
       (denvalue loaded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue loaded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))"  
    proof - 
      have "safeContract (storage st)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "methodVarsNoPref" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have svv':"svalueTypes v'" unfolding svalueTypes_def
        using 1(6,7) 7(3) 7(5) 
        using exprTypeconInduct(3)[of val e cd "(st\<lparr>gas := g\<rparr>)" g "KValue v" "Value t" g']
          typeSafeConvert[of t v "(TUInt b256)"] convertSame by auto
      moreover have "balanceTypes acc" using 1(10) unfolding balanceTypes_def
      proof - 
        have old:"balanceTypes (accounts (st\<lparr>gas := g''\<rparr>))" using 7(3) unfolding TypeSafe_def by simp
        have accExp:"(case subBalance (address e) v' (accounts (st\<lparr>gas := g''\<rparr>)) of None \<Rightarrow> None | Some x \<Rightarrow> addBalance adv v' x) = Some acc" 
          using 1(10) unfolding transfer_def by blast
        have v'TC: "typeCon (TUInt b256) v'" 
          using  svv' unfolding svalueTypes_def by blast

        show "\<forall>adv'. typeCon (TUInt b256) (bal (acc adv')) "
        proof
          fix adv'
          show "typeCon (TUInt b256) (bal (acc adv')) "
          proof(cases "adv' = (address e)")
            case True
            then have ns:"adv' \<noteq> adv" using 1 by blast
            then have tco:"typeCon (TUInt b256) (bal ((accounts (st\<lparr>gas := g''\<rparr>)) adv'))"
              using True old accExp balanceTypes_def by blast
            have "bal (acc (address e)) = ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g''\<rparr>) (address e))) - (ReadL\<^sub>i\<^sub>n\<^sub>t v'))" 
              using transfer_subRead[OF 1(10) _ v'TC ] True ns tco by auto
            then show ?thesis using True 
              by (smt (verit, best) "1"(10,3) checkUInt_def typeCon.simps(2) tco transfer_add transfer_mono transfer_sub transfer_val3)
          next
            case False
            then show ?thesis 
            proof(cases "adv' = adv")
              case True
              then have "typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g''\<rparr>) adv))"
                using True old accExp balanceTypes_def by simp
              then have "bal (acc adv) = (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g''\<rparr>) adv))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                using transfer_addRead[OF 1(10)_ v'TC  ] 1(3) by blast
              then show ?thesis using True 
                using "1"(10,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g''\<rparr>) adv))\<close> checkUInt_def transfer_val1 transfer_val2 by auto
            next
              case f2:False
              then show ?thesis using False transfer_eq[OF 1(10)] old 
                using balanceTypes_def by force
            qed
          qed
        qed
      qed

      moreover have "lessThanTopLocs emptyStore" using emptyTopLocs by simp
      moreover have "ep $$ contract cc = Some (ct, cn, fb')" using ccDef 1(5) by simp
      moreover have "addressFormat adv" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "addressFormat (sender e)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "AddressTypes acc" using 1(10) transfer_type_same 7(3) unfolding TypeSafe_def unfolding AddressTypes_def by simp
      ultimately show ?thesis 
        using a90 ccDef unfolding ffold_init_def using ffoldInitTypeSafe[of "storage st" acc v' emptyStore cc ct "(cn,fb')" adv _ " (fmdom ct)"]  
        by (metis (mono_tags, lifting) "7.prems"(1) TypeSafe_def)
    qed

    have tsInit:"\<forall>x y. TypeSafe loaded (accounts st) emptyStore emptyStore (storage st) emptyStore \<and>
       (denvalue loaded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue loaded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))"
    proof - 
      have "safeContract (storage st)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "methodVarsNoPref" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have svv':"svalueTypes v'" unfolding svalueTypes_def
        using 1(6,7) 7(3) 7(5)
        using exprTypeconInduct(3)[of val e cd "(st\<lparr>gas := g\<rparr>)" g "KValue v" "Value t" g']
          typeSafeConvert[of t v "(TUInt b256)"] convertSame by auto
      moreover have "balanceTypes (accounts st)" using 7(3) unfolding TypeSafe_def by simp      
      moreover have "lessThanTopLocs emptyStore" using emptyTopLocs by simp
      moreover have "ep $$ contract cc = Some (ct, cn, fb')" using ccDef 1(5) by simp
      moreover have "addressFormat adv" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "addressFormat (sender e)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "AddressTypes (accounts st)" using 7(3) unfolding TypeSafe_def by simp    
      ultimately show ?thesis 
        using a90 ccDef unfolding ffold_init_def using ffoldInitTypeSafe[of "storage st" acc v' emptyStore cc ct "(cn,fb')" adv _ " (fmdom ct)"]  
        by (metis (mono_tags, lifting) "7.prems"(1) statement_with_gas.ffoldInitTypeSafe statement_with_gas_axioms TypeSafe_def)
    qed

    have contractL:"contract loaded = c" using a90 by simp
    have addressL:"address loaded = adv" using a90 by simp
    have fi1:"(\<exists>c. type (accounts (st\<lparr>gas := g'\<rparr>) (address loaded)) = Some (Contract c) \<and> contract loaded = c)" using contractL addressL 1 a10 * a40 by simp
    have "\<exists>dud. ep $$ contract loaded = Some (ct, dud)" using a50 contractL 1 a10 * by blast
    moreover have "\<forall>id v. (ct $$ id = Some (Var v))  = (denvalue loaded $$ id = Some (Storage v, Storeloc id))"
      using a90 unfolding ffold_init_def using ffoldInit_var_storage_mapping_eq[of ct adv c "address e" v' loaded]  by blast
    ultimately have fi2:"(\<forall>id ct dud v. ep $$ contract loaded = Some (ct, dud) 
                          \<and> ct $$ id = Some (Var v) = (denvalue loaded $$ id = Some (Storage v, Storeloc id)))" 
      by (smt (verit, ccfv_SIG) "7.prems"(3) AddressTypes_def fullyInitialised_def tsInit TypeSafe_def)

    have "type (accounts (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) (address e\<^sub>l)) = type (accounts (st\<lparr>gas := g'\<rparr>) (address loaded))"
      using addressLoaded 1(10) a10 * transfer_type_same by simp
    then have fi3:"(\<exists>c. type (accounts (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) (address e\<^sub>l)) = Some (Contract c) \<and> contract e\<^sub>l = c)"
      using contractLoaded fi1 
      using contractL by presburger


    then have tsLoaded:"TypeSafe e\<^sub>l (accounts (st\<lparr>gas := g'\<rparr>)) k\<^sub>l m\<^sub>l (storage (st\<lparr>gas := g'\<rparr>)) cd\<^sub>l \<and>
    fullyInitialised e\<^sub>l (accounts (st\<lparr>gas := g'\<rparr>)) k\<^sub>l" 
    proof - 
      have ld:"load True fp xe loaded emptyStore emptyStore emptyStore e cd (st\<lparr>gas := g'\<rparr>) g' = Normal ((e\<^sub>l, cd\<^sub>l, k\<^sub>l, m\<^sub>l), g'')" using  1
        using a90 ffold_init_def by presburger

      have "fullyInitialised loaded (accounts (st\<lparr>gas := g'\<rparr>)) emptyStore" unfolding fullyInitialised_def 
        by (metis Denvalue.distinct(1) fi1 fi2 fmranE snd_conv tsInit)
      then show ?thesis
        using *  1(9) 7(3) tsInit 7(5)  using fi1 fi2 ld
        using  exprTypeconInduct(4)[of True fp xe loaded emptyStore emptyStore emptyStore e cd "(st\<lparr>gas := g'\<rparr>)" g' e\<^sub>l cd\<^sub>l k\<^sub>l m\<^sub>l g'']  
        by simp
    qed


    then have ts1:"TypeSafe e\<^sub>l (accounts (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (stack (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))
     (memory (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (storage (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) cd\<^sub>l"
      using tsInitAcc a10 * 1 unfolding TypeSafe_def by auto

    have fiFinal:"fullyInitialised e\<^sub>l (accounts(expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (stack (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))"
      unfolding fullyInitialised_def 
    proof (intros)
      show "\<exists>c. type (accounts (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) (address e\<^sub>l)) = Some (Contract c) \<and> contract e\<^sub>l = c"
        using tsLoaded fi3 by blast 
      show "\<And>id ct dud v. (ep $$ contract e\<^sub>l = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>l $$ id = Some (Storage v, Storeloc id))"
        using tsLoaded fi3 fullyInitialised_def by blast
      show " \<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e\<^sub>l) \<and>
       accessStore l (stack (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>l) \<and> CompStoType t' t l' p" using tsLoaded unfolding fullyInitialised_def by simp
    qed

    then have IH1:"StateInvariant e\<^sub>l (expGas\<lparr>gas := g'', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) st'' cd\<^sub>l" 
      using 7(1)[OF a5 a6 a10 a20 a30 a40 a50 _ _ a60 a70 _ a80 a90 1(8) _ _ _ _ a100 _ _ _ a110 _ _ a120 ts1 
          ] 1(11) 1(2) a10 * by fastforce

    have accFinal:"accounts st' = accounts st''" using 1 by simp
    have storageFinal:"storage st' = storage st''" using 1 by simp

    have SafeC:"safeContract (storage st'')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
    then have "storage st'' = storage st'" using 1 by auto
    then have scNew:"\<forall>e ct dud i tp. ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp) \<longrightarrow> SCon tp i (storage st'' (address e))" 
      using SafeC unfolding safeContract_def by simp
    have acc:"(\<forall>c adv ct dud. type (accounts st adv) = Some (Contract c) \<longrightarrow> ep $$ c = Some (ct,dud) \<and> addressFormat adv)"
      using 7(3) unfolding TypeSafe_def AddressTypes_def by blast
    obtain cOld where "type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld" 
      using 7(5) unfolding fullyInitialised_def by simp
    then obtain ctO dudO where ctoDef: "ep $$ contract e = Some (ctO, dudO)" using acc  by blast

    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def using 1(12) by simp
      next 
        show "safeContract (storage st')" using IH1 storageFinal unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "unique_locations (denvalue e)" using "7.prems"(1) typeSafeUnique by blast
      next
        have old:" compPointers (stack st'')  (denvalue e\<^sub>l)" 
          using IH1 unfolding StateInvariant_def TypeSafe_def by blast
        show "compPointers (stack st') (denvalue e)" unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume a0:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then have a5:"accessStore l1' (stack st') = accessStore l1' (stack st)" using 1 by simp
          have a10:"accessStore l2' (stack st') = accessStore l2' (stack st)" using 1 by auto
          show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 
                else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
            using 7(3) unfolding TypeSafe_def compPointers_def using a0 a5 a10 by simp
        qed
      next
        show "compMemPtrs (stack st') (memory st') (denvalue e)" using 1(12) "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "methodVarsNoPref"  using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using accFinal IH1 unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "addressFormat (address e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using 1(12) "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs cd" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using 1(12) "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "typeCompat (denvalue e) (stack st') (memory st') (storage st' (address e)) cd" 
          unfolding typeCompat_def
        proof intros
          fix t l 
          assume tc1:"(t, l) |\<in>| fmran (denvalue e)"
          then obtain lookupI where IDef:"(denvalue e) $$ lookupI = Some (t,l)" by blast
          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using tc1 Stackloc using 7(3) 1(12) unfolding TypeSafe_def typeCompat_def by force
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 1(12) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KCDptr x2)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 1(12) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KMemptr x3)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 1(12) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KStoptr x4)
                then have accO:"accessStore x1 (stack st) = Some( KStoptr x4)"
                  using Some 1 by auto
                then obtain struct where structDef: "t = Storage struct" 
                  using 7(3) unfolding TypeSafe_def typeCompat_def using tc1 Some KStoptr Stackloc 
                  by (cases t, force,  fastforce, fastforce, auto)
                obtain tprnt lprnt where tprntDef: "((Storage tprnt, Storeloc lprnt) |\<in>| fmran (denvalue e) \<and> CompStoType tprnt struct lprnt x4)" 
                  using 7(5) using accO tc1 unfolding fullyInitialised_def 
                  using Stackloc structDef by blast
                
                then have "SCon tprnt lprnt (storage st'' (address e))"
                  using ctoDef IH1 unfolding StateInvariant_def TypeSafe_def safeContract_def 
                  by (metis accessStore_def accessStore_updateStore fi2)
                then have "SCon struct x4 (storage st'' (address e))"
                  using tprntDef SCon_imps_sublocs by blast
                then show ?thesis using Stackloc Some KStoptr structDef storageFinal by simp
              qed
            qed
          next
            case (Storeloc x2)
            then obtain struct where structDef: "t = Storage struct" 
              using 7(3) tc1 unfolding TypeSafe_def typeCompat_def by (cases t,fastforce+)

            then have "SCon struct x2 (storage st'' (address e))"
              using ctoDef IH1 fi2 accessStore_def accessStore_updateStore 
              unfolding StateInvariant_def TypeSafe_def 
              by (metis scNew)
            then show ?thesis using Storeloc structDef 
              by (simp add: storageFinal)
          qed
        qed
      qed
    next 
      show "fullyInitialised e (accounts st') (stack st')" unfolding fullyInitialised_def
      proof intros
        show "\<exists>c. type (accounts st' (address e)) = Some (Contract c) \<and> contract e = c"
          using atype_same "7.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
      next 
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using 7(5) unfolding fullyInitialised_def by blast
      next 
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack st') = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p"
          using 1 fiFinal 7(5) unfolding fullyInitialised_def by simp
      qed

    qed
  next
    case (2 adv c g ct cn fb' v t g' v' acc st'')
    then obtain cc where ccDef: "c = contract cc" 
      by (metis Environment.select_convs(2))

    then have a5:"assert Gas (\<lambda>st. costs (EXTERNAL ad i xe val) e cd st < gas st) st =  Normal ((), st)" using 2 by simp
    then obtain sgas where *:"sgas = st\<lparr>gas := gas st - costs (EXTERNAL ad i xe val) e cd st\<rparr>" by simp
    then have a6:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (EXTERNAL ad i xe val) e cd st\<rparr>) st = Normal ((), sgas)" by simp
    obtain expGas where a10:" toState (local.expr ad e cd) sgas = Normal ((KValue adv, Value TAddr), expGas)" using 2(2) a6 * by simp
    then have a20:"(case (KValue adv, Value TAddr) of (KValue adv, Value TAddr) \<Rightarrow> return adv | (KValue adv, Value _) \<Rightarrow> throw Err 
                    | (KValue adv, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err) expGas =
    Normal (adv, expGas)" by simp
    then obtain vd where a30:"assert Err (\<lambda>_. adv \<noteq> address e) expGas = Normal (vd, expGas)" using 2 by simp
    then have a40:"(case type (accounts expGas adv) of None \<Rightarrow> throw Err expGas 
                | Some EOA \<Rightarrow> throw Err expGas 
                | Some (Contract c) \<Rightarrow> return c expGas) = Normal (c, expGas)" using 2 a10 * by auto
    then have a50:"option Err (\<lambda>_. ep $$ c) expGas = Normal ((ct, cn, fb'), expGas)" using 2 by simp
    then have a60:"toState (local.expr val e cd) expGas = Normal ((KValue v, Value t), expGas\<lparr>gas := g'\<rparr>)" using 2 a10 * by auto
    then have a70:"(case (KValue v, Value t) of (KValue v, Value t) \<Rightarrow> return (v, t) 
                    | (KValue v, _) \<Rightarrow> throw Err 
                    | (_, b) \<Rightarrow> throw Err) (expGas\<lparr>gas := g'\<rparr>) = Normal ((v,t), expGas\<lparr>gas := g'\<rparr>)" using 2 a10 * by simp
    then have a80:"option Err (\<lambda>_. convert t (TUInt b256) v) (expGas\<lparr>gas := g'\<rparr>) = Normal (v', expGas\<lparr>gas := g'\<rparr>)" using 2 by simp
    then obtain loaded where a90:"loaded = ffold_init ct (emptyEnv adv c (address e) v') (fmdom ct)" using 2(9) by blast

    then have a110:"option Err (\<lambda>st. transfer (address e) adv v' (accounts st)) (expGas\<lparr>gas := g'\<rparr>) = Normal (acc, expGas\<lparr>gas := g'\<rparr>)" 
      using 2 * a10 by auto


    have tsInitAcc:"\<forall>x y. TypeSafe loaded acc emptyStore emptyStore (storage st) emptyStore \<and>
       (denvalue loaded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue loaded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))"  
    proof - 
      have "safeContract (storage st)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 2 by simp
      moreover have "methodVarsNoPref" using 7(3) unfolding TypeSafe_def AddressTypes_def using 2 by simp
      moreover have svv':"svalueTypes v'" unfolding svalueTypes_def
        using 2(6,7) 7(3) 7(5) 
        using exprTypeconInduct(3)[of val e cd "(st\<lparr>gas := g\<rparr>)" g "KValue v" "Value t" g']
          typeSafeConvert[of t v "(TUInt b256)"] convertSame by auto
      moreover have "balanceTypes acc" using 2(10) unfolding balanceTypes_def
      proof - 
        have old:"balanceTypes (accounts (st\<lparr>gas := g'\<rparr>))" using 7(3) unfolding TypeSafe_def by simp
        have accExp:"(case subBalance (address e) v' (accounts (st)) of None \<Rightarrow> None | Some x \<Rightarrow> addBalance adv v' x) = Some acc" 
          using 2(9) unfolding transfer_def by blast
        have v'TC: "typeCon (TUInt b256) v'" 
          using  svv' unfolding svalueTypes_def by blast

        show "\<forall>adv'. typeCon (TUInt b256) (bal (acc adv')) "
        proof
          fix adv'
          show "typeCon (TUInt b256) (bal (acc adv')) "
          proof(cases "adv' = (address e)")
            case True
            then have ns:"adv' \<noteq> adv" using 2 by blast
            then have tco:"typeCon (TUInt b256) (bal ((accounts (st\<lparr>gas := g'\<rparr>)) adv'))"
              using True old accExp balanceTypes_def by blast
            have "bal (acc (address e)) = ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) (address e))) - (ReadL\<^sub>i\<^sub>n\<^sub>t v'))" 
              using transfer_subRead[OF 2(9) _ v'TC ] True ns tco by auto
            then show ?thesis using True 

              by (smt (verit, ccfv_SIG) "2"(3,9) Read_ShowL_id checkUInt_def typeCon.simps(2) tco transfer_add transfer_mono transfer_sub transfer_val3)
          next
            case False
            then show ?thesis 
            proof(cases "adv' = adv")
              case True
              then have "typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))"
                using True old accExp balanceTypes_def by simp
              then have "bal (acc adv) = (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                using transfer_addRead[OF 2(9)_ v'TC  ] 2(3) by auto
              then show ?thesis using True 
                using "2"(9,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))\<close> checkUInt_def transfer_val1 transfer_val2 by auto
            next
              case f2:False
              then show ?thesis using False transfer_eq[OF 2(9)] old 
                using balanceTypes_def by force
            qed
          qed
        qed
      qed
      moreover have "lessThanTopLocs emptyStore" using emptyTopLocs by simp
      moreover have "ep $$ contract cc = Some (ct, cn, fb')" using ccDef 2(5) by simp
      moreover have "addressFormat adv" using 7(3) unfolding TypeSafe_def AddressTypes_def using 2 by simp
      moreover have "addressFormat (sender e)" using 7(3) unfolding TypeSafe_def AddressTypes_def using 2 by simp
      moreover have "AddressTypes acc" using 2(9) transfer_type_same 7(3) unfolding TypeSafe_def unfolding AddressTypes_def by simp
      ultimately show ?thesis 
        using a90 ccDef unfolding ffold_init_def using ffoldInitTypeSafe[of "storage st" acc v' emptyStore cc ct "(cn,fb')" adv _ " (fmdom ct)"]  
        by (metis (mono_tags, lifting) "7.prems"(1) TypeSafe_def)
    qed

    have contractL:"contract loaded = c" using a90 by simp
    have addressL:"address loaded = adv" using a90 by simp
    have fi1:"(\<exists>c. type (accounts (st\<lparr>gas := g'\<rparr>) (address loaded)) = Some (Contract c) \<and> contract loaded = c)" using contractL addressL 2 a10 * a40 by simp
    have ct1:"\<exists>dud. ep $$ contract loaded = Some (ct, dud)" using a50 contractL 2 a10 * by blast
    then have fi2:"\<forall>id v. (denvalue loaded $$ id = Some (Storage v, Storeloc id)) = (ct $$ id = Some (Var v))"
      using a90 unfolding ffold_init_def using ffoldInit_var_storage_mapping_eq[of ct adv c _ v' loaded] by auto
    then have fi3:"(\<exists>c. type ((acc) (address loaded)) = Some (Contract c) \<and> contract loaded = c)"
      using fi1 contractL 2(9) transfer_type_same by simp
    have fi4:"(\<forall>id ct dud v. ep $$ contract loaded = Some (ct, dud) 
                          \<and> ct $$ id = Some (Var v) = (denvalue loaded $$ id = Some (Storage v, Storeloc id)))" 
      using fi1 ct1 fi2 
      by (metis (mono_tags, opaque_lifting) AddressTypes_def fi3 option.inject prod.inject tsInitAcc
          TypeSafe_def)

    have a120:" TypeSafe loaded (acc) (emptyStore) (emptyStore) (storage st) emptyStore" using tsInitAcc 
      by simp
    moreover have "fullyInitialised loaded (accounts (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) (stack (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>))" 
      unfolding fullyInitialised_def
    proof intros
      show "\<exists>c. type (accounts (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) (address loaded)) = Some (Contract c) \<and> contract loaded = c"
        using fi2 fi3 by simp
      show "\<And>id ct dud v. (ep $$ contract loaded = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue loaded $$ id = Some (Storage v, Storeloc id))"
        using fi2 fi3 ct1 
        by (metis (mono_tags, opaque_lifting) AddressTypes_def option.inject prod.inject tsInitAcc TypeSafe_def)
      show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue loaded) \<and>
       accessStore l (stack (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue loaded) \<and> CompStoType t' t l' p" 
        using tsInitAcc by fastforce
    qed
    ultimately have IH1:"StateInvariant loaded (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) st'' emptyStore" 
      using 7(2)[OF a5 a6 a10 a20 a30 a40 a50 _ _ a60 a70 _ a80 a90 2(8) a110, 
          of "(cn, fb')" cn fb' _ _ _ _ _ "(st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)" st''] 
        2(10) 2 * a10 a90 by fastforce

    have accFinal:"accounts st' = accounts st''" using 2 by simp
    have storageFinal:"storage st' = storage st''" using 2 by simp

    have acc:"(\<forall>c adv ct dud. type (accounts st adv) = Some (Contract c) \<longrightarrow> ep $$ c = Some (ct,dud) \<and> addressFormat adv)"
      using 7(3) unfolding TypeSafe_def AddressTypes_def by blast
    obtain cOld where "type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld" 
      using 7(5) unfolding fullyInitialised_def by simp
    then obtain ctO dudO where ctoDef: "ep $$ contract e = Some (ctO, dudO)" using acc  by blast
    have SafeC:"safeContract (storage st'')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast

    then have scNew:"\<forall>e ct dud i tp. ep $$ contract (e::Environment) = Some (ct, dud) \<and> ct $$ i = Some (Var tp) \<longrightarrow> SCon tp i (storage st'' (address e))"
      using SafeC unfolding safeContract_def by simp
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def using 2 by simp
      next 
        show "safeContract (storage st')" using IH1 storageFinal unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "unique_locations (denvalue e)" using "7.prems"(1) typeSafeUnique by blast
      next
        show "compPointers (stack st') (denvalue e)"  unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume a0:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then have a5:"accessStore l1' (stack st') = accessStore l1' (stack st)" using 2 by simp
          have a10:"accessStore l2' (stack st') = accessStore l2' (stack st)" using 2 by auto
          show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 
                else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
            using 7(3) unfolding TypeSafe_def compPointers_def using a0 a5 a10 by simp
        qed
      next
        show "compMemPtrs (stack st') (memory st') (denvalue e)" using 2 "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "methodVarsNoPref"  using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using accFinal IH1 unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "addressFormat (address e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using 2 "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs cd" using "7.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using 2 "7.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "typeCompat (denvalue e) (stack st') (memory st') (storage st' (address e)) cd" 
          unfolding typeCompat_def
        proof intros
          fix t l 
          assume tc1:"(t, l) |\<in>| fmran (denvalue e)"
          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using tc1 Stackloc using 7(3) 2 unfolding TypeSafe_def typeCompat_def by force
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 2(11) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KCDptr x2)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 2(11) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KMemptr x3)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 7(3) 2(11) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KStoptr x4)
                then have accO:"accessStore x1 (stack st) = Some( KStoptr x4)"
                  using Some 2 by auto
                then obtain struct where structDef: "t = Storage struct" 
                  using 7(3) unfolding TypeSafe_def typeCompat_def using tc1 Some KStoptr Stackloc 
                  by (cases t, force,  fastforce, fastforce, auto)
                obtain tprnt lprnt where tprntDef: "((Storage tprnt, Storeloc lprnt) |\<in>| fmran (denvalue e) \<and> CompStoType tprnt struct lprnt x4)" 
                  using 7(5) using accO tc1 unfolding fullyInitialised_def 
                  using Stackloc structDef by blast
                then have "SCon tprnt lprnt (storage st'' (address e))"
                 using ctoDef IH1 fi4 ct1 accessStore_def accessStore_updateStore scNew
                 unfolding StateInvariant_def TypeSafe_def 
                 by metis
                then have "SCon struct x4 (storage st'' (address e))"
                  using tprntDef SCon_imps_sublocs by blast
                then show ?thesis using Stackloc Some KStoptr structDef storageFinal by simp
              qed
            qed
          next
            case (Storeloc x2)
            then obtain struct where structDef: "t = Storage struct" 
              using 7(3) tc1 unfolding TypeSafe_def typeCompat_def by (cases t,fastforce+)

            then have "SCon struct x2 (storage st'' (address e))"
              using ctoDef IH1 fi4  ct1 accessStore_def accessStore_updateStore scNew unfolding StateInvariant_def TypeSafe_def safeContract_def by metis
            then show ?thesis using Storeloc structDef 
              by (simp add: storageFinal)
          qed
        qed
      qed
    next 
      show "fullyInitialised e (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address e)) = Some (Contract c) \<and> contract e = c"
          using atype_same "7.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
      next 
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using 7(5) unfolding fullyInitialised_def by blast
      next 
        fix t l p 
        assume in1:" (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack st') = Some (KStoptr p)"
        then show " \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p "
          using 7(5) 2 unfolding fullyInitialised_def by simp
      qed

    qed
  qed
next
  case (8 ad ex e cd st)
  show ?case 
  proof(cases rule:transfer[OF 8(3)])
    case (1 v t g adv c g' v' acc ct cn f st'')
    then obtain cc where ccDef: "contract cc = c" 
      by (meson Environment.select_convs(2))
    then have a1:"assert Gas (\<lambda>st. costs (TRANSFER ad ex) e cd st < gas st) st = Normal ((), st)" using 1 by simp
    have a10:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>) st = Normal ((), st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>)"
      by simp
    have a20:"toState (local.expr ad e cd) (st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>) = Normal ((KValue adv, Value TAddr), st\<lparr>gas := g\<rparr>)" 
      using 1 by simp
    then have a30:"(case (KValue adv, Value TAddr) of (KValue adv, Value TAddr) \<Rightarrow> return adv | (KValue adv, Value _) \<Rightarrow> throw Err | (KValue adv, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err)
     (st\<lparr>gas := g\<rparr>) = Normal (adv, st\<lparr>gas := g\<rparr>)" using 1 by simp
    have a40:" toState (local.expr ex e cd) (st\<lparr>gas := g\<rparr>) = Normal ((KValue v, Value t), st\<lparr>gas := g'\<rparr>)" using 1 by auto
    have a50:"(case (KValue v, Value t) of (KValue v, Value t) \<Rightarrow> return (v, t) | (KValue v, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err) (st\<lparr>gas := g'\<rparr>) = Normal ((v, t), (st\<lparr>gas := g'\<rparr>))"
      using 1 by simp
    then have a60:"option Err (\<lambda>_. convert t (TUInt b256) v) (st\<lparr>gas := g'\<rparr>) = Normal (v', st\<lparr>gas := g'\<rparr>)" using 1 by simp
    have a70:"applyf accounts (st\<lparr>gas := g'\<rparr>) = Normal (accounts (st\<lparr>gas := g\<rparr>), (st\<lparr>gas := g'\<rparr>))" using 1 by simp
    have a80:"type (accounts (st\<lparr>gas := g\<rparr>) adv) = Some (Contract c)" using 1(5) by blast
    have a90:"option Err (\<lambda>st. transfer (address e) adv v' (accounts st)) (st\<lparr>gas := g'\<rparr>) = Normal (acc, (st\<lparr>gas := g'\<rparr>))"
      using 1 by simp
    have a95:"option Err (\<lambda>_. ep $$ c) (st\<lparr>gas := g'\<rparr>) = Normal ((ct, cn, f), (st\<lparr>gas := g'\<rparr>))" using 1 by auto
    have a100:"modify (\<lambda>st. st\<lparr>accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) (st\<lparr>gas := g'\<rparr>)
                  = Normal ((), st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)" by simp
    obtain loaded where loadedDef:"loaded = ffold_init ct (emptyEnv adv c (address e) v') (fmdom ct)" by blast

    have tsLoaded':"\<forall>x y. TypeSafe loaded acc emptyStore emptyStore (storage st) emptyStore \<and>
       (denvalue loaded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue loaded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))"  
    proof - 
      have "safeContract (storage st)" using 8(2) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "methodVarsNoPref" using 8(2) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have svv':"svalueTypes v'" unfolding svalueTypes_def
        using 1(4,3) 8(2) 8(4)  
        using exprTypeconInduct(3)[of ex e cd "(st\<lparr>gas := g\<rparr>)" g "KValue v" "Value t" g']
          typeSafeConvert[of t v "(TUInt b256)"] convertSame by auto
      moreover have "balanceTypes acc"  unfolding balanceTypes_def
      proof - 
        have old:"balanceTypes (accounts (st\<lparr>gas := g'\<rparr>))" using 8(2) unfolding TypeSafe_def by simp
        have accExp:"(case subBalance (address e) v' (accounts (st)) of None \<Rightarrow> None | Some x \<Rightarrow> addBalance adv v' x) = Some acc" 
          using 1(7) unfolding transfer_def by blast
        have v'TC: "typeCon (TUInt b256) v'" 
          using  svv' unfolding svalueTypes_def by blast

        show "\<forall>adv'. typeCon (TUInt b256) (bal (acc adv')) "
        proof(cases "adv = (address e)")
          case same:True
          show ?thesis using transfer_sameRead 
            by (metis "1"(7) "8"(2) balanceTypes_def same statement_with_gas.typeSafeAccounts statement_with_gas_axioms transfer_eq v'TC)
        next
          case notSame:False
          show ?thesis 
          proof
            fix adv'
            show "typeCon (TUInt b256) (bal (acc adv')) "
            proof(cases "adv' = (address e)")
              case True
              then have tco:"typeCon (TUInt b256) (bal ((accounts (st\<lparr>gas := g'\<rparr>)) adv'))"
                using True old accExp balanceTypes_def by blast
              have "bal (acc (address e)) = ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) (address e))) - (ReadL\<^sub>i\<^sub>n\<^sub>t v'))" 
                using transfer_subRead[OF 1(7) _ v'TC ] True notSame tco by auto
              then show ?thesis using True 
                using "1"(7,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv'))\<close> checkUInt_def transfer_val1 transfer_val2
                by (smt (verit, ccfv_SIG) notSame typeCon.simps(2) transfer_sub transfer_val3)
            next
              case False
              then show ?thesis 
              proof(cases "adv' = adv")
                case True
                then have "typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))"
                  using True old accExp balanceTypes_def by simp
                then have "bal (acc adv) = (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                  using transfer_addRead[OF 1(7)_ v'TC  ] 1(3) notSame by auto
                then show ?thesis using True 
                  using "1"(7,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))\<close> checkUInt_def transfer_val1 transfer_val2 notSame by auto
              next
                case f2:False
                then show ?thesis using False transfer_eq[OF 1(7)] old 
                  using balanceTypes_def by force
              qed
            qed
          qed
        qed
      qed
      moreover have "lessThanTopLocs emptyStore" using emptyTopLocs by simp
      moreover have "ep $$ contract cc = Some (ct, cn, f)" using ccDef 1(6) by simp
      moreover have "addressFormat adv" using 8(2) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "addressFormat (sender e)" using 8(2) unfolding TypeSafe_def AddressTypes_def using 1 by simp
      moreover have "AddressTypes acc" using 1(7) transfer_type_same 8(2) unfolding TypeSafe_def unfolding AddressTypes_def by simp
      ultimately show ?thesis 
        using loadedDef ccDef unfolding ffold_init_def using ffoldInitTypeSafe[of "storage st" acc v' emptyStore cc ct "(cn,f)" adv _ " (fmdom ct)"]  
        by (metis (mono_tags, lifting) "8.prems"(1)  TypeSafe_def)
    qed
    then have tsLoaded:"TypeSafe loaded (accounts (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>))
     (stack (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) (memory (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>))
     (storage (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) emptyStore" by auto

    have contractL:"contract loaded = c" using loadedDef by simp
    have addressL:"address loaded = adv" using loadedDef by simp
    have fi1:"(\<exists>c. type (accounts (st\<lparr>gas := g'\<rparr>) (address loaded)) = Some (Contract c) \<and> contract loaded = c)" using contractL addressL 1 a10 a40 by simp
    have ctd:"\<exists>dud. ep $$ contract loaded = Some (ct, dud)" using a50 contractL 1 a10  by blast
    then have fi2:"\<forall>id v. (denvalue loaded $$ id = Some (Storage v, Storeloc id)) = (ct $$ id = Some (Var v))"
      using loadedDef unfolding ffold_init_def using ffoldInit_var_storage_mapping_eq[of ct adv c "(address e)" v' loaded] by auto
    then have fi3:"(\<exists>c. type ((acc) (address loaded)) = Some (Contract c) \<and> contract loaded = c)"
      using  fi1  contractL 1(7) transfer_type_same by simp
     have fi4:"(\<forall>id ct dud v. ep $$ contract loaded = Some (ct, dud) 
                          \<and> ct $$ id = Some (Var v) = (denvalue loaded $$ id = Some (Storage v, Storeloc id)))" 
      using fi1 ctd fi2 
      by (metis (mono_tags, opaque_lifting) AddressTypes_def fi3 option.inject prod.inject tsLoaded'
          TypeSafe_def)
    have fiLoaded:"fullyInitialised loaded (accounts (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) (stack (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>))"
      unfolding fullyInitialised_def 
    proof intros
      show "\<exists>c. type (accounts (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) (address loaded)) = Some (Contract c) \<and> contract loaded = c"
        using fi2 fi3 by auto
      show "\<And>id ct dud v. (ep $$ contract loaded = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue loaded $$ id = Some (Storage v, Storeloc id))"
        using fi2 fi3 ctd  
        by (metis (mono_tags, opaque_lifting) AddressTypes_def old.prod.inject option.inject tsLoaded' TypeSafe_def)
      show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue loaded) \<and>
       accessStore l (stack (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>)) = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue loaded) \<and> CompStoType t' t l' p" 
        by (metis Denvalue.distinct(1) fmranE snd_conv tsLoaded')
    qed
    have stmtC:"stmt f loaded emptyStore (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) = Normal ((), st'')"
      using 1(8) loadedDef unfolding ffold_init_def by simp
    have IH1:"StateInvariant loaded (st\<lparr>gas := g', accounts := acc, stack := emptyStore, memory := emptyStore\<rparr>) st'' emptyStore"
      using 8(1)[OF a1 a10 a20 a30 a40 a50 _ a60 a70 a80 _ a95 _ _ loadedDef _ _ a90 a100 tsLoaded stmtC fiLoaded ] by simp

    have acc:"(\<forall>c adv ct dud. type (accounts st adv) = Some (Contract c) \<longrightarrow> ep $$ c = Some (ct,dud) \<and> addressFormat adv)"
      using 8(2) unfolding TypeSafe_def AddressTypes_def by blast
    obtain cOld where "type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld" 
      using 8(4) unfolding fullyInitialised_def by simp
    then obtain ctO dudO where ctoDef: "ep $$ contract e = Some (ctO, dudO)" using acc  by blast
    have storageFinal:"storage st' = storage st''" using 1 by auto
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def using 1 by simp
      next 
        show "safeContract (storage st')" using IH1 1 unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "unique_locations (denvalue e)" using "8.prems"(1) typeSafeUnique by blast
      next
        have "compPointers (stack st'') (denvalue loaded)"
          using IH1 unfolding StateInvariant_def TypeSafe_def  by blast
        show "compPointers (stack st') (denvalue e)" unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume a0:"(Storage tp1, l1) |\<in>| fmran (denvalue e) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then have a5:"accessStore l1' (stack st') = accessStore l1' (stack st)" using 1 by simp
          have a10:"accessStore l2' (stack st') = accessStore l2' (stack st)" using 1 by auto
          show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 
                else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
            using 8(2) unfolding TypeSafe_def compPointers_def using a0 a5 a10 by simp
        qed
      next
        show "compMemPtrs (stack st') (memory st') (denvalue e)" using 1 "8.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "methodVarsNoPref"  using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using 1 IH1 unfolding StateInvariant_def TypeSafe_def by auto
      next 
        show "addressFormat (address e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using 1 "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs cd" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using 1 "8.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "typeCompat (denvalue e) (stack st') (memory st') (storage st' (address e)) cd" 
          unfolding typeCompat_def
        proof intros
          fix t l 
          assume tc1:"(t, l) |\<in>| fmran (denvalue e)"
          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using tc1 Stackloc using 8(2) 1 unfolding TypeSafe_def typeCompat_def by force
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 8(2) 1(9) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KCDptr x2)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 8(2) 1(9) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KMemptr x3)
                then show ?thesis apply(cases t) using tc1 Stackloc Some using 8(2) 1(9) unfolding TypeSafe_def typeCompat_def by force+
              next
                case (KStoptr x4)
                then have accO:"accessStore x1 (stack st) = Some( KStoptr x4)"
                  using Some 1 by auto
                then obtain struct where structDef: "t = Storage struct" 
                  using 8(2) unfolding TypeSafe_def typeCompat_def using tc1 Some KStoptr Stackloc 
                  by (cases t, force,  fastforce, fastforce, auto)
                obtain tprnt lprnt where tprntDef: "((Storage tprnt, Storeloc lprnt) |\<in>| fmran (denvalue e) \<and> CompStoType tprnt struct lprnt x4)" 
                  using 8(4) using accO tc1 unfolding fullyInitialised_def 
                  using Stackloc structDef by blast
                
                then have "SCon tprnt lprnt (storage st'' (address e))"
                  using ctoDef IH1 fi4 accessStore_def accessStore_updateStore  
                  unfolding StateInvariant_def TypeSafe_def safeContract_def by metis
                then have "SCon struct x4 (storage st'' (address e))"
                  using tprntDef SCon_imps_sublocs by blast
                then show ?thesis using Stackloc Some KStoptr structDef storageFinal by simp
              qed
            qed
          next
            case (Storeloc x2)
            then obtain struct where structDef: "t = Storage struct" 
              using 8(2) tc1 unfolding TypeSafe_def typeCompat_def by (cases t,fastforce+)

            then have "SCon struct x2 (storage st'' (address e))"
              using ctoDef IH1  fi4 accessStore_def accessStore_updateStore unfolding StateInvariant_def TypeSafe_def safeContract_def
              by metis
            then show ?thesis using Storeloc structDef 
              by (simp add: storageFinal)
          qed
        qed
      qed
    next 
      show "fullyInitialised e (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address e)) = Some (Contract c) \<and> contract e = c"
          using atype_same "8.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
      next 
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using 8(4) unfolding fullyInitialised_def by blast
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack st') = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p"
          using 8(4) unfolding fullyInitialised_def using 1 by auto
      qed

    qed
  next
    case (2 v t g adv g' v' acc)
    then have a1:"assert Gas (\<lambda>st. costs (TRANSFER ad ex) e cd st < gas st) st = Normal ((), st)" by simp
    have a10:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>) st = Normal ((), st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>)"
      by simp
    have a20:"toState (local.expr ad e cd) (st\<lparr>gas := gas st - costs (TRANSFER ad ex) e cd st\<rparr>) = Normal ((KValue adv, Value TAddr), st\<lparr>gas := g\<rparr>)" 
      using 2 by simp
    then have a30:"(case (KValue adv, Value TAddr) of (KValue adv, Value TAddr) \<Rightarrow> return adv | (KValue adv, Value _) \<Rightarrow> throw Err | (KValue adv, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err)
     (st\<lparr>gas := g\<rparr>) = Normal (adv, st\<lparr>gas := g\<rparr>)" using 2 by simp
    have a40:" toState (local.expr ex e cd) (st\<lparr>gas := g\<rparr>) = Normal ((KValue v, Value t), st\<lparr>gas := g'\<rparr>)" using 2 by auto
    have a50:"(case (KValue v, Value t) of (KValue v, Value t) \<Rightarrow> return (v, t) | (KValue v, _) \<Rightarrow> throw Err | (_, b) \<Rightarrow> throw Err) (st\<lparr>gas := g'\<rparr>) = Normal ((v, t), (st\<lparr>gas := g'\<rparr>))"
      using 2 by simp
    then have a60:"option Err (\<lambda>_. convert t (TUInt b256) v) (st\<lparr>gas := g'\<rparr>) = Normal (v', st\<lparr>gas := g'\<rparr>)" using 2 by simp
    have a70:"applyf accounts (st\<lparr>gas := g'\<rparr>) = Normal (accounts (st\<lparr>gas := g\<rparr>), (st\<lparr>gas := g'\<rparr>))" using 2 by simp
    have a90:"option Err (\<lambda>st. transfer (address e) adv v' (accounts st)) (st\<lparr>gas := g'\<rparr>) = Normal (acc, (st\<lparr>gas := g'\<rparr>))"
      using 2 by simp

    have svv':"svalueTypes v'" unfolding svalueTypes_def
      using 2(4,3) 8(2) 8(4)   
      using exprTypeconInduct(3)[of ex e cd "(st\<lparr>gas := g\<rparr>)" g "KValue v" "Value t" g']
        typeSafeConvert[of t v "(TUInt b256)"] convertSame by auto

    have btACC:"balanceTypes acc"  unfolding balanceTypes_def
    proof - 
      have old:"balanceTypes (accounts (st\<lparr>gas := g'\<rparr>))" using 8(2) unfolding TypeSafe_def by simp
      have accExp:"(case subBalance (address e) v' (accounts (st)) of None \<Rightarrow> None | Some x \<Rightarrow> addBalance adv v' x) = Some acc" 
        using 2(6) unfolding transfer_def by blast
      have v'TC: "typeCon (TUInt b256) v'" 
        using  svv' unfolding svalueTypes_def by blast

      show "\<forall>adv'. typeCon (TUInt b256) (bal (acc adv')) "
      proof(cases "adv = (address e)")
        case same:True
        show ?thesis using transfer_sameRead 
          by (metis "2"(6) "8"(2) balanceTypes_def same statement_with_gas.typeSafeAccounts statement_with_gas_axioms transfer_eq v'TC)
      next
        case notSame:False
        show ?thesis 
        proof
          fix adv'
          show "typeCon (TUInt b256) (bal (acc adv')) "
          proof(cases "adv' = (address e)")
            case True
            then have tco:"typeCon (TUInt b256) (bal ((accounts (st\<lparr>gas := g'\<rparr>)) adv'))"
              using True old accExp balanceTypes_def by blast
            have "bal (acc (address e)) = ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) (address e))) - (ReadL\<^sub>i\<^sub>n\<^sub>t v'))" 
              using transfer_subRead[OF 2(6) _ v'TC ] True notSame tco by auto
            then show ?thesis using True 
              using "2"(6,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv'))\<close> checkUInt_def transfer_val1 transfer_val2
              by (smt (verit, ccfv_SIG) notSame typeCon.simps(2) transfer_sub transfer_val3)
          next
            case False
            then show ?thesis 
            proof(cases "adv' = adv")
              case True
              then have "typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))"
                using True old accExp balanceTypes_def by simp
              then have "bal (acc adv) = (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                using transfer_addRead[OF 2(6)_ v'TC  ] 2(3) notSame by auto
              then show ?thesis using True 
                using "2"(6,3) Read_ShowL_id \<open>typeCon (TUInt b256) (bal (accounts (st\<lparr>gas := g'\<rparr>) adv))\<close> checkUInt_def transfer_val1 transfer_val2 notSame by auto
            next
              case f2:False
              then show ?thesis using False transfer_eq[OF 2(6)] old 
                using balanceTypes_def by force
            qed
          qed
        qed
      qed
    qed

    have accfinal:"accounts st'= acc" using 2 by simp

    have sameStores:"storage st' = storage st \<and> memory st = memory st' \<and> stack st = stack st'" using 2 by simp
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" unfolding AddressTypes_def
        proof intros
          fix c adv ct dud
          assume *:"type (accounts st' adv) = Some (Contract c)"
          then show "ep $$ c = Some (ct, dud)" using 8(2) unfolding TypeSafe_def using accfinal 2(6) transfer_type_same 

            by (metis AddressTypes_def)
          show "addressFormat adv " using 8(2) unfolding TypeSafe_def using accfinal 2(6) transfer_type_same *
            by (metis AddressTypes_def)
        qed
      next 
        show "safeContract (storage st')" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next 
        show "unique_locations (denvalue e)" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next
        show "compPointers (stack st') (denvalue e)" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next
        show "compMemPtrs (stack st') (memory st') (denvalue e)" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next 
        show "methodVarsNoPref"  using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using btACC accfinal by simp
      next 
        show "addressFormat (address e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next
        show "lessThanTopLocs cd" using "8.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using 8(2) unfolding TypeSafe_def using sameStores by simp
      next 
        show "typeCompat (denvalue e) (stack st') (memory st') (storage st' (address e)) cd" 
          using 8(2) unfolding TypeSafe_def using sameStores by simp
      qed
    next 
      show "fullyInitialised e (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address e)) = Some (Contract c) \<and> contract e = c"
          using atype_same "8.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
      next 
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using 8(4) unfolding fullyInitialised_def by blast
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack st') = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p"
          using 8(4) unfolding fullyInitialised_def using 2 by auto
      qed

    qed
  qed
next
  case (9 id0 tp s e\<^sub>v cd st)
  show ?case 
  proof(cases rule:blockNone[OF 9(3)])
    case (1 cd' mem' sck' e')
    have a10:"assert Gas (\<lambda>st. costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st < gas st) st = Normal ((), st)" using 1 by simp
    obtain sgas where sgasDef:"sgas = gas st - costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st" by simp
    then have a20:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st\<rparr>) st = Normal ((), (st\<lparr>gas := sgas\<rparr> ))" by simp
    have a30:"option Err (\<lambda>st. decl id0 tp None False cd (memory st) (storage st (address e\<^sub>v)) (cd, memory st, stack st, e\<^sub>v)) (st\<lparr>gas := sgas\<rparr> )
            = Normal ((cd', mem', sck', e'), (st\<lparr>gas := sgas\<rparr> )) " using 1 by simp
    have a40:"modify (\<lambda>st. st\<lparr>stack := sck', memory := mem'\<rparr>) (st\<lparr>gas := sgas\<rparr>) = Normal ((), st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)"
      by simp

    have tsDecl:"TypeSafe e' (accounts (st\<lparr>gas := gas st - costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st\<rparr>)) sck' mem'
     (storage (st\<lparr>gas := gas st - costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st\<rparr>)) cd' \<and>
    (\<forall>x l. (\<nexists>y y'. x = Memory y \<or> x = Value y') \<and> (x, l) |\<in>| fmran (denvalue e') \<longrightarrow>
           (x, l) |\<in>| fmran (denvalue e\<^sub>v)) \<and>
    (\<forall>sckl ptr.
        accessStore sckl sck' = Some ptr \<and> (\<nexists>y y'. ptr = KMemptr y \<or> ptr = KValue y') \<longrightarrow>
        accessStore sckl (stack (st\<lparr>gas := gas st - costs (BLOCK ((id0, tp), None) s) e\<^sub>v cd st\<rparr>)) =
        Some ptr) \<and>
    cd = cd'"
      using typeSafeDeclNone[OF _ 1(2)] 9(2) by simp

    then have a50:"TypeSafe e' (accounts (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)) (stack (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>))
   (memory (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)) (storage (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)) cd'" by simp
    have denLink:"\<forall>ii x. denvalue e\<^sub>v $$ ii = Some x \<longrightarrow> denvalue e' $$ ii = Some x" using decl_env_monotonic[OF 1(2)] by auto

    have fiDec:" fullyInitialised e' (accounts (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)) (stack (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>))" 
      unfolding fullyInitialised_def
    proof intros
      have sameStuff:"address e' = address e\<^sub>v \<and> contract e' = contract e\<^sub>v" using 1(2) decl_env by simp
      then show "\<exists>c. type (accounts (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>) (address e')) = Some (Contract c) \<and> contract e' = c"
        using 9(4) unfolding fullyInitialised_def by simp 
      show "\<And>id ct dud v. (ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id))"
        using sameStuff "1"(2) "9.prems"(1,3) tsDecl decl_env_monotonic fmranI 
        unfolding AddressTypes_def  fullyInitialised_def TypeSafe_def 
        by (smt (z3) fmupd_lookup)
      fix t l p 
      assume in1:"(Storage t, Stackloc l) |\<in>| fmran (denvalue e') \<and> accessStore l (stack (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>)) = Some (KStoptr p)"
      then have "(Storage t, Stackloc l) |\<in>| fmran (denvalue e\<^sub>v)" using tsDecl by simp

      moreover have "accessStore l (stack st) = Some (KStoptr p)" using tsDecl in1 by simp
      ultimately have "(\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t l' p)"
        using  9(4)  unfolding fullyInitialised_def  by simp
      then obtain t' l' where cp:"(Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t l' p" by auto
      moreover have "(\<forall>t id' loc. denvalue e\<^sub>v $$ id' = Some (Storage t, Storeloc loc) \<longrightarrow> denvalue e' $$ id' = Some (Storage t, Storeloc loc))"
        using decl_env_monotonic[OF 1(2)] by simp
      moreover obtain idp where "(denvalue e\<^sub>v) $$ idp = Some (Storage t', Storeloc l') " 
        using calculation(1) by auto
      ultimately have "(denvalue e\<^sub>v) $$ idp = Some (Storage t', Storeloc l')" by blast
      then have "(Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t l' p"
        using cp 
        by (meson
            \<open>\<forall>t id' loc. denvalue e\<^sub>v $$ id' = Some (Storage t, Storeloc loc) \<longrightarrow> denvalue e' $$ id' = Some (Storage t, Storeloc loc)\<close>
            fmlookup_ran_iff)
      then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t l' p" by auto

    qed

    have IH1:"StateInvariant e' (st\<lparr>gas := sgas, stack := sck', memory := mem'\<rparr>) st' cd'" 
      using 9(1)[OF a10 a20 a30, of cd' "(mem', sck', e')" mem' "(sck', e')" sck' e', OF _ _ _ a40 a50 _ fiDec, of st'] 1(3) sgasDef by simp
    then have fiFinal:" fullyInitialised e' (accounts st') (stack st')" 
      unfolding StateInvariant_def by blast
    have sameAdd:"address e' = address e\<^sub>v" using 1(2) decl_env by simp
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e\<^sub>v (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "safeContract (storage st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "unique_locations (denvalue e\<^sub>v)" using 9(2) unfolding TypeSafe_def by simp
      next
        have cpNew:"(\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
       (Storage tp1, l1) |\<in>| fmran (denvalue e') \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e') \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
       (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
          using IH1 unfolding StateInvariant_def TypeSafe_def compPointers_def by auto
        show "compPointers (stack st') (denvalue e\<^sub>v)" unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume a0:"(Storage tp1, l1) |\<in>| fmran (denvalue e\<^sub>v) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e\<^sub>v) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then obtain i1 i2 where iDefs:" (denvalue e\<^sub>v) $$ i1 = Some (Storage tp1, l1)
                                  \<and>  (denvalue e\<^sub>v) $$ i2 = Some (Storage tp2, l2)" by blast
          then have "(Storage tp1, l1) |\<in>| fmran (denvalue e') \<and> (Storage tp2, l2) |\<in>| fmran (denvalue e')" using a0 
            by (metis denLink fmlookup_ran_iff)
          then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 
                else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
            using cpNew using a0 by blast
        qed
      next
        have " compMemPtrs (stack st') (memory st') (denvalue e')" 
          using IH1 unfolding StateInvariant_def TypeSafe_def by blast
        then show "compMemPtrs (stack st') (memory st') (denvalue e\<^sub>v)" unfolding compMemPtrs_def using denLink 
          by (meson fmlookup_ran_iff)
      next 
        show "methodVarsNoPref"  using "9.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "addressFormat (address e\<^sub>v)" using 9(2) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e\<^sub>v)" using 9(2) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e\<^sub>v)" using 9(2) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next
        show "lessThanTopLocs cd" using 9(2) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        have oldTC:"typeCompat (denvalue e') (stack st') (memory st') (storage st' (address e')) cd'"
          using IH1 unfolding StateInvariant_def TypeSafe_def by blast
        show "typeCompat (denvalue e\<^sub>v) (stack st') (memory st') (storage st' (address e\<^sub>v)) cd" 
          unfolding typeCompat_def 
        proof intros
          fix t l
          assume inDen:"(t, l) |\<in>| fmran (denvalue e\<^sub>v)"
          then have inDenN:"(t, l) |\<in>| fmran (denvalue e')"
            using denLink by (meson fmlookup_ran_iff)

          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e\<^sub>v)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e\<^sub>v)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            then have oldTC':"(
             case accessStore x1 (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e')) | _ \<Rightarrow> False))"
              using oldTC unfolding typeCompat_def using inDenN by fastforce
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Stackloc by fastforce
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Some Stackloc by force
              next
                case (KCDptr x2)
                then obtain struct where structDef:"t = Calldata struct \<and> MCon struct cd' x2"
                  using oldTC' unfolding typeCompat_def using inDenN sameAdd Some Stackloc by (cases t; auto)
                then show ?thesis using tsDecl KCDptr Some Stackloc by simp
              next
                case (KMemptr x3)
                then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Some Stackloc by fastforce
              next
                case (KStoptr x4)
                then have "case t of Storage struct \<Rightarrow> SCon struct x4 (storage st' (address e')) | _ \<Rightarrow> False"
                  using oldTC' using inDenN sameAdd Some Stackloc by (auto split:option.splits Type.splits Stackvalue.splits Denvalue.splits)
                then obtain struct where "t = Storage struct \<and> SCon struct x4 (storage st' (address e'))" by (cases t; auto)
                then show ?thesis using Some Stackloc KStoptr 
                  by (simp add: sameAdd)
              qed
            qed
          next
            case (Storeloc x2)
            then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd 
              by (metis (no_types, lifting) Denvalue.simps(6) Type.exhaust Type.simps(17,18,19,20))
          qed
        qed
      qed
    next 
      show "fullyInitialised e\<^sub>v (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address e\<^sub>v)) = Some (Contract c) \<and> contract e\<^sub>v = c"
          using atype_same "9.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
      next 
        show "\<And>id ct dud v. (ep $$ contract e\<^sub>v = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>v $$ id = Some (Storage v, Storeloc id))" 
          using 9(4) unfolding fullyInitialised_def by blast
      next 
        fix t''' l''' p'''
        assume in1:"(Storage t''', Stackloc l''') |\<in>| fmran (denvalue e\<^sub>v)\<and> accessStore l''' (stack st') = Some (KStoptr p''')"
        have llink:"(\<forall>t id' loc. denvalue e\<^sub>v $$ id' = Some (Storage t, loc) \<longrightarrow> denvalue e' $$ id' = Some (Storage t, loc))"
          using decl_env_monotonic[OF 1(2)] by simp
        obtain i where "(denvalue e\<^sub>v) $$ i  = Some (Storage t''', Stackloc l''')" using in1 by auto
        then have "(Storage t''', Stackloc l''') |\<in>| fmran (denvalue e')"
          using llink by (meson fmranI)
        then obtain t' l' where t'Def:"(Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t''' l' p'''"
          using fiDec fiFinal unfolding fullyInitialised_def using in1  by blast
        then have "(Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v)" 
          using "1"(2) decl_env_not_i decl_env_storlocs_unchanged fmlookup_ran_iff by fastforce
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t''' l' p'''"
          using t'Def by auto
      qed
    qed
  qed
next
  case (10 id0 tp ex' s e\<^sub>v cd st)
  show ?case 
  proof(cases rule:blockSome[OF 10(3)])
    case (1 v t g cd' mem' sck' e')
    have a10:"assert Gas (\<lambda>st. costs (BLOCK ((id0, tp), Some ex') s) e\<^sub>v cd st < gas st) st = Normal ((), st)" using 1 by simp
    obtain sgas where sgasDef:"sgas = gas st - costs (BLOCK ((id0, tp), Some ex') s) e\<^sub>v cd st" by simp
    then have a20:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (BLOCK ((id0, tp), Some ex') s) e\<^sub>v cd st\<rparr>) st = Normal ((), (st\<lparr>gas := sgas\<rparr> ))" by simp
    have a25:"toState (local.expr ex' e\<^sub>v cd) (st\<lparr>gas := sgas\<rparr> ) = Normal ((v, t), (st\<lparr>gas := g\<rparr>))" using 1 sgasDef by auto
    have a30:"option Err (\<lambda>st. decl id0 tp (Some (v, t)) False cd (memory st) (storage st (address e\<^sub>v)) (cd, memory st, stack st, e\<^sub>v)) (st\<lparr>gas := g\<rparr> )
            = Normal ((cd', mem', sck', e'), (st\<lparr>gas := g\<rparr> )) " using 1 by simp
    have a40:"modify (\<lambda>st. st\<lparr>stack := sck', memory := mem'\<rparr>) (st\<lparr>gas := g\<rparr>) = Normal ((), st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)"
      by simp

    have "(\<exists>c. type (accounts st (address e\<^sub>v)) = Some (Contract c) \<and> contract e\<^sub>v = c) \<and>
    (\<forall>id ct dud v. (ep $$ contract e\<^sub>v = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>v $$ id = Some (Storage v, Storeloc id))) \<and>
    (\<forall>t l p.
        (Storage t, Stackloc l) |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore l (stack st) = Some (KStoptr p) \<longrightarrow>
        (\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t l' p))"
      using sgasDef 10(4) unfolding fullyInitialised_def by simp
    moreover have "fullyInitialised e\<^sub>v (accounts (st\<lparr>gas := sgas\<rparr>)) (stack (st\<lparr>gas := sgas\<rparr>))" 
      by (simp add: "10.prems"(3))
    moreover have tsSgas:"TypeSafe e\<^sub>v (accounts (st\<lparr>gas := sgas\<rparr>)) (stack (st\<lparr>gas := sgas\<rparr>)) (memory (st\<lparr>gas := sgas\<rparr>)) (storage (st\<lparr>gas := sgas\<rparr>)) cd" using 10(2) by simp
    ultimately have tcTV:"case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) \<and> (\<exists>xx. v = KValue xx)
    | Calldata struct \<Rightarrow>
        MCon struct cd (extractValueType v) \<and>
        (\<exists>xx. v = KCDptr xx) \<and>
        (\<exists>stloc tp'' p.
            (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
            accessStore stloc (stack (st\<lparr>gas := sgas\<rparr>)) = Some (KCDptr p) \<and>
            (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))
    | Memory struct \<Rightarrow>
        MCon struct (memory (st\<lparr>gas := sgas\<rparr>)) (extractValueType v) \<and>
        (\<exists>xx. v = KMemptr xx) \<and>
        (\<exists>stloc tp'' p.
            (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
            accessStore stloc (stack (st\<lparr>gas := sgas\<rparr>)) = Some (KMemptr p) \<and>
            (tp'' = struct \<and> v = KMemptr p \<or>
             (\<exists>len arr. extractValueType v \<noteq> p \<and> tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := sgas\<rparr>)) len arr struct p (extractValueType v))))
    | Storage struct \<Rightarrow>
        SCon struct (extractValueType v) (storage (st\<lparr>gas := sgas\<rparr>) (address e\<^sub>v)) \<and>
        (\<exists>xx. v = KStoptr xx) \<and>
        (\<exists>stloc tp''.
            (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
            (tp'' = struct \<and> v = KStoptr stloc \<or>
             extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))" 
      using 1(2) exprTypeconInduct(3)[of ex' "e\<^sub>v" cd "st\<lparr>gas := sgas\<rparr>" sgas v t g] sgasDef by blast
    then have tcTV':"case t of Value typ \<Rightarrow> typeCon typ (extractValueType v) | Calldata struct \<Rightarrow> MCon struct cd (extractValueType v)
    | Memory struct \<Rightarrow> MCon struct (memory (st\<lparr>gas := g\<rparr>)) (extractValueType v)
    | Storage struct \<Rightarrow> SCon struct (extractValueType v) (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v))" 
      by (cases t, simp+)

    have tsDecl:"TypeSafe e' (accounts (st\<lparr>gas := g\<rparr>)) sck' mem' (storage (st\<lparr>gas := g\<rparr>)) cd' \<and>
    (\<not> False \<longrightarrow>
     (\<forall>locs tp. MCon tp (memory (st\<lparr>gas := g\<rparr>)) locs \<longrightarrow> MCon tp mem' locs) \<and>
     ncpDenvalueLimit e' e\<^sub>v sck' (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) \<and>
     ncpOMemInDMem (memory (st\<lparr>gas := g\<rparr>)) mem' \<and> ncpElementsNoSubPref (memory (st\<lparr>gas := g\<rparr>)) mem' 
\<and> ncpNewSelfPoint (memory (st\<lparr>gas := g\<rparr>)) mem') \<and> toploc (memory (st\<lparr>gas := g\<rparr>)) \<le> toploc mem'"
    proof -
      have tsgas:"TypeSafe e\<^sub>v (accounts (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>)) cd"
        using 10(2) by simp
      have "ncpDenvalueLimit e\<^sub>v e\<^sub>v (stack (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>))" 
        unfolding ncpDenvalueLimit_def by auto
      moreover have "ncpOMemInDMem (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>))" unfolding ncpOMemInDMem_def by auto
      moreover have "ncpElementsNoSubPref (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>))"
        using ncpElementsNoSubPref_def ncpElementsNoSubPref_sameMem tsgas by blast
      moreover have "ncpNewSelfPoint (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>))"
        unfolding ncpNewSelfPoint_def by auto
      ultimately have acc0:"\<not> False \<longrightarrow>
    (\<forall>locs tp. MCon tp (memory (st\<lparr>gas := g\<rparr>)) locs \<longrightarrow> MCon tp (memory (st\<lparr>gas := g\<rparr>)) locs) \<and>
    toploc (memory (st\<lparr>gas := g\<rparr>)) \<le> toploc (memory (st\<lparr>gas := g\<rparr>)) \<and>
    ncpDenvalueLimit e\<^sub>v e\<^sub>v (stack (st\<lparr>gas := g\<rparr>)) (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) \<and>
    ncpOMemInDMem (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) \<and>
    ncpElementsNoSubPref (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) \<and> ncpNewSelfPoint (memory (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>))" by blast
      have acc1:"\<forall>struct.
     t = Memory struct \<longrightarrow>
     (\<exists>stloc tp'' p.
         (Memory tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
         accessStore stloc (stack (st\<lparr>gas := g\<rparr>)) = Some (KMemptr p) \<and>
         (tp'' = struct \<and> v = KMemptr p \<or>
          (\<exists>len arr. p \<noteq> extractValueType v \<and> tp'' = MTArray len arr \<and> CompMemType (memory (st\<lparr>gas := g\<rparr>)) len arr struct p (extractValueType v))))"
        using tcTV by (cases t, blast+; fastforce) 
      have acc2:"\<forall>struct.
     t = Calldata struct \<longrightarrow>
     (\<exists>stloc tp'' p.
         (Calldata tp'', Stackloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
         accessStore stloc (stack (st\<lparr>gas := g\<rparr>)) = Some (KCDptr p) \<and>
         (tp'' = struct \<and> v = KCDptr p \<or> (\<exists>len arr. p \<noteq> extractValueType v \<and> tp'' = MTArray len arr \<and> CompMemType cd len arr struct p (extractValueType v))))"
        using tcTV by (cases t, blast+; fastforce) 
      have acc3:"\<forall>struct.
       tp = Storage struct \<longrightarrow>
       (\<forall>locs tp. SCon tp locs (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v)) \<longrightarrow> SCon tp locs (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v))) \<and>
       (\<exists>stloc tp''.
           (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
           (tp'' = struct \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' struct stloc (extractValueType v)))"
        using tcTV
      proof(cases t)
        case (Value x1)
        then have "\<forall>struct. tp \<noteq> Storage struct " using 1(3)  decl_KValue_tp_match 
          by blast
        then show ?thesis by simp
      next
        case (Calldata x2)
        then have "\<forall>struct. tp \<noteq> Storage struct " using 1(3)  decl_Calldata_tp_match 
          by blast
        then show ?thesis by simp
      next
        case (Memory x3)
        then have "\<forall>struct. tp \<noteq> Storage struct " using 1(3)  decl_Memory_tp_match 
          by blast
        then show ?thesis by simp
      next
        case (Storage x4)
        then have sc:"SCon x4 (extractValueType v) (storage (st\<lparr>gas := sgas\<rparr>) (address e\<^sub>v)) \<and>
              (\<exists>xx. v = KStoptr xx) \<and>
              (\<exists>stloc tp''.
                  (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
                  tp'' = x4 \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v))" 
          using tcTV by auto
        have tt:"(\<exists>x t' t''. x4 = STArray x t' \<and> cps2mTypeCompatible (STArray x t') (MTArray x t'')\<and> tp = Memory (MTArray x t''))  \<or> tp = Storage x4" 
          using decl_Memory_tp_options[] 1(3) Storage by simp
        then show ?thesis 
        proof(cases "tp = Storage x4")
          case True
          moreover have "(\<forall>locs tp. SCon tp locs (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v)) \<longrightarrow> SCon tp locs (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v)))" by auto
          moreover have "(stack (st\<lparr>gas := sgas\<rparr>)) = (stack (st\<lparr>gas := g\<rparr>))" by auto
          then have "(\<exists>stloc tp''.
           (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
           tp'' = x4 \<and> v = KStoptr stloc \<or> extractValueType v \<noteq> stloc \<and> CompStoType tp'' x4 stloc (extractValueType v))" 
            using sc True Storage by presburger
          ultimately show ?thesis 
            using Storage tcTV by auto
        next
          case False
          then have "(\<exists>x t' t''. x4 = STArray x t' \<and> cps2mTypeCompatible (STArray x t') (MTArray x t'')\<and> tp = Memory (MTArray x t''))"
            using tt by simp
          then show ?thesis by auto
        qed
      qed
      have " TypeSafe e' (accounts (st\<lparr>gas := g\<rparr>)) sck' mem' (storage (st\<lparr>gas := g\<rparr>)) cd' \<and>
    (\<not> False \<longrightarrow>
     (\<forall>locs tp. MCon tp (memory (st\<lparr>gas := g\<rparr>)) locs \<longrightarrow> MCon tp mem' locs) \<and>
     toploc (memory (st\<lparr>gas := g\<rparr>)) \<le> toploc mem' \<and>
     ncpDenvalueLimit e' e\<^sub>v sck' (stack (st\<lparr>gas := g\<rparr>)) (memory (st\<lparr>gas := g\<rparr>)) \<and>
     ncpOMemInDMem (memory (st\<lparr>gas := g\<rparr>)) mem' \<and>
     ncpElementsNoSubPref (memory (st\<lparr>gas := g\<rparr>)) mem' \<and>
     ncpNewSelfPoint (memory (st\<lparr>gas := g\<rparr>)) mem')
    "
        using typeSafeDecl[OF tsgas tcTV' tsgas 1(3) acc0 acc1 acc2 ] acc3 by fastforce
      then show ?thesis by simp
    qed

    

    then have a50:"TypeSafe e' (accounts (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) (stack (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>))
   (memory (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) (storage (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) cd'" 
      using tsDecl by simp

    have fiDec:" fullyInitialised e' (accounts (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) (stack (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>))" unfolding fullyInitialised_def
    proof intros
      have sameStuff:"address e' = address e\<^sub>v \<and> contract e' = contract e\<^sub>v" using 1(3) decl_env by simp
      then show "\<exists>c. type (accounts (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>) (address e')) = Some (Contract c) \<and> contract e' = c"
        using 10(4) unfolding fullyInitialised_def by simp 
      show "\<And>id ct dud v. (ep $$ contract e' = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e' $$ id = Some (Storage v, Storeloc id))"
        using sameStuff tsDecl 
        by (smt (z3) "1"(3)
            \<open>(\<exists>c. type (accounts st (address e\<^sub>v)) = Some (Contract c) \<and> contract e\<^sub>v = c) \<and> (\<forall>id ct dud v. (ep $$ contract e\<^sub>v = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>v $$ id = Some (Storage v, Storeloc id))) \<and> (\<forall>t l p. (Storage t, Stackloc l) |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore l (stack st) = Some (KStoptr p) \<longrightarrow> (\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t l' p))\<close>
            decl_env_not_i decl_env_storlocs_unchanged fmempty.rep_eq option.distinct(1))


      fix tt l p 
      assume in1:"(Storage tt, Stackloc l) |\<in>| fmran (denvalue e')\<and>accessStore l (stack (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) = Some (KStoptr p)"
      then obtain idd where iddDef: "denvalue e' $$ idd = Some (Storage tt, Stackloc l)" by auto
      then show " \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' tt l' p" 
      proof(cases "idd = id0")
        case True
        then have ddd:"denvalue e' $$ id0 = Some (Storage tt, Stackloc l)" using iddDef by simp
        then show ?thesis  
        proof(cases "denvalue e\<^sub>v $$ id0")
          case None

          have ldef:"l = (ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (stack (st\<lparr>gas := g\<rparr>))))" using decl_stack_top[OF 1(3) None] iddDef True by simp

          then obtain p2 where p2Def:"Some (v, t) = Some (KStoptr p2, Storage tt)"
            using ddd True decl_storage_tp[OF 1(3) None, of tt ] by blast
          then have dcc:"decl id0 tp (Some (KStoptr p2, Storage tt)) False cd (memory (st\<lparr>gas := g\<rparr>)) (storage (st\<lparr>gas := g\<rparr>) (address e\<^sub>v))
     (cd, memory (st\<lparr>gas := g\<rparr>), stack (st\<lparr>gas := g\<rparr>), e\<^sub>v) =
    Some (cd', mem', sck', e')" using 1(3) True by simp
          then have "v = KStoptr p" using decl_stack_topLoc[OF dcc None] using in1 ldef p2Def by auto  
          then have "(\<exists>stloc tp''.
          (Storage tp'', Storeloc stloc) |\<in>| fmran (denvalue e\<^sub>v) \<and>
          (tp'' = tt \<and> v = KStoptr stloc \<or> p \<noteq> stloc \<and> CompStoType tp'' tt stloc p))" 
            using tcTV 1(3) p2Def by auto
          then show ?thesis using decl_env_monotonic[OF 1(3)] 
            by (metis CompStoType_sameLocNdTyp Stackvalue.inject(4) \<open>v = KStoptr p\<close> fmlookup_ran_iff)
        next
          case (Some a)
          then have "e\<^sub>v = e' \<and> sck' = stack st" using  decl_some_same[OF 1(3)] by auto
          then show ?thesis using 10(4) unfolding fullyInitialised_def using in1  by simp
        qed
      next
        case False
        then have oldD:"denvalue e\<^sub>v $$ idd = Some (Storage tt, Stackloc l)" 
          using iddDef in1 1 decl_env_not_i[OF 1(3)] by blast

        then show ?thesis 
        proof(cases "l = ShowL\<^sub>n\<^sub>a\<^sub>t (toploc (stack st))")
          case True
          then show ?thesis 
            by (metis "10.prems"(1) True oldD snd_conv statement_with_gas.stackLocs_imp_NotDen statement_with_gas_axioms TypeSafe_def)
        next
          case False
          then have "accessStore l (stack (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>)) = accessStore l (stack (st))"
            using decl_stack_change[OF 1(3)] by simp
          then obtain t' l' where t'Def: "(Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' tt l' p"
            using 10(4) oldD in1 unfolding fullyInitialised_def 
            by (metis fmranI)
          then have "(Storage t', Storeloc l') |\<in>| fmran (denvalue e')"
            using decl_env_monotonic[OF 1(3)] by (meson fmlookup_ran_iff)
          then show ?thesis using t'Def by auto
        qed
      qed

    qed
    have sameCD:"cd = cd'" using decl_env_false_same_cd[OF 1(3)] by simp
    have IH1:" StateInvariant e' (st\<lparr>gas := g, stack := sck', memory := mem'\<rparr>) st' cd'" 
      using 10(1)[OF a10 a20 a25 _ a30, of  cd' "(mem', sck', e')" mem' "(sck', e')" sck' e', OF _ _ _ _ a40 a50 _ fiDec, of st'] 1(4) sgasDef by simp

    have denLink:"\<forall>ii x. denvalue e\<^sub>v $$ ii = Some x \<longrightarrow> denvalue e' $$ ii = Some x" using decl_env_monotonic[OF 1(3)] by auto
    have sameAdd:"address e' = address e\<^sub>v"using 1(3) decl_env by simp
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e\<^sub>v (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        show "AddressTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "safeContract (storage st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "unique_locations (denvalue e\<^sub>v)" using 10(2) unfolding TypeSafe_def by simp
      next
        have cpNew:"(\<forall>tp1 tp2 l1 l2 l1' l2' stl1 stl2.
       (Storage tp1, l1) |\<in>| fmran (denvalue e') \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e') \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2) \<longrightarrow>
       (if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True))"
          using IH1 unfolding StateInvariant_def TypeSafe_def compPointers_def by auto
        show "compPointers (stack st') (denvalue e\<^sub>v)" unfolding compPointers_def
        proof intros
          fix tp1 tp2 l1 l2 l1' l2' stl1 stl2
          assume a0:"(Storage tp1, l1) |\<in>| fmran (denvalue e\<^sub>v) \<and>
       (Storage tp2, l2) |\<in>| fmran (denvalue e\<^sub>v) \<and>
       (l1 = Stackloc l1' \<and> accessStore l1' (stack st') = Some (KStoptr stl1) \<or> l1 = Storeloc stl1) \<and>
       (l2 = Stackloc l2' \<and> accessStore l2' (stack st') = Some (KStoptr stl2) \<or> l2 = Storeloc stl2)"
          then obtain i1 i2 where iDefs:" (denvalue e\<^sub>v) $$ i1 = Some (Storage tp1, l1)
                                  \<and>  (denvalue e\<^sub>v) $$ i2 = Some (Storage tp2, l2)" by blast
          then have "(Storage tp1, l1) |\<in>| fmran (denvalue e') \<and> (Storage tp2, l2) |\<in>| fmran (denvalue e')" using a0 
            by (metis denLink fmlookup_ran_iff)
          then show "if TypedStoSubpref stl2 stl1 tp1 then CompStoType tp1 tp2 stl1 stl2 
                else if TypedStoSubpref stl1 stl2 tp2 then CompStoType tp2 tp1 stl2 stl1 else True" 
            using cpNew using a0 by blast
        qed
      next
        have " compMemPtrs (stack st') (memory st') (denvalue e')" 
          using IH1 unfolding StateInvariant_def TypeSafe_def by blast
        then show "compMemPtrs (stack st') (memory st') (denvalue e\<^sub>v)" unfolding compMemPtrs_def using denLink 
          by (meson fmlookup_ran_iff) 
      next 
        show "methodVarsNoPref"  using "10.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        show "addressFormat (address e\<^sub>v)" using 10(2) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e\<^sub>v)" using 10(2) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e\<^sub>v)" using 10(2) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next
        show "lessThanTopLocs cd" using 10(2) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using IH1 unfolding StateInvariant_def TypeSafe_def by blast
      next 
        have oldTC:"typeCompat (denvalue e') (stack st') (memory st') (storage st' (address e')) cd'"
          using IH1 unfolding StateInvariant_def TypeSafe_def by blast
        show "typeCompat (denvalue e\<^sub>v) (stack st') (memory st') (storage st' (address e\<^sub>v)) cd" 
          unfolding typeCompat_def 
        proof intros
          fix t l
          assume inDen:"(t, l) |\<in>| fmran (denvalue e\<^sub>v)"
          then have inDenN:"(t, l) |\<in>| fmran (denvalue e')"
            using denLink by (meson fmlookup_ran_iff)

          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e\<^sub>v)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e\<^sub>v)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            then have oldTC':"(
             case accessStore x1 (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd' stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e')) | _ \<Rightarrow> False))"
              using oldTC unfolding typeCompat_def using inDenN by fastforce
            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Stackloc by fastforce
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Some Stackloc by force
              next
                case (KCDptr x2)
                then obtain struct where structDef:"t = Calldata struct \<and> MCon struct cd' x2"
                  using oldTC' unfolding typeCompat_def using inDenN sameAdd Some Stackloc by (cases t; auto)
                then show ?thesis using tsDecl KCDptr Some Stackloc sameCD by simp
              next
                case (KMemptr x3)
                then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd Some Stackloc by fastforce
              next
                case (KStoptr x4)
                then have "case t of Storage struct \<Rightarrow> SCon struct x4 (storage st' (address e')) | _ \<Rightarrow> False"
                  using oldTC' using inDenN sameAdd Some Stackloc by (auto split:option.splits Type.splits Stackvalue.splits Denvalue.splits)
                then obtain struct where "t = Storage struct \<and> SCon struct x4 (storage st' (address e'))" by (cases t; auto)
                then show ?thesis using Some Stackloc KStoptr 
                  by (simp add: sameAdd)
              qed
            qed
          next
            case (Storeloc x2)
            then show ?thesis using oldTC unfolding typeCompat_def using inDenN sameAdd 
              by (metis (no_types, lifting) Denvalue.simps(6) Type.exhaust Type.simps(17,18,19,20))
          qed
        qed
      qed

    next 
      show "fullyInitialised e\<^sub>v (accounts st') (stack st')" unfolding fullyInitialised_def  
      proof intros
        show "\<exists>c. type (accounts st' (address e\<^sub>v)) = Some (Contract c) \<and> contract e\<^sub>v = c"
          using atype_same "10.prems"(2,3) fullyInitialised_def statement_with_gas.atype_same statement_with_gas_axioms by blast
        show "\<And>id ct dud v. (ep $$ contract e\<^sub>v = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>v $$ id = Some (Storage v, Storeloc id))" 
          using 10(4) unfolding fullyInitialised_def by blast
        fix t'' l'' p''
        assume a1:"(Storage t'', Stackloc l'') |\<in>| fmran (denvalue e\<^sub>v) \<and> accessStore l'' (stack st') = Some (KStoptr p'')"
        then have a5:"(Storage t'', Stackloc l'') |\<in>| fmran (denvalue e')" using tsDecl 

          by (meson "1"(3) decl_env_monotonic fmlookup_ran_iff)
        then obtain t' l' where t'Def:"(Storage t', Storeloc l') |\<in>| fmran (denvalue e') \<and> CompStoType t' t'' l' p''"
          using IH1 a1 unfolding StateInvariant_def fullyInitialised_def by blast
        then have "(Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v)" 
          using "1"(3) decl_env_storlocs_unchanged 
          using fmlookup_ran_iff decl_env_not_i by fastforce
        then show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>v) \<and> CompStoType t' t'' l' p''" using t'Def by auto
      qed

    qed
  qed
next
  case (11 i xe val e cd st)
  show ?case
  proof(cases rule:new[OF 11(3)])
    case (1 v t g ct cn fb e\<^sub>l cd\<^sub>l k\<^sub>l m\<^sub>l g' acc st'' v')
    then have a10:"assert Gas (\<lambda>st. costs (NEW i xe val) e cd st < gas st) st = Normal ((), st)" by simp
    let ?sgas = "st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>" 
    have a20:"modify (\<lambda>st. st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>) st = Normal ((), ?sgas)" by simp
    let ?newAdd = "hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts ?sgas (address e))))"
    have notSame:"(address e) \<noteq> ?newAdd" 
      by (metis hash_version_inequality)
    have formatAdd:"addressFormat (hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>) (address e)))))" 
      unfolding addressFormat_def typeCon.simps
    proof - 
      have "CHR ''.'' \<notin> set (literal.explode (address e))" 
        using 11(2) unfolding TypeSafe_def addressFormat_def typeCon.simps checkAddress_def by blast
      then have "CHR ''.'' \<notin> set (literal.explode (STR ''-'' + address e))" 
        by (simp add: Literal.rep_eq add_Literal_assoc)
      moreover have "CHR ''.'' \<notin> set (literal.explode (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>) (address e)))))"
        using ShowLNatDot by blast

      ultimately have "CHR ''.'' \<notin> set 
                      (literal.explode ((ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>) (address e)))) 
                      + (STR ''-'' + address e)))" 
        by (simp add: plus_literal.rep_eq)
      then show "checkAddress (hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>) (address e)))))"
        unfolding checkAddress_def hash_version_def by blast
    qed
    let ?updState = "st\<lparr>gas := g, accounts := (accounts st)((?newAdd) := \<lparr>bal = ShowL\<^sub>i\<^sub>n\<^sub>t 0, type = Some (Contract i), contracts = 0\<rparr>), 
                                                storage := (storage st)((?newAdd) := {$$})\<rparr>" 
    obtain uus where uusDef:"uus = ?updState" by blast
    have sameUpd:"memory ?updState = memory st \<and> stack ?updState = stack st" by auto
    have a30:"applyf (\<lambda>st. hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts st (address e))))) (?sgas) 
                    = Normal (hash_version (address e) (ShowL\<^sub>n\<^sub>a\<^sub>t (contracts (accounts ?sgas (address e)))) , (?sgas))" using 1 by auto
    have a40:" assert Err (\<lambda>st. type (accounts st ?newAdd) = None) (?sgas) 
                          = Normal ((), ?sgas)" using 1  by simp
    have a50:"toState (local.expr val e cd) (?sgas) = Normal ((KValue v, Value t), st\<lparr>gas := g\<rparr>)" using 1  by auto
    have a60:"(case (KValue v, Value t) of (KValue v, Value t) \<Rightarrow> return (v, t) | (KValue v, _) \<Rightarrow> throw Err 
                  | (_, b) \<Rightarrow> throw Err) (st\<lparr>gas := g\<rparr>) = Normal ((v,t), st\<lparr>gas := g\<rparr>)" using 1 by simp
    have a65:"option Err (\<lambda>_. convert t (TUInt b256) v) (st\<lparr>gas := g\<rparr>) = Normal (v', st\<lparr>gas := g\<rparr>)" using 1 by simp
    have a70:"option Err (\<lambda>_. ep $$ i) (st\<lparr>gas := g\<rparr>) = Normal ((ct, cn, fb), st\<lparr>gas := g\<rparr>)" using 1 by simp
    obtain folded where a80: "folded = ffold_init ct (emptyEnv (?newAdd) i (address e) v') (fmdom ct)"
      using 1 by blast
    have a90:"toState (local.load True (fst cn) xe folded emptyStore emptyStore emptyStore e cd) ?updState = Normal ((e\<^sub>l, cd\<^sub>l, k\<^sub>l, m\<^sub>l), ?updState\<lparr>gas := g'\<rparr>)"
      using 1  a80  by simp


    have a110:" option Err (\<lambda>st. transfer (address e) ?newAdd v' (accounts st)) (?updState\<lparr>gas:=g'\<rparr>) = Normal (acc, ?updState\<lparr>gas:=g'\<rparr>)"
      using 1   by auto
    have a120:"applyf (\<lambda>st. (stack st, memory st)) (?updState\<lparr>gas:=g'\<rparr>) = Normal ((stack st, memory st), ?updState\<lparr>gas:=g'\<rparr>)"
      by simp
    have a130:"modify (\<lambda>st'. st'\<lparr>accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) (?updState \<lparr>gas:=g'\<rparr>)
              = Normal ((), ?updState\<lparr>gas:=g', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)"
      by simp

    have BtUus:"balanceTypes (accounts uus)"
      unfolding balanceTypes_def
    proof intros
      fix adv
      show "typeCon (TUInt b256) (bal (accounts uus adv)) "
      proof(cases "adv = ?newAdd")
        case True
        then have " (bal (accounts uus adv)) =  (ShowL\<^sub>i\<^sub>n\<^sub>t 0)" using uusDef by simp
        then show ?thesis unfolding typeCon.simps checkUInt_def 
          using Read_ShowL_id by presburger
      next
        case False
        then have "(bal (accounts uus adv)) = (bal (accounts st adv))" using uusDef by simp
        then show ?thesis using 11(2) unfolding TypeSafe_def balanceTypes_def by simp
      qed
    qed

    have svv':"svalueTypes v'" unfolding svalueTypes_def
      using 1(4,3) 11(2) 11(4)   
      using exprTypeconInduct(3)[of ]
        typeSafeConvert[of t v "(TUInt b256)"] convertSame by fastforce

    have btACC:"balanceTypes acc"  unfolding balanceTypes_def
    proof - 
      have old:"balanceTypes (accounts (uus))" using BtUus  by simp
      have accExp:"(case subBalance (address e) v' (accounts (uus)) of None \<Rightarrow> None | Some x \<Rightarrow> addBalance ?newAdd v' x) = Some acc" 
        using 1(7) uusDef unfolding transfer_def by simp
      have v'TC: "typeCon (TUInt b256) v'" 
        using  svv' unfolding svalueTypes_def by blast

      show "\<forall>adv'. typeCon (TUInt b256) (bal (acc adv')) "
      proof(cases "?newAdd = (address e)")
        case same:True
        then show ?thesis using notSame by simp
      next
        case notSame:False
        show ?thesis 
        proof
          fix adv'
          show "typeCon (TUInt b256) (bal (acc adv')) "
          proof(cases "adv' = (address e)")
            case True

            then have tco:"typeCon (TUInt b256) (bal ((accounts uus) adv'))"
              using True old accExp balanceTypes_def by blast
            have "bal (acc (address e)) = ShowL\<^sub>i\<^sub>n\<^sub>t (ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (uus) (address e))) - (ReadL\<^sub>i\<^sub>n\<^sub>t v'))" 
              using transfer_subRead[OF _ _ v'TC ] 1(7) uusDef True notSame tco by auto
            then show ?thesis using True 
              using "1"(7,3) Read_ShowL_id tco checkUInt_def transfer_val1 transfer_val2
              by (smt (verit, ccfv_SIG) notSame typeCon.simps(2) transfer_sub transfer_val3)

          next
            case False
            then show ?thesis 
            proof(cases "adv' = ?newAdd")
              case True
              then have tco:"typeCon (TUInt b256) (bal ((accounts uus) ?newAdd))"
                using True old accExp balanceTypes_def by simp
              then have "bal (acc ?newAdd) = (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (uus) ?newAdd))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                using transfer_addRead[OF 1(7)_ v'TC  ] 1(3) notSame uusDef by auto
              moreover have "typeCon (TUInt b256) (ShowL\<^sub>i\<^sub>n\<^sub>t ((ReadL\<^sub>i\<^sub>n\<^sub>t (bal (accounts (uus) ?newAdd))) + (ReadL\<^sub>i\<^sub>n\<^sub>t v')))" 
                using "1"(7,3) Read_ShowL_id tco checkUInt_def transfer_val1 transfer_val2 transfer_val3 
                by (smt (verit, best) b256.rep_eq calculation notSame typeCon.simps(2) transfer_add)
              ultimately show ?thesis using True by simp
            next
              case f2:False
              show ?thesis using transfer_eq[OF 1(7) False f2] old 
                using balanceTypes_def uusDef by simp
            qed
          qed
        qed
      qed
    qed

    obtain ii where iiDef: "i = contract ii" using 1 
      by (metis Environment.select_convs(2))
    have epA:"ep $$ contract ii = Some (ct, cn, fb)" using 1 iiDef by blast
    have TSInit:"\<forall>x y. TypeSafe folded (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>)) 
                  emptyStore emptyStore (storage (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>)) emptyStore \<and>
       (denvalue folded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue folded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))"
    proof - 
      have "safeContract (storage (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>))"  using 11(2) unfolding TypeSafe_def by auto
      moreover have "methodVarsNoPref" using 11(2) unfolding TypeSafe_def by blast
      moreover have "balanceTypes (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>))"  using 11(2) unfolding TypeSafe_def by auto
      moreover have "svalueTypes v'" 
      proof - 
        have "typeCon t (extractValueType (KValue v))"
          using 1(4,3) 11(2) 11(4) 
          using exprTypeconInduct(3)[of val e cd "(st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>)" "(gas (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>))" "KValue v" "Value t" g]
            typeSafeConvert[of t v "(TUInt b256)"] convertSame by simp
        then show ?thesis unfolding svalueTypes_def using 1(3) a65 
          by (metis "1"(4) convertSame extractValueType.simps(1) typeSafeConvert)
      qed
      moreover have "lessThanTopLocs emptyStore"  using emptyTopLocs by simp


      moreover have "addressFormat (address e)" using 11(2) unfolding TypeSafe_def by simp
      moreover have "AddressTypes (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>))" using 11(2) unfolding TypeSafe_def by simp
      ultimately show "\<forall>x y. TypeSafe folded (accounts (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>)) 
                  emptyStore emptyStore (storage (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st\<rparr>)) emptyStore \<and>
       (denvalue folded $$ x = Some y \<longrightarrow> snd y = Storeloc x) \<and> (denvalue folded $$ x = Some y \<longrightarrow> (\<exists>t1. ct $$ x = Some (Var t1) \<and> fst y = Storage t1))" 
        using a80 unfolding ffold_init_def 
        using ffoldInitTypeSafe[of "storage ?sgas" "accounts ?sgas" v' emptyStore ii ct "(cn, fb)" ?newAdd "address e" "fmdom ct"] 
        using iiDef epA formatAdd by blast
    qed
    have a140:"TypeSafe e\<^sub>l (accounts (uus\<lparr>gas:=g', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))
                            (stack (uus\<lparr>gas:=g', accounts := acc, stack := k\<^sub>l, memory :=m\<^sub>l\<rparr>)) 
                            (memory (uus\<lparr>gas:=g', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))
                            (storage (uus\<lparr>gas:=g', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) 
                            cd\<^sub>l \<and> fullyInitialised e\<^sub>l acc k\<^sub>l" 
    proof - 
      obtain stO where stODef:"stO = (st\<lparr>gas := gas st - costs (NEW i xe val) e cd st, gas := g\<rparr>)" by blast

      then have aa1:"load True (fst cn) xe folded emptyStore emptyStore emptyStore e cd ?updState g =
    Normal ((e\<^sub>l, cd\<^sub>l, k\<^sub>l, m\<^sub>l), g')" using 1(6) a80 unfolding ffold_init_def by simp
      moreover have tsE:"TypeSafe e (accounts uus) (stack uus) (memory uus) (storage uus) cd" 
        unfolding TypeSafe_def 
      proof intros
        show "AddressTypes (accounts uus)" unfolding AddressTypes_def
        proof intros
          fix c adv ct' dud
          assume in1:"type (accounts uus adv) = Some (Contract c)"
          have cc1:"ep $$ c = Some (ct', dud) \<and> addressFormat adv"
          proof(cases "adv = ?newAdd")
            case True
            then have "type (accounts uus adv) = Some (Contract i)" using uusDef by auto
            then have "i = c" using in1 by simp
            moreover have "ep $$ i = Some (ct, cn, fb)" using epA iiDef by simp
            moreover have "addressFormat adv" using iiDef epA formatAdd True by simp
            ultimately show ?thesis 
              by (smt (verit) assms(1) inits AddressTypes_def fullyInitialised_def TypeSafe_def
                  statement_with_gas_axioms)
          next
            case False
            then have " (accounts uus adv) = accounts st adv" using uusDef by simp
            then show ?thesis using 11(2) unfolding TypeSafe_def AddressTypes_def using in1 by presburger
          qed
          then show "ep $$ c = Some (ct', dud)"  by auto
          show "addressFormat adv" using cc1 by auto
        qed
      next 
        show "safeContract (storage uus)" 
          unfolding safeContract_def
        proof intros
          fix e' ct' dud' i' tp
          assume in1:"ep $$ contract (e'::Environment) = Some (ct', dud') \<and> ct' $$ i' = Some (Var tp)"
          show "SCon tp i' (storage uus (address e'))"
          proof(cases "address e' = ?newAdd")
            case True
            then have "(storage uus (address e')) = {$$}" using uusDef by simp
            then show ?thesis 
            proof(induction tp arbitrary:i')
              case (STArray x1 tp)
              then show ?case by simp
            next
              case (STMap x1 tp)
              then show ?case by simp
            next
              case (STValue x)
              have "typeCon x (ival x)" by (simp add: ivalTypeCon)
              then show ?case unfolding SCon.simps accessStorage_def using STValue by simp
            qed
          next
            case False
            then have "storage uus (address e') = storage st (address e')"
              using uusDef by simp
            then show ?thesis using 11(2) unfolding TypeSafe_def safeContract_def using in1 by metis
          qed
        qed
      next 
        show "unique_locations (denvalue e)" using 11(2) unfolding TypeSafe_def by simp
      next

        show "compPointers (stack uus) (denvalue e)" 
          using 11(2) unfolding TypeSafe_def 
          using sameUpd uusDef by argo

      next
        show "compMemPtrs (stack uus) (memory uus) (denvalue e)" 
          using 11(2) sameUpd uusDef unfolding TypeSafe_def by simp
      next 
        show "methodVarsNoPref"  using 11(2) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts uus)" using BtUus by simp
      next 
        show "addressFormat (address e)" using 11(2) sameUpd uusDef unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using 11(2) sameUpd uusDef unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using 11(2) sameUpd uusDef unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack uus)" using 11(2) sameUpd uusDef unfolding TypeSafe_def by auto
      next
        show "lessThanTopLocs cd" using 11(2) sameUpd uusDef unfolding TypeSafe_def by auto
      next
        show "lessThanTopLocs (memory uus)" using 11(2) sameUpd uusDef unfolding TypeSafe_def by auto
      next 
        have tcOld:"typeCompat (denvalue e) (stack st) (memory st) (storage st (address e)) cd"
          using 11(2) unfolding TypeSafe_def by blast
        show "typeCompat (denvalue e) (stack uus) (memory uus) (storage uus (address e)) cd" 
          unfolding typeCompat_def 
        proof intros
          fix t l
          assume inDen:"(t, l) |\<in>| fmran (denvalue e)"

          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack uus) of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory uus) stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage uus (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage uus (address e)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)
            have tcOld':"case accessStore x1 (stack st) of None \<Rightarrow> False 
                         | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
                         | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
                         | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st) stloc | _ \<Rightarrow> False)
                         | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st (address e)) | _ \<Rightarrow> False)"
              using sameUpd Stackloc inDen tcOld unfolding typeCompat_def by force
            then show ?thesis 
            proof(cases "accessStore x1 (stack uus)")
              case None
              then show ?thesis using tcOld' sameUpd uusDef by simp
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using tcOld' sameUpd uusDef Some Stackloc by simp
              next
                case (KCDptr x2)

                then show ?thesis using tcOld' sameUpd uusDef Some Stackloc by simp
              next
                case (KMemptr x3)
                then show ?thesis using tcOld' sameUpd uusDef Some Stackloc by (cases t; fastforce)
              next
                case (KStoptr x4)

                then show ?thesis
                proof(cases "address e = ?newAdd")
                  case True
                  then have empt:"storage uus (address e) = {$$}" using uusDef by simp
                  then obtain struct where struct_def:"t = Storage struct"
                    using tcOld' sameUpd uusDef Some Stackloc KStoptr by (cases t; fastforce)
                  have "SCon struct x4 (storage uus (address e))"
                  proof(induction struct arbitrary:x4)
                    case (STArray x1 tp)
                    then show ?case by simp
                  next
                    case (STMap x1 tp)
                    then show ?case by simp
                  next
                    case (STValue x)
                    have "typeCon x (ival x)" by (simp add: ivalTypeCon)
                    then show ?case unfolding SCon.simps accessStorage_def using STValue empt by simp
                  qed
                  then show ?thesis using tcOld' sameUpd uusDef Some Stackloc KStoptr struct_def by simp
                next
                  case False
                  then have "storage uus (address e) = storage st (address e)" using uusDef by simp
                  then show ?thesis using tcOld' sameUpd uusDef Some Stackloc KStoptr by (cases t; fastforce)
                qed
              qed
            qed
          next
            case (Storeloc x2)
            then show ?thesis 
            proof(cases "address e = ?newAdd")
              case True
              then have empt:"storage uus (address e) = {$$}" using uusDef by simp
              then obtain struct where struct_def:"t = Storage struct"
                using  sameUpd uusDef Storeloc tcOld inDen unfolding typeCompat_def by (cases t; fastforce)
              have "SCon struct x2 (storage uus (address e))"
              proof(induction struct arbitrary:x2)
                case (STArray x1 tp)
                then show ?case by simp
              next
                case (STMap x1 tp)
                then show ?case by simp
              next
                case (STValue x)
                have "typeCon x (ival x)" by (simp add: ivalTypeCon)
                then show ?case unfolding SCon.simps accessStorage_def using STValue empt by simp
              qed
              then show ?thesis using  tcOld inDen unfolding typeCompat_def using sameUpd uusDef Storeloc struct_def by simp
            next
              case False
              then have "storage uus (address e) = storage st (address e)" using uusDef by simp
              then show ?thesis using tcOld inDen unfolding typeCompat_def using sameUpd uusDef Storeloc by (cases t; fastforce)
            qed
          qed
        qed
      qed

      moreover have "TypeSafe folded (accounts uus) emptyStore emptyStore (storage uus) emptyStore" using TSInit 
        by (metis a80 calculation(2) emptyEnv_svalue epA ffoldInitTypeSafe ffold_init_ad_same ffold_init_def formatAdd iiDef TypeSafe_def)

      moreover have a6:"fullyInitialised e (accounts uus) (stack uus)" 
        unfolding fullyInitialised_def
      proof intros

        show " \<exists>c. type (accounts uus (address e)) = Some (Contract c) \<and> contract e = c"
          using 11(4) unfolding fullyInitialised_def using  uusDef notSame by simp
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))"
          using 11(4) unfolding fullyInitialised_def by blast
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e) \<and> accessStore l (stack uus) = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t l' p"
          using 11(4) unfolding fullyInitialised_def using  uusDef  by simp
      qed

      have contractL:"contract folded = contract ii" using a80 iiDef by simp
      have addressL:"address folded = ?newAdd" using a80 by simp
      have fi1:"(type (accounts (?updState\<lparr>gas := g'\<rparr>) (?newAdd)) = Some (Contract i))" 
        using contractL addressL 1 a10 a40 by simp
      have ctd:"ep $$ contract folded = Some (ct, cn, fb)" using a50 contractL 1 a10 iiDef by metis
      then have fi2:"\<forall>id v. (denvalue folded $$ id = Some (Storage v, Storeloc id)) = (ct $$ id = Some (Var v))"
        using a80 unfolding ffold_init_def using ffoldInit_var_storage_mapping_eq[of ct ?newAdd i "(address e)" v' folded] by auto
      moreover have "fullyInitialised e (accounts ?updState) (stack ?updState)" using a6 uusDef by blast
      moreover have fiFolded:"fullyInitialised folded (accounts uus) emptyStore" 
        unfolding fullyInitialised_def
      proof intros
        show "\<exists>c. type (accounts uus (address folded)) = Some (Contract c) \<and> contract folded = c"
          using a80 11(4) uusDef unfolding fullyInitialised_def by simp
        show "\<And>id ct dud v. (ep $$ contract folded = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue folded $$ id = Some (Storage v, Storeloc id))"
          using fi2 ctd  
          by (smt (verit, ccfv_threshold) AddressTypes_def assms(1) fullyInitialised_def inits statement_with_gas.TypeSafe_def statement_with_gas_axioms)
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue folded) \<and> accessStore l emptyStore = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue folded) \<and> CompStoType t' t l' p " 
          using TSInit by fastforce
      qed

      ultimately have exprTS:" TypeSafe e\<^sub>l (accounts ?updState) k\<^sub>l m\<^sub>l (storage ?updState) cd\<^sub>l \<and>
    fullyInitialised e\<^sub>l (accounts ?updState) k\<^sub>l \<and> fullyInitialised e\<^sub>l
     (accounts ?updState) k\<^sub>l" 
        using  exprTypeconInduct(4)[of True "fst cn" xe folded emptyStore emptyStore
            emptyStore e cd ?updState g e\<^sub>l cd\<^sub>l k\<^sub>l m\<^sub>l g'] uusDef by blast

      have cc1:"TypeSafe e\<^sub>l (acc) (k\<^sub>l) (m\<^sub>l) (storage (uus)) cd\<^sub>l" 
        unfolding TypeSafe_def 
      proof intros
        show "AddressTypes acc" unfolding AddressTypes_def using tsE unfolding TypeSafe_def AddressTypes_def using 1(7) transfer_type_same uusDef by simp
      next 
        show "safeContract (storage uus)" using tsE unfolding TypeSafe_def by blast
      next 
        show "unique_locations (denvalue e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next 
        show "compPointers k\<^sub>l (denvalue e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next 
        show "compMemPtrs k\<^sub>l m\<^sub>l (denvalue e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next 
        show "methodVarsNoPref" using exprTS unfolding TypeSafe_def by blast
      next 
        show "balanceTypes acc" using btACC by auto
      next
        show "addressFormat (address e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next 
        show "addressFormat (sender e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next
        show "svalueTypes (svalue e\<^sub>l)" using exprTS unfolding TypeSafe_def by blast
      next
        show " lessThanTopLocs k\<^sub>l" using exprTS unfolding TypeSafe_def by blast
      next
        show " lessThanTopLocs cd\<^sub>l" using exprTS unfolding TypeSafe_def by blast
      next
        show "lessThanTopLocs m\<^sub>l" using exprTS unfolding TypeSafe_def by blast
      next 
        show "typeCompat (denvalue e\<^sub>l) k\<^sub>l m\<^sub>l (storage uus (address e\<^sub>l)) cd\<^sub>l" using uusDef exprTS unfolding TypeSafe_def by blast
      qed

      have elFolded:"address e\<^sub>l = address folded \<and> contract e\<^sub>l = contract folded" using 1 a80 
        using  msel_ssel_expr_load_rexp_gas(4) aa1 by blast
      have cc2:"fullyInitialised e\<^sub>l acc k\<^sub>l" 
        unfolding fullyInitialised_def
      proof(intros)
        show "\<exists>c. type (acc (address e\<^sub>l)) = Some (Contract c) \<and> contract e\<^sub>l = c"
          using elFolded fiFolded 1(7) transfer_type_same uusDef unfolding fullyInitialised_def by simp
        show "\<And>id ct dud v. (ep $$ contract e\<^sub>l = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e\<^sub>l $$ id = Some (Storage v, Storeloc id))"
          using elFolded exprTS 1(7) transfer_type_same uusDef unfolding fullyInitialised_def  by blast
        show "\<And>t l p.
       (Storage t, Stackloc l) |\<in>| fmran (denvalue e\<^sub>l) \<and> accessStore l k\<^sub>l = Some (KStoptr p) \<Longrightarrow>
       \<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e\<^sub>l) \<and> CompStoType t' t l' p"
          using exprTS unfolding fullyInitialised_def by auto
      qed

      then show "TypeSafe e\<^sub>l (accounts (uus\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (stack (uus\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))
     (memory (uus\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (storage (uus\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) cd\<^sub>l
\<and> fullyInitialised e\<^sub>l acc k\<^sub>l"
        using cc1 by auto
    qed
    have a140':"TypeSafe e\<^sub>l (accounts (?updState\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (stack (?updState\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>))
   (memory (?updState\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) (storage (?updState\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>)) cd\<^sub>l" 
      using a140 uusDef by auto
    have "st\<lparr>gas := g', accounts := (accounts st)((?newAdd) := \<lparr>bal = ShowL\<^sub>i\<^sub>n\<^sub>t 0, type = Some (Contract i), contracts = 0\<rparr>), 
                                                storage := (storage st)((?newAdd) := {$$})\<rparr>
= (?updState\<lparr>gas := g'\<rparr>)" by simp
    then have a18Exp:"local.stmt (snd cn) e\<^sub>l cd\<^sub>l
     (?updState\<lparr>gas := g', accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) = Normal ((), st'')" using 1(8) by argo
    have a150:"fullyInitialised e\<^sub>l acc k\<^sub>l" using a140 by simp


    have IH1:" StateInvariant e\<^sub>l (?updState\<lparr>gas:=g',accounts := acc, stack := k\<^sub>l, memory := m\<^sub>l\<rparr>) st'' cd\<^sub>l"
      using 11(1)[OF a10 a20 a30  a40 a50 a60 _ a65  a70 _ _ _ a80 a90 _  _ _ a110 a120 _ a130 a140' a18Exp] a30 1(8) a150  by simp

    have st'Final:"st' = incrementAccountContracts (address e) (st''\<lparr>stack := stack st, memory := memory st\<rparr>)" using 1 by blast

    then have sameStores:"memory st = memory st' \<and> stack st = stack st'" using 1 by simp
    show ?thesis unfolding StateInvariant_def
    proof intros
      show "TypeSafe e (accounts st') (stack st') (memory st') (storage st') cd" unfolding TypeSafe_def
      proof intros
        have old:"AddressTypes (accounts st'')" using IH1 unfolding StateInvariant_def TypeSafe_def by auto
        show "AddressTypes (accounts st')" unfolding AddressTypes_def
        proof intros
          fix c adv ct dud
          assume *:"type (accounts st' adv) = Some (Contract c)"
          then show "ep $$ c = Some (ct, dud)" using old unfolding AddressTypes_def using  st'Final by fastforce
          show "\<And>c adv x. type (accounts st' adv) = Some (Contract c) \<Longrightarrow> addressFormat adv "
            using old unfolding AddressTypes_def using  st'Final by fastforce
        qed
      next 
        show "safeContract (storage st')" using IH1 unfolding StateInvariant_def TypeSafe_def using st'Final sameStores incrementAccountContracts_storage by fastforce
      next 
        show "unique_locations (denvalue e)" using 11(2) unfolding TypeSafe_def using sameStores by simp
      next
        show "compPointers (stack st') (denvalue e)" using 11(2) st'Final unfolding StateInvariant_def TypeSafe_def by simp
      next
        show "compMemPtrs (stack st') (memory st') (denvalue e)" using 11(2) unfolding TypeSafe_def using sameStores by simp
      next 
        show "methodVarsNoPref"  using "11.prems"(1) unfolding TypeSafe_def by simp
      next
        show "balanceTypes (accounts st')" using IH1 unfolding StateInvariant_def TypeSafe_def balanceTypes_def using  st'Final sameStores  by fastforce
      next 
        show "addressFormat (address e)" using "11.prems"(1) unfolding TypeSafe_def by simp
      next
        show "addressFormat (sender e)" using "11.prems"(1) unfolding TypeSafe_def by simp
      next 
        show "svalueTypes (svalue e)" using "11.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (stack st')" using 11(2) unfolding TypeSafe_def using sameStores by simp
      next
        show "lessThanTopLocs cd" using "11.prems"(1) unfolding TypeSafe_def by simp
      next
        show "lessThanTopLocs (memory st')" using 11(2) unfolding TypeSafe_def using sameStores by simp
      next 
        show "typeCompat (denvalue e) (stack st') (memory st') (storage st' (address e)) cd" 
          unfolding typeCompat_def 
        proof intros
          fix t l
          assume inDen:"(t, l) |\<in>| fmran (denvalue e)" 

          have acc:"(\<forall>c adv ct dud. type (accounts st adv) = Some (Contract c) \<longrightarrow> ep $$ c = Some (ct,dud) \<and> addressFormat adv)"
            using 11(2) unfolding TypeSafe_def AddressTypes_def by blast
          obtain cOld where "type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld" 
            using 11(4) unfolding fullyInitialised_def by simp
          then obtain ctO dudO where ctoDef: "ep $$ contract e = Some (ctO, dudO)" using acc  by blast
          have storageFinal:"storage st' = storage st''" using 1 by auto

          show "case l of
           Stackloc loc \<Rightarrow>
             (case accessStore loc (stack st') of None \<Rightarrow> False 
              | Some (KValue val) \<Rightarrow> (case t of Value typ \<Rightarrow> typeCon typ val | _ \<Rightarrow> False)
              | Some (KCDptr stloc) \<Rightarrow> (case t of Calldata struct \<Rightarrow> MCon struct cd stloc | _ \<Rightarrow> False)
              | Some (KMemptr stloc) \<Rightarrow> (case t of Memory struct \<Rightarrow> MCon struct (memory st') stloc | _ \<Rightarrow> False)
              | Some (KStoptr stloc) \<Rightarrow> (case t of Storage struct \<Rightarrow> SCon struct stloc (storage st' (address e)) | _ \<Rightarrow> False))
           | Storeloc loc \<Rightarrow> (case t of Storage typ \<Rightarrow> SCon typ loc (storage st' (address e)) | _ \<Rightarrow> False)"
          proof(cases l)
            case (Stackloc x1)

            then show ?thesis 
            proof(cases "accessStore x1 (stack st')")
              case None
              then show ?thesis using 11(2) unfolding TypeSafe_def typeCompat_def using inDen sameStores Stackloc by fastforce
            next
              case (Some a)
              then show ?thesis 
              proof(cases a)
                case (KValue x1')
                then show ?thesis using 11(2) unfolding TypeSafe_def typeCompat_def using inDen sameStores Stackloc Some by fastforce
              next
                case (KCDptr x2)
                then show ?thesis using 11(2) unfolding TypeSafe_def typeCompat_def using inDen sameStores Stackloc Some by fastforce
              next
                case (KMemptr x3)
                then show ?thesis using 11(2) unfolding TypeSafe_def typeCompat_def using inDen sameStores Stackloc Some by (cases t; fastforce)
              next
                case (KStoptr x4)
                then have accO:"accessStore x1 (stack st) = Some( KStoptr x4)"
                  using Some 1 by auto
                then obtain struct where structDef: "t = Storage struct" 
                  using 11(2) unfolding TypeSafe_def typeCompat_def using inDen Some KStoptr Stackloc 
                  by (cases t, force,  fastforce, fastforce, auto)
                obtain tprnt lprnt where tprntDef: "((Storage tprnt, Storeloc lprnt) |\<in>| fmran (denvalue e) \<and> CompStoType tprnt struct lprnt x4)" 
                  using 11(4) using accO inDen unfolding fullyInitialised_def 
                  using Stackloc structDef by blast
                
                then have "SCon tprnt lprnt (storage st'' (address e))"
                  using ctoDef IH1  accessStore_def accessStore_updateStore 
                  unfolding StateInvariant_def fullyInitialised_def TypeSafe_def safeContract_def 
                  by (metis
                      \<open>\<And>thesis. (\<And>cOld. type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld \<Longrightarrow> thesis) \<Longrightarrow> thesis\<close>
                      acc)
                then have "SCon struct x4 (storage st'' (address e))"
                  using tprntDef SCon_imps_sublocs by blast
                then show ?thesis using Stackloc Some KStoptr structDef storageFinal by simp
              qed
            qed
          next
            case (Storeloc x2)
            then obtain struct where structDef: "t = Storage struct" 
              using 11(2) inDen unfolding TypeSafe_def typeCompat_def by (cases t,fastforce+)

            then have "SCon struct x2 (storage st'' (address e))"
              using ctoDef IH1 accessStore_def accessStore_updateStore 
              unfolding StateInvariant_def TypeSafe_def safeContract_def fullyInitialised_def 
              by (metis \<open>type (accounts st (address e)) = Some (Contract cOld) \<and> contract e = cOld\<close> acc)
            then show ?thesis using Storeloc structDef 
              by (simp add: storageFinal)
          qed
        qed
      qed
    next 
      show "fullyInitialised e (accounts st') (stack st')" unfolding fullyInitialised_def 
      proof intros
        show "\<exists>c. type (accounts st' (address e)) = Some (Contract c) \<and> contract e = c"
          using IH1 atype_same[OF 1(8)] st'Final unfolding StateInvariant_def fullyInitialised_def 
          by (metis "11.prems"(2,3) fullyInitialised_def atype_same)
      next 
        show "\<And>id ct dud v. (ep $$ contract e = Some (ct, dud) \<and> ct $$ id = Some (Var v)) = (denvalue e $$ id = Some (Storage v, Storeloc id))" 
          using 11(4) unfolding fullyInitialised_def by blast
      next
        fix t2 l2 p2 
        assume in1:"(Storage t2, Stackloc l2) |\<in>| fmran (denvalue e) \<and> accessStore l2 (stack st') = Some (KStoptr p2)"
        show "\<exists>t' l'. (Storage t', Storeloc l') |\<in>| fmran (denvalue e) \<and> CompStoType t' t2 l' p2" 
          using "11.prems"(3) in1 sameStores statement_with_gas.fullyInitialised_def statement_with_gas_axioms by auto
      qed
    qed
  qed  
qed

end
end
